"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/firebase";
exports.ids = ["vendor-chunks/firebase"];
exports.modules = {

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/index.js":
/*!************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Client = __webpack_require__(/*! ./lib/client */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/client.js\");\nconst Dispatcher = __webpack_require__(/*! ./lib/dispatcher */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/dispatcher.js\");\nconst errors = __webpack_require__(/*! ./lib/core/errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\nconst Pool = __webpack_require__(/*! ./lib/pool */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/pool.js\");\nconst BalancedPool = __webpack_require__(/*! ./lib/balanced-pool */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/balanced-pool.js\");\nconst Agent = __webpack_require__(/*! ./lib/agent */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/agent.js\");\nconst util = __webpack_require__(/*! ./lib/core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst { InvalidArgumentError } = errors;\nconst api = __webpack_require__(/*! ./lib/api */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/api/index.js\");\nconst buildConnector = __webpack_require__(/*! ./lib/core/connect */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/connect.js\");\nconst MockClient = __webpack_require__(/*! ./lib/mock/mock-client */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-client.js\");\nconst MockAgent = __webpack_require__(/*! ./lib/mock/mock-agent */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-agent.js\");\nconst MockPool = __webpack_require__(/*! ./lib/mock/mock-pool */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-pool.js\");\nconst mockErrors = __webpack_require__(/*! ./lib/mock/mock-errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-errors.js\");\nconst ProxyAgent = __webpack_require__(/*! ./lib/proxy-agent */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/proxy-agent.js\");\nconst RetryHandler = __webpack_require__(/*! ./lib/handler/RetryHandler */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/handler/RetryHandler.js\");\nconst { getGlobalDispatcher, setGlobalDispatcher } = __webpack_require__(/*! ./lib/global */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/global.js\");\nconst DecoratorHandler = __webpack_require__(/*! ./lib/handler/DecoratorHandler */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/handler/DecoratorHandler.js\");\nconst RedirectHandler = __webpack_require__(/*! ./lib/handler/RedirectHandler */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/handler/RedirectHandler.js\");\nconst createRedirectInterceptor = __webpack_require__(/*! ./lib/interceptor/redirectInterceptor */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/interceptor/redirectInterceptor.js\");\nlet hasCrypto;\ntry {\n    __webpack_require__(/*! crypto */ \"crypto\");\n    hasCrypto = true;\n} catch  {\n    hasCrypto = false;\n}\nObject.assign(Dispatcher.prototype, api);\nmodule.exports.Dispatcher = Dispatcher;\nmodule.exports.Client = Client;\nmodule.exports.Pool = Pool;\nmodule.exports.BalancedPool = BalancedPool;\nmodule.exports.Agent = Agent;\nmodule.exports.ProxyAgent = ProxyAgent;\nmodule.exports.RetryHandler = RetryHandler;\nmodule.exports.DecoratorHandler = DecoratorHandler;\nmodule.exports.RedirectHandler = RedirectHandler;\nmodule.exports.createRedirectInterceptor = createRedirectInterceptor;\nmodule.exports.buildConnector = buildConnector;\nmodule.exports.errors = errors;\nfunction makeDispatcher(fn) {\n    return (url, opts, handler)=>{\n        if (typeof opts === \"function\") {\n            handler = opts;\n            opts = null;\n        }\n        if (!url || typeof url !== \"string\" && typeof url !== \"object\" && !(url instanceof URL)) {\n            throw new InvalidArgumentError(\"invalid url\");\n        }\n        if (opts != null && typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"invalid opts\");\n        }\n        if (opts && opts.path != null) {\n            if (typeof opts.path !== \"string\") {\n                throw new InvalidArgumentError(\"invalid opts.path\");\n            }\n            let path = opts.path;\n            if (!opts.path.startsWith(\"/\")) {\n                path = `/${path}`;\n            }\n            url = new URL(util.parseOrigin(url).origin + path);\n        } else {\n            if (!opts) {\n                opts = typeof url === \"object\" ? url : {};\n            }\n            url = util.parseURL(url);\n        }\n        const { agent, dispatcher = getGlobalDispatcher() } = opts;\n        if (agent) {\n            throw new InvalidArgumentError(\"unsupported opts.agent. Did you mean opts.client?\");\n        }\n        return fn.call(dispatcher, {\n            ...opts,\n            origin: url.origin,\n            path: url.search ? `${url.pathname}${url.search}` : url.pathname,\n            method: opts.method || (opts.body ? \"PUT\" : \"GET\")\n        }, handler);\n    };\n}\nmodule.exports.setGlobalDispatcher = setGlobalDispatcher;\nmodule.exports.getGlobalDispatcher = getGlobalDispatcher;\nif (util.nodeMajor > 16 || util.nodeMajor === 16 && util.nodeMinor >= 8) {\n    let fetchImpl = null;\n    module.exports.fetch = async function fetch(resource) {\n        if (!fetchImpl) {\n            fetchImpl = (__webpack_require__(/*! ./lib/fetch */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/index.js\").fetch);\n        }\n        try {\n            return await fetchImpl(...arguments);\n        } catch (err) {\n            if (typeof err === \"object\") {\n                Error.captureStackTrace(err, this);\n            }\n            throw err;\n        }\n    };\n    module.exports.Headers = __webpack_require__(/*! ./lib/fetch/headers */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/headers.js\").Headers;\n    module.exports.Response = __webpack_require__(/*! ./lib/fetch/response */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/response.js\").Response;\n    module.exports.Request = __webpack_require__(/*! ./lib/fetch/request */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/request.js\").Request;\n    module.exports.FormData = __webpack_require__(/*! ./lib/fetch/formdata */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/formdata.js\").FormData;\n    module.exports.File = __webpack_require__(/*! ./lib/fetch/file */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/file.js\").File;\n    module.exports.FileReader = __webpack_require__(/*! ./lib/fileapi/filereader */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fileapi/filereader.js\").FileReader;\n    const { setGlobalOrigin, getGlobalOrigin } = __webpack_require__(/*! ./lib/fetch/global */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/global.js\");\n    module.exports.setGlobalOrigin = setGlobalOrigin;\n    module.exports.getGlobalOrigin = getGlobalOrigin;\n    const { CacheStorage } = __webpack_require__(/*! ./lib/cache/cachestorage */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/cache/cachestorage.js\");\n    const { kConstruct } = __webpack_require__(/*! ./lib/cache/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/cache/symbols.js\");\n    // Cache & CacheStorage are tightly coupled with fetch. Even if it may run\n    // in an older version of Node, it doesn't have any use without fetch.\n    module.exports.caches = new CacheStorage(kConstruct);\n}\nif (util.nodeMajor >= 16) {\n    const { deleteCookie, getCookies, getSetCookies, setCookie } = __webpack_require__(/*! ./lib/cookies */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/cookies/index.js\");\n    module.exports.deleteCookie = deleteCookie;\n    module.exports.getCookies = getCookies;\n    module.exports.getSetCookies = getSetCookies;\n    module.exports.setCookie = setCookie;\n    const { parseMIMEType, serializeAMimeType } = __webpack_require__(/*! ./lib/fetch/dataURL */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/dataURL.js\");\n    module.exports.parseMIMEType = parseMIMEType;\n    module.exports.serializeAMimeType = serializeAMimeType;\n}\nif (util.nodeMajor >= 18 && hasCrypto) {\n    const { WebSocket } = __webpack_require__(/*! ./lib/websocket/websocket */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/websocket.js\");\n    module.exports.WebSocket = WebSocket;\n}\nmodule.exports.request = makeDispatcher(api.request);\nmodule.exports.stream = makeDispatcher(api.stream);\nmodule.exports.pipeline = makeDispatcher(api.pipeline);\nmodule.exports.connect = makeDispatcher(api.connect);\nmodule.exports.upgrade = makeDispatcher(api.upgrade);\nmodule.exports.MockClient = MockClient;\nmodule.exports.MockPool = MockPool;\nmodule.exports.MockAgent = MockAgent;\nmodule.exports.mockErrors = mockErrors;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1FLFNBQVNGLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1HLE9BQU9ILG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1JLGVBQWVKLG1CQUFPQSxDQUFDO0FBQzdCLE1BQU1LLFFBQVFMLG1CQUFPQSxDQUFDO0FBQ3RCLE1BQU1NLE9BQU9OLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRU8sb0JBQW9CLEVBQUUsR0FBR0w7QUFDakMsTUFBTU0sTUFBTVIsbUJBQU9BLENBQUM7QUFDcEIsTUFBTVMsaUJBQWlCVCxtQkFBT0EsQ0FBQztBQUMvQixNQUFNVSxhQUFhVixtQkFBT0EsQ0FBQztBQUMzQixNQUFNVyxZQUFZWCxtQkFBT0EsQ0FBQztBQUMxQixNQUFNWSxXQUFXWixtQkFBT0EsQ0FBQztBQUN6QixNQUFNYSxhQUFhYixtQkFBT0EsQ0FBQztBQUMzQixNQUFNYyxhQUFhZCxtQkFBT0EsQ0FBQztBQUMzQixNQUFNZSxlQUFlZixtQkFBT0EsQ0FBQztBQUM3QixNQUFNLEVBQUVnQixtQkFBbUIsRUFBRUMsbUJBQW1CLEVBQUUsR0FBR2pCLG1CQUFPQSxDQUFDO0FBQzdELE1BQU1rQixtQkFBbUJsQixtQkFBT0EsQ0FBQztBQUNqQyxNQUFNbUIsa0JBQWtCbkIsbUJBQU9BLENBQUM7QUFDaEMsTUFBTW9CLDRCQUE0QnBCLG1CQUFPQSxDQUFDO0FBRTFDLElBQUlxQjtBQUNKLElBQUk7SUFDRnJCLG1CQUFPQSxDQUFDO0lBQ1JxQixZQUFZO0FBQ2QsRUFBRSxPQUFNO0lBQ05BLFlBQVk7QUFDZDtBQUVBQyxPQUFPQyxNQUFNLENBQUN0QixXQUFXdUIsU0FBUyxFQUFFaEI7QUFFcENpQix5QkFBeUIsR0FBR3hCO0FB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R1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvdW5kaWNpL2luZGV4LmpzPzhmNDUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IENsaWVudCA9IHJlcXVpcmUoJy4vbGliL2NsaWVudCcpXG5jb25zdCBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi9saWIvZGlzcGF0Y2hlcicpXG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuL2xpYi9jb3JlL2Vycm9ycycpXG5jb25zdCBQb29sID0gcmVxdWlyZSgnLi9saWIvcG9vbCcpXG5jb25zdCBCYWxhbmNlZFBvb2wgPSByZXF1aXJlKCcuL2xpYi9iYWxhbmNlZC1wb29sJylcbmNvbnN0IEFnZW50ID0gcmVxdWlyZSgnLi9saWIvYWdlbnQnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vbGliL2NvcmUvdXRpbCcpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSBlcnJvcnNcbmNvbnN0IGFwaSA9IHJlcXVpcmUoJy4vbGliL2FwaScpXG5jb25zdCBidWlsZENvbm5lY3RvciA9IHJlcXVpcmUoJy4vbGliL2NvcmUvY29ubmVjdCcpXG5jb25zdCBNb2NrQ2xpZW50ID0gcmVxdWlyZSgnLi9saWIvbW9jay9tb2NrLWNsaWVudCcpXG5jb25zdCBNb2NrQWdlbnQgPSByZXF1aXJlKCcuL2xpYi9tb2NrL21vY2stYWdlbnQnKVxuY29uc3QgTW9ja1Bvb2wgPSByZXF1aXJlKCcuL2xpYi9tb2NrL21vY2stcG9vbCcpXG5jb25zdCBtb2NrRXJyb3JzID0gcmVxdWlyZSgnLi9saWIvbW9jay9tb2NrLWVycm9ycycpXG5jb25zdCBQcm94eUFnZW50ID0gcmVxdWlyZSgnLi9saWIvcHJveHktYWdlbnQnKVxuY29uc3QgUmV0cnlIYW5kbGVyID0gcmVxdWlyZSgnLi9saWIvaGFuZGxlci9SZXRyeUhhbmRsZXInKVxuY29uc3QgeyBnZXRHbG9iYWxEaXNwYXRjaGVyLCBzZXRHbG9iYWxEaXNwYXRjaGVyIH0gPSByZXF1aXJlKCcuL2xpYi9nbG9iYWwnKVxuY29uc3QgRGVjb3JhdG9ySGFuZGxlciA9IHJlcXVpcmUoJy4vbGliL2hhbmRsZXIvRGVjb3JhdG9ySGFuZGxlcicpXG5jb25zdCBSZWRpcmVjdEhhbmRsZXIgPSByZXF1aXJlKCcuL2xpYi9oYW5kbGVyL1JlZGlyZWN0SGFuZGxlcicpXG5jb25zdCBjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yID0gcmVxdWlyZSgnLi9saWIvaW50ZXJjZXB0b3IvcmVkaXJlY3RJbnRlcmNlcHRvcicpXG5cbmxldCBoYXNDcnlwdG9cbnRyeSB7XG4gIHJlcXVpcmUoJ2NyeXB0bycpXG4gIGhhc0NyeXB0byA9IHRydWVcbn0gY2F0Y2gge1xuICBoYXNDcnlwdG8gPSBmYWxzZVxufVxuXG5PYmplY3QuYXNzaWduKERpc3BhdGNoZXIucHJvdG90eXBlLCBhcGkpXG5cbm1vZHVsZS5leHBvcnRzLkRpc3BhdGNoZXIgPSBEaXNwYXRjaGVyXG5tb2R1bGUuZXhwb3J0cy5DbGllbnQgPSBDbGllbnRcbm1vZHVsZS5leHBvcnRzLlBvb2wgPSBQb29sXG5tb2R1bGUuZXhwb3J0cy5CYWxhbmNlZFBvb2wgPSBCYWxhbmNlZFBvb2xcbm1vZHVsZS5leHBvcnRzLkFnZW50ID0gQWdlbnRcbm1vZHVsZS5leHBvcnRzLlByb3h5QWdlbnQgPSBQcm94eUFnZW50XG5tb2R1bGUuZXhwb3J0cy5SZXRyeUhhbmRsZXIgPSBSZXRyeUhhbmRsZXJcblxubW9kdWxlLmV4cG9ydHMuRGVjb3JhdG9ySGFuZGxlciA9IERlY29yYXRvckhhbmRsZXJcbm1vZHVsZS5leHBvcnRzLlJlZGlyZWN0SGFuZGxlciA9IFJlZGlyZWN0SGFuZGxlclxubW9kdWxlLmV4cG9ydHMuY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvciA9IGNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3JcblxubW9kdWxlLmV4cG9ydHMuYnVpbGRDb25uZWN0b3IgPSBidWlsZENvbm5lY3RvclxubW9kdWxlLmV4cG9ydHMuZXJyb3JzID0gZXJyb3JzXG5cbmZ1bmN0aW9uIG1ha2VEaXNwYXRjaGVyIChmbikge1xuICByZXR1cm4gKHVybCwgb3B0cywgaGFuZGxlcikgPT4ge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaGFuZGxlciA9IG9wdHNcbiAgICAgIG9wdHMgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKCF1cmwgfHwgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnICYmIHR5cGVvZiB1cmwgIT09ICdvYmplY3QnICYmICEodXJsIGluc3RhbmNlb2YgVVJMKSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCB1cmwnKVxuICAgIH1cblxuICAgIGlmIChvcHRzICE9IG51bGwgJiYgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb3B0cycpXG4gICAgfVxuXG4gICAgaWYgKG9wdHMgJiYgb3B0cy5wYXRoICE9IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0cy5wYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb3B0cy5wYXRoJylcbiAgICAgIH1cblxuICAgICAgbGV0IHBhdGggPSBvcHRzLnBhdGhcbiAgICAgIGlmICghb3B0cy5wYXRoLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICBwYXRoID0gYC8ke3BhdGh9YFxuICAgICAgfVxuXG4gICAgICB1cmwgPSBuZXcgVVJMKHV0aWwucGFyc2VPcmlnaW4odXJsKS5vcmlnaW4gKyBwYXRoKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgb3B0cyA9IHR5cGVvZiB1cmwgPT09ICdvYmplY3QnID8gdXJsIDoge31cbiAgICAgIH1cblxuICAgICAgdXJsID0gdXRpbC5wYXJzZVVSTCh1cmwpXG4gICAgfVxuXG4gICAgY29uc3QgeyBhZ2VudCwgZGlzcGF0Y2hlciA9IGdldEdsb2JhbERpc3BhdGNoZXIoKSB9ID0gb3B0c1xuXG4gICAgaWYgKGFnZW50KSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Vuc3VwcG9ydGVkIG9wdHMuYWdlbnQuIERpZCB5b3UgbWVhbiBvcHRzLmNsaWVudD8nKVxuICAgIH1cblxuICAgIHJldHVybiBmbi5jYWxsKGRpc3BhdGNoZXIsIHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBvcmlnaW46IHVybC5vcmlnaW4sXG4gICAgICBwYXRoOiB1cmwuc2VhcmNoID8gYCR7dXJsLnBhdGhuYW1lfSR7dXJsLnNlYXJjaH1gIDogdXJsLnBhdGhuYW1lLFxuICAgICAgbWV0aG9kOiBvcHRzLm1ldGhvZCB8fCAob3B0cy5ib2R5ID8gJ1BVVCcgOiAnR0VUJylcbiAgICB9LCBoYW5kbGVyKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLnNldEdsb2JhbERpc3BhdGNoZXIgPSBzZXRHbG9iYWxEaXNwYXRjaGVyXG5tb2R1bGUuZXhwb3J0cy5nZXRHbG9iYWxEaXNwYXRjaGVyID0gZ2V0R2xvYmFsRGlzcGF0Y2hlclxuXG5pZiAodXRpbC5ub2RlTWFqb3IgPiAxNiB8fCAodXRpbC5ub2RlTWFqb3IgPT09IDE2ICYmIHV0aWwubm9kZU1pbm9yID49IDgpKSB7XG4gIGxldCBmZXRjaEltcGwgPSBudWxsXG4gIG1vZHVsZS5leHBvcnRzLmZldGNoID0gYXN5bmMgZnVuY3Rpb24gZmV0Y2ggKHJlc291cmNlKSB7XG4gICAgaWYgKCFmZXRjaEltcGwpIHtcbiAgICAgIGZldGNoSW1wbCA9IHJlcXVpcmUoJy4vbGliL2ZldGNoJykuZmV0Y2hcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGZldGNoSW1wbCguLi5hcmd1bWVudHMpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodHlwZW9mIGVyciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCB0aGlzKVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cbiAgbW9kdWxlLmV4cG9ydHMuSGVhZGVycyA9IHJlcXVpcmUoJy4vbGliL2ZldGNoL2hlYWRlcnMnKS5IZWFkZXJzXG4gIG1vZHVsZS5leHBvcnRzLlJlc3BvbnNlID0gcmVxdWlyZSgnLi9saWIvZmV0Y2gvcmVzcG9uc2UnKS5SZXNwb25zZVxuICBtb2R1bGUuZXhwb3J0cy5SZXF1ZXN0ID0gcmVxdWlyZSgnLi9saWIvZmV0Y2gvcmVxdWVzdCcpLlJlcXVlc3RcbiAgbW9kdWxlLmV4cG9ydHMuRm9ybURhdGEgPSByZXF1aXJlKCcuL2xpYi9mZXRjaC9mb3JtZGF0YScpLkZvcm1EYXRhXG4gIG1vZHVsZS5leHBvcnRzLkZpbGUgPSByZXF1aXJlKCcuL2xpYi9mZXRjaC9maWxlJykuRmlsZVxuICBtb2R1bGUuZXhwb3J0cy5GaWxlUmVhZGVyID0gcmVxdWlyZSgnLi9saWIvZmlsZWFwaS9maWxlcmVhZGVyJykuRmlsZVJlYWRlclxuXG4gIGNvbnN0IHsgc2V0R2xvYmFsT3JpZ2luLCBnZXRHbG9iYWxPcmlnaW4gfSA9IHJlcXVpcmUoJy4vbGliL2ZldGNoL2dsb2JhbCcpXG5cbiAgbW9kdWxlLmV4cG9ydHMuc2V0R2xvYmFsT3JpZ2luID0gc2V0R2xvYmFsT3JpZ2luXG4gIG1vZHVsZS5leHBvcnRzLmdldEdsb2JhbE9yaWdpbiA9IGdldEdsb2JhbE9yaWdpblxuXG4gIGNvbnN0IHsgQ2FjaGVTdG9yYWdlIH0gPSByZXF1aXJlKCcuL2xpYi9jYWNoZS9jYWNoZXN0b3JhZ2UnKVxuICBjb25zdCB7IGtDb25zdHJ1Y3QgfSA9IHJlcXVpcmUoJy4vbGliL2NhY2hlL3N5bWJvbHMnKVxuXG4gIC8vIENhY2hlICYgQ2FjaGVTdG9yYWdlIGFyZSB0aWdodGx5IGNvdXBsZWQgd2l0aCBmZXRjaC4gRXZlbiBpZiBpdCBtYXkgcnVuXG4gIC8vIGluIGFuIG9sZGVyIHZlcnNpb24gb2YgTm9kZSwgaXQgZG9lc24ndCBoYXZlIGFueSB1c2Ugd2l0aG91dCBmZXRjaC5cbiAgbW9kdWxlLmV4cG9ydHMuY2FjaGVzID0gbmV3IENhY2hlU3RvcmFnZShrQ29uc3RydWN0KVxufVxuXG5pZiAodXRpbC5ub2RlTWFqb3IgPj0gMTYpIHtcbiAgY29uc3QgeyBkZWxldGVDb29raWUsIGdldENvb2tpZXMsIGdldFNldENvb2tpZXMsIHNldENvb2tpZSB9ID0gcmVxdWlyZSgnLi9saWIvY29va2llcycpXG5cbiAgbW9kdWxlLmV4cG9ydHMuZGVsZXRlQ29va2llID0gZGVsZXRlQ29va2llXG4gIG1vZHVsZS5leHBvcnRzLmdldENvb2tpZXMgPSBnZXRDb29raWVzXG4gIG1vZHVsZS5leHBvcnRzLmdldFNldENvb2tpZXMgPSBnZXRTZXRDb29raWVzXG4gIG1vZHVsZS5leHBvcnRzLnNldENvb2tpZSA9IHNldENvb2tpZVxuXG4gIGNvbnN0IHsgcGFyc2VNSU1FVHlwZSwgc2VyaWFsaXplQU1pbWVUeXBlIH0gPSByZXF1aXJlKCcuL2xpYi9mZXRjaC9kYXRhVVJMJylcblxuICBtb2R1bGUuZXhwb3J0cy5wYXJzZU1JTUVUeXBlID0gcGFyc2VNSU1FVHlwZVxuICBtb2R1bGUuZXhwb3J0cy5zZXJpYWxpemVBTWltZVR5cGUgPSBzZXJpYWxpemVBTWltZVR5cGVcbn1cblxuaWYgKHV0aWwubm9kZU1ham9yID49IDE4ICYmIGhhc0NyeXB0bykge1xuICBjb25zdCB7IFdlYlNvY2tldCB9ID0gcmVxdWlyZSgnLi9saWIvd2Vic29ja2V0L3dlYnNvY2tldCcpXG5cbiAgbW9kdWxlLmV4cG9ydHMuV2ViU29ja2V0ID0gV2ViU29ja2V0XG59XG5cbm1vZHVsZS5leHBvcnRzLnJlcXVlc3QgPSBtYWtlRGlzcGF0Y2hlcihhcGkucmVxdWVzdClcbm1vZHVsZS5leHBvcnRzLnN0cmVhbSA9IG1ha2VEaXNwYXRjaGVyKGFwaS5zdHJlYW0pXG5tb2R1bGUuZXhwb3J0cy5waXBlbGluZSA9IG1ha2VEaXNwYXRjaGVyKGFwaS5waXBlbGluZSlcbm1vZHVsZS5leHBvcnRzLmNvbm5lY3QgPSBtYWtlRGlzcGF0Y2hlcihhcGkuY29ubmVjdClcbm1vZHVsZS5leHBvcnRzLnVwZ3JhZGUgPSBtYWtlRGlzcGF0Y2hlcihhcGkudXBncmFkZSlcblxubW9kdWxlLmV4cG9ydHMuTW9ja0NsaWVudCA9IE1vY2tDbGllbnRcbm1vZHVsZS5leHBvcnRzLk1vY2tQb29sID0gTW9ja1Bvb2xcbm1vZHVsZS5leHBvcnRzLk1vY2tBZ2VudCA9IE1vY2tBZ2VudFxubW9kdWxlLmV4cG9ydHMubW9ja0Vycm9ycyA9IG1vY2tFcnJvcnNcbiJdLCJuYW1lcyI6WyJDbGllbnQiLCJyZXF1aXJlIiwiRGlzcGF0Y2hlciIsImVycm9ycyIsIlBvb2wiLCJCYWxhbmNlZFBvb2wiLCJBZ2VudCIsInV0aWwiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsImFwaSIsImJ1aWxkQ29ubmVjdG9yIiwiTW9ja0NsaWVudCIsIk1vY2tBZ2VudCIsIk1vY2tQb29sIiwibW9ja0Vycm9ycyIsIlByb3h5QWdlbnQiLCJSZXRyeUhhbmRsZXIiLCJnZXRHbG9iYWxEaXNwYXRjaGVyIiwic2V0R2xvYmFsRGlzcGF0Y2hlciIsIkRlY29yYXRvckhhbmRsZXIiLCJSZWRpcmVjdEhhbmRsZXIiLCJjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yIiwiaGFzQ3J5cHRvIiwiT2JqZWN0IiwiYXNzaWduIiwicHJvdG90eXBlIiwibW9kdWxlIiwiZXhwb3J0cyIsIm1ha2VEaXNwYXRjaGVyIiwiZm4iLCJ1cmwiLCJvcHRzIiwiaGFuZGxlciIsIlVSTCIsInBhdGgiLCJzdGFydHNXaXRoIiwicGFyc2VPcmlnaW4iLCJvcmlnaW4iLCJwYXJzZVVSTCIsImFnZW50IiwiZGlzcGF0Y2hlciIsImNhbGwiLCJzZWFyY2giLCJwYXRobmFtZSIsIm1ldGhvZCIsImJvZHkiLCJub2RlTWFqb3IiLCJub2RlTWlub3IiLCJmZXRjaEltcGwiLCJmZXRjaCIsInJlc291cmNlIiwiYXJndW1lbnRzIiwiZXJyIiwiRXJyb3IiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIkhlYWRlcnMiLCJSZXNwb25zZSIsIlJlcXVlc3QiLCJGb3JtRGF0YSIsIkZpbGUiLCJGaWxlUmVhZGVyIiwic2V0R2xvYmFsT3JpZ2luIiwiZ2V0R2xvYmFsT3JpZ2luIiwiQ2FjaGVTdG9yYWdlIiwia0NvbnN0cnVjdCIsImNhY2hlcyIsImRlbGV0ZUNvb2tpZSIsImdldENvb2tpZXMiLCJnZXRTZXRDb29raWVzIiwic2V0Q29va2llIiwicGFyc2VNSU1FVHlwZSIsInNlcmlhbGl6ZUFNaW1lVHlwZSIsIldlYlNvY2tldCIsInJlcXVlc3QiLCJzdHJlYW0iLCJwaXBlbGluZSIsImNvbm5lY3QiLCJ1cGdyYWRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/agent.js":
/*!****************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/agent.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\nconst { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = __webpack_require__(/*! ./core/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\");\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/dispatcher-base.js\");\nconst Pool = __webpack_require__(/*! ./pool */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/pool.js\");\nconst Client = __webpack_require__(/*! ./client */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/client.js\");\nconst util = __webpack_require__(/*! ./core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst createRedirectInterceptor = __webpack_require__(/*! ./interceptor/redirectInterceptor */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/interceptor/redirectInterceptor.js\");\nconst { WeakRef, FinalizationRegistry } = __webpack_require__(/*! ./compat/dispatcher-weakref */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/compat/dispatcher-weakref.js\")();\nconst kOnConnect = Symbol(\"onConnect\");\nconst kOnDisconnect = Symbol(\"onDisconnect\");\nconst kOnConnectionError = Symbol(\"onConnectionError\");\nconst kMaxRedirections = Symbol(\"maxRedirections\");\nconst kOnDrain = Symbol(\"onDrain\");\nconst kFactory = Symbol(\"factory\");\nconst kFinalizer = Symbol(\"finalizer\");\nconst kOptions = Symbol(\"options\");\nfunction defaultFactory(origin, opts) {\n    return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);\n}\nclass Agent extends DispatcherBase {\n    constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}){\n        super();\n        if (typeof factory !== \"function\") {\n            throw new InvalidArgumentError(\"factory must be a function.\");\n        }\n        if (connect != null && typeof connect !== \"function\" && typeof connect !== \"object\") {\n            throw new InvalidArgumentError(\"connect must be a function or an object\");\n        }\n        if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n            throw new InvalidArgumentError(\"maxRedirections must be a positive number\");\n        }\n        if (connect && typeof connect !== \"function\") {\n            connect = {\n                ...connect\n            };\n        }\n        this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [\n            createRedirectInterceptor({\n                maxRedirections\n            })\n        ];\n        this[kOptions] = {\n            ...util.deepClone(options),\n            connect\n        };\n        this[kOptions].interceptors = options.interceptors ? {\n            ...options.interceptors\n        } : undefined;\n        this[kMaxRedirections] = maxRedirections;\n        this[kFactory] = factory;\n        this[kClients] = new Map();\n        this[kFinalizer] = new FinalizationRegistry(/* istanbul ignore next: gc is undeterministic */ (key)=>{\n            const ref = this[kClients].get(key);\n            if (ref !== undefined && ref.deref() === undefined) {\n                this[kClients].delete(key);\n            }\n        });\n        const agent = this;\n        this[kOnDrain] = (origin, targets)=>{\n            agent.emit(\"drain\", origin, [\n                agent,\n                ...targets\n            ]);\n        };\n        this[kOnConnect] = (origin, targets)=>{\n            agent.emit(\"connect\", origin, [\n                agent,\n                ...targets\n            ]);\n        };\n        this[kOnDisconnect] = (origin, targets, err)=>{\n            agent.emit(\"disconnect\", origin, [\n                agent,\n                ...targets\n            ], err);\n        };\n        this[kOnConnectionError] = (origin, targets, err)=>{\n            agent.emit(\"connectionError\", origin, [\n                agent,\n                ...targets\n            ], err);\n        };\n    }\n    get [kRunning]() {\n        let ret = 0;\n        for (const ref of this[kClients].values()){\n            const client = ref.deref();\n            /* istanbul ignore next: gc is undeterministic */ if (client) {\n                ret += client[kRunning];\n            }\n        }\n        return ret;\n    }\n    [kDispatch](opts, handler) {\n        let key;\n        if (opts.origin && (typeof opts.origin === \"string\" || opts.origin instanceof URL)) {\n            key = String(opts.origin);\n        } else {\n            throw new InvalidArgumentError(\"opts.origin must be a non-empty string or URL.\");\n        }\n        const ref = this[kClients].get(key);\n        let dispatcher = ref ? ref.deref() : null;\n        if (!dispatcher) {\n            dispatcher = this[kFactory](opts.origin, this[kOptions]).on(\"drain\", this[kOnDrain]).on(\"connect\", this[kOnConnect]).on(\"disconnect\", this[kOnDisconnect]).on(\"connectionError\", this[kOnConnectionError]);\n            this[kClients].set(key, new WeakRef(dispatcher));\n            this[kFinalizer].register(dispatcher, key);\n        }\n        return dispatcher.dispatch(opts, handler);\n    }\n    async [kClose]() {\n        const closePromises = [];\n        for (const ref of this[kClients].values()){\n            const client = ref.deref();\n            /* istanbul ignore else: gc is undeterministic */ if (client) {\n                closePromises.push(client.close());\n            }\n        }\n        await Promise.all(closePromises);\n    }\n    async [kDestroy](err) {\n        const destroyPromises = [];\n        for (const ref of this[kClients].values()){\n            const client = ref.deref();\n            /* istanbul ignore else: gc is undeterministic */ if (client) {\n                destroyPromises.push(client.destroy(err));\n            }\n        }\n        await Promise.all(destroyPromises);\n    }\n}\nmodule.exports = Agent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYWdlbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLG9CQUFvQixFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ3pDLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxTQUFTLEVBQUVDLGFBQWEsRUFBRSxHQUFHTixtQkFBT0EsQ0FBQztBQUNuRixNQUFNTyxpQkFBaUJQLG1CQUFPQSxDQUFDO0FBQy9CLE1BQU1RLE9BQU9SLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1TLFNBQVNULG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1VLE9BQU9WLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1XLDRCQUE0QlgsbUJBQU9BLENBQUM7QUFDMUMsTUFBTSxFQUFFWSxPQUFPLEVBQUVDLG9CQUFvQixFQUFFLEdBQUdiLG1CQUFPQSxDQUFDO0FBRWxELE1BQU1jLGFBQWFDLE9BQU87QUFDMUIsTUFBTUMsZ0JBQWdCRCxPQUFPO0FBQzdCLE1BQU1FLHFCQUFxQkYsT0FBTztBQUNsQyxNQUFNRyxtQkFBbUJILE9BQU87QUFDaEMsTUFBTUksV0FBV0osT0FBTztBQUN4QixNQUFNSyxXQUFXTCxPQUFPO0FBQ3hCLE1BQU1NLGFBQWFOLE9BQU87QUFDMUIsTUFBTU8sV0FBV1AsT0FBTztBQUV4QixTQUFTUSxlQUFnQkMsTUFBTSxFQUFFQyxJQUFJO0lBQ25DLE9BQU9BLFFBQVFBLEtBQUtDLFdBQVcsS0FBSyxJQUNoQyxJQUFJakIsT0FBT2UsUUFBUUMsUUFDbkIsSUFBSWpCLEtBQUtnQixRQUFRQztBQUN2QjtBQUVBLE1BQU1FLGNBQWNwQjtJQUNsQnFCLFlBQWEsRUFBRUMsVUFBVU4sY0FBYyxFQUFFTyxrQkFBa0IsQ0FBQyxFQUFFQyxPQUFPLEVBQUUsR0FBR0MsU0FBUyxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQ3hGLEtBQUs7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TSxHQUFJO1lBQ3pDLE1BQU1DLFNBQVNWLElBQUlFLEtBQUs7WUFDeEIsK0NBQStDLEdBQy9DLElBQUlRLFFBQVE7Z0JBQ1ZjLGdCQUFnQkosSUFBSSxDQUFDVixPQUFPZSxPQUFPLENBQUNsQjtZQUN0QztRQUNGO1FBRUEsTUFBTWUsUUFBUUMsR0FBRyxDQUFDQztJQUNwQjtBQUNGO0FBRUFFLE9BQU9DLE9BQU8sR0FBRzFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1maWdodGVyLWFjYWRlbXkvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYWdlbnQuanM/MTdhMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi9jb3JlL2Vycm9ycycpXG5jb25zdCB7IGtDbGllbnRzLCBrUnVubmluZywga0Nsb3NlLCBrRGVzdHJveSwga0Rpc3BhdGNoLCBrSW50ZXJjZXB0b3JzIH0gPSByZXF1aXJlKCcuL2NvcmUvc3ltYm9scycpXG5jb25zdCBEaXNwYXRjaGVyQmFzZSA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hlci1iYXNlJylcbmNvbnN0IFBvb2wgPSByZXF1aXJlKCcuL3Bvb2wnKVxuY29uc3QgQ2xpZW50ID0gcmVxdWlyZSgnLi9jbGllbnQnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJylcbmNvbnN0IGNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IgPSByZXF1aXJlKCcuL2ludGVyY2VwdG9yL3JlZGlyZWN0SW50ZXJjZXB0b3InKVxuY29uc3QgeyBXZWFrUmVmLCBGaW5hbGl6YXRpb25SZWdpc3RyeSB9ID0gcmVxdWlyZSgnLi9jb21wYXQvZGlzcGF0Y2hlci13ZWFrcmVmJykoKVxuXG5jb25zdCBrT25Db25uZWN0ID0gU3ltYm9sKCdvbkNvbm5lY3QnKVxuY29uc3Qga09uRGlzY29ubmVjdCA9IFN5bWJvbCgnb25EaXNjb25uZWN0JylcbmNvbnN0IGtPbkNvbm5lY3Rpb25FcnJvciA9IFN5bWJvbCgnb25Db25uZWN0aW9uRXJyb3InKVxuY29uc3Qga01heFJlZGlyZWN0aW9ucyA9IFN5bWJvbCgnbWF4UmVkaXJlY3Rpb25zJylcbmNvbnN0IGtPbkRyYWluID0gU3ltYm9sKCdvbkRyYWluJylcbmNvbnN0IGtGYWN0b3J5ID0gU3ltYm9sKCdmYWN0b3J5JylcbmNvbnN0IGtGaW5hbGl6ZXIgPSBTeW1ib2woJ2ZpbmFsaXplcicpXG5jb25zdCBrT3B0aW9ucyA9IFN5bWJvbCgnb3B0aW9ucycpXG5cbmZ1bmN0aW9uIGRlZmF1bHRGYWN0b3J5IChvcmlnaW4sIG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgb3B0cy5jb25uZWN0aW9ucyA9PT0gMVxuICAgID8gbmV3IENsaWVudChvcmlnaW4sIG9wdHMpXG4gICAgOiBuZXcgUG9vbChvcmlnaW4sIG9wdHMpXG59XG5cbmNsYXNzIEFnZW50IGV4dGVuZHMgRGlzcGF0Y2hlckJhc2Uge1xuICBjb25zdHJ1Y3RvciAoeyBmYWN0b3J5ID0gZGVmYXVsdEZhY3RvcnksIG1heFJlZGlyZWN0aW9ucyA9IDAsIGNvbm5lY3QsIC4uLm9wdGlvbnMgfSA9IHt9KSB7XG4gICAgc3VwZXIoKVxuXG4gICAgaWYgKHR5cGVvZiBmYWN0b3J5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ZhY3RvcnkgbXVzdCBiZSBhIGZ1bmN0aW9uLicpXG4gICAgfVxuXG4gICAgaWYgKGNvbm5lY3QgIT0gbnVsbCAmJiB0eXBlb2YgY29ubmVjdCAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY29ubmVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignY29ubmVjdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0JylcbiAgICB9XG5cbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4UmVkaXJlY3Rpb25zKSB8fCBtYXhSZWRpcmVjdGlvbnMgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heFJlZGlyZWN0aW9ucyBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICBpZiAoY29ubmVjdCAmJiB0eXBlb2YgY29ubmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29ubmVjdCA9IHsgLi4uY29ubmVjdCB9XG4gICAgfVxuXG4gICAgdGhpc1trSW50ZXJjZXB0b3JzXSA9IG9wdGlvbnMuaW50ZXJjZXB0b3JzICYmIG9wdGlvbnMuaW50ZXJjZXB0b3JzLkFnZW50ICYmIEFycmF5LmlzQXJyYXkob3B0aW9ucy5pbnRlcmNlcHRvcnMuQWdlbnQpXG4gICAgICA/IG9wdGlvbnMuaW50ZXJjZXB0b3JzLkFnZW50XG4gICAgICA6IFtjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yKHsgbWF4UmVkaXJlY3Rpb25zIH0pXVxuXG4gICAgdGhpc1trT3B0aW9uc10gPSB7IC4uLnV0aWwuZGVlcENsb25lKG9wdGlvbnMpLCBjb25uZWN0IH1cbiAgICB0aGlzW2tPcHRpb25zXS5pbnRlcmNlcHRvcnMgPSBvcHRpb25zLmludGVyY2VwdG9yc1xuICAgICAgPyB7IC4uLm9wdGlvbnMuaW50ZXJjZXB0b3JzIH1cbiAgICAgIDogdW5kZWZpbmVkXG4gICAgdGhpc1trTWF4UmVkaXJlY3Rpb25zXSA9IG1heFJlZGlyZWN0aW9uc1xuICAgIHRoaXNba0ZhY3RvcnldID0gZmFjdG9yeVxuICAgIHRoaXNba0NsaWVudHNdID0gbmV3IE1hcCgpXG4gICAgdGhpc1trRmluYWxpemVyXSA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZ2MgaXMgdW5kZXRlcm1pbmlzdGljICovIGtleSA9PiB7XG4gICAgICBjb25zdCByZWYgPSB0aGlzW2tDbGllbnRzXS5nZXQoa2V5KVxuICAgICAgaWYgKHJlZiAhPT0gdW5kZWZpbmVkICYmIHJlZi5kZXJlZigpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpc1trQ2xpZW50c10uZGVsZXRlKGtleSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3QgYWdlbnQgPSB0aGlzXG5cbiAgICB0aGlzW2tPbkRyYWluXSA9IChvcmlnaW4sIHRhcmdldHMpID0+IHtcbiAgICAgIGFnZW50LmVtaXQoJ2RyYWluJywgb3JpZ2luLCBbYWdlbnQsIC4uLnRhcmdldHNdKVxuICAgIH1cblxuICAgIHRoaXNba09uQ29ubmVjdF0gPSAob3JpZ2luLCB0YXJnZXRzKSA9PiB7XG4gICAgICBhZ2VudC5lbWl0KCdjb25uZWN0Jywgb3JpZ2luLCBbYWdlbnQsIC4uLnRhcmdldHNdKVxuICAgIH1cblxuICAgIHRoaXNba09uRGlzY29ubmVjdF0gPSAob3JpZ2luLCB0YXJnZXRzLCBlcnIpID0+IHtcbiAgICAgIGFnZW50LmVtaXQoJ2Rpc2Nvbm5lY3QnLCBvcmlnaW4sIFthZ2VudCwgLi4udGFyZ2V0c10sIGVycilcbiAgICB9XG5cbiAgICB0aGlzW2tPbkNvbm5lY3Rpb25FcnJvcl0gPSAob3JpZ2luLCB0YXJnZXRzLCBlcnIpID0+IHtcbiAgICAgIGFnZW50LmVtaXQoJ2Nvbm5lY3Rpb25FcnJvcicsIG9yaWdpbiwgW2FnZW50LCAuLi50YXJnZXRzXSwgZXJyKVxuICAgIH1cbiAgfVxuXG4gIGdldCBba1J1bm5pbmddICgpIHtcbiAgICBsZXQgcmV0ID0gMFxuICAgIGZvciAoY29uc3QgcmVmIG9mIHRoaXNba0NsaWVudHNdLnZhbHVlcygpKSB7XG4gICAgICBjb25zdCBjbGllbnQgPSByZWYuZGVyZWYoKVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGdjIGlzIHVuZGV0ZXJtaW5pc3RpYyAqL1xuICAgICAgaWYgKGNsaWVudCkge1xuICAgICAgICByZXQgKz0gY2xpZW50W2tSdW5uaW5nXVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBba0Rpc3BhdGNoXSAob3B0cywgaGFuZGxlcikge1xuICAgIGxldCBrZXlcbiAgICBpZiAob3B0cy5vcmlnaW4gJiYgKHR5cGVvZiBvcHRzLm9yaWdpbiA9PT0gJ3N0cmluZycgfHwgb3B0cy5vcmlnaW4gaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgICBrZXkgPSBTdHJpbmcob3B0cy5vcmlnaW4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignb3B0cy5vcmlnaW4gbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgVVJMLicpXG4gICAgfVxuXG4gICAgY29uc3QgcmVmID0gdGhpc1trQ2xpZW50c10uZ2V0KGtleSlcblxuICAgIGxldCBkaXNwYXRjaGVyID0gcmVmID8gcmVmLmRlcmVmKCkgOiBudWxsXG4gICAgaWYgKCFkaXNwYXRjaGVyKSB7XG4gICAgICBkaXNwYXRjaGVyID0gdGhpc1trRmFjdG9yeV0ob3B0cy5vcmlnaW4sIHRoaXNba09wdGlvbnNdKVxuICAgICAgICAub24oJ2RyYWluJywgdGhpc1trT25EcmFpbl0pXG4gICAgICAgIC5vbignY29ubmVjdCcsIHRoaXNba09uQ29ubmVjdF0pXG4gICAgICAgIC5vbignZGlzY29ubmVjdCcsIHRoaXNba09uRGlzY29ubmVjdF0pXG4gICAgICAgIC5vbignY29ubmVjdGlvbkVycm9yJywgdGhpc1trT25Db25uZWN0aW9uRXJyb3JdKVxuXG4gICAgICB0aGlzW2tDbGllbnRzXS5zZXQoa2V5LCBuZXcgV2Vha1JlZihkaXNwYXRjaGVyKSlcbiAgICAgIHRoaXNba0ZpbmFsaXplcl0ucmVnaXN0ZXIoZGlzcGF0Y2hlciwga2V5KVxuICAgIH1cblxuICAgIHJldHVybiBkaXNwYXRjaGVyLmRpc3BhdGNoKG9wdHMsIGhhbmRsZXIpXG4gIH1cblxuICBhc3luYyBba0Nsb3NlXSAoKSB7XG4gICAgY29uc3QgY2xvc2VQcm9taXNlcyA9IFtdXG4gICAgZm9yIChjb25zdCByZWYgb2YgdGhpc1trQ2xpZW50c10udmFsdWVzKCkpIHtcbiAgICAgIGNvbnN0IGNsaWVudCA9IHJlZi5kZXJlZigpXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogZ2MgaXMgdW5kZXRlcm1pbmlzdGljICovXG4gICAgICBpZiAoY2xpZW50KSB7XG4gICAgICAgIGNsb3NlUHJvbWlzZXMucHVzaChjbGllbnQuY2xvc2UoKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChjbG9zZVByb21pc2VzKVxuICB9XG5cbiAgYXN5bmMgW2tEZXN0cm95XSAoZXJyKSB7XG4gICAgY29uc3QgZGVzdHJveVByb21pc2VzID0gW11cbiAgICBmb3IgKGNvbnN0IHJlZiBvZiB0aGlzW2tDbGllbnRzXS52YWx1ZXMoKSkge1xuICAgICAgY29uc3QgY2xpZW50ID0gcmVmLmRlcmVmKClcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBnYyBpcyB1bmRldGVybWluaXN0aWMgKi9cbiAgICAgIGlmIChjbGllbnQpIHtcbiAgICAgICAgZGVzdHJveVByb21pc2VzLnB1c2goY2xpZW50LmRlc3Ryb3koZXJyKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChkZXN0cm95UHJvbWlzZXMpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBZ2VudFxuIl0sIm5hbWVzIjpbIkludmFsaWRBcmd1bWVudEVycm9yIiwicmVxdWlyZSIsImtDbGllbnRzIiwia1J1bm5pbmciLCJrQ2xvc2UiLCJrRGVzdHJveSIsImtEaXNwYXRjaCIsImtJbnRlcmNlcHRvcnMiLCJEaXNwYXRjaGVyQmFzZSIsIlBvb2wiLCJDbGllbnQiLCJ1dGlsIiwiY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvciIsIldlYWtSZWYiLCJGaW5hbGl6YXRpb25SZWdpc3RyeSIsImtPbkNvbm5lY3QiLCJTeW1ib2wiLCJrT25EaXNjb25uZWN0Iiwia09uQ29ubmVjdGlvbkVycm9yIiwia01heFJlZGlyZWN0aW9ucyIsImtPbkRyYWluIiwia0ZhY3RvcnkiLCJrRmluYWxpemVyIiwia09wdGlvbnMiLCJkZWZhdWx0RmFjdG9yeSIsIm9yaWdpbiIsIm9wdHMiLCJjb25uZWN0aW9ucyIsIkFnZW50IiwiY29uc3RydWN0b3IiLCJmYWN0b3J5IiwibWF4UmVkaXJlY3Rpb25zIiwiY29ubmVjdCIsIm9wdGlvbnMiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJpbnRlcmNlcHRvcnMiLCJBcnJheSIsImlzQXJyYXkiLCJkZWVwQ2xvbmUiLCJ1bmRlZmluZWQiLCJNYXAiLCJrZXkiLCJyZWYiLCJnZXQiLCJkZXJlZiIsImRlbGV0ZSIsImFnZW50IiwidGFyZ2V0cyIsImVtaXQiLCJlcnIiLCJyZXQiLCJ2YWx1ZXMiLCJjbGllbnQiLCJoYW5kbGVyIiwiVVJMIiwiU3RyaW5nIiwiZGlzcGF0Y2hlciIsIm9uIiwic2V0IiwicmVnaXN0ZXIiLCJkaXNwYXRjaCIsImNsb3NlUHJvbWlzZXMiLCJwdXNoIiwiY2xvc2UiLCJQcm9taXNlIiwiYWxsIiwiZGVzdHJveVByb21pc2VzIiwiZGVzdHJveSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/agent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/api/abort-signal.js":
/*!***************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/api/abort-signal.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { addAbortListener } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst { RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\nconst kListener = Symbol(\"kListener\");\nconst kSignal = Symbol(\"kSignal\");\nfunction abort(self) {\n    if (self.abort) {\n        self.abort();\n    } else {\n        self.onError(new RequestAbortedError());\n    }\n}\nfunction addSignal(self, signal) {\n    self[kSignal] = null;\n    self[kListener] = null;\n    if (!signal) {\n        return;\n    }\n    if (signal.aborted) {\n        abort(self);\n        return;\n    }\n    self[kSignal] = signal;\n    self[kListener] = ()=>{\n        abort(self);\n    };\n    addAbortListener(self[kSignal], self[kListener]);\n}\nfunction removeSignal(self) {\n    if (!self[kSignal]) {\n        return;\n    }\n    if (\"removeEventListener\" in self[kSignal]) {\n        self[kSignal].removeEventListener(\"abort\", self[kListener]);\n    } else {\n        self[kSignal].removeListener(\"abort\", self[kListener]);\n    }\n    self[kSignal] = null;\n    self[kListener] = null;\n}\nmodule.exports = {\n    addSignal,\n    removeSignal\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2Fib3J0LXNpZ25hbC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxFQUFFQSxnQkFBZ0IsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUNyQyxNQUFNLEVBQUVDLG1CQUFtQixFQUFFLEdBQUdELG1CQUFPQSxDQUFDO0FBRXhDLE1BQU1FLFlBQVlDLE9BQU87QUFDekIsTUFBTUMsVUFBVUQsT0FBTztBQUV2QixTQUFTRSxNQUFPQyxJQUFJO0lBQ2xCLElBQUlBLEtBQUtELEtBQUssRUFBRTtRQUNkQyxLQUFLRCxLQUFLO0lBQ1osT0FBTztRQUNMQyxLQUFLQyxPQUFPLENBQUMsSUFBSU47SUFDbkI7QUFDRjtBQUVBLFNBQVNPLFVBQVdGLElBQUksRUFBRUcsTUFBTTtJQUM5QkgsSUFBSSxDQUFDRixRQUFRLEdBQUc7SUFDaEJFLElBQUksQ0FBQ0osVUFBVSxHQUFHO0lBRWxCLElBQUksQ0FBQ08sUUFBUTtRQUNYO0lBQ0Y7SUFFQSxJQUFJQSxPQUFPQyxPQUFPLEVBQUU7UUFDbEJMLE1BQU1DO1FBQ047SUFDRjtJQUVBQSxJQUFJLENBQUNGLFFBQVEsR0FBR0s7SUFDaEJILElBQUksQ0FBQ0osVUFBVSxHQUFHO1FBQ2hCRyxNQUFNQztJQUNSO0lBRUFQLGlCQUFpQk8sSUFBSSxDQUFDRixRQUFRLEVBQUVFLElBQUksQ0FBQ0osVUFBVTtBQUNqRDtBQUVBLFNBQVNTLGFBQWNMLElBQUk7SUFDekIsSUFBSSxDQUFDQSxJQUFJLENBQUNGLFFBQVEsRUFBRTtRQUNsQjtJQUNGO0lBRUEsSUFBSSx5QkFBeUJFLElBQUksQ0FBQ0YsUUFBUSxFQUFFO1FBQzFDRSxJQUFJLENBQUNGLFFBQVEsQ0FBQ1EsbUJBQW1CLENBQUMsU0FBU04sSUFBSSxDQUFDSixVQUFVO0lBQzVELE9BQU87UUFDTEksSUFBSSxDQUFDRixRQUFRLENBQUNTLGNBQWMsQ0FBQyxTQUFTUCxJQUFJLENBQUNKLFVBQVU7SUFDdkQ7SUFFQUksSUFBSSxDQUFDRixRQUFRLEdBQUc7SUFDaEJFLElBQUksQ0FBQ0osVUFBVSxHQUFHO0FBQ3BCO0FBRUFZLE9BQU9DLE9BQU8sR0FBRztJQUNmUDtJQUNBRztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1maWdodGVyLWFjYWRlbXkvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2Fib3J0LXNpZ25hbC5qcz9hMWQyIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgYWRkQWJvcnRMaXN0ZW5lciB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgUmVxdWVzdEFib3J0ZWRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuXG5jb25zdCBrTGlzdGVuZXIgPSBTeW1ib2woJ2tMaXN0ZW5lcicpXG5jb25zdCBrU2lnbmFsID0gU3ltYm9sKCdrU2lnbmFsJylcblxuZnVuY3Rpb24gYWJvcnQgKHNlbGYpIHtcbiAgaWYgKHNlbGYuYWJvcnQpIHtcbiAgICBzZWxmLmFib3J0KClcbiAgfSBlbHNlIHtcbiAgICBzZWxmLm9uRXJyb3IobmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRTaWduYWwgKHNlbGYsIHNpZ25hbCkge1xuICBzZWxmW2tTaWduYWxdID0gbnVsbFxuICBzZWxmW2tMaXN0ZW5lcl0gPSBudWxsXG5cbiAgaWYgKCFzaWduYWwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgIGFib3J0KHNlbGYpXG4gICAgcmV0dXJuXG4gIH1cblxuICBzZWxmW2tTaWduYWxdID0gc2lnbmFsXG4gIHNlbGZba0xpc3RlbmVyXSA9ICgpID0+IHtcbiAgICBhYm9ydChzZWxmKVxuICB9XG5cbiAgYWRkQWJvcnRMaXN0ZW5lcihzZWxmW2tTaWduYWxdLCBzZWxmW2tMaXN0ZW5lcl0pXG59XG5cbmZ1bmN0aW9uIHJlbW92ZVNpZ25hbCAoc2VsZikge1xuICBpZiAoIXNlbGZba1NpZ25hbF0pIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gc2VsZltrU2lnbmFsXSkge1xuICAgIHNlbGZba1NpZ25hbF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBzZWxmW2tMaXN0ZW5lcl0pXG4gIH0gZWxzZSB7XG4gICAgc2VsZltrU2lnbmFsXS5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBzZWxmW2tMaXN0ZW5lcl0pXG4gIH1cblxuICBzZWxmW2tTaWduYWxdID0gbnVsbFxuICBzZWxmW2tMaXN0ZW5lcl0gPSBudWxsXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZGRTaWduYWwsXG4gIHJlbW92ZVNpZ25hbFxufVxuIl0sIm5hbWVzIjpbImFkZEFib3J0TGlzdGVuZXIiLCJyZXF1aXJlIiwiUmVxdWVzdEFib3J0ZWRFcnJvciIsImtMaXN0ZW5lciIsIlN5bWJvbCIsImtTaWduYWwiLCJhYm9ydCIsInNlbGYiLCJvbkVycm9yIiwiYWRkU2lnbmFsIiwic2lnbmFsIiwiYWJvcnRlZCIsInJlbW92ZVNpZ25hbCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/api/abort-signal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/api/api-connect.js":
/*!**************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/api/api-connect.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\nconst { InvalidArgumentError, RequestAbortedError, SocketError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/api/abort-signal.js\");\nclass ConnectHandler extends AsyncResource {\n    constructor(opts, callback){\n        if (!opts || typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"invalid opts\");\n        }\n        if (typeof callback !== \"function\") {\n            throw new InvalidArgumentError(\"invalid callback\");\n        }\n        const { signal, opaque, responseHeaders } = opts;\n        if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n            throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n        }\n        super(\"UNDICI_CONNECT\");\n        this.opaque = opaque || null;\n        this.responseHeaders = responseHeaders || null;\n        this.callback = callback;\n        this.abort = null;\n        addSignal(this, signal);\n    }\n    onConnect(abort, context) {\n        if (!this.callback) {\n            throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = context;\n    }\n    onHeaders() {\n        throw new SocketError(\"bad connect\", null);\n    }\n    onUpgrade(statusCode, rawHeaders, socket) {\n        const { callback, opaque, context } = this;\n        removeSignal(this);\n        this.callback = null;\n        let headers = rawHeaders;\n        // Indicates is an HTTP2Session\n        if (headers != null) {\n            headers = this.responseHeaders === \"raw\" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        }\n        this.runInAsyncScope(callback, null, null, {\n            statusCode,\n            headers,\n            socket,\n            opaque,\n            context\n        });\n    }\n    onError(err) {\n        const { callback, opaque } = this;\n        removeSignal(this);\n        if (callback) {\n            this.callback = null;\n            queueMicrotask(()=>{\n                this.runInAsyncScope(callback, null, err, {\n                    opaque\n                });\n            });\n        }\n    }\n}\nfunction connect(opts, callback) {\n    if (callback === undefined) {\n        return new Promise((resolve, reject)=>{\n            connect.call(this, opts, (err, data)=>{\n                return err ? reject(err) : resolve(data);\n            });\n        });\n    }\n    try {\n        const connectHandler = new ConnectHandler(opts, callback);\n        this.dispatch({\n            ...opts,\n            method: \"CONNECT\"\n        }, connectHandler);\n    } catch (err) {\n        if (typeof callback !== \"function\") {\n            throw err;\n        }\n        const opaque = opts && opts.opaque;\n        queueMicrotask(()=>callback(err, {\n                opaque\n            }));\n    }\n}\nmodule.exports = connect;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS1jb25uZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxhQUFhLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUFFQyxvQkFBb0IsRUFBRUMsbUJBQW1CLEVBQUVDLFdBQVcsRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQztBQUMzRSxNQUFNSSxPQUFPSixtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQUVLLFNBQVMsRUFBRUMsWUFBWSxFQUFFLEdBQUdOLG1CQUFPQSxDQUFDO0FBRTVDLE1BQU1PLHVCQUF1QlI7SUFDM0JTLFlBQWFDLElBQUksRUFBRUMsUUFBUSxDQUFFO1FBQzNCLElBQUksQ0FBQ0QsUUFBUSxPQUFPQSxTQUFTLFVBQVU7WUFDckMsTUFBTSxJQUFJUixxQkFBcUI7UUFDakM7UUFFQSxJQUFJLE9BQU9TLGFBQWEsWUFBWTtZQUNsQyxNQUFNLElBQUlULHFCQUFxQjtRQUNqQztRQUVBLE1BQU0sRUFBRVUsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLGVBQWUsRUFBRSxHQUFHSjtRQUU1QyxJQUFJRSxVQUFVLE9BQU9BLE9BQU9HLEVBQUUsS0FBSyxjQUFjLE9BQU9ILE9BQU9JLGdCQUFnQixLQUFLLFlBQVk7WUFDOUYsTUFBTSxJQUFJZCxxQkFBcUI7UUFDakM7UUFFQSxLQUFLLENBQUM7UUFFTixJQUFJLENBQUNXLE1BQU0sR0FBR0EsVUFBVTtRQUN4QixJQUFJLENBQUNDLGVBQWUsR0FBR0EsbUJBQW1CO1FBQzFDLElBQUksQ0FBQ0gsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNNLEtBQUssR0FBRztRQUViWCxVQUFVLElBQUksRUFBRU07SUFDbEI7SUFFQU0sVUFBV0QsS0FBSyxFQUFFRSxPQUFPLEVBQUU7UUFDekIsSUFBSSxDQUFDLElBQUksQ0FBQ1IsUUFBUSxFQUFFO1lBQ2xCLE1BQU0sSUFBSVI7UUFDWjtRQUVBLElBQUksQ0FBQ2MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0UsT0FBTyxHQUFHQTtJQUNqQjtJQUVBQyxZQUFhO1FBQ1gsTUFBTSxJQUFJaEIsWUFBWSxlQUFlO0lBQ3ZDO0lBRUFpQixVQUFXQyxVQUFVLEVBQUVDLFVBQVUsRUFBRUMsTUFBTSxFQUFFO1FBQ3pDLE1BQU0sRUFBRWIsUUFBUSxFQUFFRSxNQUFNLEVBQUVNLE9BQU8sRUFBRSxHQUFHLElBQUk7UUFFMUNaLGFBQWEsSUFBSTtRQUVqQixJQUFJLENBQUNJLFFBQVEsR0FBRztRQUVoQixJQUFJYyxVQUFVRjtRQUNkLCtCQUErQjtRQUMvQixJQUFJRSxXQUFXLE1BQU07WUFDbkJBLFVBQVUsSUFBSSxDQUFDWCxlQUFlLEtBQUssUUFBUVQsS0FBS3FCLGVBQWUsQ0FBQ0gsY0FBY2xCLEtBQUtzQixZQUFZLENBQUNKO1FBQ2xHO1FBRUEsSUFBSSxDQUFDSyxlQUFlLENBQUNqQixVQUFVLE1BQU0sTUFBTTtZQUN6Q1c7WUFDQUc7WUFDQUQ7WUFDQVg7WUFDQU07UUFDRjtJQUNGO0lBRUFVLFFBQVNDLEdBQUcsRUFBRTtRQUNaLE1BQU0sRUFBRW5CLFFBQVEsRUFBRUUsTUFBTSxFQUFFLEdBQUcsSUFBSTtRQUVqQ04sYUFBYSxJQUFJO1FBRWpCLElBQUlJLFVBQVU7WUFDWixJQUFJLENBQUNBLFFBQVEsR0FBRztZQUNoQm9CLGVBQWU7Z0JBQ2IsSUFBSSxDQUFDSCxlQUFlLENBQUNqQixVQUFVLE1BQU1tQixLQUFLO29CQUFFakI7Z0JBQU87WUFDckQ7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxTQUFTbUIsUUFBU3RCLElBQUksRUFBRUMsUUFBUTtJQUM5QixJQUFJQSxhQUFhc0IsV0FBVztRQUMxQixPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDM0JKLFFBQVFLLElBQUksQ0FBQyxJQUFJLEVBQUUzQixNQUFNLENBQUNvQixLQUFLUTtnQkFDN0IsT0FBT1IsTUFBTU0sT0FBT04sT0FBT0ssUUFBUUc7WUFDckM7UUFDRjtJQUNGO0lBRUEsSUFBSTtRQUNGLE1BQU1DLGlCQUFpQixJQUFJL0IsZUFBZUUsTUFBTUM7UUFDaEQsSUFBSSxDQUFDNkIsUUFBUSxDQUFDO1lBQUUsR0FBRzlCLElBQUk7WUFBRStCLFFBQVE7UUFBVSxHQUFHRjtJQUNoRCxFQUFFLE9BQU9ULEtBQUs7UUFDWixJQUFJLE9BQU9uQixhQUFhLFlBQVk7WUFDbEMsTUFBTW1CO1FBQ1I7UUFDQSxNQUFNakIsU0FBU0gsUUFBUUEsS0FBS0csTUFBTTtRQUNsQ2tCLGVBQWUsSUFBTXBCLFNBQVNtQixLQUFLO2dCQUFFakI7WUFBTztJQUM5QztBQUNGO0FBRUE2QixPQUFPQyxPQUFPLEdBQUdYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1maWdodGVyLWFjYWRlbXkvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS1jb25uZWN0LmpzPzk0NTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQXN5bmNSZXNvdXJjZSB9ID0gcmVxdWlyZSgnYXN5bmNfaG9va3MnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgUmVxdWVzdEFib3J0ZWRFcnJvciwgU29ja2V0RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBhZGRTaWduYWwsIHJlbW92ZVNpZ25hbCB9ID0gcmVxdWlyZSgnLi9hYm9ydC1zaWduYWwnKVxuXG5jbGFzcyBDb25uZWN0SGFuZGxlciBleHRlbmRzIEFzeW5jUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3RvciAob3B0cywgY2FsbGJhY2spIHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb3B0cycpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNhbGxiYWNrJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHNpZ25hbCwgb3BhcXVlLCByZXNwb25zZUhlYWRlcnMgfSA9IG9wdHNcblxuICAgIGlmIChzaWduYWwgJiYgdHlwZW9mIHNpZ25hbC5vbiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignc2lnbmFsIG11c3QgYmUgYW4gRXZlbnRFbWl0dGVyIG9yIEV2ZW50VGFyZ2V0JylcbiAgICB9XG5cbiAgICBzdXBlcignVU5ESUNJX0NPTk5FQ1QnKVxuXG4gICAgdGhpcy5vcGFxdWUgPSBvcGFxdWUgfHwgbnVsbFxuICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzIHx8IG51bGxcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLmFib3J0ID0gbnVsbFxuXG4gICAgYWRkU2lnbmFsKHRoaXMsIHNpZ25hbClcbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQsIGNvbnRleHQpIHtcbiAgICBpZiAoIXRoaXMuY2FsbGJhY2spIHtcbiAgICAgIHRocm93IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICB9XG5cbiAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0XG4gIH1cblxuICBvbkhlYWRlcnMgKCkge1xuICAgIHRocm93IG5ldyBTb2NrZXRFcnJvcignYmFkIGNvbm5lY3QnLCBudWxsKVxuICB9XG5cbiAgb25VcGdyYWRlIChzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCBzb2NrZXQpIHtcbiAgICBjb25zdCB7IGNhbGxiYWNrLCBvcGFxdWUsIGNvbnRleHQgfSA9IHRoaXNcblxuICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgdGhpcy5jYWxsYmFjayA9IG51bGxcblxuICAgIGxldCBoZWFkZXJzID0gcmF3SGVhZGVyc1xuICAgIC8vIEluZGljYXRlcyBpcyBhbiBIVFRQMlNlc3Npb25cbiAgICBpZiAoaGVhZGVycyAhPSBudWxsKSB7XG4gICAgICBoZWFkZXJzID0gdGhpcy5yZXNwb25zZUhlYWRlcnMgPT09ICdyYXcnID8gdXRpbC5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKVxuICAgIH1cblxuICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBudWxsLCB7XG4gICAgICBzdGF0dXNDb2RlLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHNvY2tldCxcbiAgICAgIG9wYXF1ZSxcbiAgICAgIGNvbnRleHRcbiAgICB9KVxuICB9XG5cbiAgb25FcnJvciAoZXJyKSB7XG4gICAgY29uc3QgeyBjYWxsYmFjaywgb3BhcXVlIH0gPSB0aGlzXG5cbiAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIGVyciwgeyBvcGFxdWUgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbm5lY3QgKG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbm5lY3QuY2FsbCh0aGlzLCBvcHRzLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgIHJldHVybiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoZGF0YSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgY29ubmVjdEhhbmRsZXIgPSBuZXcgQ29ubmVjdEhhbmRsZXIob3B0cywgY2FsbGJhY2spXG4gICAgdGhpcy5kaXNwYXRjaCh7IC4uLm9wdHMsIG1ldGhvZDogJ0NPTk5FQ1QnIH0sIGNvbm5lY3RIYW5kbGVyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gICAgY29uc3Qgb3BhcXVlID0gb3B0cyAmJiBvcHRzLm9wYXF1ZVxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKGVyciwgeyBvcGFxdWUgfSkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25uZWN0XG4iXSwibmFtZXMiOlsiQXN5bmNSZXNvdXJjZSIsInJlcXVpcmUiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIlJlcXVlc3RBYm9ydGVkRXJyb3IiLCJTb2NrZXRFcnJvciIsInV0aWwiLCJhZGRTaWduYWwiLCJyZW1vdmVTaWduYWwiLCJDb25uZWN0SGFuZGxlciIsImNvbnN0cnVjdG9yIiwib3B0cyIsImNhbGxiYWNrIiwic2lnbmFsIiwib3BhcXVlIiwicmVzcG9uc2VIZWFkZXJzIiwib24iLCJhZGRFdmVudExpc3RlbmVyIiwiYWJvcnQiLCJvbkNvbm5lY3QiLCJjb250ZXh0Iiwib25IZWFkZXJzIiwib25VcGdyYWRlIiwic3RhdHVzQ29kZSIsInJhd0hlYWRlcnMiLCJzb2NrZXQiLCJoZWFkZXJzIiwicGFyc2VSYXdIZWFkZXJzIiwicGFyc2VIZWFkZXJzIiwicnVuSW5Bc3luY1Njb3BlIiwib25FcnJvciIsImVyciIsInF1ZXVlTWljcm90YXNrIiwiY29ubmVjdCIsInVuZGVmaW5lZCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiY2FsbCIsImRhdGEiLCJjb25uZWN0SGFuZGxlciIsImRpc3BhdGNoIiwibWV0aG9kIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/api/api-connect.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/api/api-pipeline.js":
/*!***************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/api/api-pipeline.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Readable, Duplex, PassThrough } = __webpack_require__(/*! stream */ \"stream\");\nconst { InvalidArgumentError, InvalidReturnValueError, RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/api/abort-signal.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst kResume = Symbol(\"resume\");\nclass PipelineRequest extends Readable {\n    constructor(){\n        super({\n            autoDestroy: true\n        });\n        this[kResume] = null;\n    }\n    _read() {\n        const { [kResume]: resume } = this;\n        if (resume) {\n            this[kResume] = null;\n            resume();\n        }\n    }\n    _destroy(err, callback) {\n        this._read();\n        callback(err);\n    }\n}\nclass PipelineResponse extends Readable {\n    constructor(resume){\n        super({\n            autoDestroy: true\n        });\n        this[kResume] = resume;\n    }\n    _read() {\n        this[kResume]();\n    }\n    _destroy(err, callback) {\n        if (!err && !this._readableState.endEmitted) {\n            err = new RequestAbortedError();\n        }\n        callback(err);\n    }\n}\nclass PipelineHandler extends AsyncResource {\n    constructor(opts, handler){\n        if (!opts || typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"invalid opts\");\n        }\n        if (typeof handler !== \"function\") {\n            throw new InvalidArgumentError(\"invalid handler\");\n        }\n        const { signal, method, opaque, onInfo, responseHeaders } = opts;\n        if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n            throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n        }\n        if (method === \"CONNECT\") {\n            throw new InvalidArgumentError(\"invalid method\");\n        }\n        if (onInfo && typeof onInfo !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onInfo callback\");\n        }\n        super(\"UNDICI_PIPELINE\");\n        this.opaque = opaque || null;\n        this.responseHeaders = responseHeaders || null;\n        this.handler = handler;\n        this.abort = null;\n        this.context = null;\n        this.onInfo = onInfo || null;\n        this.req = new PipelineRequest().on(\"error\", util.nop);\n        this.ret = new Duplex({\n            readableObjectMode: opts.objectMode,\n            autoDestroy: true,\n            read: ()=>{\n                const { body } = this;\n                if (body && body.resume) {\n                    body.resume();\n                }\n            },\n            write: (chunk, encoding, callback)=>{\n                const { req } = this;\n                if (req.push(chunk, encoding) || req._readableState.destroyed) {\n                    callback();\n                } else {\n                    req[kResume] = callback;\n                }\n            },\n            destroy: (err, callback)=>{\n                const { body, req, res, ret, abort } = this;\n                if (!err && !ret._readableState.endEmitted) {\n                    err = new RequestAbortedError();\n                }\n                if (abort && err) {\n                    abort();\n                }\n                util.destroy(body, err);\n                util.destroy(req, err);\n                util.destroy(res, err);\n                removeSignal(this);\n                callback(err);\n            }\n        }).on(\"prefinish\", ()=>{\n            const { req } = this;\n            // Node < 15 does not call _final in same tick.\n            req.push(null);\n        });\n        this.res = null;\n        addSignal(this, signal);\n    }\n    onConnect(abort, context) {\n        const { ret, res } = this;\n        assert(!res, \"pipeline cannot be retried\");\n        if (ret.destroyed) {\n            throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = context;\n    }\n    onHeaders(statusCode, rawHeaders, resume) {\n        const { opaque, handler, context } = this;\n        if (statusCode < 200) {\n            if (this.onInfo) {\n                const headers = this.responseHeaders === \"raw\" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n                this.onInfo({\n                    statusCode,\n                    headers\n                });\n            }\n            return;\n        }\n        this.res = new PipelineResponse(resume);\n        let body;\n        try {\n            this.handler = null;\n            const headers = this.responseHeaders === \"raw\" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n            body = this.runInAsyncScope(handler, null, {\n                statusCode,\n                headers,\n                opaque,\n                body: this.res,\n                context\n            });\n        } catch (err) {\n            this.res.on(\"error\", util.nop);\n            throw err;\n        }\n        if (!body || typeof body.on !== \"function\") {\n            throw new InvalidReturnValueError(\"expected Readable\");\n        }\n        body.on(\"data\", (chunk)=>{\n            const { ret, body } = this;\n            if (!ret.push(chunk) && body.pause) {\n                body.pause();\n            }\n        }).on(\"error\", (err)=>{\n            const { ret } = this;\n            util.destroy(ret, err);\n        }).on(\"end\", ()=>{\n            const { ret } = this;\n            ret.push(null);\n        }).on(\"close\", ()=>{\n            const { ret } = this;\n            if (!ret._readableState.ended) {\n                util.destroy(ret, new RequestAbortedError());\n            }\n        });\n        this.body = body;\n    }\n    onData(chunk) {\n        const { res } = this;\n        return res.push(chunk);\n    }\n    onComplete(trailers) {\n        const { res } = this;\n        res.push(null);\n    }\n    onError(err) {\n        const { ret } = this;\n        this.handler = null;\n        util.destroy(ret, err);\n    }\n}\nfunction pipeline(opts, handler) {\n    try {\n        const pipelineHandler = new PipelineHandler(opts, handler);\n        this.dispatch({\n            ...opts,\n            body: pipelineHandler.req\n        }, pipelineHandler);\n        return pipelineHandler.ret;\n    } catch (err) {\n        return new PassThrough().destroy(err);\n    }\n}\nmodule.exports = pipeline;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS1waXBlbGluZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFDSkEsUUFBUSxFQUNSQyxNQUFNLEVBQ05DLFdBQVcsRUFDWixHQUFHQyxtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFDSkMsb0JBQW9CLEVBQ3BCQyx1QkFBdUIsRUFDdkJDLG1CQUFtQixFQUNwQixHQUFHSCxtQkFBT0EsQ0FBQztBQUNaLE1BQU1JLE9BQU9KLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRUssYUFBYSxFQUFFLEdBQUdMLG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU0sRUFBRU0sU0FBUyxFQUFFQyxZQUFZLEVBQUUsR0FBR1AsbUJBQU9BLENBQUM7QUFDNUMsTUFBTVEsU0FBU1IsbUJBQU9BLENBQUM7QUFFdkIsTUFBTVMsVUFBVUMsT0FBTztBQUV2QixNQUFNQyx3QkFBd0JkO0lBQzVCZSxhQUFlO1FBQ2IsS0FBSyxDQUFDO1lBQUVDLGFBQWE7UUFBSztRQUUxQixJQUFJLENBQUNKLFFBQVEsR0FBRztJQUNsQjtJQUVBSyxRQUFTO1FBQ1AsTUFBTSxFQUFFLENBQUNMLFFBQVEsRUFBRU0sTUFBTSxFQUFFLEdBQUcsSUFBSTtRQUVsQyxJQUFJQSxRQUFRO1lBQ1YsSUFBSSxDQUFDTixRQUFRLEdBQUc7WUFDaEJNO1FBQ0Y7SUFDRjtJQUVBQyxTQUFVQyxHQUFHLEVBQUVDLFFBQVEsRUFBRTtRQUN2QixJQUFJLENBQUNKLEtBQUs7UUFFVkksU0FBU0Q7SUFDWDtBQUNGO0FBRUEsTUFBTUUseUJBQXlCdEI7SUFDN0JlLFlBQWFHLE1BQU0sQ0FBRTtRQUNuQixLQUFLLENBQUM7WUFBRUYsYUFBYTtRQUFLO1FBQzFCLElBQUksQ0FBQ0osUUFBUSxHQUFHTTtJQUNsQjtJQUVBRCxRQUFTO1FBQ1AsSUFBSSxDQUFDTCxRQUFRO0lBQ2Y7SUFFQU8sU0FBVUMsR0FBRyxFQUFF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QUc7UUFDZnBCLEtBQUswQyxPQUFPLENBQUNWLEtBQUtuQjtJQUNwQjtBQUNGO0FBRUEsU0FBUzZDLFNBQVV2QyxJQUFJLEVBQUVDLE9BQU87SUFDOUIsSUFBSTtRQUNGLE1BQU11QyxrQkFBa0IsSUFBSXpDLGdCQUFnQkMsTUFBTUM7UUFDbEQsSUFBSSxDQUFDd0MsUUFBUSxDQUFDO1lBQUUsR0FBR3pDLElBQUk7WUFBRWlCLE1BQU11QixnQkFBZ0I3QixHQUFHO1FBQUMsR0FBRzZCO1FBQ3RELE9BQU9BLGdCQUFnQjNCLEdBQUc7SUFDNUIsRUFBRSxPQUFPbkIsS0FBSztRQUNaLE9BQU8sSUFBSWxCLGNBQWMrQyxPQUFPLENBQUM3QjtJQUNuQztBQUNGO0FBRUFnRCxPQUFPQyxPQUFPLEdBQUdKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1maWdodGVyLWFjYWRlbXkvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS1waXBlbGluZS5qcz8xOTBhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIFJlYWRhYmxlLFxuICBEdXBsZXgsXG4gIFBhc3NUaHJvdWdoXG59ID0gcmVxdWlyZSgnc3RyZWFtJylcbmNvbnN0IHtcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIEludmFsaWRSZXR1cm5WYWx1ZUVycm9yLFxuICBSZXF1ZXN0QWJvcnRlZEVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IEFzeW5jUmVzb3VyY2UgfSA9IHJlcXVpcmUoJ2FzeW5jX2hvb2tzJylcbmNvbnN0IHsgYWRkU2lnbmFsLCByZW1vdmVTaWduYWwgfSA9IHJlcXVpcmUoJy4vYWJvcnQtc2lnbmFsJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5cbmNvbnN0IGtSZXN1bWUgPSBTeW1ib2woJ3Jlc3VtZScpXG5cbmNsYXNzIFBpcGVsaW5lUmVxdWVzdCBleHRlbmRzIFJlYWRhYmxlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKHsgYXV0b0Rlc3Ryb3k6IHRydWUgfSlcblxuICAgIHRoaXNba1Jlc3VtZV0gPSBudWxsXG4gIH1cblxuICBfcmVhZCAoKSB7XG4gICAgY29uc3QgeyBba1Jlc3VtZV06IHJlc3VtZSB9ID0gdGhpc1xuXG4gICAgaWYgKHJlc3VtZSkge1xuICAgICAgdGhpc1trUmVzdW1lXSA9IG51bGxcbiAgICAgIHJlc3VtZSgpXG4gICAgfVxuICB9XG5cbiAgX2Rlc3Ryb3kgKGVyciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9yZWFkKClcblxuICAgIGNhbGxiYWNrKGVycilcbiAgfVxufVxuXG5jbGFzcyBQaXBlbGluZVJlc3BvbnNlIGV4dGVuZHMgUmVhZGFibGUge1xuICBjb25zdHJ1Y3RvciAocmVzdW1lKSB7XG4gICAgc3VwZXIoeyBhdXRvRGVzdHJveTogdHJ1ZSB9KVxuICAgIHRoaXNba1Jlc3VtZV0gPSByZXN1bWVcbiAgfVxuXG4gIF9yZWFkICgpIHtcbiAgICB0aGlzW2tSZXN1bWVdKClcbiAgfVxuXG4gIF9kZXN0cm95IChlcnIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFlcnIgJiYgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgZXJyID0gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgIH1cblxuICAgIGNhbGxiYWNrKGVycilcbiAgfVxufVxuXG5jbGFzcyBQaXBlbGluZUhhbmRsZXIgZXh0ZW5kcyBBc3luY1Jlc291cmNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb3B0cycpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgaGFuZGxlcicpXG4gICAgfVxuXG4gICAgY29uc3QgeyBzaWduYWwsIG1ldGhvZCwgb3BhcXVlLCBvbkluZm8sIHJlc3BvbnNlSGVhZGVycyB9ID0gb3B0c1xuXG4gICAgaWYgKHNpZ25hbCAmJiB0eXBlb2Ygc2lnbmFsLm9uICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdzaWduYWwgbXVzdCBiZSBhbiBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXQnKVxuICAgIH1cblxuICAgIGlmIChtZXRob2QgPT09ICdDT05ORUNUJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG1ldGhvZCcpXG4gICAgfVxuXG4gICAgaWYgKG9uSW5mbyAmJiB0eXBlb2Ygb25JbmZvICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25JbmZvIGNhbGxiYWNrJylcbiAgICB9XG5cbiAgICBzdXBlcignVU5ESUNJX1BJUEVMSU5FJylcblxuICAgIHRoaXMub3BhcXVlID0gb3BhcXVlIHx8IG51bGxcbiAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyB8fCBudWxsXG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlclxuICAgIHRoaXMuYWJvcnQgPSBudWxsXG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbFxuICAgIHRoaXMub25JbmZvID0gb25JbmZvIHx8IG51bGxcblxuICAgIHRoaXMucmVxID0gbmV3IFBpcGVsaW5lUmVxdWVzdCgpLm9uKCdlcnJvcicsIHV0aWwubm9wKVxuXG4gICAgdGhpcy5yZXQgPSBuZXcgRHVwbGV4KHtcbiAgICAgIHJlYWRhYmxlT2JqZWN0TW9kZTogb3B0cy5vYmplY3RNb2RlLFxuICAgICAgYXV0b0Rlc3Ryb3k6IHRydWUsXG4gICAgICByZWFkOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYm9keSB9ID0gdGhpc1xuXG4gICAgICAgIGlmIChib2R5ICYmIGJvZHkucmVzdW1lKSB7XG4gICAgICAgICAgYm9keS5yZXN1bWUoKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgd3JpdGU6IChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVxIH0gPSB0aGlzXG5cbiAgICAgICAgaWYgKHJlcS5wdXNoKGNodW5rLCBlbmNvZGluZykgfHwgcmVxLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXFba1Jlc3VtZV0gPSBjYWxsYmFja1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVzdHJveTogKGVyciwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgY29uc3QgeyBib2R5LCByZXEsIHJlcywgcmV0LCBhYm9ydCB9ID0gdGhpc1xuXG4gICAgICAgIGlmICghZXJyICYmICFyZXQuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICAgIGVyciA9IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhYm9ydCAmJiBlcnIpIHtcbiAgICAgICAgICBhYm9ydCgpXG4gICAgICAgIH1cblxuICAgICAgICB1dGlsLmRlc3Ryb3koYm9keSwgZXJyKVxuICAgICAgICB1dGlsLmRlc3Ryb3kocmVxLCBlcnIpXG4gICAgICAgIHV0aWwuZGVzdHJveShyZXMsIGVycilcblxuICAgICAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICB9XG4gICAgfSkub24oJ3ByZWZpbmlzaCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVxIH0gPSB0aGlzXG5cbiAgICAgIC8vIE5vZGUgPCAxNSBkb2VzIG5vdCBjYWxsIF9maW5hbCBpbiBzYW1lIHRpY2suXG4gICAgICByZXEucHVzaChudWxsKVxuICAgIH0pXG5cbiAgICB0aGlzLnJlcyA9IG51bGxcblxuICAgIGFkZFNpZ25hbCh0aGlzLCBzaWduYWwpXG4gIH1cblxuICBvbkNvbm5lY3QgKGFib3J0LCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyByZXQsIHJlcyB9ID0gdGhpc1xuXG4gICAgYXNzZXJ0KCFyZXMsICdwaXBlbGluZSBjYW5ub3QgYmUgcmV0cmllZCcpXG5cbiAgICBpZiAocmV0LmRlc3Ryb3llZCkge1xuICAgICAgdGhyb3cgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgIH1cblxuICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHRcbiAgfVxuXG4gIG9uSGVhZGVycyAoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgcmVzdW1lKSB7XG4gICAgY29uc3QgeyBvcGFxdWUsIGhhbmRsZXIsIGNvbnRleHQgfSA9IHRoaXNcblxuICAgIGlmIChzdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICBpZiAodGhpcy5vbkluZm8pIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMucmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcbiAgICAgICAgdGhpcy5vbkluZm8oeyBzdGF0dXNDb2RlLCBoZWFkZXJzIH0pXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnJlcyA9IG5ldyBQaXBlbGluZVJlc3BvbnNlKHJlc3VtZSlcblxuICAgIGxldCBib2R5XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuaGFuZGxlciA9IG51bGxcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlUmF3SGVhZGVycyhyYXdIZWFkZXJzKSA6IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpXG4gICAgICBib2R5ID0gdGhpcy5ydW5JbkFzeW5jU2NvcGUoaGFuZGxlciwgbnVsbCwge1xuICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBvcGFxdWUsXG4gICAgICAgIGJvZHk6IHRoaXMucmVzLFxuICAgICAgICBjb250ZXh0XG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5yZXMub24oJ2Vycm9yJywgdXRpbC5ub3ApXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICBpZiAoIWJvZHkgfHwgdHlwZW9mIGJvZHkub24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcignZXhwZWN0ZWQgUmVhZGFibGUnKVxuICAgIH1cblxuICAgIGJvZHlcbiAgICAgIC5vbignZGF0YScsIChjaHVuaykgPT4ge1xuICAgICAgICBjb25zdCB7IHJldCwgYm9keSB9ID0gdGhpc1xuXG4gICAgICAgIGlmICghcmV0LnB1c2goY2h1bmspICYmIGJvZHkucGF1c2UpIHtcbiAgICAgICAgICBib2R5LnBhdXNlKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmV0IH0gPSB0aGlzXG5cbiAgICAgICAgdXRpbC5kZXN0cm95KHJldCwgZXJyKVxuICAgICAgfSlcbiAgICAgIC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJldCB9ID0gdGhpc1xuXG4gICAgICAgIHJldC5wdXNoKG51bGwpXG4gICAgICB9KVxuICAgICAgLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgY29uc3QgeyByZXQgfSA9IHRoaXNcblxuICAgICAgICBpZiAoIXJldC5fcmVhZGFibGVTdGF0ZS5lbmRlZCkge1xuICAgICAgICAgIHV0aWwuZGVzdHJveShyZXQsIG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKCkpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICB0aGlzLmJvZHkgPSBib2R5XG4gIH1cblxuICBvbkRhdGEgKGNodW5rKSB7XG4gICAgY29uc3QgeyByZXMgfSA9IHRoaXNcbiAgICByZXR1cm4gcmVzLnB1c2goY2h1bmspXG4gIH1cblxuICBvbkNvbXBsZXRlICh0cmFpbGVycykge1xuICAgIGNvbnN0IHsgcmVzIH0gPSB0aGlzXG4gICAgcmVzLnB1c2gobnVsbClcbiAgfVxuXG4gIG9uRXJyb3IgKGVycikge1xuICAgIGNvbnN0IHsgcmV0IH0gPSB0aGlzXG4gICAgdGhpcy5oYW5kbGVyID0gbnVsbFxuICAgIHV0aWwuZGVzdHJveShyZXQsIGVycilcbiAgfVxufVxuXG5mdW5jdGlvbiBwaXBlbGluZSAob3B0cywgaGFuZGxlcikge1xuICB0cnkge1xuICAgIGNvbnN0IHBpcGVsaW5lSGFuZGxlciA9IG5ldyBQaXBlbGluZUhhbmRsZXIob3B0cywgaGFuZGxlcilcbiAgICB0aGlzLmRpc3BhdGNoKHsgLi4ub3B0cywgYm9keTogcGlwZWxpbmVIYW5kbGVyLnJlcSB9LCBwaXBlbGluZUhhbmRsZXIpXG4gICAgcmV0dXJuIHBpcGVsaW5lSGFuZGxlci5yZXRcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaCgpLmRlc3Ryb3koZXJyKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGlwZWxpbmVcbiJdLCJuYW1lcyI6WyJSZWFkYWJsZSIsIkR1cGxleCIsIlBhc3NUaHJvdWdoIiwicmVxdWlyZSIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiSW52YWxpZFJldHVyblZhbHVlRXJyb3IiLCJSZXF1ZXN0QWJvcnRlZEVycm9yIiwidXRpbCIsIkFzeW5jUmVzb3VyY2UiLCJhZGRTaWduYWwiLCJyZW1vdmVTaWduYWwiLCJhc3NlcnQiLCJrUmVzdW1lIiwiU3ltYm9sIiwiUGlwZWxpbmVSZXF1ZXN0IiwiY29uc3RydWN0b3IiLCJhdXRvRGVzdHJveSIsIl9yZWFkIiwicmVzdW1lIiwiX2Rlc3Ryb3kiLCJlcnIiLCJjYWxsYmFjayIsIlBpcGVsaW5lUmVzcG9uc2UiLCJfcmVhZGFibGVTdGF0ZSIsImVuZEVtaXR0ZWQiLCJQaXBlbGluZUhhbmRsZXIiLCJvcHRzIiwiaGFuZGxlciIsInNpZ25hbCIsIm1ldGhvZCIsIm9wYXF1ZSIsIm9uSW5mbyIsInJlc3BvbnNlSGVhZGVycyIsIm9uIiwiYWRkRXZlbnRMaXN0ZW5lciIsImFib3J0IiwiY29udGV4dCIsInJlcSIsIm5vcCIsInJldCIsInJlYWRhYmxlT2JqZWN0TW9kZSIsIm9iamVjdE1vZGUiLCJyZWFkIiwiYm9keSIsIndyaXRlIiwiY2h1bmsiLCJlbmNvZGluZyIsInB1c2giLCJkZXN0cm95ZWQiLCJkZXN0cm95IiwicmVzIiwib25Db25uZWN0Iiwib25IZWFkZXJzIiwic3RhdHVzQ29kZSIsInJhd0hlYWRlcnMiLCJoZWFkZXJzIiwicGFyc2VSYXdIZWFkZXJzIiwicGFyc2VIZWFkZXJzIiwicnVuSW5Bc3luY1Njb3BlIiwicGF1c2UiLCJlbmRlZCIsIm9uRGF0YSIsIm9uQ29tcGxldGUiLCJ0cmFpbGVycyIsIm9uRXJyb3IiLCJwaXBlbGluZSIsInBpcGVsaW5lSGFuZGxlciIsImRpc3BhdGNoIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/api/api-pipeline.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/api/api-request.js":
/*!**************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/api/api-request.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Readable = __webpack_require__(/*! ./readable */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/api/readable.js\");\nconst { InvalidArgumentError, RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst { getResolveErrorBodyCallback } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/api/util.js\");\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/api/abort-signal.js\");\nclass RequestHandler extends AsyncResource {\n    constructor(opts, callback){\n        if (!opts || typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"invalid opts\");\n        }\n        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;\n        try {\n            if (typeof callback !== \"function\") {\n                throw new InvalidArgumentError(\"invalid callback\");\n            }\n            if (highWaterMark && (typeof highWaterMark !== \"number\" || highWaterMark < 0)) {\n                throw new InvalidArgumentError(\"invalid highWaterMark\");\n            }\n            if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n                throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n            }\n            if (method === \"CONNECT\") {\n                throw new InvalidArgumentError(\"invalid method\");\n            }\n            if (onInfo && typeof onInfo !== \"function\") {\n                throw new InvalidArgumentError(\"invalid onInfo callback\");\n            }\n            super(\"UNDICI_REQUEST\");\n        } catch (err) {\n            if (util.isStream(body)) {\n                util.destroy(body.on(\"error\", util.nop), err);\n            }\n            throw err;\n        }\n        this.responseHeaders = responseHeaders || null;\n        this.opaque = opaque || null;\n        this.callback = callback;\n        this.res = null;\n        this.abort = null;\n        this.body = body;\n        this.trailers = {};\n        this.context = null;\n        this.onInfo = onInfo || null;\n        this.throwOnError = throwOnError;\n        this.highWaterMark = highWaterMark;\n        if (util.isStream(body)) {\n            body.on(\"error\", (err)=>{\n                this.onError(err);\n            });\n        }\n        addSignal(this, signal);\n    }\n    onConnect(abort, context) {\n        if (!this.callback) {\n            throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = context;\n    }\n    onHeaders(statusCode, rawHeaders, resume, statusMessage) {\n        const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;\n        const headers = responseHeaders === \"raw\" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        if (statusCode < 200) {\n            if (this.onInfo) {\n                this.onInfo({\n                    statusCode,\n                    headers\n                });\n            }\n            return;\n        }\n        const parsedHeaders = responseHeaders === \"raw\" ? util.parseHeaders(rawHeaders) : headers;\n        const contentType = parsedHeaders[\"content-type\"];\n        const body = new Readable({\n            resume,\n            abort,\n            contentType,\n            highWaterMark\n        });\n        this.callback = null;\n        this.res = body;\n        if (callback !== null) {\n            if (this.throwOnError && statusCode >= 400) {\n                this.runInAsyncScope(getResolveErrorBodyCallback, null, {\n                    callback,\n                    body,\n                    contentType,\n                    statusCode,\n                    statusMessage,\n                    headers\n                });\n            } else {\n                this.runInAsyncScope(callback, null, null, {\n                    statusCode,\n                    headers,\n                    trailers: this.trailers,\n                    opaque,\n                    body,\n                    context\n                });\n            }\n        }\n    }\n    onData(chunk) {\n        const { res } = this;\n        return res.push(chunk);\n    }\n    onComplete(trailers) {\n        const { res } = this;\n        removeSignal(this);\n        util.parseHeaders(trailers, this.trailers);\n        res.push(null);\n    }\n    onError(err) {\n        const { res, callback, body, opaque } = this;\n        removeSignal(this);\n        if (callback) {\n            // TODO: Does this need queueMicrotask?\n            this.callback = null;\n            queueMicrotask(()=>{\n                this.runInAsyncScope(callback, null, err, {\n                    opaque\n                });\n            });\n        }\n        if (res) {\n            this.res = null;\n            // Ensure all queued handlers are invoked before destroying res.\n            queueMicrotask(()=>{\n                util.destroy(res, err);\n            });\n        }\n        if (body) {\n            this.body = null;\n            util.destroy(body, err);\n        }\n    }\n}\nfunction request(opts, callback) {\n    if (callback === undefined) {\n        return new Promise((resolve, reject)=>{\n            request.call(this, opts, (err, data)=>{\n                return err ? reject(err) : resolve(data);\n            });\n        });\n    }\n    try {\n        this.dispatch(opts, new RequestHandler(opts, callback));\n    } catch (err) {\n        if (typeof callback !== \"function\") {\n            throw err;\n        }\n        const opaque = opts && opts.opaque;\n        queueMicrotask(()=>callback(err, {\n                opaque\n            }));\n    }\n}\nmodule.exports = request;\nmodule.exports.RequestHandler = RequestHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS1yZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsV0FBV0MsbUJBQU9BLENBQUM7QUFDekIsTUFBTSxFQUNKQyxvQkFBb0IsRUFDcEJDLG1CQUFtQixFQUNwQixHQUFHRixtQkFBT0EsQ0FBQztBQUNaLE1BQU1HLE9BQU9ILG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRUksMkJBQTJCLEVBQUUsR0FBR0osbUJBQU9BLENBQUM7QUFDaEQsTUFBTSxFQUFFSyxhQUFhLEVBQUUsR0FBR0wsbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUFFTSxTQUFTLEVBQUVDLFlBQVksRUFBRSxHQUFHUCxtQkFBT0EsQ0FBQztBQUU1QyxNQUFNUSx1QkFBdUJIO0lBQzNCSSxZQUFhQyxJQUFJLEVBQUVDLFFBQVEsQ0FBRTtRQUMzQixJQUFJLENBQUNELFFBQVEsT0FBT0EsU0FBUyxVQUFVO1lBQ3JDLE1BQU0sSUFBSVQscUJBQXFCO1FBQ2pDO1FBRUEsTUFBTSxFQUFFVyxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsZUFBZSxFQUFFQyxZQUFZLEVBQUVDLGFBQWEsRUFBRSxHQUFHVDtRQUUvRixJQUFJO1lBQ0YsSUFBSSxPQUFPQyxhQUFhLFlBQVk7Z0JBQ2xDLE1BQU0sSUFBSVYscUJBQXFCO1lBQ2pDO1lBRUEsSUFBSWtCLGlCQUFrQixRQUFPQSxrQkFBa0IsWUFBWUEsZ0JBQWdCLElBQUk7Z0JBQzdFLE1BQU0sSUFBSWxCLHFCQUFxQjtZQUNqQztZQUVBLElBQUlXLFVBQVUsT0FBT0EsT0FBT1EsRUFBRSxLQUFLLGNBQWMsT0FBT1IsT0FBT1MsZ0JBQWdCLEtBQUssWUFBWTtnQkFDOUYsTUFBTSxJQUFJcEIscUJBQXFCO1lBQ2pDO1lBRUEsSUFBSVksV0FBVyxXQUFXO2dCQUN4QixNQUFNLElB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LFlBQVk7WUFDbEMsTUFBTVc7UUFDUjtRQUNBLE1BQU1SLFNBQVNKLFFBQVFBLEtBQUtJLE1BQU07UUFDbENpQyxlQUFlLElBQU1wQyxTQUFTVyxLQUFLO2dCQUFFUjtZQUFPO0lBQzlDO0FBQ0Y7QUFFQTBDLE9BQU9DLE9BQU8sR0FBR1Q7QUFDakJRLDZCQUE2QixHQUFHaEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXJlcXVlc3QuanM/MmY3OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgUmVhZGFibGUgPSByZXF1aXJlKCcuL3JlYWRhYmxlJylcbmNvbnN0IHtcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIFJlcXVlc3RBYm9ydGVkRXJyb3Jcbn0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgZ2V0UmVzb2x2ZUVycm9yQm9keUNhbGxiYWNrIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBBc3luY1Jlc291cmNlIH0gPSByZXF1aXJlKCdhc3luY19ob29rcycpXG5jb25zdCB7IGFkZFNpZ25hbCwgcmVtb3ZlU2lnbmFsIH0gPSByZXF1aXJlKCcuL2Fib3J0LXNpZ25hbCcpXG5cbmNsYXNzIFJlcXVlc3RIYW5kbGVyIGV4dGVuZHMgQXN5bmNSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBjYWxsYmFjaykge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHNpZ25hbCwgbWV0aG9kLCBvcGFxdWUsIGJvZHksIG9uSW5mbywgcmVzcG9uc2VIZWFkZXJzLCB0aHJvd09uRXJyb3IsIGhpZ2hXYXRlck1hcmsgfSA9IG9wdHNcblxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjYWxsYmFjaycpXG4gICAgICB9XG5cbiAgICAgIGlmIChoaWdoV2F0ZXJNYXJrICYmICh0eXBlb2YgaGlnaFdhdGVyTWFyayAhPT0gJ251bWJlcicgfHwgaGlnaFdhdGVyTWFyayA8IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBoaWdoV2F0ZXJNYXJrJylcbiAgICAgIH1cblxuICAgICAgaWYgKHNpZ25hbCAmJiB0eXBlb2Ygc2lnbmFsLm9uICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3NpZ25hbCBtdXN0IGJlIGFuIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldCcpXG4gICAgICB9XG5cbiAgICAgIGlmIChtZXRob2QgPT09ICdDT05ORUNUJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgbWV0aG9kJylcbiAgICAgIH1cblxuICAgICAgaWYgKG9uSW5mbyAmJiB0eXBlb2Ygb25JbmZvICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkluZm8gY2FsbGJhY2snKVxuICAgICAgfVxuXG4gICAgICBzdXBlcignVU5ESUNJX1JFUVVFU1QnKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHV0aWwuaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgICAgdXRpbC5kZXN0cm95KGJvZHkub24oJ2Vycm9yJywgdXRpbC5ub3ApLCBlcnIpXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyB8fCBudWxsXG4gICAgdGhpcy5vcGFxdWUgPSBvcGFxdWUgfHwgbnVsbFxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMucmVzID0gbnVsbFxuICAgIHRoaXMuYWJvcnQgPSBudWxsXG4gICAgdGhpcy5ib2R5ID0gYm9keVxuICAgIHRoaXMudHJhaWxlcnMgPSB7fVxuICAgIHRoaXMuY29udGV4dCA9IG51bGxcbiAgICB0aGlzLm9uSW5mbyA9IG9uSW5mbyB8fCBudWxsXG4gICAgdGhpcy50aHJvd09uRXJyb3IgPSB0aHJvd09uRXJyb3JcbiAgICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBoaWdoV2F0ZXJNYXJrXG5cbiAgICBpZiAodXRpbC5pc1N0cmVhbShib2R5KSkge1xuICAgICAgYm9keS5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMub25FcnJvcihlcnIpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGFkZFNpZ25hbCh0aGlzLCBzaWduYWwpXG4gIH1cblxuICBvbkNvbm5lY3QgKGFib3J0LCBjb250ZXh0KSB7XG4gICAgaWYgKCF0aGlzLmNhbGxiYWNrKSB7XG4gICAgICB0aHJvdyBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gICAgfVxuXG4gICAgdGhpcy5hYm9ydCA9IGFib3J0XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dFxuICB9XG5cbiAgb25IZWFkZXJzIChzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCByZXN1bWUsIHN0YXR1c01lc3NhZ2UpIHtcbiAgICBjb25zdCB7IGNhbGxiYWNrLCBvcGFxdWUsIGFib3J0LCBjb250ZXh0LCByZXNwb25zZUhlYWRlcnMsIGhpZ2hXYXRlck1hcmsgfSA9IHRoaXNcblxuICAgIGNvbnN0IGhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgPT09ICdyYXcnID8gdXRpbC5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKVxuXG4gICAgaWYgKHN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgIGlmICh0aGlzLm9uSW5mbykge1xuICAgICAgICB0aGlzLm9uSW5mbyh7IHN0YXR1c0NvZGUsIGhlYWRlcnMgfSlcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHBhcnNlZEhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgPT09ICdyYXcnID8gdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycykgOiBoZWFkZXJzXG4gICAgY29uc3QgY29udGVudFR5cGUgPSBwYXJzZWRIZWFkZXJzWydjb250ZW50LXR5cGUnXVxuICAgIGNvbnN0IGJvZHkgPSBuZXcgUmVhZGFibGUoeyByZXN1bWUsIGFib3J0LCBjb250ZW50VHlwZSwgaGlnaFdhdGVyTWFyayB9KVxuXG4gICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICB0aGlzLnJlcyA9IGJvZHlcbiAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLnRocm93T25FcnJvciAmJiBzdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2ssIG51bGwsXG4gICAgICAgICAgeyBjYWxsYmFjaywgYm9keSwgY29udGVudFR5cGUsIHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMgfVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgbnVsbCwge1xuICAgICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICB0cmFpbGVyczogdGhpcy50cmFpbGVycyxcbiAgICAgICAgICBvcGFxdWUsXG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIGNvbnN0IHsgcmVzIH0gPSB0aGlzXG4gICAgcmV0dXJuIHJlcy5wdXNoKGNodW5rKVxuICB9XG5cbiAgb25Db21wbGV0ZSAodHJhaWxlcnMpIHtcbiAgICBjb25zdCB7IHJlcyB9ID0gdGhpc1xuXG4gICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICB1dGlsLnBhcnNlSGVhZGVycyh0cmFpbGVycywgdGhpcy50cmFpbGVycylcblxuICAgIHJlcy5wdXNoKG51bGwpXG4gIH1cblxuICBvbkVycm9yIChlcnIpIHtcbiAgICBjb25zdCB7IHJlcywgY2FsbGJhY2ssIGJvZHksIG9wYXF1ZSB9ID0gdGhpc1xuXG4gICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIC8vIFRPRE86IERvZXMgdGhpcyBuZWVkIHF1ZXVlTWljcm90YXNrP1xuICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIGVyciwgeyBvcGFxdWUgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHJlcykge1xuICAgICAgdGhpcy5yZXMgPSBudWxsXG4gICAgICAvLyBFbnN1cmUgYWxsIHF1ZXVlZCBoYW5kbGVycyBhcmUgaW52b2tlZCBiZWZvcmUgZGVzdHJveWluZyByZXMuXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHV0aWwuZGVzdHJveShyZXMsIGVycilcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKGJvZHkpIHtcbiAgICAgIHRoaXMuYm9keSA9IG51bGxcbiAgICAgIHV0aWwuZGVzdHJveShib2R5LCBlcnIpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3QgKG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHJlcXVlc3QuY2FsbCh0aGlzLCBvcHRzLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgIHJldHVybiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoZGF0YSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgdGhpcy5kaXNwYXRjaChvcHRzLCBuZXcgUmVxdWVzdEhhbmRsZXIob3B0cywgY2FsbGJhY2spKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gICAgY29uc3Qgb3BhcXVlID0gb3B0cyAmJiBvcHRzLm9wYXF1ZVxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKGVyciwgeyBvcGFxdWUgfSkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1ZXN0XG5tb2R1bGUuZXhwb3J0cy5SZXF1ZXN0SGFuZGxlciA9IFJlcXVlc3RIYW5kbGVyXG4iXSwibmFtZXMiOlsiUmVhZGFibGUiLCJyZXF1aXJlIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJSZXF1ZXN0QWJvcnRlZEVycm9yIiwidXRpbCIsImdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjayIsIkFzeW5jUmVzb3VyY2UiLCJhZGRTaWduYWwiLCJyZW1vdmVTaWduYWwiLCJSZXF1ZXN0SGFuZGxlciIsImNvbnN0cnVjdG9yIiwib3B0cyIsImNhbGxiYWNrIiwic2lnbmFsIiwibWV0aG9kIiwib3BhcXVlIiwiYm9keSIsIm9uSW5mbyIsInJlc3BvbnNlSGVhZGVycyIsInRocm93T25FcnJvciIsImhpZ2hXYXRlck1hcmsiLCJvbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJlcnIiLCJpc1N0cmVhbSIsImRlc3Ryb3kiLCJub3AiLCJyZXMiLCJhYm9ydCIsInRyYWlsZXJzIiwiY29udGV4dCIsIm9uRXJyb3IiLCJvbkNvbm5lY3QiLCJvbkhlYWRlcnMiLCJzdGF0dXNDb2RlIiwicmF3SGVhZGVycyIsInJlc3VtZSIsInN0YXR1c01lc3NhZ2UiLCJoZWFkZXJzIiwicGFyc2VSYXdIZWFkZXJzIiwicGFyc2VIZWFkZXJzIiwicGFyc2VkSGVhZGVycyIsImNvbnRlbnRUeXBlIiwicnVuSW5Bc3luY1Njb3BlIiwib25EYXRhIiwiY2h1bmsiLCJwdXNoIiwib25Db21wbGV0ZSIsInF1ZXVlTWljcm90YXNrIiwicmVxdWVzdCIsInVuZGVmaW5lZCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiY2FsbCIsImRhdGEiLCJkaXNwYXRjaCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/api/api-request.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/api/api-stream.js":
/*!*************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/api/api-stream.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { finished, PassThrough } = __webpack_require__(/*! stream */ \"stream\");\nconst { InvalidArgumentError, InvalidReturnValueError, RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst { getResolveErrorBodyCallback } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/api/util.js\");\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/api/abort-signal.js\");\nclass StreamHandler extends AsyncResource {\n    constructor(opts, factory, callback){\n        if (!opts || typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"invalid opts\");\n        }\n        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;\n        try {\n            if (typeof callback !== \"function\") {\n                throw new InvalidArgumentError(\"invalid callback\");\n            }\n            if (typeof factory !== \"function\") {\n                throw new InvalidArgumentError(\"invalid factory\");\n            }\n            if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n                throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n            }\n            if (method === \"CONNECT\") {\n                throw new InvalidArgumentError(\"invalid method\");\n            }\n            if (onInfo && typeof onInfo !== \"function\") {\n                throw new InvalidArgumentError(\"invalid onInfo callback\");\n            }\n            super(\"UNDICI_STREAM\");\n        } catch (err) {\n            if (util.isStream(body)) {\n                util.destroy(body.on(\"error\", util.nop), err);\n            }\n            throw err;\n        }\n        this.responseHeaders = responseHeaders || null;\n        this.opaque = opaque || null;\n        this.factory = factory;\n        this.callback = callback;\n        this.res = null;\n        this.abort = null;\n        this.context = null;\n        this.trailers = null;\n        this.body = body;\n        this.onInfo = onInfo || null;\n        this.throwOnError = throwOnError || false;\n        if (util.isStream(body)) {\n            body.on(\"error\", (err)=>{\n                this.onError(err);\n            });\n        }\n        addSignal(this, signal);\n    }\n    onConnect(abort, context) {\n        if (!this.callback) {\n            throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = context;\n    }\n    onHeaders(statusCode, rawHeaders, resume, statusMessage) {\n        const { factory, opaque, context, callback, responseHeaders } = this;\n        const headers = responseHeaders === \"raw\" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        if (statusCode < 200) {\n            if (this.onInfo) {\n                this.onInfo({\n                    statusCode,\n                    headers\n                });\n            }\n            return;\n        }\n        this.factory = null;\n        let res;\n        if (this.throwOnError && statusCode >= 400) {\n            const parsedHeaders = responseHeaders === \"raw\" ? util.parseHeaders(rawHeaders) : headers;\n            const contentType = parsedHeaders[\"content-type\"];\n            res = new PassThrough();\n            this.callback = null;\n            this.runInAsyncScope(getResolveErrorBodyCallback, null, {\n                callback,\n                body: res,\n                contentType,\n                statusCode,\n                statusMessage,\n                headers\n            });\n        } else {\n            if (factory === null) {\n                return;\n            }\n            res = this.runInAsyncScope(factory, null, {\n                statusCode,\n                headers,\n                opaque,\n                context\n            });\n            if (!res || typeof res.write !== \"function\" || typeof res.end !== \"function\" || typeof res.on !== \"function\") {\n                throw new InvalidReturnValueError(\"expected Writable\");\n            }\n            // TODO: Avoid finished. It registers an unnecessary amount of listeners.\n            finished(res, {\n                readable: false\n            }, (err)=>{\n                const { callback, res, opaque, trailers, abort } = this;\n                this.res = null;\n                if (err || !res.readable) {\n                    util.destroy(res, err);\n                }\n                this.callback = null;\n                this.runInAsyncScope(callback, null, err || null, {\n                    opaque,\n                    trailers\n                });\n                if (err) {\n                    abort();\n                }\n            });\n        }\n        res.on(\"drain\", resume);\n        this.res = res;\n        const needDrain = res.writableNeedDrain !== undefined ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;\n        return needDrain !== true;\n    }\n    onData(chunk) {\n        const { res } = this;\n        return res ? res.write(chunk) : true;\n    }\n    onComplete(trailers) {\n        const { res } = this;\n        removeSignal(this);\n        if (!res) {\n            return;\n        }\n        this.trailers = util.parseHeaders(trailers);\n        res.end();\n    }\n    onError(err) {\n        const { res, callback, opaque, body } = this;\n        removeSignal(this);\n        this.factory = null;\n        if (res) {\n            this.res = null;\n            util.destroy(res, err);\n        } else if (callback) {\n            this.callback = null;\n            queueMicrotask(()=>{\n                this.runInAsyncScope(callback, null, err, {\n                    opaque\n                });\n            });\n        }\n        if (body) {\n            this.body = null;\n            util.destroy(body, err);\n        }\n    }\n}\nfunction stream(opts, factory, callback) {\n    if (callback === undefined) {\n        return new Promise((resolve, reject)=>{\n            stream.call(this, opts, factory, (err, data)=>{\n                return err ? reject(err) : resolve(data);\n            });\n        });\n    }\n    try {\n        this.dispatch(opts, new StreamHandler(opts, factory, callback));\n    } catch (err) {\n        if (typeof callback !== \"function\") {\n            throw err;\n        }\n        const opaque = opts && opts.opaque;\n        queueMicrotask(()=>callback(err, {\n                opaque\n            }));\n    }\n}\nmodule.exports = stream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS1zdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFFBQVEsRUFBRUMsV0FBVyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzFDLE1BQU0sRUFDSkMsb0JBQW9CLEVBQ3BCQyx1QkFBdUIsRUFDdkJDLG1CQUFtQixFQUNwQixHQUFHSCxtQkFBT0EsQ0FBQztBQUNaLE1BQU1JLE9BQU9KLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRUssMkJBQTJCLEVBQUUsR0FBR0wsbUJBQU9BLENBQUM7QUFDaEQsTUFBTSxFQUFFTSxhQUFhLEVBQUUsR0FBR04sbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUFFTyxTQUFTLEVBQUVDLFlBQVksRUFBRSxHQUFHUixtQkFBT0EsQ0FBQztBQUU1QyxNQUFNUyxzQkFBc0JIO0lBQzFCSSxZQUFhQyxJQUFJLEVBQUVDLE9BQU8sRUFBRUMsUUFBUSxDQUFFO1FBQ3BDLElBQUksQ0FBQ0YsUUFBUSxPQUFPQSxTQUFTLFVBQVU7WUFDckMsTUFBTSxJQUFJVixxQkFBcUI7UUFDakM7UUFFQSxNQUFNLEVBQUVhLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFQyxlQUFlLEVBQUVDLFlBQVksRUFBRSxHQUFHVDtRQUVoRixJQUFJO1lBQ0YsSUFBSSxPQUFPRSxhQUFhLFlBQVk7Z0JBQ2xDLE1BQU0sSUFBSVoscUJBQXFCO1lBQ2pDO1lBRUEsSUFBSSxPQUFPVyxZQUFZLFlBQVk7Z0JBQ2pDLE1BQU0sSUFBSVgscUJBQXFCO1lBQ2pDO1lBRUEsSUFBSWEsVUFBVSxPQUFPQSxPQUFPTyxFQUFFLEtBQUssY0FBYyxPQUFPUCxPQUFPUSxnQkFBZ0IsS0FBSyxZQUFZO2dCQUM5RixNQUFNLElBQUlyQixxQkFBcUI7WUFDakM7WUFFQSxJQUFJYyxXQUFXLFdBQVc7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bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9hcGktc3RyZWFtLmpzPzY1ZGIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgZmluaXNoZWQsIFBhc3NUaHJvdWdoIH0gPSByZXF1aXJlKCdzdHJlYW0nKVxuY29uc3Qge1xuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgSW52YWxpZFJldHVyblZhbHVlRXJyb3IsXG4gIFJlcXVlc3RBYm9ydGVkRXJyb3Jcbn0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgZ2V0UmVzb2x2ZUVycm9yQm9keUNhbGxiYWNrIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBBc3luY1Jlc291cmNlIH0gPSByZXF1aXJlKCdhc3luY19ob29rcycpXG5jb25zdCB7IGFkZFNpZ25hbCwgcmVtb3ZlU2lnbmFsIH0gPSByZXF1aXJlKCcuL2Fib3J0LXNpZ25hbCcpXG5cbmNsYXNzIFN0cmVhbUhhbmRsZXIgZXh0ZW5kcyBBc3luY1Jlc291cmNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIGZhY3RvcnksIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMnKVxuICAgIH1cblxuICAgIGNvbnN0IHsgc2lnbmFsLCBtZXRob2QsIG9wYXF1ZSwgYm9keSwgb25JbmZvLCByZXNwb25zZUhlYWRlcnMsIHRocm93T25FcnJvciB9ID0gb3B0c1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNhbGxiYWNrJylcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBmYWN0b3J5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBmYWN0b3J5JylcbiAgICAgIH1cblxuICAgICAgaWYgKHNpZ25hbCAmJiB0eXBlb2Ygc2lnbmFsLm9uICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3NpZ25hbCBtdXN0IGJlIGFuIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldCcpXG4gICAgICB9XG5cbiAgICAgIGlmIChtZXRob2QgPT09ICdDT05ORUNUJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgbWV0aG9kJylcbiAgICAgIH1cblxuICAgICAgaWYgKG9uSW5mbyAmJiB0eXBlb2Ygb25JbmZvICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkluZm8gY2FsbGJhY2snKVxuICAgICAgfVxuXG4gICAgICBzdXBlcignVU5ESUNJX1NUUkVBTScpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodXRpbC5pc1N0cmVhbShib2R5KSkge1xuICAgICAgICB1dGlsLmRlc3Ryb3koYm9keS5vbignZXJyb3InLCB1dGlsLm5vcCksIGVycilcbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzIHx8IG51bGxcbiAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZSB8fCBudWxsXG4gICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeVxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMucmVzID0gbnVsbFxuICAgIHRoaXMuYWJvcnQgPSBudWxsXG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbFxuICAgIHRoaXMudHJhaWxlcnMgPSBudWxsXG4gICAgdGhpcy5ib2R5ID0gYm9keVxuICAgIHRoaXMub25JbmZvID0gb25JbmZvIHx8IG51bGxcbiAgICB0aGlzLnRocm93T25FcnJvciA9IHRocm93T25FcnJvciB8fCBmYWxzZVxuXG4gICAgaWYgKHV0aWwuaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgIGJvZHkub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBhZGRTaWduYWwodGhpcywgc2lnbmFsKVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCwgY29udGV4dCkge1xuICAgIGlmICghdGhpcy5jYWxsYmFjaykge1xuICAgICAgdGhyb3cgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgIH1cblxuICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHRcbiAgfVxuXG4gIG9uSGVhZGVycyAoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgcmVzdW1lLCBzdGF0dXNNZXNzYWdlKSB7XG4gICAgY29uc3QgeyBmYWN0b3J5LCBvcGFxdWUsIGNvbnRleHQsIGNhbGxiYWNrLCByZXNwb25zZUhlYWRlcnMgfSA9IHRoaXNcblxuICAgIGNvbnN0IGhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgPT09ICdyYXcnID8gdXRpbC5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKVxuXG4gICAgaWYgKHN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgIGlmICh0aGlzLm9uSW5mbykge1xuICAgICAgICB0aGlzLm9uSW5mbyh7IHN0YXR1c0NvZGUsIGhlYWRlcnMgfSlcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuZmFjdG9yeSA9IG51bGxcblxuICAgIGxldCByZXNcblxuICAgIGlmICh0aGlzLnRocm93T25FcnJvciAmJiBzdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgY29uc3QgcGFyc2VkSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSA6IGhlYWRlcnNcbiAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcGFyc2VkSGVhZGVyc1snY29udGVudC10eXBlJ11cbiAgICAgIHJlcyA9IG5ldyBQYXNzVGhyb3VnaCgpXG5cbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG4gICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2ssIG51bGwsXG4gICAgICAgIHsgY2FsbGJhY2ssIGJvZHk6IHJlcywgY29udGVudFR5cGUsIHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMgfVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZmFjdG9yeSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgcmVzID0gdGhpcy5ydW5JbkFzeW5jU2NvcGUoZmFjdG9yeSwgbnVsbCwge1xuICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBvcGFxdWUsXG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pXG5cbiAgICAgIGlmIChcbiAgICAgICAgIXJlcyB8fFxuICAgICAgICB0eXBlb2YgcmVzLndyaXRlICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIHR5cGVvZiByZXMuZW5kICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIHR5cGVvZiByZXMub24gIT09ICdmdW5jdGlvbidcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFJldHVyblZhbHVlRXJyb3IoJ2V4cGVjdGVkIFdyaXRhYmxlJylcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogQXZvaWQgZmluaXNoZWQuIEl0IHJlZ2lzdGVycyBhbiB1bm5lY2Vzc2FyeSBhbW91bnQgb2YgbGlzdGVuZXJzLlxuICAgICAgZmluaXNoZWQocmVzLCB7IHJlYWRhYmxlOiBmYWxzZSB9LCAoZXJyKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY2FsbGJhY2ssIHJlcywgb3BhcXVlLCB0cmFpbGVycywgYWJvcnQgfSA9IHRoaXNcblxuICAgICAgICB0aGlzLnJlcyA9IG51bGxcbiAgICAgICAgaWYgKGVyciB8fCAhcmVzLnJlYWRhYmxlKSB7XG4gICAgICAgICAgdXRpbC5kZXN0cm95KHJlcywgZXJyKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIGVyciB8fCBudWxsLCB7IG9wYXF1ZSwgdHJhaWxlcnMgfSlcblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgYWJvcnQoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIHJlcy5vbignZHJhaW4nLCByZXN1bWUpXG5cbiAgICB0aGlzLnJlcyA9IHJlc1xuXG4gICAgY29uc3QgbmVlZERyYWluID0gcmVzLndyaXRhYmxlTmVlZERyYWluICE9PSB1bmRlZmluZWRcbiAgICAgID8gcmVzLndyaXRhYmxlTmVlZERyYWluXG4gICAgICA6IHJlcy5fd3JpdGFibGVTdGF0ZSAmJiByZXMuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluXG5cbiAgICByZXR1cm4gbmVlZERyYWluICE9PSB0cnVlXG4gIH1cblxuICBvbkRhdGEgKGNodW5rKSB7XG4gICAgY29uc3QgeyByZXMgfSA9IHRoaXNcblxuICAgIHJldHVybiByZXMgPyByZXMud3JpdGUoY2h1bmspIDogdHJ1ZVxuICB9XG5cbiAgb25Db21wbGV0ZSAodHJhaWxlcnMpIHtcbiAgICBjb25zdCB7IHJlcyB9ID0gdGhpc1xuXG4gICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICBpZiAoIXJlcykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy50cmFpbGVycyA9IHV0aWwucGFyc2VIZWFkZXJzKHRyYWlsZXJzKVxuXG4gICAgcmVzLmVuZCgpXG4gIH1cblxuICBvbkVycm9yIChlcnIpIHtcbiAgICBjb25zdCB7IHJlcywgY2FsbGJhY2ssIG9wYXF1ZSwgYm9keSB9ID0gdGhpc1xuXG4gICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICB0aGlzLmZhY3RvcnkgPSBudWxsXG5cbiAgICBpZiAocmVzKSB7XG4gICAgICB0aGlzLnJlcyA9IG51bGxcbiAgICAgIHV0aWwuZGVzdHJveShyZXMsIGVycilcbiAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgZXJyLCB7IG9wYXF1ZSB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoYm9keSkge1xuICAgICAgdGhpcy5ib2R5ID0gbnVsbFxuICAgICAgdXRpbC5kZXN0cm95KGJvZHksIGVycilcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyZWFtIChvcHRzLCBmYWN0b3J5LCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBzdHJlYW0uY2FsbCh0aGlzLCBvcHRzLCBmYWN0b3J5LCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgIHJldHVybiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoZGF0YSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgdGhpcy5kaXNwYXRjaChvcHRzLCBuZXcgU3RyZWFtSGFuZGxlcihvcHRzLCBmYWN0b3J5LCBjYWxsYmFjaykpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgICBjb25zdCBvcGFxdWUgPSBvcHRzICYmIG9wdHMub3BhcXVlXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2soZXJyLCB7IG9wYXF1ZSB9KSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmVhbVxuIl0sIm5hbWVzIjpbImZpbmlzaGVkIiwiUGFzc1Rocm91Z2giLCJyZXF1aXJlIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJJbnZhbGlkUmV0dXJuVmFsdWVFcnJvciIsIlJlcXVlc3RBYm9ydGVkRXJyb3IiLCJ1dGlsIiwiZ2V0UmVzb2x2ZUVycm9yQm9keUNhbGxiYWNrIiwiQXN5bmNSZXNvdXJjZSIsImFkZFNpZ25hbCIsInJlbW92ZVNpZ25hbCIsIlN0cmVhbUhhbmRsZXIiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJmYWN0b3J5IiwiY2FsbGJhY2siLCJzaWduYWwiLCJtZXRob2QiLCJvcGFxdWUiLCJib2R5Iiwib25JbmZvIiwicmVzcG9uc2VIZWFkZXJzIiwidGhyb3dPbkVycm9yIiwib24iLCJhZGRFdmVudExpc3RlbmVyIiwiZXJyIiwiaXNTdHJlYW0iLCJkZXN0cm95Iiwibm9wIiwicmVzIiwiYWJvcnQiLCJjb250ZXh0IiwidHJhaWxlcnMiLCJvbkVycm9yIiwib25Db25uZWN0Iiwib25IZWFkZXJzIiwic3RhdHVzQ29kZSIsInJhd0hlYWRlcnMiLCJyZXN1bWUiLCJzdGF0dXNNZXNzYWdlIiwiaGVhZGVycyIsInBhcnNlUmF3SGVhZGVycyIsInBhcnNlSGVhZGVycyIsInBhcnNlZEhlYWRlcnMiLCJjb250ZW50VHlwZSIsInJ1bkluQXN5bmNTY29wZSIsIndyaXRlIiwiZW5kIiwicmVhZGFibGUiLCJuZWVkRHJhaW4iLCJ3cml0YWJsZU5lZWREcmFpbiIsInVuZGVmaW5lZCIsIl93cml0YWJsZVN0YXRlIiwib25EYXRhIiwiY2h1bmsiLCJvbkNvbXBsZXRlIiwicXVldWVNaWNyb3Rhc2siLCJzdHJlYW0iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNhbGwiLCJkYXRhIiwiZGlzcGF0Y2giLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/api/api-stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/api/api-upgrade.js":
/*!**************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/api/api-upgrade.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { InvalidArgumentError, RequestAbortedError, SocketError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/api/abort-signal.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nclass UpgradeHandler extends AsyncResource {\n    constructor(opts, callback){\n        if (!opts || typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"invalid opts\");\n        }\n        if (typeof callback !== \"function\") {\n            throw new InvalidArgumentError(\"invalid callback\");\n        }\n        const { signal, opaque, responseHeaders } = opts;\n        if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n            throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n        }\n        super(\"UNDICI_UPGRADE\");\n        this.responseHeaders = responseHeaders || null;\n        this.opaque = opaque || null;\n        this.callback = callback;\n        this.abort = null;\n        this.context = null;\n        addSignal(this, signal);\n    }\n    onConnect(abort, context) {\n        if (!this.callback) {\n            throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = null;\n    }\n    onHeaders() {\n        throw new SocketError(\"bad upgrade\", null);\n    }\n    onUpgrade(statusCode, rawHeaders, socket) {\n        const { callback, opaque, context } = this;\n        assert.strictEqual(statusCode, 101);\n        removeSignal(this);\n        this.callback = null;\n        const headers = this.responseHeaders === \"raw\" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        this.runInAsyncScope(callback, null, null, {\n            headers,\n            socket,\n            opaque,\n            context\n        });\n    }\n    onError(err) {\n        const { callback, opaque } = this;\n        removeSignal(this);\n        if (callback) {\n            this.callback = null;\n            queueMicrotask(()=>{\n                this.runInAsyncScope(callback, null, err, {\n                    opaque\n                });\n            });\n        }\n    }\n}\nfunction upgrade(opts, callback) {\n    if (callback === undefined) {\n        return new Promise((resolve, reject)=>{\n            upgrade.call(this, opts, (err, data)=>{\n                return err ? reject(err) : resolve(data);\n            });\n        });\n    }\n    try {\n        const upgradeHandler = new UpgradeHandler(opts, callback);\n        this.dispatch({\n            ...opts,\n            method: opts.method || \"GET\",\n            upgrade: opts.protocol || \"Websocket\"\n        }, upgradeHandler);\n    } catch (err) {\n        if (typeof callback !== \"function\") {\n            throw err;\n        }\n        const opaque = opts && opts.opaque;\n        queueMicrotask(()=>callback(err, {\n                opaque\n            }));\n    }\n}\nmodule.exports = upgrade;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS11cGdyYWRlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxvQkFBb0IsRUFBRUMsbUJBQW1CLEVBQUVDLFdBQVcsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUMzRSxNQUFNLEVBQUVDLGFBQWEsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUNsQyxNQUFNRSxPQUFPRixtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQUVHLFNBQVMsRUFBRUMsWUFBWSxFQUFFLEdBQUdKLG1CQUFPQSxDQUFDO0FBQzVDLE1BQU1LLFNBQVNMLG1CQUFPQSxDQUFDO0FBRXZCLE1BQU1NLHVCQUF1Qkw7SUFDM0JNLFlBQWFDLElBQUksRUFBRUMsUUFBUSxDQUFFO1FBQzNCLElBQUksQ0FBQ0QsUUFBUSxPQUFPQSxTQUFTLFVBQVU7WUFDckMsTUFBTSxJQUFJWCxxQkFBcUI7UUFDakM7UUFFQSxJQUFJLE9BQU9ZLGFBQWEsWUFBWTtZQUNsQyxNQUFNLElBQUlaLHFCQUFxQjtRQUNqQztRQUVBLE1BQU0sRUFBRWEsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLGVBQWUsRUFBRSxHQUFHSjtRQUU1QyxJQUFJRSxVQUFVLE9BQU9BLE9BQU9HLEVBQUUsS0FBSyxjQUFjLE9BQU9ILE9BQU9JLGdCQUFnQixLQUFLLFlBQVk7WUFDOUYsTUFBTSxJQUFJakIscUJBQXFCO1FBQ2pDO1FBRUEsS0FBSyxDQUFDO1FBRU4sSUFBSSxDQUFDZSxlQUFlLEdBQUdBLG1CQUFtQjtRQUMxQyxJQUFJLENBQUNELE1BQU0sR0FBR0EsVUFBVTtRQUN4QixJQUFJLENBQUNGLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDTSxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUNDLE9BQU8sR0FBRztRQUVmYixVQUFVLElBQUksRUFBRU87SUFDbEI7SUFFQU8sVUFBV0YsS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDekIsSUFBSSxDQUFDLElBQUksQ0FBQ1AsUUFBUSxFQUFFO1lBQ2xCLE1BQU0sSUFBSVg7UUFDWjtRQUVBLElBQUksQ0FBQ2lCLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLE9BQU8sR0FBRztJQUNqQjtJQUVBRSxZQUFhO1FBQ1gsTUFBTSxJQUFJbkIsWUFBWSxlQUFlO0lBQ3ZDO0lBRUFvQixVQUFXQyxVQUFVLEVBQUVDLFVBQVUsRUFBRUMsTUFBTSxFQUFFO1FBQ3pDLE1BQU0sRUFBRWIsUUFBUSxFQUFFRSxNQUFNLEVBQUVLLE9BQU8sRUFBRSxHQUFHLElBQUk7UUFFMUNYLE9BQU9rQixXQUFXLENBQUNILFlBQVk7UUFFL0JoQixhQUFhLElBQUk7UUFFakIsSUFBSSxDQUFDSyxRQUFRLEdBQUc7UUFDaEIsTUFBTWUsVUFBVSxJQUFJLENBQUNaLGVBQWUsS0FBSyxRQUFRVixLQUFLdUIsZUFBZSxDQUFDSixjQUFjbkIsS0FBS3dCLFlBQVksQ0FBQ0w7UUFDdEcsSUFBSSxDQUFDTSxlQUFlLENBQUNsQixVQUFVLE1BQU0sTUFBTTtZQUN6Q2U7WUFDQUY7WUFDQVg7WUFDQUs7UUFDRjtJQUNGO0lBRUFZLFFBQVNDLEdBQUcsRUFBRTtRQUNaLE1BQU0sRUFBRXBCLFFBQVEsRUFBRUUsTUFBTSxFQUFFLEdBQUcsSUFBSTtRQUVqQ1AsYUFBYSxJQUFJO1FBRWpCLElBQUlLLFVBQVU7WUFDWixJQUFJLENBQUNBLFFBQVEsR0FBRztZQUNoQnFCLGVBQWU7Z0JBQ2IsSUFBSSxDQUFDSCxlQUFlLENBQUNsQixVQUFVLE1BQU1vQixLQUFLO29CQUFFbEI7Z0JBQU87WUFDckQ7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxTQUFTb0IsUUFBU3ZCLElBQUksRUFBRUMsUUFBUTtJQUM5QixJQUFJQSxhQUFhdUIsV0FBVztRQUMxQixPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDM0JKLFFBQVFLLElBQUksQ0FBQyxJQUFJLEVBQUU1QixNQUFNLENBQUNxQixLQUFLUTtnQkFDN0IsT0FBT1IsTUFBTU0sT0FBT04sT0FBT0ssUUFBUUc7WUFDckM7UUFDRjtJQUNGO0lBRUEsSUFBSTtRQUNGLE1BQU1DLGlCQUFpQixJQUFJaEMsZUFBZUUsTUFBTUM7UUFDaEQsSUFBSSxDQUFDOEIsUUFBUSxDQUFDO1lBQ1osR0FBRy9CLElBQUk7WUFDUGdDLFFBQVFoQyxLQUFLZ0MsTUFBTSxJQUFJO1lBQ3ZCVCxTQUFTdkIsS0FBS2lDLFFBQVEsSUFBSTtRQUM1QixHQUFHSDtJQUNMLEVBQUUsT0FBT1QsS0FBSztRQUNaLElBQUksT0FBT3BCLGFBQWEsWUFBWTtZQUNsQyxNQUFNb0I7UUFDUjtRQUNBLE1BQU1sQixTQUFTSCxRQUFRQSxLQUFLRyxNQUFNO1FBQ2xDbUIsZUFBZSxJQUFNckIsU0FBU29CLEtBQUs7Z0JBQUVsQjtZQUFPO0lBQzlDO0FBQ0Y7QUFFQStCLE9BQU9DLE9BQU8sR0FBR1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXVwZ3JhZGUuanM/OTg0NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgUmVxdWVzdEFib3J0ZWRFcnJvciwgU29ja2V0RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHsgQXN5bmNSZXNvdXJjZSB9ID0gcmVxdWlyZSgnYXN5bmNfaG9va3MnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGFkZFNpZ25hbCwgcmVtb3ZlU2lnbmFsIH0gPSByZXF1aXJlKCcuL2Fib3J0LXNpZ25hbCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuXG5jbGFzcyBVcGdyYWRlSGFuZGxlciBleHRlbmRzIEFzeW5jUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3RvciAob3B0cywgY2FsbGJhY2spIHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb3B0cycpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNhbGxiYWNrJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHNpZ25hbCwgb3BhcXVlLCByZXNwb25zZUhlYWRlcnMgfSA9IG9wdHNcblxuICAgIGlmIChzaWduYWwgJiYgdHlwZW9mIHNpZ25hbC5vbiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignc2lnbmFsIG11c3QgYmUgYW4gRXZlbnRFbWl0dGVyIG9yIEV2ZW50VGFyZ2V0JylcbiAgICB9XG5cbiAgICBzdXBlcignVU5ESUNJX1VQR1JBREUnKVxuXG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgfHwgbnVsbFxuICAgIHRoaXMub3BhcXVlID0gb3BhcXVlIHx8IG51bGxcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLmFib3J0ID0gbnVsbFxuICAgIHRoaXMuY29udGV4dCA9IG51bGxcblxuICAgIGFkZFNpZ25hbCh0aGlzLCBzaWduYWwpXG4gIH1cblxuICBvbkNvbm5lY3QgKGFib3J0LCBjb250ZXh0KSB7XG4gICAgaWYgKCF0aGlzLmNhbGxiYWNrKSB7XG4gICAgICB0aHJvdyBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gICAgfVxuXG4gICAgdGhpcy5hYm9ydCA9IGFib3J0XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbFxuICB9XG5cbiAgb25IZWFkZXJzICgpIHtcbiAgICB0aHJvdyBuZXcgU29ja2V0RXJyb3IoJ2JhZCB1cGdyYWRlJywgbnVsbClcbiAgfVxuXG4gIG9uVXBncmFkZSAoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgc29ja2V0KSB7XG4gICAgY29uc3QgeyBjYWxsYmFjaywgb3BhcXVlLCBjb250ZXh0IH0gPSB0aGlzXG5cbiAgICBhc3NlcnQuc3RyaWN0RXF1YWwoc3RhdHVzQ29kZSwgMTAxKVxuXG4gICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlUmF3SGVhZGVycyhyYXdIZWFkZXJzKSA6IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpXG4gICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIG51bGwsIHtcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzb2NrZXQsXG4gICAgICBvcGFxdWUsXG4gICAgICBjb250ZXh0XG4gICAgfSlcbiAgfVxuXG4gIG9uRXJyb3IgKGVycikge1xuICAgIGNvbnN0IHsgY2FsbGJhY2ssIG9wYXF1ZSB9ID0gdGhpc1xuXG4gICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBlcnIsIHsgb3BhcXVlIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGdyYWRlIChvcHRzLCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB1cGdyYWRlLmNhbGwodGhpcywgb3B0cywgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHVwZ3JhZGVIYW5kbGVyID0gbmV3IFVwZ3JhZGVIYW5kbGVyKG9wdHMsIGNhbGxiYWNrKVxuICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgLi4ub3B0cyxcbiAgICAgIG1ldGhvZDogb3B0cy5tZXRob2QgfHwgJ0dFVCcsXG4gICAgICB1cGdyYWRlOiBvcHRzLnByb3RvY29sIHx8ICdXZWJzb2NrZXQnXG4gICAgfSwgdXBncmFkZUhhbmRsZXIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgICBjb25zdCBvcGFxdWUgPSBvcHRzICYmIG9wdHMub3BhcXVlXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2soZXJyLCB7IG9wYXF1ZSB9KSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVwZ3JhZGVcbiJdLCJuYW1lcyI6WyJJbnZhbGlkQXJndW1lbnRFcnJvciIsIlJlcXVlc3RBYm9ydGVkRXJyb3IiLCJTb2NrZXRFcnJvciIsInJlcXVpcmUiLCJBc3luY1Jlc291cmNlIiwidXRpbCIsImFkZFNpZ25hbCIsInJlbW92ZVNpZ25hbCIsImFzc2VydCIsIlVwZ3JhZGVIYW5kbGVyIiwiY29uc3RydWN0b3IiLCJvcHRzIiwiY2FsbGJhY2siLCJzaWduYWwiLCJvcGFxdWUiLCJyZXNwb25zZUhlYWRlcnMiLCJvbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJhYm9ydCIsImNvbnRleHQiLCJvbkNvbm5lY3QiLCJvbkhlYWRlcnMiLCJvblVwZ3JhZGUiLCJzdGF0dXNDb2RlIiwicmF3SGVhZGVycyIsInNvY2tldCIsInN0cmljdEVxdWFsIiwiaGVhZGVycyIsInBhcnNlUmF3SGVhZGVycyIsInBhcnNlSGVhZGVycyIsInJ1bkluQXN5bmNTY29wZSIsIm9uRXJyb3IiLCJlcnIiLCJxdWV1ZU1pY3JvdGFzayIsInVwZ3JhZGUiLCJ1bmRlZmluZWQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNhbGwiLCJkYXRhIiwidXBncmFkZUhhbmRsZXIiLCJkaXNwYXRjaCIsIm1ldGhvZCIsInByb3RvY29sIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/api/api-upgrade.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/api/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/api/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports.request = __webpack_require__(/*! ./api-request */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/api/api-request.js\");\nmodule.exports.stream = __webpack_require__(/*! ./api-stream */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/api/api-stream.js\");\nmodule.exports.pipeline = __webpack_require__(/*! ./api-pipeline */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/api/api-pipeline.js\");\nmodule.exports.upgrade = __webpack_require__(/*! ./api-upgrade */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/api/api-upgrade.js\");\nmodule.exports.connect = __webpack_require__(/*! ./api-connect */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/api/api-connect.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDZJQUFpQztBQUNqQ0EsMElBQWdDO0FBQ2hDQSxnSkFBa0M7QUFDbENBLDZJQUFpQztBQUNqQ0EsNklBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1maWdodGVyLWFjYWRlbXkvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2luZGV4LmpzP2I0MGQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzLnJlcXVlc3QgPSByZXF1aXJlKCcuL2FwaS1yZXF1ZXN0Jylcbm1vZHVsZS5leHBvcnRzLnN0cmVhbSA9IHJlcXVpcmUoJy4vYXBpLXN0cmVhbScpXG5tb2R1bGUuZXhwb3J0cy5waXBlbGluZSA9IHJlcXVpcmUoJy4vYXBpLXBpcGVsaW5lJylcbm1vZHVsZS5leHBvcnRzLnVwZ3JhZGUgPSByZXF1aXJlKCcuL2FwaS11cGdyYWRlJylcbm1vZHVsZS5leHBvcnRzLmNvbm5lY3QgPSByZXF1aXJlKCcuL2FwaS1jb25uZWN0JylcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWVzdCIsInJlcXVpcmUiLCJzdHJlYW0iLCJwaXBlbGluZSIsInVwZ3JhZGUiLCJjb25uZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/api/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/api/readable.js":
/*!***********************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/api/readable.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Ported from https://github.com/nodejs/undici/pull/907\n\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { Readable } = __webpack_require__(/*! stream */ \"stream\");\nconst { RequestAbortedError, NotSupportedError, InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst { ReadableStreamFrom, toUSVString } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nlet Blob;\nconst kConsume = Symbol(\"kConsume\");\nconst kReading = Symbol(\"kReading\");\nconst kBody = Symbol(\"kBody\");\nconst kAbort = Symbol(\"abort\");\nconst kContentType = Symbol(\"kContentType\");\nconst noop = ()=>{};\nmodule.exports = class BodyReadable extends Readable {\n    constructor({ resume, abort, contentType = \"\", highWaterMark = 64 * 1024 // Same as nodejs fs streams.\n     }){\n        super({\n            autoDestroy: true,\n            read: resume,\n            highWaterMark\n        });\n        this._readableState.dataEmitted = false;\n        this[kAbort] = abort;\n        this[kConsume] = null;\n        this[kBody] = null;\n        this[kContentType] = contentType;\n        // Is stream being consumed through Readable API?\n        // This is an optimization so that we avoid checking\n        // for 'data' and 'readable' listeners in the hot path\n        // inside push().\n        this[kReading] = false;\n    }\n    destroy(err) {\n        if (this.destroyed) {\n            // Node < 16\n            return this;\n        }\n        if (!err && !this._readableState.endEmitted) {\n            err = new RequestAbortedError();\n        }\n        if (err) {\n            this[kAbort]();\n        }\n        return super.destroy(err);\n    }\n    emit(ev, ...args) {\n        if (ev === \"data\") {\n            // Node < 16.7\n            this._readableState.dataEmitted = true;\n        } else if (ev === \"error\") {\n            // Node < 16\n            this._readableState.errorEmitted = true;\n        }\n        return super.emit(ev, ...args);\n    }\n    on(ev, ...args) {\n        if (ev === \"data\" || ev === \"readable\") {\n            this[kReading] = true;\n        }\n        return super.on(ev, ...args);\n    }\n    addListener(ev, ...args) {\n        return this.on(ev, ...args);\n    }\n    off(ev, ...args) {\n        const ret = super.off(ev, ...args);\n        if (ev === \"data\" || ev === \"readable\") {\n            this[kReading] = this.listenerCount(\"data\") > 0 || this.listenerCount(\"readable\") > 0;\n        }\n        return ret;\n    }\n    removeListener(ev, ...args) {\n        return this.off(ev, ...args);\n    }\n    push(chunk) {\n        if (this[kConsume] && chunk !== null && this.readableLength === 0) {\n            consumePush(this[kConsume], chunk);\n            return this[kReading] ? super.push(chunk) : true;\n        }\n        return super.push(chunk);\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-text\n    async text() {\n        return consume(this, \"text\");\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-json\n    async json() {\n        return consume(this, \"json\");\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-blob\n    async blob() {\n        return consume(this, \"blob\");\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n    async arrayBuffer() {\n        return consume(this, \"arrayBuffer\");\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-formdata\n    async formData() {\n        // TODO: Implement.\n        throw new NotSupportedError();\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-bodyused\n    get bodyUsed() {\n        return util.isDisturbed(this);\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-body\n    get body() {\n        if (!this[kBody]) {\n            this[kBody] = ReadableStreamFrom(this);\n            if (this[kConsume]) {\n                // TODO: Is this the best way to force a lock?\n                this[kBody].getReader() // Ensure stream is locked.\n                ;\n                assert(this[kBody].locked);\n            }\n        }\n        return this[kBody];\n    }\n    dump(opts) {\n        let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;\n        const signal = opts && opts.signal;\n        if (signal) {\n            try {\n                if (typeof signal !== \"object\" || !(\"aborted\" in signal)) {\n                    throw new InvalidArgumentError(\"signal must be an AbortSignal\");\n                }\n                util.throwIfAborted(signal);\n            } catch (err) {\n                return Promise.reject(err);\n            }\n        }\n        if (this.closed) {\n            return Promise.resolve(null);\n        }\n        return new Promise((resolve, reject)=>{\n            const signalListenerCleanup = signal ? util.addAbortListener(signal, ()=>{\n                this.destroy();\n            }) : noop;\n            this.on(\"close\", function() {\n                signalListenerCleanup();\n                if (signal && signal.aborted) {\n                    reject(signal.reason || Object.assign(new Error(\"The operation was aborted\"), {\n                        name: \"AbortError\"\n                    }));\n                } else {\n                    resolve(null);\n                }\n            }).on(\"error\", noop).on(\"data\", function(chunk) {\n                limit -= chunk.length;\n                if (limit <= 0) {\n                    this.destroy();\n                }\n            }).resume();\n        });\n    }\n};\n// https://streams.spec.whatwg.org/#readablestream-locked\nfunction isLocked(self) {\n    // Consume is an implicit lock.\n    return self[kBody] && self[kBody].locked === true || self[kConsume];\n}\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction isUnusable(self) {\n    return util.isDisturbed(self) || isLocked(self);\n}\nasync function consume(stream, type) {\n    if (isUnusable(stream)) {\n        throw new TypeError(\"unusable\");\n    }\n    assert(!stream[kConsume]);\n    return new Promise((resolve, reject)=>{\n        stream[kConsume] = {\n            type,\n            stream,\n            resolve,\n            reject,\n            length: 0,\n            body: []\n        };\n        stream.on(\"error\", function(err) {\n            consumeFinish(this[kConsume], err);\n        }).on(\"close\", function() {\n            if (this[kConsume].body !== null) {\n                consumeFinish(this[kConsume], new RequestAbortedError());\n            }\n        });\n        process.nextTick(consumeStart, stream[kConsume]);\n    });\n}\nfunction consumeStart(consume) {\n    if (consume.body === null) {\n        return;\n    }\n    const { _readableState: state } = consume.stream;\n    for (const chunk of state.buffer){\n        consumePush(consume, chunk);\n    }\n    if (state.endEmitted) {\n        consumeEnd(this[kConsume]);\n    } else {\n        consume.stream.on(\"end\", function() {\n            consumeEnd(this[kConsume]);\n        });\n    }\n    consume.stream.resume();\n    while(consume.stream.read() != null){\n    // Loop\n    }\n}\nfunction consumeEnd(consume) {\n    const { type, body, resolve, stream, length } = consume;\n    try {\n        if (type === \"text\") {\n            resolve(toUSVString(Buffer.concat(body)));\n        } else if (type === \"json\") {\n            resolve(JSON.parse(Buffer.concat(body)));\n        } else if (type === \"arrayBuffer\") {\n            const dst = new Uint8Array(length);\n            let pos = 0;\n            for (const buf of body){\n                dst.set(buf, pos);\n                pos += buf.byteLength;\n            }\n            resolve(dst.buffer);\n        } else if (type === \"blob\") {\n            if (!Blob) {\n                Blob = (__webpack_require__(/*! buffer */ \"buffer\").Blob);\n            }\n            resolve(new Blob(body, {\n                type: stream[kContentType]\n            }));\n        }\n        consumeFinish(consume);\n    } catch (err) {\n        stream.destroy(err);\n    }\n}\nfunction consumePush(consume, chunk) {\n    consume.length += chunk.length;\n    consume.body.push(chunk);\n}\nfunction consumeFinish(consume, err) {\n    if (consume.body === null) {\n        return;\n    }\n    if (err) {\n        consume.reject(err);\n    } else {\n        consume.resolve();\n    }\n    consume.type = null;\n    consume.stream = null;\n    consume.resolve = null;\n    consume.reject = null;\n    consume.length = 0;\n    consume.body = null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL3JlYWRhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFBLHdEQUF3RDtBQUV4RDtBQUVBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRUMsUUFBUSxFQUFFLEdBQUdELG1CQUFPQSxDQUFDO0FBQzdCLE1BQU0sRUFBRUUsbUJBQW1CLEVBQUVDLGlCQUFpQixFQUFFQyxvQkFBb0IsRUFBRSxHQUFHSixtQkFBT0EsQ0FBQztBQUNqRixNQUFNSyxPQUFPTCxtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQUVNLGtCQUFrQixFQUFFQyxXQUFXLEVBQUUsR0FBR1AsbUJBQU9BLENBQUM7QUFFcEQsSUFBSVE7QUFFSixNQUFNQyxXQUFXQyxPQUFPO0FBQ3hCLE1BQU1DLFdBQVdELE9BQU87QUFDeEIsTUFBTUUsUUFBUUYsT0FBTztBQUNyQixNQUFNRyxTQUFTSCxPQUFPO0FBQ3RCLE1BQU1JLGVBQWVKLE9BQU87QUFFNUIsTUFBTUssT0FBTyxLQUFPO0FBRXBCQyxPQUFPQyxPQUFPLEdBQUcsTUFBTUMscUJBQXFCakI7SUFDMUNrQixZQUFhLEVBQ1hDLE1BQU0sRUFDTkMsS0FBSyxFQUNMQyxjQUFjLEVBQUUsRUFDaEJDLGdCQUFnQixLQUFLLEtBQUssNkJBQTZCO0lBQTlCLEVBQzFCLENBQUU7UUFDRCxLQUFLLENBQUM7WUFDSkMsYUFBYTtZQUNiQyxNQUFNTDtZQUNORztRQUNGO1FBRUEsSUFBSSxDQUFDRyxjQUFjLENBQUNDLFdBQVcsR0FBRztRQUVsQyxJQUFJLENBQUNkLE9BQU8sR0FBR1E7UUFDZixJQUFJLENBQUNaLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNHLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0UsYUFBYSxHQUFHUTtRQUVyQixpREFBaUQ7UUFDakQsb0RBQW9EO1FBQ3BELHNEQUFzRDtRQUN0RCxpQkFBaUI7UUFDakIsSUFBSSxDQUFDWCxTQUFTLEdBQUc7SUFDbkI7SUFFQWlCLFFBQVNDLEdBQUcsRUFBRTtRQUNaLElBQUksSUFBSSxDQUFDQyxTQUFTLEVBQUU7WUFDbEIsWUFBWTtZQUNaLE9BQU8sSUFBSTtRQUNiO1FBRUEsSUFBSSxDQUFDRCxPQUFPLENBQUMsSUFBSSxDQUFDSCxjQUFjLENBQUNLLFVBQVUsRUFBRTtZQUMzQ0YsTUFBTSxJQUFJM0I7UUFDWjtRQUVBLElBQUkyQixLQUFLO1lBQ1AsSUFBSSxDQUFDaEIsT0FBTztRQUNkO1FBRUEsT0FBTyxLQUFLLENBQUNlLFFBQVFDO0lBQ3ZCO0lBRUFHLEtBQU1DLEVBQUUsRUFBRSxHQUFHQyxJQUFJLEVBQUU7UUFDakIsSUFBSUQsT0FBTyxRQUFRO1lBQ2pCLGNBQWM7WUFDZCxJQUFJLENBQUNQLGNBQWMsQ0FBQ0MsV0FBVyxHQUFHO1FBQ3BDLE9BQU8sSUFBSU0sT0FBTyxTQUFTO1lBQ3pCLFlBQVk7WUFDWixJQUFJLENBQUNQLGNBQWMsQ0FBQ1MsWUFBWSxHQUFHO1FBQ3JDO1FBQ0EsT0FBTyxLQUFLLENBQUNILEtBQUtDLE9BQU9DO0lBQzNCO0lBRUFFLEdBQUlILEVBQUUsRUFBRSxHQUFHQyxJQUFJLEVBQUU7UUFDZixJQUFJRCxPQUFPLFVBQVVBLE9BQU8sWUFBWTtZQUN0QyxJQUFJLENBQUN0QixTQUFTLEdBQUc7UUFDbkI7UUFDQSxPQUFPLEtBQUssQ0FBQ3lCLEdBQUdILE9BQU9DO0lBQ3pCO0lBRUFHLFlBQWFKLEVBQUUsRUFBRSxHQUFHQyxJQUFJLEVBQUU7UUFDeEIsT0FBTyxJQUFJLENBQUNFLEVBQUUsQ0FBQ0gsT0FBT0M7SUFDeEI7SUFFQUksSUFBS0wsRUFBRSxFQUFFLEdBQUdDLElBQUksRUFBRTtRQUNoQixNQUFNSyxNQUFNLEtBQUssQ0FBQ0QsSUFBSUwsT0FBT0M7UUFDN0IsSUFBSUQsT0FBTyxVQUFVQSxPQUFPLFlBQVk7WUFDdEMsSUFBSSxDQUFDdEIsU0FBUyxHQUNaLElBQUksQ0FBQzZCLGFBQWEsQ0FBQyxVQUFVLEtBQzdCLElBQUksQ0FBQ0EsYUFBYSxDQUFDLGNBQWM7UUFFckM7UUFDQSxPQUFPRDtJQUNUO0lBRUFFLGVBQWdCUixFQUFFLEVBQUUsR0FBR0MsSUFBSSxFQUFFO1FBQzNCLE9BQU8sSUFBSSxDQUFDSSxHQUFHLENBQUNMLE9BQU9DO0lBQ3pCO0lBRUFRLEtBQU1DLEtBQUssRUFBRTtRQUNYLElBQUksSUFBSSxDQUFDbEMsU0FBUyxJQUFJa0MsVUFBVSxRQUFRLElBQUksQ0FBQ0MsY0FBYyxLQUFLLEdBQUc7WUFDakVDLFlBQVksSUFBSSxDQUFDcEMsU0FBUyxFQUFFa0M7WUFDNUIsT0FBTyxJQUFJLENBQUNoQyxTQUFTLEdBQUcsS0FBSyxDQUFDK0IsS0FBS0MsU0FBUztRQUM5QztRQUNBLE9BQU8sS0FBSyxDQUFDRCxLQUFLQztJQUNwQjtJQUVBLCtDQUErQztJQUMvQyxNQUFNRyxPQUFRO1FBQ1osT0FBT0MsUUFBUSxJQUFJLEVBQUU7SUFDdkI7SUFFQSwrQ0FBK0M7SUFDL0MsTUFBTUMsT0FBUTtRQUNaLE9BQU9ELFFBQVEsSUFBSSxFQUFFO0lBQ3ZCO0lBRUEsK0NBQStDO0lBQy9DLE1BQU1FLE9BQVE7UUFDWixPQUFPRixRQUFRLElBQUksRUFBRTtJQUN2QjtJQUVBLHNEQUFzRDtJQUN0RCxNQUFNRyxjQUFlO1FBQ25CLE9BQU9ILFFBQVEsSUFBSSxFQUFFO0lBQ3ZCO0lBRUEsbURBQW1EO0lBQ25ELE1BQU1JLFdBQVk7UUFDaEIsbUJBQW1CO1FBQ25CLE1BQU0sSUFBSWhEO0lBQ1o7SUFFQSxtREFBbUQ7SUFDbkQsSUFBSWlELFdBQVk7UUFDZCxPQUFPL0MsS0FBS2dELFdBQVcsQ0FBQyxJQUFJO0lBQzlCO0lBRUEsK0NBQStDO0lBQy9DLElBQUlDLE9BQVE7UUFDVixJQUFJLENBQUMsSUFBSSxDQUFDMUMsTUFBTSxFQUFFO1lBQ2hCLElBQUksQ0FBQ0EsTUFBTSxHQUFHTixtQkFBbUIsSUFBSTtZQUNyQyxJQUFJLElBQUksQ0FBQ0csU0FBUyxFQUFFO2dCQUNsQiw4Q0FBOEM7Z0JBQzlDLElBQUksQ0FBQ0csTUFBTSxDQUFDMkMsU0FBUyxHQUFHLDJCQUEyQjs7Z0JBQ25EeEQsT0FBTyxJQUFJLENBQUNhLE1BQU0sQ0FBQzRDLE1BQU07WUFDM0I7UUFDRjtRQUNBLE9BQU8sSUFBSSxDQUFDNUMsTUFBTTtJQUNwQjtJQUVBNkMsS0FBTUMsSUFBSSxFQUFFO1FBQ1YsSUFBSUMsUUFBUUQsUUFBUUUsT0FBT0MsUUFBUSxDQUFDSCxLQUFLQyxLQUFLLElBQUlELEtBQUtDLEtBQUssR0FBRztRQUMvRCxNQUFNRyxTQUFTSixRQUFRQSxLQUFLSSxNQUFNO1FBRWxDLElBQUlBLFFBQVE7WUFDVixJQUFJO2dCQUNGLElBQUksT0FBT0EsV0FBVyxZQUFZLENBQUUsY0FBYUEsTUFBSyxHQUFJO29CQUN4RCxNQUFNLElBQUkxRCxxQkFBcUI7Z0JBQ2pDO2dCQUNBQyxLQUFLMEQsY0FBYyxDQUFDRDtZQUN0QixFQUFFLE9BQU9qQyxLQUFLO2dCQUNaLE9BQU9tQyxRQUFRQyxNQUFNLENBQUNwQztZQUN4QjtRQUNGO1FBRUEsSUFBSSxJQUFJLENBQUNxQyxNQUFNLEVBQUU7WUFDZixPQUFPRixRQUFRRyxPQUFPLENBQUM7UUFDekI7UUFFQSxPQUFPLElBQUlILFFBQVEsQ0FBQ0csU0FBU0Y7WUFDM0IsTUFBTUcsd0JBQXdCTixTQUMxQnpELEtBQUtnRSxnQkFBZ0IsQ0FBQ1AsUUFBUTtnQkFDOUIsSUFBSSxDQUFDbEMsT0FBTztZQUNkLEtBQ0ViO1lBRUosSUFBSSxDQUNEcUIsRUFBRSxDQUFDLFNBQVM7Z0JBQ1hnQztnQkFDQSxJQUFJTixVQUFVQSxPQUFPUSxPQUFPLEVBQUU7b0JBQzVCTCxPQUFPSCxPQUFPUyxNQUFNLElBQUlDLE9BQU9DLE1BQU0sQ0FBQyxJQUFJQyxNQUFNLDhCQUE4Qjt3QkFBRUMsTUFBTTtvQkFBYTtnQkFDckcsT0FBTztvQkFDTFIsUUFBUTtnQkFDVjtZQUNGLEdBQ0MvQixFQUFFLENBQUMsU0FBU3JCLE1BQ1pxQixFQUFFLENBQUMsUUFBUSxTQUFVTyxLQUFLO2dCQUN6QmdCLFNBQVNoQixNQUFNaUMsTUFBTTtnQkFDckIsSUFBSWpCLFNBQVMsR0FBRztvQkFDZCxJQUFJLENBQUMvQixPQUFPO2dCQUNkO1lBQ0YsR0FDQ1IsTUFBTTtRQUNYO0lBQ0Y7QUFDRjtBQUVBLHlEQUF5RDtBQUN6RCxTQUFTeUQsU0FBVUMsSUFBSTtJQUNyQiwrQkFBK0I7SUFDL0IsT0FBTyxJQUFLLENBQUNsRSxNQUFNLElBQUlrRSxJQUFJLENBQUNsRSxNQUFNLENBQUM0QyxNQUFNLEtBQUssUUFBU3NCLElBQUksQ0FBQ3JFLFNBQVM7QUFDdkU7QUFFQSwrQ0FBK0M7QUFDL0MsU0FBU3NFLFdBQVlELElBQUk7SUFDdkIsT0FBT3pFLEtBQUtnRCxXQUFXLENBQUN5QixTQUFTRCxTQUFTQztBQUM1QztBQUVBLGVBQWUvQixRQUFTaUMsTUFBTSxFQUFFQyxJQUFJO0lBQ2xDLElBQUlGLFdBQVdDLFNBQVM7UUFDdEIsTUFBTSxJQUFJRSxVQUFVO0lBQ3RCO0lBRUFuRixPQUFPLENBQUNpRixNQUFNLENBQUN2RSxTQUFTO0lBRXhCLE9BQU8sSUFBSXVELFFBQVEsQ0FBQ0csU0FBU0Y7UUFDM0JlLE1BQU0sQ0FBQ3ZFLFNBQVMsR0FBRztZQUNqQndFO1lBQ0FEO1lBQ0FiO1lBQ0FGO1lBQ0FXLFFBQVE7WUFDUnRCLE1BQU0sRUFBRTtRQUNWO1FBRUEwQixPQUNHNUMsRUFBRSxDQUFDLFNBQVMsU0FBVVAsR0FBRztZQUN4QnNELGNBQWMsSUFBSSxDQUFDMUUsU0FBUyxFQUFFb0I7UUFDaEMsR0FDQ08sRUFBRSxDQUFDLFNBQVM7WUFDWCxJQUFJLElBQUksQ0FBQzNCLFNBQVMsQ0FBQzZDLElBQUksS0FBSyxNQUFNO2dCQUNoQzZCLGNBQWMsSUFBSSxDQUFDMUUsU0FBUyxFQUFFLElBQUlQO1lBQ3BDO1FBQ0Y7UUFFRmtGLFFBQVFDLFFBQVEsQ0FBQ0MsY0FBY04sTUFBTSxDQUFDdkUsU0FBUztJQUNqRDtBQUNGO0FBRUEsU0FBUzZFLGFBQWN2QyxPQUFPO0lBQzVCLElBQUlBLFFBQVFPLElBQUksS0FBSyxNQUFNO1FBQ3pCO0lBQ0Y7SUFFQSxNQUFNLEVBQUU1QixnQkFBZ0I2RCxLQUFLLEVBQUUsR0FBR3hDLFFBQVFpQyxNQUFNO0lBRWhELEtBQUssTUFBTXJDLFNBQVM0QyxNQUFNQyxNQUFNLENBQUU7UUFDaEMzQyxZQUFZRSxTQUFTSjtJQUN2QjtJQUVBLElBQUk0QyxNQUFNeEQsVUFBVSxFQUFFO1FBQ3BCMEQsV0FBVyxJQUFJLENBQUNoRixTQUFTO0lBQzNCLE9BQU87UUFDTHNDLFFBQVFpQyxNQUFNLENBQUM1QyxFQUFFLENBQUMsT0FBTztZQUN2QnFELFdBQVcsSUFBSSxDQUFDaEYsU0FBUztRQUMzQjtJQUNGO0lBRUFzQyxRQUFRaUMsTUFBTSxDQUFDNUQsTUFBTTtJQUVyQixNQUFPMkIsUUFBUWlDLE1BQU0sQ0FBQ3ZELElBQUksTUFBTSxLQUFNO0lBQ3BDLE9BQU87SUFDVDtBQUNGO0FBRUEsU0FBU2dFLFdBQVkxQyxPQUFPO0lBQzFCLE1BQU0sRUFBRWtDLElBQUksRUFBRTNCLElBQUksRUFBRWEsT0FBTyxFQUFFYSxNQUFNLEVBQUVKLE1BQU0sRUFBRSxHQUFHN0I7SUFFaEQsSUFBSTtRQUNGLElBQUlrQyxTQUFTLFFBQVE7WUFDbkJkLFFBQVE1RCxZQUFZbUYsT0FBT0MsTUFBTSxDQUFDckM7UUFDcEMsT0FBTyxJQUFJMkIsU0FBUyxRQUFRO1lBQzFCZCxRQUFReUIsS0FBS0MsS0FBSyxDQUFDSCxPQUFPQyxNQUFNLENBQUNyQztRQUNuQyxPQUFPLElBQUkyQixTQUFTLGVBQWU7WUFDakMsTUFBTWEsTUFBTSxJQUFJQyxXQUFXbkI7WUFFM0IsSUFBSW9CLE1BQU07WUFDVixLQUFLLE1BQU1DLE9BQU8zQyxLQUFNO2dCQUN0QndDLElBQUlJLEdBQUcsQ0FBQ0QsS0FBS0Q7Z0JBQ2JBLE9BQU9DLElBQUlFLFVBQVU7WUFDdkI7WUFFQWhDLFFBQVEyQixJQUFJTixNQUFNO1FBQ3BCLE9BQU8sSUFBSVAsU0FBUyxRQUFRO1lBQzFCLElBQUksQ0FBQ3pFLE1BQU07Z0JBQ1RBLE9BQU9SLGtEQUFzQjtZQUMvQjtZQUNBbUUsUUFBUSxJQUFJM0QsS0FBSzhDLE1BQU07Z0JBQUUyQixNQUFNRCxNQUFNLENBQUNsRSxhQUFhO1lBQUM7UUFDdEQ7UUFFQXFFLGNBQWNwQztJQUNoQixFQUFFLE9BQU9sQixLQUFLO1FBQ1ptRCxPQUFPcEQsT0FBTyxDQUFDQztJQUNqQjtBQUNGO0FBRUEsU0FBU2dCLFlBQWFFLE9BQU8sRUFBRUosS0FBSztJQUNsQ0ksUUFBUTZCLE1BQU0sSUFBSWpDLE1BQU1pQyxNQUFNO0lBQzlCN0IsUUFBUU8sSUFBSSxDQUFDWixJQUFJLENBQUNDO0FBQ3BCO0FBRUEsU0FBU3dDLGNBQWVwQyxPQUFPLEVBQUVsQixHQUFHO0lBQ2xDLElBQUlrQixRQUFRTyxJQUFJLEtBQUssTUFBTTtRQUN6QjtJQUNGO0lBRUEsSUFBSXpCLEtBQUs7UUFDUGtCLFFBQVFrQixNQUFNLENBQUNwQztJQUNqQixPQUFPO1FBQ0xrQixRQUFRb0IsT0FBTztJQUNqQjtJQUVBcEIsUUFBUWtDLElBQUksR0FBRztJQUNmbEMsUUFBUWlDLE1BQU0sR0FBRztJQUNqQmpDLFFBQVFvQixPQUFPLEdBQUc7SUFDbEJwQixRQUFRa0IsTUFBTSxHQUFHO0lBQ2pCbEIsUUFBUTZCLE1BQU0sR0FBRztJQUNqQjdCLFFBQVFPLElBQUksR0FBRztBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9yZWFkYWJsZS5qcz84YWYzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL3B1bGwvOTA3XG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgeyBSZWFkYWJsZSB9ID0gcmVxdWlyZSgnc3RyZWFtJylcbmNvbnN0IHsgUmVxdWVzdEFib3J0ZWRFcnJvciwgTm90U3VwcG9ydGVkRXJyb3IsIEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgUmVhZGFibGVTdHJlYW1Gcm9tLCB0b1VTVlN0cmluZyB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcblxubGV0IEJsb2JcblxuY29uc3Qga0NvbnN1bWUgPSBTeW1ib2woJ2tDb25zdW1lJylcbmNvbnN0IGtSZWFkaW5nID0gU3ltYm9sKCdrUmVhZGluZycpXG5jb25zdCBrQm9keSA9IFN5bWJvbCgna0JvZHknKVxuY29uc3Qga0Fib3J0ID0gU3ltYm9sKCdhYm9ydCcpXG5jb25zdCBrQ29udGVudFR5cGUgPSBTeW1ib2woJ2tDb250ZW50VHlwZScpXG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEJvZHlSZWFkYWJsZSBleHRlbmRzIFJlYWRhYmxlIHtcbiAgY29uc3RydWN0b3IgKHtcbiAgICByZXN1bWUsXG4gICAgYWJvcnQsXG4gICAgY29udGVudFR5cGUgPSAnJyxcbiAgICBoaWdoV2F0ZXJNYXJrID0gNjQgKiAxMDI0IC8vIFNhbWUgYXMgbm9kZWpzIGZzIHN0cmVhbXMuXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBhdXRvRGVzdHJveTogdHJ1ZSxcbiAgICAgIHJlYWQ6IHJlc3VtZSxcbiAgICAgIGhpZ2hXYXRlck1hcmtcbiAgICB9KVxuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kYXRhRW1pdHRlZCA9IGZhbHNlXG5cbiAgICB0aGlzW2tBYm9ydF0gPSBhYm9ydFxuICAgIHRoaXNba0NvbnN1bWVdID0gbnVsbFxuICAgIHRoaXNba0JvZHldID0gbnVsbFxuICAgIHRoaXNba0NvbnRlbnRUeXBlXSA9IGNvbnRlbnRUeXBlXG5cbiAgICAvLyBJcyBzdHJlYW0gYmVpbmcgY29uc3VtZWQgdGhyb3VnaCBSZWFkYWJsZSBBUEk/XG4gICAgLy8gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gc28gdGhhdCB3ZSBhdm9pZCBjaGVja2luZ1xuICAgIC8vIGZvciAnZGF0YScgYW5kICdyZWFkYWJsZScgbGlzdGVuZXJzIGluIHRoZSBob3QgcGF0aFxuICAgIC8vIGluc2lkZSBwdXNoKCkuXG4gICAgdGhpc1trUmVhZGluZ10gPSBmYWxzZVxuICB9XG5cbiAgZGVzdHJveSAoZXJyKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAvLyBOb2RlIDwgMTZcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgaWYgKCFlcnIgJiYgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgZXJyID0gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgIH1cblxuICAgIGlmIChlcnIpIHtcbiAgICAgIHRoaXNba0Fib3J0XSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLmRlc3Ryb3koZXJyKVxuICB9XG5cbiAgZW1pdCAoZXYsIC4uLmFyZ3MpIHtcbiAgICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgICAgLy8gTm9kZSA8IDE2LjdcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGF0YUVtaXR0ZWQgPSB0cnVlXG4gICAgfSBlbHNlIGlmIChldiA9PT0gJ2Vycm9yJykge1xuICAgICAgLy8gTm9kZSA8IDE2XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWVcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmVtaXQoZXYsIC4uLmFyZ3MpXG4gIH1cblxuICBvbiAoZXYsIC4uLmFyZ3MpIHtcbiAgICBpZiAoZXYgPT09ICdkYXRhJyB8fCBldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgICAgdGhpc1trUmVhZGluZ10gPSB0cnVlXG4gICAgfVxuICAgIHJldHVybiBzdXBlci5vbihldiwgLi4uYXJncylcbiAgfVxuXG4gIGFkZExpc3RlbmVyIChldiwgLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLm9uKGV2LCAuLi5hcmdzKVxuICB9XG5cbiAgb2ZmIChldiwgLi4uYXJncykge1xuICAgIGNvbnN0IHJldCA9IHN1cGVyLm9mZihldiwgLi4uYXJncylcbiAgICBpZiAoZXYgPT09ICdkYXRhJyB8fCBldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgICAgdGhpc1trUmVhZGluZ10gPSAoXG4gICAgICAgIHRoaXMubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMCB8fFxuICAgICAgICB0aGlzLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIHJlbW92ZUxpc3RlbmVyIChldiwgLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLm9mZihldiwgLi4uYXJncylcbiAgfVxuXG4gIHB1c2ggKGNodW5rKSB7XG4gICAgaWYgKHRoaXNba0NvbnN1bWVdICYmIGNodW5rICE9PSBudWxsICYmIHRoaXMucmVhZGFibGVMZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN1bWVQdXNoKHRoaXNba0NvbnN1bWVdLCBjaHVuaylcbiAgICAgIHJldHVybiB0aGlzW2tSZWFkaW5nXSA/IHN1cGVyLnB1c2goY2h1bmspIDogdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucHVzaChjaHVuaylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS10ZXh0XG4gIGFzeW5jIHRleHQgKCkge1xuICAgIHJldHVybiBjb25zdW1lKHRoaXMsICd0ZXh0JylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS1qc29uXG4gIGFzeW5jIGpzb24gKCkge1xuICAgIHJldHVybiBjb25zdW1lKHRoaXMsICdqc29uJylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS1ibG9iXG4gIGFzeW5jIGJsb2IgKCkge1xuICAgIHJldHVybiBjb25zdW1lKHRoaXMsICdibG9iJylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS1hcnJheWJ1ZmZlclxuICBhc3luYyBhcnJheUJ1ZmZlciAoKSB7XG4gICAgcmV0dXJuIGNvbnN1bWUodGhpcywgJ2FycmF5QnVmZmVyJylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS1mb3JtZGF0YVxuICBhc3luYyBmb3JtRGF0YSAoKSB7XG4gICAgLy8gVE9ETzogSW1wbGVtZW50LlxuICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFcnJvcigpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWJvZHktYm9keXVzZWRcbiAgZ2V0IGJvZHlVc2VkICgpIHtcbiAgICByZXR1cm4gdXRpbC5pc0Rpc3R1cmJlZCh0aGlzKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ib2R5LWJvZHlcbiAgZ2V0IGJvZHkgKCkge1xuICAgIGlmICghdGhpc1trQm9keV0pIHtcbiAgICAgIHRoaXNba0JvZHldID0gUmVhZGFibGVTdHJlYW1Gcm9tKHRoaXMpXG4gICAgICBpZiAodGhpc1trQ29uc3VtZV0pIHtcbiAgICAgICAgLy8gVE9ETzogSXMgdGhpcyB0aGUgYmVzdCB3YXkgdG8gZm9yY2UgYSBsb2NrP1xuICAgICAgICB0aGlzW2tCb2R5XS5nZXRSZWFkZXIoKSAvLyBFbnN1cmUgc3RyZWFtIGlzIGxvY2tlZC5cbiAgICAgICAgYXNzZXJ0KHRoaXNba0JvZHldLmxvY2tlZClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXNba0JvZHldXG4gIH1cblxuICBkdW1wIChvcHRzKSB7XG4gICAgbGV0IGxpbWl0ID0gb3B0cyAmJiBOdW1iZXIuaXNGaW5pdGUob3B0cy5saW1pdCkgPyBvcHRzLmxpbWl0IDogMjYyMTQ0XG4gICAgY29uc3Qgc2lnbmFsID0gb3B0cyAmJiBvcHRzLnNpZ25hbFxuXG4gICAgaWYgKHNpZ25hbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzaWduYWwgIT09ICdvYmplY3QnIHx8ICEoJ2Fib3J0ZWQnIGluIHNpZ25hbCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3NpZ25hbCBtdXN0IGJlIGFuIEFib3J0U2lnbmFsJylcbiAgICAgICAgfVxuICAgICAgICB1dGlsLnRocm93SWZBYm9ydGVkKHNpZ25hbClcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBzaWduYWxMaXN0ZW5lckNsZWFudXAgPSBzaWduYWxcbiAgICAgICAgPyB1dGlsLmFkZEFib3J0TGlzdGVuZXIoc2lnbmFsLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5kZXN0cm95KClcbiAgICAgICAgfSlcbiAgICAgICAgOiBub29wXG5cbiAgICAgIHRoaXNcbiAgICAgICAgLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzaWduYWxMaXN0ZW5lckNsZWFudXAoKVxuICAgICAgICAgIGlmIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHJlamVjdChzaWduYWwucmVhc29uIHx8IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCdUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkJyksIHsgbmFtZTogJ0Fib3J0RXJyb3InIH0pKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKG51bGwpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAub24oJ2Vycm9yJywgbm9vcClcbiAgICAgICAgLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgbGltaXQgLT0gY2h1bmsubGVuZ3RoXG4gICAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAucmVzdW1lKClcbiAgICB9KVxuICB9XG59XG5cbi8vIGh0dHBzOi8vc3RyZWFtcy5zcGVjLndoYXR3Zy5vcmcvI3JlYWRhYmxlc3RyZWFtLWxvY2tlZFxuZnVuY3Rpb24gaXNMb2NrZWQgKHNlbGYpIHtcbiAgLy8gQ29uc3VtZSBpcyBhbiBpbXBsaWNpdCBsb2NrLlxuICByZXR1cm4gKHNlbGZba0JvZHldICYmIHNlbGZba0JvZHldLmxvY2tlZCA9PT0gdHJ1ZSkgfHwgc2VsZltrQ29uc3VtZV1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2JvZHktdW51c2FibGVcbmZ1bmN0aW9uIGlzVW51c2FibGUgKHNlbGYpIHtcbiAgcmV0dXJuIHV0aWwuaXNEaXN0dXJiZWQoc2VsZikgfHwgaXNMb2NrZWQoc2VsZilcbn1cblxuYXN5bmMgZnVuY3Rpb24gY29uc3VtZSAoc3RyZWFtLCB0eXBlKSB7XG4gIGlmIChpc1VudXNhYmxlKHN0cmVhbSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bnVzYWJsZScpXG4gIH1cblxuICBhc3NlcnQoIXN0cmVhbVtrQ29uc3VtZV0pXG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBzdHJlYW1ba0NvbnN1bWVdID0ge1xuICAgICAgdHlwZSxcbiAgICAgIHN0cmVhbSxcbiAgICAgIHJlc29sdmUsXG4gICAgICByZWplY3QsXG4gICAgICBsZW5ndGg6IDAsXG4gICAgICBib2R5OiBbXVxuICAgIH1cblxuICAgIHN0cmVhbVxuICAgICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgY29uc3VtZUZpbmlzaCh0aGlzW2tDb25zdW1lXSwgZXJyKVxuICAgICAgfSlcbiAgICAgIC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzW2tDb25zdW1lXS5ib2R5ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3VtZUZpbmlzaCh0aGlzW2tDb25zdW1lXSwgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgIHByb2Nlc3MubmV4dFRpY2soY29uc3VtZVN0YXJ0LCBzdHJlYW1ba0NvbnN1bWVdKVxuICB9KVxufVxuXG5mdW5jdGlvbiBjb25zdW1lU3RhcnQgKGNvbnN1bWUpIHtcbiAgaWYgKGNvbnN1bWUuYm9keSA9PT0gbnVsbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgeyBfcmVhZGFibGVTdGF0ZTogc3RhdGUgfSA9IGNvbnN1bWUuc3RyZWFtXG5cbiAgZm9yIChjb25zdCBjaHVuayBvZiBzdGF0ZS5idWZmZXIpIHtcbiAgICBjb25zdW1lUHVzaChjb25zdW1lLCBjaHVuaylcbiAgfVxuXG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgY29uc3VtZUVuZCh0aGlzW2tDb25zdW1lXSlcbiAgfSBlbHNlIHtcbiAgICBjb25zdW1lLnN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3VtZUVuZCh0aGlzW2tDb25zdW1lXSlcbiAgICB9KVxuICB9XG5cbiAgY29uc3VtZS5zdHJlYW0ucmVzdW1lKClcblxuICB3aGlsZSAoY29uc3VtZS5zdHJlYW0ucmVhZCgpICE9IG51bGwpIHtcbiAgICAvLyBMb29wXG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3VtZUVuZCAoY29uc3VtZSkge1xuICBjb25zdCB7IHR5cGUsIGJvZHksIHJlc29sdmUsIHN0cmVhbSwgbGVuZ3RoIH0gPSBjb25zdW1lXG5cbiAgdHJ5IHtcbiAgICBpZiAodHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICByZXNvbHZlKHRvVVNWU3RyaW5nKEJ1ZmZlci5jb25jYXQoYm9keSkpKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2pzb24nKSB7XG4gICAgICByZXNvbHZlKEpTT04ucGFyc2UoQnVmZmVyLmNvbmNhdChib2R5KSkpXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnYXJyYXlCdWZmZXInKSB7XG4gICAgICBjb25zdCBkc3QgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG5cbiAgICAgIGxldCBwb3MgPSAwXG4gICAgICBmb3IgKGNvbnN0IGJ1ZiBvZiBib2R5KSB7XG4gICAgICAgIGRzdC5zZXQoYnVmLCBwb3MpXG4gICAgICAgIHBvcyArPSBidWYuYnl0ZUxlbmd0aFxuICAgICAgfVxuXG4gICAgICByZXNvbHZlKGRzdC5idWZmZXIpXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnYmxvYicpIHtcbiAgICAgIGlmICghQmxvYikge1xuICAgICAgICBCbG9iID0gcmVxdWlyZSgnYnVmZmVyJykuQmxvYlxuICAgICAgfVxuICAgICAgcmVzb2x2ZShuZXcgQmxvYihib2R5LCB7IHR5cGU6IHN0cmVhbVtrQ29udGVudFR5cGVdIH0pKVxuICAgIH1cblxuICAgIGNvbnN1bWVGaW5pc2goY29uc3VtZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgc3RyZWFtLmRlc3Ryb3koZXJyKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVQdXNoIChjb25zdW1lLCBjaHVuaykge1xuICBjb25zdW1lLmxlbmd0aCArPSBjaHVuay5sZW5ndGhcbiAgY29uc3VtZS5ib2R5LnB1c2goY2h1bmspXG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVGaW5pc2ggKGNvbnN1bWUsIGVycikge1xuICBpZiAoY29uc3VtZS5ib2R5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoZXJyKSB7XG4gICAgY29uc3VtZS5yZWplY3QoZXJyKVxuICB9IGVsc2Uge1xuICAgIGNvbnN1bWUucmVzb2x2ZSgpXG4gIH1cblxuICBjb25zdW1lLnR5cGUgPSBudWxsXG4gIGNvbnN1bWUuc3RyZWFtID0gbnVsbFxuICBjb25zdW1lLnJlc29sdmUgPSBudWxsXG4gIGNvbnN1bWUucmVqZWN0ID0gbnVsbFxuICBjb25zdW1lLmxlbmd0aCA9IDBcbiAgY29uc3VtZS5ib2R5ID0gbnVsbFxufVxuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJSZWFkYWJsZSIsIlJlcXVlc3RBYm9ydGVkRXJyb3IiLCJOb3RTdXBwb3J0ZWRFcnJvciIsIkludmFsaWRBcmd1bWVudEVycm9yIiwidXRpbCIsIlJlYWRhYmxlU3RyZWFtRnJvbSIsInRvVVNWU3RyaW5nIiwiQmxvYiIsImtDb25zdW1lIiwiU3ltYm9sIiwia1JlYWRpbmciLCJrQm9keSIsImtBYm9ydCIsImtDb250ZW50VHlwZSIsIm5vb3AiLCJtb2R1bGUiLCJleHBvcnRzIiwiQm9keVJlYWRhYmxlIiwiY29uc3RydWN0b3IiLCJyZXN1bWUiLCJhYm9ydCIsImNvbnRlbnRUeXBlIiwiaGlnaFdhdGVyTWFyayIsImF1dG9EZXN0cm95IiwicmVhZCIsIl9yZWFkYWJsZVN0YXRlIiwiZGF0YUVtaXR0ZWQiLCJkZXN0cm95IiwiZXJyIiwiZGVzdHJveWVkIiwiZW5kRW1pdHRlZCIsImVtaXQiLCJldiIsImFyZ3MiLCJlcnJvckVtaXR0ZWQiLCJvbiIsImFkZExpc3RlbmVyIiwib2ZmIiwicmV0IiwibGlzdGVuZXJDb3VudCIsInJlbW92ZUxpc3RlbmVyIiwicHVzaCIsImNodW5rIiwicmVhZGFibGVMZW5ndGgiLCJjb25zdW1lUHVzaCIsInRleHQiLCJjb25zdW1lIiwianNvbiIsImJsb2IiLCJhcnJheUJ1ZmZlciIsImZvcm1EYXRhIiwiYm9keVVzZWQiLCJpc0Rpc3R1cmJlZCIsImJvZHkiLCJnZXRSZWFkZXIiLCJsb2NrZWQiLCJkdW1wIiwib3B0cyIsImxpbWl0IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJzaWduYWwiLCJ0aHJvd0lmQWJvcnRlZCIsIlByb21pc2UiLCJyZWplY3QiLCJjbG9zZWQiLCJyZXNvbHZlIiwic2lnbmFsTGlzdGVuZXJDbGVhbnVwIiwiYWRkQWJvcnRMaXN0ZW5lciIsImFib3J0ZWQiLCJyZWFzb24iLCJPYmplY3QiLCJhc3NpZ24iLCJFcnJvciIsIm5hbWUiLCJsZW5ndGgiLCJpc0xvY2tlZCIsInNlbGYiLCJpc1VudXNhYmxlIiwic3RyZWFtIiwidHlwZSIsIlR5cGVFcnJvciIsImNvbnN1bWVGaW5pc2giLCJwcm9jZXNzIiwibmV4dFRpY2siLCJjb25zdW1lU3RhcnQiLCJzdGF0ZSIsImJ1ZmZlciIsImNvbnN1bWVFbmQiLCJCdWZmZXIiLCJjb25jYXQiLCJKU09OIiwicGFyc2UiLCJkc3QiLCJVaW50OEFycmF5IiwicG9zIiwiYnVmIiwic2V0IiwiYnl0ZUxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/api/readable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/api/util.js":
/*!*******************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/api/util.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { ResponseStatusCodeError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\nconst { toUSVString } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nasync function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {\n    assert(body);\n    let chunks = [];\n    let limit = 0;\n    for await (const chunk of body){\n        chunks.push(chunk);\n        limit += chunk.length;\n        if (limit > 128 * 1024) {\n            chunks = null;\n            break;\n        }\n    }\n    if (statusCode === 204 || !contentType || !chunks) {\n        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : \"\"}`, statusCode, headers));\n        return;\n    }\n    try {\n        if (contentType.startsWith(\"application/json\")) {\n            const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));\n            process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : \"\"}`, statusCode, headers, payload));\n            return;\n        }\n        if (contentType.startsWith(\"text/\")) {\n            const payload = toUSVString(Buffer.concat(chunks));\n            process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : \"\"}`, statusCode, headers, payload));\n            return;\n        }\n    } catch (err) {\n    // Process in a fallback if error\n    }\n    process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : \"\"}`, statusCode, headers));\n}\nmodule.exports = {\n    getResolveErrorBodyCallback\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL3V0aWwuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFDSkMsdUJBQXVCLEVBQ3hCLEdBQUdELG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFRSxXQUFXLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFFaEMsZUFBZUcsNEJBQTZCLEVBQUVDLFFBQVEsRUFBRUMsSUFBSSxFQUFFQyxXQUFXLEVBQUVDLFVBQVUsRUFBRUMsYUFBYSxFQUFFQyxPQUFPLEVBQUU7SUFDN0dWLE9BQU9NO0lBRVAsSUFBSUssU0FBUyxFQUFFO0lBQ2YsSUFBSUMsUUFBUTtJQUVaLFdBQVcsTUFBTUMsU0FBU1AsS0FBTTtRQUM5QkssT0FBT0csSUFBSSxDQUFDRDtRQUNaRCxTQUFTQyxNQUFNRSxNQUFNO1FBQ3JCLElBQUlILFFBQVEsTUFBTSxNQUFNO1lBQ3RCRCxTQUFTO1lBQ1Q7UUFDRjtJQUNGO0lBRUEsSUFBSUgsZUFBZSxPQUFPLENBQUNELGVBQWUsQ0FBQ0ksUUFBUTtRQUNqREssUUFBUUMsUUFBUSxDQUFDWixVQUFVLElBQUlILHdCQUF3QixDQUFDLHFCQUFxQixFQUFFTSxXQUFXLEVBQUVDLGdCQUFnQixDQUFDLEVBQUUsRUFBRUEsY0FBYyxDQUFDLEdBQUcsR0FBRyxDQUFDLEVBQUVELFlBQVlFO1FBQ3JKO0lBQ0Y7SUFFQSxJQUFJO1FBQ0YsSUFBSUgsWUFBWVcsVUFBVSxDQUFDLHFCQUFxQjtZQUM5QyxNQUFNQyxVQUFVQyxLQUFLQyxLQUFLLENBQUNsQixZQUFZbUIsT0FBT0MsTUFBTSxDQUFDWjtZQUNyREssUUFBUUMsUUFBUSxDQUFDWixVQUFVLElBQUlILHdCQUF3QixDQUFDLHFCQUFxQixFQUFFTSxXQUFXLEVBQUVDLGdCQUFnQixDQUFDLEVBQUUsRUFBRUEsY0FBYyxDQUFDLEdBQUcsR0FBRyxDQUFDLEVBQUVELFlBQVlFLFNBQVNTO1lBQzlKO1FBQ0Y7UUFFQSxJQUFJWixZQUFZVyxVQUFVLENBQUMsVUFBVTtZQUNuQyxNQUFNQyxVQUFVaEIsWUFBWW1CLE9BQU9DLE1BQU0sQ0FBQ1o7WUFDMUNLLFFBQVFDLFFBQVEsQ0FBQ1osVUFBVSxJQUFJSCx3QkFBd0IsQ0FBQyxxQkFBcUIsRUFBRU0sV0FBVyxFQUFFQyxnQkFBZ0IsQ0FBQyxFQUFFLEVBQUVBLGNBQWMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxFQUFFRCxZQUFZRSxTQUFTUztZQUM5SjtRQUNGO0lBQ0YsRUFBRSxPQUFPSyxLQUFLO0lBQ1osaUNBQWlDO0lBQ25DO0lBRUFSLFFBQVFDLFFBQVEsQ0FBQ1osVUFBVSxJQUFJSCx3QkFBd0IsQ0FBQyxxQkFBcUIsRUFBRU0sV0FBVyxFQUFFQyxnQkFBZ0IsQ0FBQyxFQUFFLEVBQUVBLGNBQWMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxFQUFFRCxZQUFZRTtBQUN2SjtBQUVBZSxPQUFPQyxPQUFPLEdBQUc7SUFBRXRCO0FBQTRCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1maWdodGVyLWFjYWRlbXkvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL3V0aWwuanM/NTI3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3Qge1xuICBSZXNwb25zZVN0YXR1c0NvZGVFcnJvclxufSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHsgdG9VU1ZTdHJpbmcgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5cbmFzeW5jIGZ1bmN0aW9uIGdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjayAoeyBjYWxsYmFjaywgYm9keSwgY29udGVudFR5cGUsIHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMgfSkge1xuICBhc3NlcnQoYm9keSlcblxuICBsZXQgY2h1bmtzID0gW11cbiAgbGV0IGxpbWl0ID0gMFxuXG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgYm9keSkge1xuICAgIGNodW5rcy5wdXNoKGNodW5rKVxuICAgIGxpbWl0ICs9IGNodW5rLmxlbmd0aFxuICAgIGlmIChsaW1pdCA+IDEyOCAqIDEwMjQpIHtcbiAgICAgIGNodW5rcyA9IG51bGxcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXR1c0NvZGUgPT09IDIwNCB8fCAhY29udGVudFR5cGUgfHwgIWNodW5rcykge1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIG5ldyBSZXNwb25zZVN0YXR1c0NvZGVFcnJvcihgUmVzcG9uc2Ugc3RhdHVzIGNvZGUgJHtzdGF0dXNDb2RlfSR7c3RhdHVzTWVzc2FnZSA/IGA6ICR7c3RhdHVzTWVzc2FnZX1gIDogJyd9YCwgc3RhdHVzQ29kZSwgaGVhZGVycykpXG4gICAgcmV0dXJuXG4gIH1cblxuICB0cnkge1xuICAgIGlmIChjb250ZW50VHlwZS5zdGFydHNXaXRoKCdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKHRvVVNWU3RyaW5nKEJ1ZmZlci5jb25jYXQoY2h1bmtzKSkpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBuZXcgUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IoYFJlc3BvbnNlIHN0YXR1cyBjb2RlICR7c3RhdHVzQ29kZX0ke3N0YXR1c01lc3NhZ2UgPyBgOiAke3N0YXR1c01lc3NhZ2V9YCA6ICcnfWAsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIHBheWxvYWQpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoJ3RleHQvJykpIHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB0b1VTVlN0cmluZyhCdWZmZXIuY29uY2F0KGNodW5rcykpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBuZXcgUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IoYFJlc3BvbnNlIHN0YXR1cyBjb2RlICR7c3RhdHVzQ29kZX0ke3N0YXR1c01lc3NhZ2UgPyBgOiAke3N0YXR1c01lc3NhZ2V9YCA6ICcnfWAsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIHBheWxvYWQpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBQcm9jZXNzIGluIGEgZmFsbGJhY2sgaWYgZXJyb3JcbiAgfVxuXG4gIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIG5ldyBSZXNwb25zZVN0YXR1c0NvZGVFcnJvcihgUmVzcG9uc2Ugc3RhdHVzIGNvZGUgJHtzdGF0dXNDb2RlfSR7c3RhdHVzTWVzc2FnZSA/IGA6ICR7c3RhdHVzTWVzc2FnZX1gIDogJyd9YCwgc3RhdHVzQ29kZSwgaGVhZGVycykpXG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2sgfVxuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJSZXNwb25zZVN0YXR1c0NvZGVFcnJvciIsInRvVVNWU3RyaW5nIiwiZ2V0UmVzb2x2ZUVycm9yQm9keUNhbGxiYWNrIiwiY2FsbGJhY2siLCJib2R5IiwiY29udGVudFR5cGUiLCJzdGF0dXNDb2RlIiwic3RhdHVzTWVzc2FnZSIsImhlYWRlcnMiLCJjaHVua3MiLCJsaW1pdCIsImNodW5rIiwicHVzaCIsImxlbmd0aCIsInByb2Nlc3MiLCJuZXh0VGljayIsInN0YXJ0c1dpdGgiLCJwYXlsb2FkIiwiSlNPTiIsInBhcnNlIiwiQnVmZmVyIiwiY29uY2F0IiwiZXJyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/api/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/balanced-pool.js":
/*!************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/balanced-pool.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { BalancedPoolMissingUpstreamError, InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\nconst { PoolBase, kClients, kNeedDrain, kAddClient, kRemoveClient, kGetDispatcher } = __webpack_require__(/*! ./pool-base */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/pool-base.js\");\nconst Pool = __webpack_require__(/*! ./pool */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/pool.js\");\nconst { kUrl, kInterceptors } = __webpack_require__(/*! ./core/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\");\nconst { parseOrigin } = __webpack_require__(/*! ./core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst kFactory = Symbol(\"factory\");\nconst kOptions = Symbol(\"options\");\nconst kGreatestCommonDivisor = Symbol(\"kGreatestCommonDivisor\");\nconst kCurrentWeight = Symbol(\"kCurrentWeight\");\nconst kIndex = Symbol(\"kIndex\");\nconst kWeight = Symbol(\"kWeight\");\nconst kMaxWeightPerServer = Symbol(\"kMaxWeightPerServer\");\nconst kErrorPenalty = Symbol(\"kErrorPenalty\");\nfunction getGreatestCommonDivisor(a, b) {\n    if (b === 0) return a;\n    return getGreatestCommonDivisor(b, a % b);\n}\nfunction defaultFactory(origin, opts) {\n    return new Pool(origin, opts);\n}\nclass BalancedPool extends PoolBase {\n    constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}){\n        super();\n        this[kOptions] = opts;\n        this[kIndex] = -1;\n        this[kCurrentWeight] = 0;\n        this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;\n        this[kErrorPenalty] = this[kOptions].errorPenalty || 15;\n        if (!Array.isArray(upstreams)) {\n            upstreams = [\n                upstreams\n            ];\n        }\n        if (typeof factory !== \"function\") {\n            throw new InvalidArgumentError(\"factory must be a function.\");\n        }\n        this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];\n        this[kFactory] = factory;\n        for (const upstream of upstreams){\n            this.addUpstream(upstream);\n        }\n        this._updateBalancedPoolStats();\n    }\n    addUpstream(upstream) {\n        const upstreamOrigin = parseOrigin(upstream).origin;\n        if (this[kClients].find((pool)=>pool[kUrl].origin === upstreamOrigin && pool.closed !== true && pool.destroyed !== true)) {\n            return this;\n        }\n        const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));\n        this[kAddClient](pool);\n        pool.on(\"connect\", ()=>{\n            pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);\n        });\n        pool.on(\"connectionError\", ()=>{\n            pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);\n            this._updateBalancedPoolStats();\n        });\n        pool.on(\"disconnect\", (...args)=>{\n            const err = args[2];\n            if (err && err.code === \"UND_ERR_SOCKET\") {\n                // decrease the weight of the pool.\n                pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);\n                this._updateBalancedPoolStats();\n            }\n        });\n        for (const client of this[kClients]){\n            client[kWeight] = this[kMaxWeightPerServer];\n        }\n        this._updateBalancedPoolStats();\n        return this;\n    }\n    _updateBalancedPoolStats() {\n        this[kGreatestCommonDivisor] = this[kClients].map((p)=>p[kWeight]).reduce(getGreatestCommonDivisor, 0);\n    }\n    removeUpstream(upstream) {\n        const upstreamOrigin = parseOrigin(upstream).origin;\n        const pool = this[kClients].find((pool)=>pool[kUrl].origin === upstreamOrigin && pool.closed !== true && pool.destroyed !== true);\n        if (pool) {\n            this[kRemoveClient](pool);\n        }\n        return this;\n    }\n    get upstreams() {\n        return this[kClients].filter((dispatcher)=>dispatcher.closed !== true && dispatcher.destroyed !== true).map((p)=>p[kUrl].origin);\n    }\n    [kGetDispatcher]() {\n        // We validate that pools is greater than 0,\n        // otherwise we would have to wait until an upstream\n        // is added, which might never happen.\n        if (this[kClients].length === 0) {\n            throw new BalancedPoolMissingUpstreamError();\n        }\n        const dispatcher = this[kClients].find((dispatcher)=>!dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);\n        if (!dispatcher) {\n            return;\n        }\n        const allClientsBusy = this[kClients].map((pool)=>pool[kNeedDrain]).reduce((a, b)=>a && b, true);\n        if (allClientsBusy) {\n            return;\n        }\n        let counter = 0;\n        let maxWeightIndex = this[kClients].findIndex((pool)=>!pool[kNeedDrain]);\n        while(counter++ < this[kClients].length){\n            this[kIndex] = (this[kIndex] + 1) % this[kClients].length;\n            const pool = this[kClients][this[kIndex]];\n            // find pool index with the largest weight\n            if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {\n                maxWeightIndex = this[kIndex];\n            }\n            // decrease the current weight every `this[kClients].length`.\n            if (this[kIndex] === 0) {\n                // Set the current weight to the next lower weight.\n                this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];\n                if (this[kCurrentWeight] <= 0) {\n                    this[kCurrentWeight] = this[kMaxWeightPerServer];\n                }\n            }\n            if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {\n                return pool;\n            }\n        }\n        this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];\n        this[kIndex] = maxWeightIndex;\n        return this[kClients][maxWeightIndex];\n    }\n}\nmodule.exports = BalancedPool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYmFsYW5jZWQtcG9vbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFDSkEsZ0NBQWdDLEVBQ2hDQyxvQkFBb0IsRUFDckIsR0FBR0MsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQ0pDLFFBQVEsRUFDUkMsUUFBUSxFQUNSQyxVQUFVLEVBQ1ZDLFVBQVUsRUFDVkMsYUFBYSxFQUNiQyxjQUFjLEVBQ2YsR0FBR04sbUJBQU9BLENBQUM7QUFDWixNQUFNTyxPQUFPUCxtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQUVRLElBQUksRUFBRUMsYUFBYSxFQUFFLEdBQUdULG1CQUFPQSxDQUFDO0FBQ3hDLE1BQU0sRUFBRVUsV0FBVyxFQUFFLEdBQUdWLG1CQUFPQSxDQUFDO0FBQ2hDLE1BQU1XLFdBQVdDLE9BQU87QUFFeEIsTUFBTUMsV0FBV0QsT0FBTztBQUN4QixNQUFNRSx5QkFBeUJGLE9BQU87QUFDdEMsTUFBTUcsaUJBQWlCSCxPQUFPO0FBQzlCLE1BQU1JLFNBQVNKLE9BQU87QUFDdEIsTUFBTUssVUFBVUwsT0FBTztBQUN2QixNQUFNTSxzQkFBc0JOLE9BQU87QUFDbkMsTUFBTU8sZ0JBQWdCUCxPQUFPO0FBRTdCLFNBQVNRLHlCQUEwQkMsQ0FBQyxFQUFFQyxDQUFDO0lBQ3JDLElBQUlBLE1BQU0sR0FBRyxPQUFPRDtJQUNwQixPQUFPRCx5QkFBeUJFLEdBQUdELElBQUlDO0FBQ3pDO0FBRUEsU0FBU0MsZUFBZ0JDLE1BQU0sRUFBRUMsSUFBSTtJQUNuQyxPQUFPLElBQUlsQixLQUFLaUIsUUFBUUM7QUFDMUI7QUFFQSxNQUFNQyxxQkFBcUJ6QjtJQUN6QjBCLFlBQWFDLFlBQVksRUFBRSxFQUFFLEVBQUVDLFVBQVVOLGNBQWMsRUFBRSxHQUFHRSxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDdkUsS0FBSztRQUVMLElBQUksQ0FBQ1osU0FBUyxH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Q0FBQzVELFNBQVMsQ0FBQzRELGVBQWU7SUFDdkM7QUFDRjtBQUVBRSxPQUFPQyxPQUFPLEdBQUd2QyIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2JhbGFuY2VkLXBvb2wuanM/YjdjNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBCYWxhbmNlZFBvb2xNaXNzaW5nVXBzdHJlYW1FcnJvcixcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3Jcbn0gPSByZXF1aXJlKCcuL2NvcmUvZXJyb3JzJylcbmNvbnN0IHtcbiAgUG9vbEJhc2UsXG4gIGtDbGllbnRzLFxuICBrTmVlZERyYWluLFxuICBrQWRkQ2xpZW50LFxuICBrUmVtb3ZlQ2xpZW50LFxuICBrR2V0RGlzcGF0Y2hlclxufSA9IHJlcXVpcmUoJy4vcG9vbC1iYXNlJylcbmNvbnN0IFBvb2wgPSByZXF1aXJlKCcuL3Bvb2wnKVxuY29uc3QgeyBrVXJsLCBrSW50ZXJjZXB0b3JzIH0gPSByZXF1aXJlKCcuL2NvcmUvc3ltYm9scycpXG5jb25zdCB7IHBhcnNlT3JpZ2luIH0gPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpXG5jb25zdCBrRmFjdG9yeSA9IFN5bWJvbCgnZmFjdG9yeScpXG5cbmNvbnN0IGtPcHRpb25zID0gU3ltYm9sKCdvcHRpb25zJylcbmNvbnN0IGtHcmVhdGVzdENvbW1vbkRpdmlzb3IgPSBTeW1ib2woJ2tHcmVhdGVzdENvbW1vbkRpdmlzb3InKVxuY29uc3Qga0N1cnJlbnRXZWlnaHQgPSBTeW1ib2woJ2tDdXJyZW50V2VpZ2h0JylcbmNvbnN0IGtJbmRleCA9IFN5bWJvbCgna0luZGV4JylcbmNvbnN0IGtXZWlnaHQgPSBTeW1ib2woJ2tXZWlnaHQnKVxuY29uc3Qga01heFdlaWdodFBlclNlcnZlciA9IFN5bWJvbCgna01heFdlaWdodFBlclNlcnZlcicpXG5jb25zdCBrRXJyb3JQZW5hbHR5ID0gU3ltYm9sKCdrRXJyb3JQZW5hbHR5JylcblxuZnVuY3Rpb24gZ2V0R3JlYXRlc3RDb21tb25EaXZpc29yIChhLCBiKSB7XG4gIGlmIChiID09PSAwKSByZXR1cm4gYVxuICByZXR1cm4gZ2V0R3JlYXRlc3RDb21tb25EaXZpc29yKGIsIGEgJSBiKVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0RmFjdG9yeSAob3JpZ2luLCBvcHRzKSB7XG4gIHJldHVybiBuZXcgUG9vbChvcmlnaW4sIG9wdHMpXG59XG5cbmNsYXNzIEJhbGFuY2VkUG9vbCBleHRlbmRzIFBvb2xCYXNlIHtcbiAgY29uc3RydWN0b3IgKHVwc3RyZWFtcyA9IFtdLCB7IGZhY3RvcnkgPSBkZWZhdWx0RmFjdG9yeSwgLi4ub3B0cyB9ID0ge30pIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzW2tPcHRpb25zXSA9IG9wdHNcbiAgICB0aGlzW2tJbmRleF0gPSAtMVxuICAgIHRoaXNba0N1cnJlbnRXZWlnaHRdID0gMFxuXG4gICAgdGhpc1trTWF4V2VpZ2h0UGVyU2VydmVyXSA9IHRoaXNba09wdGlvbnNdLm1heFdlaWdodFBlclNlcnZlciB8fCAxMDBcbiAgICB0aGlzW2tFcnJvclBlbmFsdHldID0gdGhpc1trT3B0aW9uc10uZXJyb3JQZW5hbHR5IHx8IDE1XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodXBzdHJlYW1zKSkge1xuICAgICAgdXBzdHJlYW1zID0gW3Vwc3RyZWFtc11cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZhY3RvcnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignZmFjdG9yeSBtdXN0IGJlIGEgZnVuY3Rpb24uJylcbiAgICB9XG5cbiAgICB0aGlzW2tJbnRlcmNlcHRvcnNdID0gb3B0cy5pbnRlcmNlcHRvcnMgJiYgb3B0cy5pbnRlcmNlcHRvcnMuQmFsYW5jZWRQb29sICYmIEFycmF5LmlzQXJyYXkob3B0cy5pbnRlcmNlcHRvcnMuQmFsYW5jZWRQb29sKVxuICAgICAgPyBvcHRzLmludGVyY2VwdG9ycy5CYWxhbmNlZFBvb2xcbiAgICAgIDogW11cbiAgICB0aGlzW2tGYWN0b3J5XSA9IGZhY3RvcnlcblxuICAgIGZvciAoY29uc3QgdXBzdHJlYW0gb2YgdXBzdHJlYW1zKSB7XG4gICAgICB0aGlzLmFkZFVwc3RyZWFtKHVwc3RyZWFtKVxuICAgIH1cbiAgICB0aGlzLl91cGRhdGVCYWxhbmNlZFBvb2xTdGF0cygpXG4gIH1cblxuICBhZGRVcHN0cmVhbSAodXBzdHJlYW0pIHtcbiAgICBjb25zdCB1cHN0cmVhbU9yaWdpbiA9IHBhcnNlT3JpZ2luKHVwc3RyZWFtKS5vcmlnaW5cblxuICAgIGlmICh0aGlzW2tDbGllbnRzXS5maW5kKChwb29sKSA9PiAoXG4gICAgICBwb29sW2tVcmxdLm9yaWdpbiA9PT0gdXBzdHJlYW1PcmlnaW4gJiZcbiAgICAgIHBvb2wuY2xvc2VkICE9PSB0cnVlICYmXG4gICAgICBwb29sLmRlc3Ryb3llZCAhPT0gdHJ1ZVxuICAgICkpKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICBjb25zdCBwb29sID0gdGhpc1trRmFjdG9yeV0odXBzdHJlYW1PcmlnaW4sIE9iamVjdC5hc3NpZ24oe30sIHRoaXNba09wdGlvbnNdKSlcblxuICAgIHRoaXNba0FkZENsaWVudF0ocG9vbClcbiAgICBwb29sLm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgcG9vbFtrV2VpZ2h0XSA9IE1hdGgubWluKHRoaXNba01heFdlaWdodFBlclNlcnZlcl0sIHBvb2xba1dlaWdodF0gKyB0aGlzW2tFcnJvclBlbmFsdHldKVxuICAgIH0pXG5cbiAgICBwb29sLm9uKCdjb25uZWN0aW9uRXJyb3InLCAoKSA9PiB7XG4gICAgICBwb29sW2tXZWlnaHRdID0gTWF0aC5tYXgoMSwgcG9vbFtrV2VpZ2h0XSAtIHRoaXNba0Vycm9yUGVuYWx0eV0pXG4gICAgICB0aGlzLl91cGRhdGVCYWxhbmNlZFBvb2xTdGF0cygpXG4gICAgfSlcblxuICAgIHBvb2wub24oJ2Rpc2Nvbm5lY3QnLCAoLi4uYXJncykgPT4ge1xuICAgICAgY29uc3QgZXJyID0gYXJnc1syXVxuICAgICAgaWYgKGVyciAmJiBlcnIuY29kZSA9PT0gJ1VORF9FUlJfU09DS0VUJykge1xuICAgICAgICAvLyBkZWNyZWFzZSB0aGUgd2VpZ2h0IG9mIHRoZSBwb29sLlxuICAgICAgICBwb29sW2tXZWlnaHRdID0gTWF0aC5tYXgoMSwgcG9vbFtrV2VpZ2h0XSAtIHRoaXNba0Vycm9yUGVuYWx0eV0pXG4gICAgICAgIHRoaXMuX3VwZGF0ZUJhbGFuY2VkUG9vbFN0YXRzKClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgZm9yIChjb25zdCBjbGllbnQgb2YgdGhpc1trQ2xpZW50c10pIHtcbiAgICAgIGNsaWVudFtrV2VpZ2h0XSA9IHRoaXNba01heFdlaWdodFBlclNlcnZlcl1cbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVCYWxhbmNlZFBvb2xTdGF0cygpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgX3VwZGF0ZUJhbGFuY2VkUG9vbFN0YXRzICgpIHtcbiAgICB0aGlzW2tHcmVhdGVzdENvbW1vbkRpdmlzb3JdID0gdGhpc1trQ2xpZW50c10ubWFwKHAgPT4gcFtrV2VpZ2h0XSkucmVkdWNlKGdldEdyZWF0ZXN0Q29tbW9uRGl2aXNvciwgMClcbiAgfVxuXG4gIHJlbW92ZVVwc3RyZWFtICh1cHN0cmVhbSkge1xuICAgIGNvbnN0IHVwc3RyZWFtT3JpZ2luID0gcGFyc2VPcmlnaW4odXBzdHJlYW0pLm9yaWdpblxuXG4gICAgY29uc3QgcG9vbCA9IHRoaXNba0NsaWVudHNdLmZpbmQoKHBvb2wpID0+IChcbiAgICAgIHBvb2xba1VybF0ub3JpZ2luID09PSB1cHN0cmVhbU9yaWdpbiAmJlxuICAgICAgcG9vbC5jbG9zZWQgIT09IHRydWUgJiZcbiAgICAgIHBvb2wuZGVzdHJveWVkICE9PSB0cnVlXG4gICAgKSlcblxuICAgIGlmIChwb29sKSB7XG4gICAgICB0aGlzW2tSZW1vdmVDbGllbnRdKHBvb2wpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCB1cHN0cmVhbXMgKCkge1xuICAgIHJldHVybiB0aGlzW2tDbGllbnRzXVxuICAgICAgLmZpbHRlcihkaXNwYXRjaGVyID0+IGRpc3BhdGNoZXIuY2xvc2VkICE9PSB0cnVlICYmIGRpc3BhdGNoZXIuZGVzdHJveWVkICE9PSB0cnVlKVxuICAgICAgLm1hcCgocCkgPT4gcFtrVXJsXS5vcmlnaW4pXG4gIH1cblxuICBba0dldERpc3BhdGNoZXJdICgpIHtcbiAgICAvLyBXZSB2YWxpZGF0ZSB0aGF0IHBvb2xzIGlzIGdyZWF0ZXIgdGhhbiAwLFxuICAgIC8vIG90aGVyd2lzZSB3ZSB3b3VsZCBoYXZlIHRvIHdhaXQgdW50aWwgYW4gdXBzdHJlYW1cbiAgICAvLyBpcyBhZGRlZCwgd2hpY2ggbWlnaHQgbmV2ZXIgaGFwcGVuLlxuICAgIGlmICh0aGlzW2tDbGllbnRzXS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBCYWxhbmNlZFBvb2xNaXNzaW5nVXBzdHJlYW1FcnJvcigpXG4gICAgfVxuXG4gICAgY29uc3QgZGlzcGF0Y2hlciA9IHRoaXNba0NsaWVudHNdLmZpbmQoZGlzcGF0Y2hlciA9PiAoXG4gICAgICAhZGlzcGF0Y2hlcltrTmVlZERyYWluXSAmJlxuICAgICAgZGlzcGF0Y2hlci5jbG9zZWQgIT09IHRydWUgJiZcbiAgICAgIGRpc3BhdGNoZXIuZGVzdHJveWVkICE9PSB0cnVlXG4gICAgKSlcblxuICAgIGlmICghZGlzcGF0Y2hlcikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgYWxsQ2xpZW50c0J1c3kgPSB0aGlzW2tDbGllbnRzXS5tYXAocG9vbCA9PiBwb29sW2tOZWVkRHJhaW5dKS5yZWR1Y2UoKGEsIGIpID0+IGEgJiYgYiwgdHJ1ZSlcblxuICAgIGlmIChhbGxDbGllbnRzQnVzeSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGNvdW50ZXIgPSAwXG5cbiAgICBsZXQgbWF4V2VpZ2h0SW5kZXggPSB0aGlzW2tDbGllbnRzXS5maW5kSW5kZXgocG9vbCA9PiAhcG9vbFtrTmVlZERyYWluXSlcblxuICAgIHdoaWxlIChjb3VudGVyKysgPCB0aGlzW2tDbGllbnRzXS5sZW5ndGgpIHtcbiAgICAgIHRoaXNba0luZGV4XSA9ICh0aGlzW2tJbmRleF0gKyAxKSAlIHRoaXNba0NsaWVudHNdLmxlbmd0aFxuICAgICAgY29uc3QgcG9vbCA9IHRoaXNba0NsaWVudHNdW3RoaXNba0luZGV4XV1cblxuICAgICAgLy8gZmluZCBwb29sIGluZGV4IHdpdGggdGhlIGxhcmdlc3Qgd2VpZ2h0XG4gICAgICBpZiAocG9vbFtrV2VpZ2h0XSA+IHRoaXNba0NsaWVudHNdW21heFdlaWdodEluZGV4XVtrV2VpZ2h0XSAmJiAhcG9vbFtrTmVlZERyYWluXSkge1xuICAgICAgICBtYXhXZWlnaHRJbmRleCA9IHRoaXNba0luZGV4XVxuICAgICAgfVxuXG4gICAgICAvLyBkZWNyZWFzZSB0aGUgY3VycmVudCB3ZWlnaHQgZXZlcnkgYHRoaXNba0NsaWVudHNdLmxlbmd0aGAuXG4gICAgICBpZiAodGhpc1trSW5kZXhdID09PSAwKSB7XG4gICAgICAgIC8vIFNldCB0aGUgY3VycmVudCB3ZWlnaHQgdG8gdGhlIG5leHQgbG93ZXIgd2VpZ2h0LlxuICAgICAgICB0aGlzW2tDdXJyZW50V2VpZ2h0XSA9IHRoaXNba0N1cnJlbnRXZWlnaHRdIC0gdGhpc1trR3JlYXRlc3RDb21tb25EaXZpc29yXVxuXG4gICAgICAgIGlmICh0aGlzW2tDdXJyZW50V2VpZ2h0XSA8PSAwKSB7XG4gICAgICAgICAgdGhpc1trQ3VycmVudFdlaWdodF0gPSB0aGlzW2tNYXhXZWlnaHRQZXJTZXJ2ZXJdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwb29sW2tXZWlnaHRdID49IHRoaXNba0N1cnJlbnRXZWlnaHRdICYmICghcG9vbFtrTmVlZERyYWluXSkpIHtcbiAgICAgICAgcmV0dXJuIHBvb2xcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzW2tDdXJyZW50V2VpZ2h0XSA9IHRoaXNba0NsaWVudHNdW21heFdlaWdodEluZGV4XVtrV2VpZ2h0XVxuICAgIHRoaXNba0luZGV4XSA9IG1heFdlaWdodEluZGV4XG4gICAgcmV0dXJuIHRoaXNba0NsaWVudHNdW21heFdlaWdodEluZGV4XVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQmFsYW5jZWRQb29sXG4iXSwibmFtZXMiOlsiQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsInJlcXVpcmUiLCJQb29sQmFzZSIsImtDbGllbnRzIiwia05lZWREcmFpbiIsImtBZGRDbGllbnQiLCJrUmVtb3ZlQ2xpZW50Iiwia0dldERpc3BhdGNoZXIiLCJQb29sIiwia1VybCIsImtJbnRlcmNlcHRvcnMiLCJwYXJzZU9yaWdpbiIsImtGYWN0b3J5IiwiU3ltYm9sIiwia09wdGlvbnMiLCJrR3JlYXRlc3RDb21tb25EaXZpc29yIiwia0N1cnJlbnRXZWlnaHQiLCJrSW5kZXgiLCJrV2VpZ2h0Iiwia01heFdlaWdodFBlclNlcnZlciIsImtFcnJvclBlbmFsdHkiLCJnZXRHcmVhdGVzdENvbW1vbkRpdmlzb3IiLCJhIiwiYiIsImRlZmF1bHRGYWN0b3J5Iiwib3JpZ2luIiwib3B0cyIsIkJhbGFuY2VkUG9vbCIsImNvbnN0cnVjdG9yIiwidXBzdHJlYW1zIiwiZmFjdG9yeSIsIm1heFdlaWdodFBlclNlcnZlciIsImVycm9yUGVuYWx0eSIsIkFycmF5IiwiaXNBcnJheSIsImludGVyY2VwdG9ycyIsInVwc3RyZWFtIiwiYWRkVXBzdHJlYW0iLCJfdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMiLCJ1cHN0cmVhbU9yaWdpbiIsImZpbmQiLCJwb29sIiwiY2xvc2VkIiwiZGVzdHJveWVkIiwiT2JqZWN0IiwiYXNzaWduIiwib24iLCJNYXRoIiwibWluIiwibWF4IiwiYXJncyIsImVyciIsImNvZGUiLCJjbGllbnQiLCJtYXAiLCJwIiwicmVkdWNlIiwicmVtb3ZlVXBzdHJlYW0iLCJmaWx0ZXIiLCJkaXNwYXRjaGVyIiwibGVuZ3RoIiwiYWxsQ2xpZW50c0J1c3kiLCJjb3VudGVyIiwibWF4V2VpZ2h0SW5kZXgiLCJmaW5kSW5kZXgiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/balanced-pool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/cache/cache.js":
/*!**********************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/cache/cache.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kConstruct } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/cache/symbols.js\");\nconst { urlEquals, fieldValues: getFieldValues } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/cache/util.js\");\nconst { kEnumerableProperty, isDisturbed } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/webidl.js\");\nconst { Response, cloneResponse } = __webpack_require__(/*! ../fetch/response */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/response.js\");\nconst { Request } = __webpack_require__(/*! ../fetch/request */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/request.js\");\nconst { kState, kHeaders, kGuard, kRealm } = __webpack_require__(/*! ../fetch/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/symbols.js\");\nconst { fetching } = __webpack_require__(/*! ../fetch/index */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/index.js\");\nconst { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = __webpack_require__(/*! ../fetch/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/util.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../global */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/global.js\");\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation\n * @typedef {Object} CacheBatchOperation\n * @property {'delete' | 'put'} type\n * @property {any} request\n * @property {any} response\n * @property {import('../../types/cache').CacheQueryOptions} options\n */ /**\n * @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list\n * @typedef {[any, any][]} requestResponseList\n */ class Cache {\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list\n   * @type {requestResponseList}\n   */ #relevantRequestResponseList;\n    constructor(){\n        if (arguments[0] !== kConstruct) {\n            webidl.illegalConstructor();\n        }\n        this.#relevantRequestResponseList = arguments[1];\n    }\n    async match(request, options = {}) {\n        webidl.brandCheck(this, Cache);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Cache.match\"\n        });\n        request = webidl.converters.RequestInfo(request);\n        options = webidl.converters.CacheQueryOptions(options);\n        const p = await this.matchAll(request, options);\n        if (p.length === 0) {\n            return;\n        }\n        return p[0];\n    }\n    async matchAll(request = undefined, options = {}) {\n        webidl.brandCheck(this, Cache);\n        if (request !== undefined) request = webidl.converters.RequestInfo(request);\n        options = webidl.converters.CacheQueryOptions(options);\n        // 1.\n        let r = null;\n        // 2.\n        if (request !== undefined) {\n            if (request instanceof Request) {\n                // 2.1.1\n                r = request[kState];\n                // 2.1.2\n                if (r.method !== \"GET\" && !options.ignoreMethod) {\n                    return [];\n                }\n            } else if (typeof request === \"string\") {\n                // 2.2.1\n                r = new Request(request)[kState];\n            }\n        }\n        // 5.\n        // 5.1\n        const responses = [];\n        // 5.2\n        if (request === undefined) {\n            // 5.2.1\n            for (const requestResponse of this.#relevantRequestResponseList){\n                responses.push(requestResponse[1]);\n            }\n        } else {\n            // 5.3.1\n            const requestResponses = this.#queryCache(r, options);\n            // 5.3.2\n            for (const requestResponse of requestResponses){\n                responses.push(requestResponse[1]);\n            }\n        }\n        // 5.4\n        // We don't implement CORs so we don't need to loop over the responses, yay!\n        // 5.5.1\n        const responseList = [];\n        // 5.5.2\n        for (const response of responses){\n            // 5.5.2.1\n            const responseObject = new Response(response.body?.source ?? null);\n            const body = responseObject[kState].body;\n            responseObject[kState] = response;\n            responseObject[kState].body = body;\n            responseObject[kHeaders][kHeadersList] = response.headersList;\n            responseObject[kHeaders][kGuard] = \"immutable\";\n            responseList.push(responseObject);\n        }\n        // 6.\n        return Object.freeze(responseList);\n    }\n    async add(request) {\n        webidl.brandCheck(this, Cache);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Cache.add\"\n        });\n        request = webidl.converters.RequestInfo(request);\n        // 1.\n        const requests = [\n            request\n        ];\n        // 2.\n        const responseArrayPromise = this.addAll(requests);\n        // 3.\n        return await responseArrayPromise;\n    }\n    async addAll(requests) {\n        webidl.brandCheck(this, Cache);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Cache.addAll\"\n        });\n        requests = webidl.converters[\"sequence<RequestInfo>\"](requests);\n        // 1.\n        const responsePromises = [];\n        // 2.\n        const requestList = [];\n        // 3.\n        for (const request of requests){\n            if (typeof request === \"string\") {\n                continue;\n            }\n            // 3.1\n            const r = request[kState];\n            // 3.2\n            if (!urlIsHttpHttpsScheme(r.url) || r.method !== \"GET\") {\n                throw webidl.errors.exception({\n                    header: \"Cache.addAll\",\n                    message: \"Expected http/s scheme when method is not GET.\"\n                });\n            }\n        }\n        // 4.\n        /** @type {ReturnType<typeof fetching>[]} */ const fetchControllers = [];\n        // 5.\n        for (const request of requests){\n            // 5.1\n            const r = new Request(request)[kState];\n            // 5.2\n            if (!urlIsHttpHttpsScheme(r.url)) {\n                throw webidl.errors.exception({\n                    header: \"Cache.addAll\",\n                    message: \"Expected http/s scheme.\"\n                });\n            }\n            // 5.4\n            r.initiator = \"fetch\";\n            r.destination = \"subresource\";\n            // 5.5\n            requestList.push(r);\n            // 5.6\n            const responsePromise = createDeferredPromise();\n            // 5.7\n            fetchControllers.push(fetching({\n                request: r,\n                dispatcher: getGlobalDispatcher(),\n                processResponse (response) {\n                    // 1.\n                    if (response.type === \"error\" || response.status === 206 || response.status < 200 || response.status > 299) {\n                        responsePromise.reject(webidl.errors.exception({\n                            header: \"Cache.addAll\",\n                            message: \"Received an invalid status code or the request failed.\"\n                        }));\n                    } else if (response.headersList.contains(\"vary\")) {\n                        // 2.1\n                        const fieldValues = getFieldValues(response.headersList.get(\"vary\"));\n                        // 2.2\n                        for (const fieldValue of fieldValues){\n                            // 2.2.1\n                            if (fieldValue === \"*\") {\n                                responsePromise.reject(webidl.errors.exception({\n                                    header: \"Cache.addAll\",\n                                    message: \"invalid vary field value\"\n                                }));\n                                for (const controller of fetchControllers){\n                                    controller.abort();\n                                }\n                                return;\n                            }\n                        }\n                    }\n                },\n                processResponseEndOfBody (response) {\n                    // 1.\n                    if (response.aborted) {\n                        responsePromise.reject(new DOMException(\"aborted\", \"AbortError\"));\n                        return;\n                    }\n                    // 2.\n                    responsePromise.resolve(response);\n                }\n            }));\n            // 5.8\n            responsePromises.push(responsePromise.promise);\n        }\n        // 6.\n        const p = Promise.all(responsePromises);\n        // 7.\n        const responses = await p;\n        // 7.1\n        const operations = [];\n        // 7.2\n        let index = 0;\n        // 7.3\n        for (const response of responses){\n            // 7.3.1\n            /** @type {CacheBatchOperation} */ const operation = {\n                type: \"put\",\n                request: requestList[index],\n                response\n            };\n            operations.push(operation) // 7.3.5\n            ;\n            index++ // 7.3.6\n            ;\n        }\n        // 7.5\n        const cacheJobPromise = createDeferredPromise();\n        // 7.6.1\n        let errorData = null;\n        // 7.6.2\n        try {\n            this.#batchCacheOperations(operations);\n        } catch (e) {\n            errorData = e;\n        }\n        // 7.6.3\n        queueMicrotask(()=>{\n            // 7.6.3.1\n            if (errorData === null) {\n                cacheJobPromise.resolve(undefined);\n            } else {\n                // 7.6.3.2\n                cacheJobPromise.reject(errorData);\n            }\n        });\n        // 7.7\n        return cacheJobPromise.promise;\n    }\n    async put(request, response) {\n        webidl.brandCheck(this, Cache);\n        webidl.argumentLengthCheck(arguments, 2, {\n            header: \"Cache.put\"\n        });\n        request = webidl.converters.RequestInfo(request);\n        response = webidl.converters.Response(response);\n        // 1.\n        let innerRequest = null;\n        // 2.\n        if (request instanceof Request) {\n            innerRequest = request[kState];\n        } else {\n            innerRequest = new Request(request)[kState];\n        }\n        // 4.\n        if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== \"GET\") {\n            throw webidl.errors.exception({\n                header: \"Cache.put\",\n                message: \"Expected an http/s scheme when method is not GET\"\n            });\n        }\n        // 5.\n        const innerResponse = response[kState];\n        // 6.\n        if (innerResponse.status === 206) {\n            throw webidl.errors.exception({\n                header: \"Cache.put\",\n                message: \"Got 206 status\"\n            });\n        }\n        // 7.\n        if (innerResponse.headersList.contains(\"vary\")) {\n            // 7.1.\n            const fieldValues = getFieldValues(innerResponse.headersList.get(\"vary\"));\n            // 7.2.\n            for (const fieldValue of fieldValues){\n                // 7.2.1\n                if (fieldValue === \"*\") {\n                    throw webidl.errors.exception({\n                        header: \"Cache.put\",\n                        message: \"Got * vary field value\"\n                    });\n                }\n            }\n        }\n        // 8.\n        if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {\n            throw webidl.errors.exception({\n                header: \"Cache.put\",\n                message: \"Response body is locked or disturbed\"\n            });\n        }\n        // 9.\n        const clonedResponse = cloneResponse(innerResponse);\n        // 10.\n        const bodyReadPromise = createDeferredPromise();\n        // 11.\n        if (innerResponse.body != null) {\n            // 11.1\n            const stream = innerResponse.body.stream;\n            // 11.2\n            const reader = stream.getReader();\n            // 11.3\n            readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);\n        } else {\n            bodyReadPromise.resolve(undefined);\n        }\n        // 12.\n        /** @type {CacheBatchOperation[]} */ const operations = [];\n        // 13.\n        /** @type {CacheBatchOperation} */ const operation = {\n            type: \"put\",\n            request: innerRequest,\n            response: clonedResponse // 16.\n        };\n        // 17.\n        operations.push(operation);\n        // 19.\n        const bytes = await bodyReadPromise.promise;\n        if (clonedResponse.body != null) {\n            clonedResponse.body.source = bytes;\n        }\n        // 19.1\n        const cacheJobPromise = createDeferredPromise();\n        // 19.2.1\n        let errorData = null;\n        // 19.2.2\n        try {\n            this.#batchCacheOperations(operations);\n        } catch (e) {\n            errorData = e;\n        }\n        // 19.2.3\n        queueMicrotask(()=>{\n            // 19.2.3.1\n            if (errorData === null) {\n                cacheJobPromise.resolve();\n            } else {\n                cacheJobPromise.reject(errorData);\n            }\n        });\n        return cacheJobPromise.promise;\n    }\n    async delete(request, options = {}) {\n        webidl.brandCheck(this, Cache);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Cache.delete\"\n        });\n        request = webidl.converters.RequestInfo(request);\n        options = webidl.converters.CacheQueryOptions(options);\n        /**\n     * @type {Request}\n     */ let r = null;\n        if (request instanceof Request) {\n            r = request[kState];\n            if (r.method !== \"GET\" && !options.ignoreMethod) {\n                return false;\n            }\n        } else {\n            assert(typeof request === \"string\");\n            r = new Request(request)[kState];\n        }\n        /** @type {CacheBatchOperation[]} */ const operations = [];\n        /** @type {CacheBatchOperation} */ const operation = {\n            type: \"delete\",\n            request: r,\n            options\n        };\n        operations.push(operation);\n        const cacheJobPromise = createDeferredPromise();\n        let errorData = null;\n        let requestResponses;\n        try {\n            requestResponses = this.#batchCacheOperations(operations);\n        } catch (e) {\n            errorData = e;\n        }\n        queueMicrotask(()=>{\n            if (errorData === null) {\n                cacheJobPromise.resolve(!!requestResponses?.length);\n            } else {\n                cacheJobPromise.reject(errorData);\n            }\n        });\n        return cacheJobPromise.promise;\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys\n   * @param {any} request\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @returns {readonly Request[]}\n   */ async keys(request = undefined, options = {}) {\n        webidl.brandCheck(this, Cache);\n        if (request !== undefined) request = webidl.converters.RequestInfo(request);\n        options = webidl.converters.CacheQueryOptions(options);\n        // 1.\n        let r = null;\n        // 2.\n        if (request !== undefined) {\n            // 2.1\n            if (request instanceof Request) {\n                // 2.1.1\n                r = request[kState];\n                // 2.1.2\n                if (r.method !== \"GET\" && !options.ignoreMethod) {\n                    return [];\n                }\n            } else if (typeof request === \"string\") {\n                r = new Request(request)[kState];\n            }\n        }\n        // 4.\n        const promise = createDeferredPromise();\n        // 5.\n        // 5.1\n        const requests = [];\n        // 5.2\n        if (request === undefined) {\n            // 5.2.1\n            for (const requestResponse of this.#relevantRequestResponseList){\n                // 5.2.1.1\n                requests.push(requestResponse[0]);\n            }\n        } else {\n            // 5.3.1\n            const requestResponses = this.#queryCache(r, options);\n            // 5.3.2\n            for (const requestResponse of requestResponses){\n                // 5.3.2.1\n                requests.push(requestResponse[0]);\n            }\n        }\n        // 5.4\n        queueMicrotask(()=>{\n            // 5.4.1\n            const requestList = [];\n            // 5.4.2\n            for (const request of requests){\n                const requestObject = new Request(\"https://a\");\n                requestObject[kState] = request;\n                requestObject[kHeaders][kHeadersList] = request.headersList;\n                requestObject[kHeaders][kGuard] = \"immutable\";\n                requestObject[kRealm] = request.client;\n                // 5.4.2.1\n                requestList.push(requestObject);\n            }\n            // 5.4.3\n            promise.resolve(Object.freeze(requestList));\n        });\n        return promise.promise;\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm\n   * @param {CacheBatchOperation[]} operations\n   * @returns {requestResponseList}\n   */ #batchCacheOperations(operations) {\n        // 1.\n        const cache = this.#relevantRequestResponseList;\n        // 2.\n        const backupCache = [\n            ...cache\n        ];\n        // 3.\n        const addedItems = [];\n        // 4.1\n        const resultList = [];\n        try {\n            // 4.2\n            for (const operation of operations){\n                // 4.2.1\n                if (operation.type !== \"delete\" && operation.type !== \"put\") {\n                    throw webidl.errors.exception({\n                        header: \"Cache.#batchCacheOperations\",\n                        message: 'operation type does not match \"delete\" or \"put\"'\n                    });\n                }\n                // 4.2.2\n                if (operation.type === \"delete\" && operation.response != null) {\n                    throw webidl.errors.exception({\n                        header: \"Cache.#batchCacheOperations\",\n                        message: \"delete operation should not have an associated response\"\n                    });\n                }\n                // 4.2.3\n                if (this.#queryCache(operation.request, operation.options, addedItems).length) {\n                    throw new DOMException(\"???\", \"InvalidStateError\");\n                }\n                // 4.2.4\n                let requestResponses;\n                // 4.2.5\n                if (operation.type === \"delete\") {\n                    // 4.2.5.1\n                    requestResponses = this.#queryCache(operation.request, operation.options);\n                    // TODO: the spec is wrong, this is needed to pass WPTs\n                    if (requestResponses.length === 0) {\n                        return [];\n                    }\n                    // 4.2.5.2\n                    for (const requestResponse of requestResponses){\n                        const idx = cache.indexOf(requestResponse);\n                        assert(idx !== -1);\n                        // 4.2.5.2.1\n                        cache.splice(idx, 1);\n                    }\n                } else if (operation.type === \"put\") {\n                    // 4.2.6.1\n                    if (operation.response == null) {\n                        throw webidl.errors.exception({\n                            header: \"Cache.#batchCacheOperations\",\n                            message: \"put operation should have an associated response\"\n                        });\n                    }\n                    // 4.2.6.2\n                    const r = operation.request;\n                    // 4.2.6.3\n                    if (!urlIsHttpHttpsScheme(r.url)) {\n                        throw webidl.errors.exception({\n                            header: \"Cache.#batchCacheOperations\",\n                            message: \"expected http or https scheme\"\n                        });\n                    }\n                    // 4.2.6.4\n                    if (r.method !== \"GET\") {\n                        throw webidl.errors.exception({\n                            header: \"Cache.#batchCacheOperations\",\n                            message: \"not get method\"\n                        });\n                    }\n                    // 4.2.6.5\n                    if (operation.options != null) {\n                        throw webidl.errors.exception({\n                            header: \"Cache.#batchCacheOperations\",\n                            message: \"options must not be defined\"\n                        });\n                    }\n                    // 4.2.6.6\n                    requestResponses = this.#queryCache(operation.request);\n                    // 4.2.6.7\n                    for (const requestResponse of requestResponses){\n                        const idx = cache.indexOf(requestResponse);\n                        assert(idx !== -1);\n                        // 4.2.6.7.1\n                        cache.splice(idx, 1);\n                    }\n                    // 4.2.6.8\n                    cache.push([\n                        operation.request,\n                        operation.response\n                    ]);\n                    // 4.2.6.10\n                    addedItems.push([\n                        operation.request,\n                        operation.response\n                    ]);\n                }\n                // 4.2.7\n                resultList.push([\n                    operation.request,\n                    operation.response\n                ]);\n            }\n            // 4.3\n            return resultList;\n        } catch (e) {\n            // 5.1\n            this.#relevantRequestResponseList.length = 0;\n            // 5.2\n            this.#relevantRequestResponseList = backupCache;\n            // 5.3\n            throw e;\n        }\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#query-cache\n   * @param {any} requestQuery\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @param {requestResponseList} targetStorage\n   * @returns {requestResponseList}\n   */ #queryCache(requestQuery, options, targetStorage) {\n        /** @type {requestResponseList} */ const resultList = [];\n        const storage = targetStorage ?? this.#relevantRequestResponseList;\n        for (const requestResponse of storage){\n            const [cachedRequest, cachedResponse] = requestResponse;\n            if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {\n                resultList.push(requestResponse);\n            }\n        }\n        return resultList;\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm\n   * @param {any} requestQuery\n   * @param {any} request\n   * @param {any | null} response\n   * @param {import('../../types/cache').CacheQueryOptions | undefined} options\n   * @returns {boolean}\n   */ #requestMatchesCachedItem(requestQuery, request, response = null, options) {\n        // if (options?.ignoreMethod === false && request.method === 'GET') {\n        //   return false\n        // }\n        const queryURL = new URL(requestQuery.url);\n        const cachedURL = new URL(request.url);\n        if (options?.ignoreSearch) {\n            cachedURL.search = \"\";\n            queryURL.search = \"\";\n        }\n        if (!urlEquals(queryURL, cachedURL, true)) {\n            return false;\n        }\n        if (response == null || options?.ignoreVary || !response.headersList.contains(\"vary\")) {\n            return true;\n        }\n        const fieldValues = getFieldValues(response.headersList.get(\"vary\"));\n        for (const fieldValue of fieldValues){\n            if (fieldValue === \"*\") {\n                return false;\n            }\n            const requestValue = request.headersList.get(fieldValue);\n            const queryValue = requestQuery.headersList.get(fieldValue);\n            // If one has the header and the other doesn't, or one has\n            // a different value than the other, return false\n            if (requestValue !== queryValue) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nObject.defineProperties(Cache.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"Cache\",\n        configurable: true\n    },\n    match: kEnumerableProperty,\n    matchAll: kEnumerableProperty,\n    add: kEnumerableProperty,\n    addAll: kEnumerableProperty,\n    put: kEnumerableProperty,\n    delete: kEnumerableProperty,\n    keys: kEnumerableProperty\n});\nconst cacheQueryOptionConverters = [\n    {\n        key: \"ignoreSearch\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: \"ignoreMethod\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: \"ignoreVary\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    }\n];\nwebidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);\nwebidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([\n    ...cacheQueryOptionConverters,\n    {\n        key: \"cacheName\",\n        converter: webidl.converters.DOMString\n    }\n]);\nwebidl.converters.Response = webidl.interfaceConverter(Response);\nwebidl.converters[\"sequence<RequestInfo>\"] = webidl.sequenceConverter(webidl.converters.RequestInfo);\nmodule.exports = {\n    Cache\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY2FjaGUvY2FjaGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFVBQVUsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUMvQixNQUFNLEVBQUVDLFNBQVMsRUFBRUMsYUFBYUMsY0FBYyxFQUFFLEdBQUdILG1CQUFPQSxDQUFDO0FBQzNELE1BQU0sRUFBRUksbUJBQW1CLEVBQUVDLFdBQVcsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUNyRCxNQUFNLEVBQUVNLFlBQVksRUFBRSxHQUFHTixtQkFBT0EsQ0FBQztBQUNqQyxNQUFNLEVBQUVPLE1BQU0sRUFBRSxHQUFHUCxtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUVRLFFBQVEsRUFBRUMsYUFBYSxFQUFFLEdBQUdULG1CQUFPQSxDQUFDO0FBQzVDLE1BQU0sRUFBRVUsT0FBTyxFQUFFLEdBQUdWLG1CQUFPQSxDQUFDO0FBQzVCLE1BQU0sRUFBRVcsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsTUFBTSxFQUFFLEdBQUdkLG1CQUFPQSxDQUFDO0FBQ3JELE1BQU0sRUFBRWUsUUFBUSxFQUFFLEdBQUdmLG1CQUFPQSxDQUFDO0FBQzdCLE1BQU0sRUFBRWdCLG9CQUFvQixFQUFFQyxxQkFBcUIsRUFBRUMsWUFBWSxFQUFFLEdBQUdsQixtQkFBT0EsQ0FBQztBQUM5RSxNQUFNbUIsU0FBU25CLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRW9CLG1CQUFtQixFQUFFLEdBQUdwQixtQkFBT0EsQ0FBQztBQUV4Qzs7Ozs7OztDQU9DLEdBRUQ7OztDQUdDLEdBRUQsTUFBTXFCO0lBQ0o7OztHQUdDLEdBQ0QsQ0FBQ0MsMkJBQTJCO0lBRTVCQyxhQUFlO1FBQ2IsSUFBSUMsU0FBUyxDQUFDLEVBQUUsS0FBS3pCLFlBQVk7WUFDL0JRLE9BQU9rQixrQkFBa0I7UUFDM0I7UUFFQSxJQUFJLENB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LE9BQU95QixVQUFVLENBQUMyRyxPQUFPO1FBQ3BDQyxjQUFjO0lBQ2hCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXbkksT0FBT3lCLFVBQVUsQ0FBQzJHLE9BQU87UUFDcENDLGNBQWM7SUFDaEI7Q0FDRDtBQUVEckksT0FBT3lCLFVBQVUsQ0FBQ0UsaUJBQWlCLEdBQUczQixPQUFPc0ksbUJBQW1CLENBQUNMO0FBRWpFakksT0FBT3lCLFVBQVUsQ0FBQzhHLHNCQUFzQixHQUFHdkksT0FBT3NJLG1CQUFtQixDQUFDO09BQ2pFTDtJQUNIO1FBQ0VDLEtBQUs7UUFDTEMsV0FBV25JLE9BQU95QixVQUFVLENBQUMrRyxTQUFTO0lBQ3hDO0NBQ0Q7QUFFRHhJLE9BQU95QixVQUFVLENBQUN4QixRQUFRLEdBQUdELE9BQU95SSxrQkFBa0IsQ0FBQ3hJO0FBRXZERCxPQUFPeUIsVUFBVSxDQUFDLHdCQUF3QixHQUFHekIsT0FBTzBJLGlCQUFpQixDQUNuRTFJLE9BQU95QixVQUFVLENBQUNDLFdBQVc7QUFHL0JpSCxPQUFPQyxPQUFPLEdBQUc7SUFDZjlIO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jYWNoZS9jYWNoZS5qcz9kODNlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGtDb25zdHJ1Y3QgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IHVybEVxdWFscywgZmllbGRWYWx1ZXM6IGdldEZpZWxkVmFsdWVzIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5LCBpc0Rpc3R1cmJlZCB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsga0hlYWRlcnNMaXN0IH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3dlYmlkbCcpXG5jb25zdCB7IFJlc3BvbnNlLCBjbG9uZVJlc3BvbnNlIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9yZXNwb25zZScpXG5jb25zdCB7IFJlcXVlc3QgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3JlcXVlc3QnKVxuY29uc3QgeyBrU3RhdGUsIGtIZWFkZXJzLCBrR3VhcmQsIGtSZWFsbSB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvc3ltYm9scycpXG5jb25zdCB7IGZldGNoaW5nIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9pbmRleCcpXG5jb25zdCB7IHVybElzSHR0cEh0dHBzU2NoZW1lLCBjcmVhdGVEZWZlcnJlZFByb21pc2UsIHJlYWRBbGxCeXRlcyB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvdXRpbCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgeyBnZXRHbG9iYWxEaXNwYXRjaGVyIH0gPSByZXF1aXJlKCcuLi9nbG9iYWwnKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2Rmbi1jYWNoZS1iYXRjaC1vcGVyYXRpb25cbiAqIEB0eXBlZGVmIHtPYmplY3R9IENhY2hlQmF0Y2hPcGVyYXRpb25cbiAqIEBwcm9wZXJ0eSB7J2RlbGV0ZScgfCAncHV0J30gdHlwZVxuICogQHByb3BlcnR5IHthbnl9IHJlcXVlc3RcbiAqIEBwcm9wZXJ0eSB7YW55fSByZXNwb25zZVxuICogQHByb3BlcnR5IHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlJykuQ2FjaGVRdWVyeU9wdGlvbnN9IG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2Rmbi1yZXF1ZXN0LXJlc3BvbnNlLWxpc3RcbiAqIEB0eXBlZGVmIHtbYW55LCBhbnldW119IHJlcXVlc3RSZXNwb25zZUxpc3RcbiAqL1xuXG5jbGFzcyBDYWNoZSB7XG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNkZm4tcmVsZXZhbnQtcmVxdWVzdC1yZXNwb25zZS1saXN0XG4gICAqIEB0eXBlIHtyZXF1ZXN0UmVzcG9uc2VMaXN0fVxuICAgKi9cbiAgI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdFxuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdICE9PSBrQ29uc3RydWN0KSB7XG4gICAgICB3ZWJpZGwuaWxsZWdhbENvbnN0cnVjdG9yKClcbiAgICB9XG5cbiAgICB0aGlzLiNyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3QgPSBhcmd1bWVudHNbMV1cbiAgfVxuXG4gIGFzeW5jIG1hdGNoIChyZXF1ZXN0LCBvcHRpb25zID0ge30pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnQ2FjaGUubWF0Y2gnIH0pXG5cbiAgICByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdClcbiAgICBvcHRpb25zID0gd2ViaWRsLmNvbnZlcnRlcnMuQ2FjaGVRdWVyeU9wdGlvbnMob3B0aW9ucylcblxuICAgIGNvbnN0IHAgPSBhd2FpdCB0aGlzLm1hdGNoQWxsKHJlcXVlc3QsIG9wdGlvbnMpXG5cbiAgICBpZiAocC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHJldHVybiBwWzBdXG4gIH1cblxuICBhc3luYyBtYXRjaEFsbCAocmVxdWVzdCA9IHVuZGVmaW5lZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGUpXG5cbiAgICBpZiAocmVxdWVzdCAhPT0gdW5kZWZpbmVkKSByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdClcbiAgICBvcHRpb25zID0gd2ViaWRsLmNvbnZlcnRlcnMuQ2FjaGVRdWVyeU9wdGlvbnMob3B0aW9ucylcblxuICAgIC8vIDEuXG4gICAgbGV0IHIgPSBudWxsXG5cbiAgICAvLyAyLlxuICAgIGlmIChyZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChyZXF1ZXN0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgICAvLyAyLjEuMVxuICAgICAgICByID0gcmVxdWVzdFtrU3RhdGVdXG5cbiAgICAgICAgLy8gMi4xLjJcbiAgICAgICAgaWYgKHIubWV0aG9kICE9PSAnR0VUJyAmJiAhb3B0aW9ucy5pZ25vcmVNZXRob2QpIHtcbiAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVxdWVzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gMi4yLjFcbiAgICAgICAgciA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QpW2tTdGF0ZV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA1LlxuICAgIC8vIDUuMVxuICAgIGNvbnN0IHJlc3BvbnNlcyA9IFtdXG5cbiAgICAvLyA1LjJcbiAgICBpZiAocmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyA1LjIuMVxuICAgICAgZm9yIChjb25zdCByZXF1ZXN0UmVzcG9uc2Ugb2YgdGhpcy4jcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0KSB7XG4gICAgICAgIHJlc3BvbnNlcy5wdXNoKHJlcXVlc3RSZXNwb25zZVsxXSlcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyA1LjNcbiAgICAgIC8vIDUuMy4xXG4gICAgICBjb25zdCByZXF1ZXN0UmVzcG9uc2VzID0gdGhpcy4jcXVlcnlDYWNoZShyLCBvcHRpb25zKVxuXG4gICAgICAvLyA1LjMuMlxuICAgICAgZm9yIChjb25zdCByZXF1ZXN0UmVzcG9uc2Ugb2YgcmVxdWVzdFJlc3BvbnNlcykge1xuICAgICAgICByZXNwb25zZXMucHVzaChyZXF1ZXN0UmVzcG9uc2VbMV0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNS40XG4gICAgLy8gV2UgZG9uJ3QgaW1wbGVtZW50IENPUnMgc28gd2UgZG9uJ3QgbmVlZCB0byBsb29wIG92ZXIgdGhlIHJlc3BvbnNlcywgeWF5IVxuXG4gICAgLy8gNS41LjFcbiAgICBjb25zdCByZXNwb25zZUxpc3QgPSBbXVxuXG4gICAgLy8gNS41LjJcbiAgICBmb3IgKGNvbnN0IHJlc3BvbnNlIG9mIHJlc3BvbnNlcykge1xuICAgICAgLy8gNS41LjIuMVxuICAgICAgY29uc3QgcmVzcG9uc2VPYmplY3QgPSBuZXcgUmVzcG9uc2UocmVzcG9uc2UuYm9keT8uc291cmNlID8/IG51bGwpXG4gICAgICBjb25zdCBib2R5ID0gcmVzcG9uc2VPYmplY3Rba1N0YXRlXS5ib2R5XG4gICAgICByZXNwb25zZU9iamVjdFtrU3RhdGVdID0gcmVzcG9uc2VcbiAgICAgIHJlc3BvbnNlT2JqZWN0W2tTdGF0ZV0uYm9keSA9IGJvZHlcbiAgICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrSGVhZGVyc0xpc3RdID0gcmVzcG9uc2UuaGVhZGVyc0xpc3RcbiAgICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrR3VhcmRdID0gJ2ltbXV0YWJsZSdcblxuICAgICAgcmVzcG9uc2VMaXN0LnB1c2gocmVzcG9uc2VPYmplY3QpXG4gICAgfVxuXG4gICAgLy8gNi5cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShyZXNwb25zZUxpc3QpXG4gIH1cblxuICBhc3luYyBhZGQgKHJlcXVlc3QpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnQ2FjaGUuYWRkJyB9KVxuXG4gICAgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QpXG5cbiAgICAvLyAxLlxuICAgIGNvbnN0IHJlcXVlc3RzID0gW3JlcXVlc3RdXG5cbiAgICAvLyAyLlxuICAgIGNvbnN0IHJlc3BvbnNlQXJyYXlQcm9taXNlID0gdGhpcy5hZGRBbGwocmVxdWVzdHMpXG5cbiAgICAvLyAzLlxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZUFycmF5UHJvbWlzZVxuICB9XG5cbiAgYXN5bmMgYWRkQWxsIChyZXF1ZXN0cykge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlKVxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdDYWNoZS5hZGRBbGwnIH0pXG5cbiAgICByZXF1ZXN0cyA9IHdlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxSZXF1ZXN0SW5mbz4nXShyZXF1ZXN0cylcblxuICAgIC8vIDEuXG4gICAgY29uc3QgcmVzcG9uc2VQcm9taXNlcyA9IFtdXG5cbiAgICAvLyAyLlxuICAgIGNvbnN0IHJlcXVlc3RMaXN0ID0gW11cblxuICAgIC8vIDMuXG4gICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHJlcXVlc3RzKSB7XG4gICAgICBpZiAodHlwZW9mIHJlcXVlc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDMuMVxuICAgICAgY29uc3QgciA9IHJlcXVlc3Rba1N0YXRlXVxuXG4gICAgICAvLyAzLjJcbiAgICAgIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUoci51cmwpIHx8IHIubWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuYWRkQWxsJyxcbiAgICAgICAgICBtZXNzYWdlOiAnRXhwZWN0ZWQgaHR0cC9zIHNjaGVtZSB3aGVuIG1ldGhvZCBpcyBub3QgR0VULidcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0LlxuICAgIC8qKiBAdHlwZSB7UmV0dXJuVHlwZTx0eXBlb2YgZmV0Y2hpbmc+W119ICovXG4gICAgY29uc3QgZmV0Y2hDb250cm9sbGVycyA9IFtdXG5cbiAgICAvLyA1LlxuICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiByZXF1ZXN0cykge1xuICAgICAgLy8gNS4xXG4gICAgICBjb25zdCByID0gbmV3IFJlcXVlc3QocmVxdWVzdClba1N0YXRlXVxuXG4gICAgICAvLyA1LjJcbiAgICAgIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUoci51cmwpKSB7XG4gICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICBoZWFkZXI6ICdDYWNoZS5hZGRBbGwnLFxuICAgICAgICAgIG1lc3NhZ2U6ICdFeHBlY3RlZCBodHRwL3Mgc2NoZW1lLidcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gNS40XG4gICAgICByLmluaXRpYXRvciA9ICdmZXRjaCdcbiAgICAgIHIuZGVzdGluYXRpb24gPSAnc3VicmVzb3VyY2UnXG5cbiAgICAgIC8vIDUuNVxuICAgICAgcmVxdWVzdExpc3QucHVzaChyKVxuXG4gICAgICAvLyA1LjZcbiAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgICAgIC8vIDUuN1xuICAgICAgZmV0Y2hDb250cm9sbGVycy5wdXNoKGZldGNoaW5nKHtcbiAgICAgICAgcmVxdWVzdDogcixcbiAgICAgICAgZGlzcGF0Y2hlcjogZ2V0R2xvYmFsRGlzcGF0Y2hlcigpLFxuICAgICAgICBwcm9jZXNzUmVzcG9uc2UgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgLy8gMS5cbiAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PT0gJ2Vycm9yJyB8fCByZXNwb25zZS5zdGF0dXMgPT09IDIwNiB8fCByZXNwb25zZS5zdGF0dXMgPCAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzID4gMjk5KSB7XG4gICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuYWRkQWxsJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ1JlY2VpdmVkIGFuIGludmFsaWQgc3RhdHVzIGNvZGUgb3IgdGhlIHJlcXVlc3QgZmFpbGVkLidcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2UuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3ZhcnknKSkgeyAvLyAyLlxuICAgICAgICAgICAgLy8gMi4xXG4gICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGdldEZpZWxkVmFsdWVzKHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgndmFyeScpKVxuXG4gICAgICAgICAgICAvLyAyLjJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGRWYWx1ZSBvZiBmaWVsZFZhbHVlcykge1xuICAgICAgICAgICAgICAvLyAyLjIuMVxuICAgICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdCh3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS5hZGRBbGwnLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2ludmFsaWQgdmFyeSBmaWVsZCB2YWx1ZSdcbiAgICAgICAgICAgICAgICB9KSlcblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiBmZXRjaENvbnRyb2xsZXJzKSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5IChyZXNwb25zZSkge1xuICAgICAgICAgIC8vIDEuXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZWplY3QobmV3IERPTUV4Y2VwdGlvbignYWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAyLlxuICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKVxuICAgICAgICB9XG4gICAgICB9KSlcblxuICAgICAgLy8gNS44XG4gICAgICByZXNwb25zZVByb21pc2VzLnB1c2gocmVzcG9uc2VQcm9taXNlLnByb21pc2UpXG4gICAgfVxuXG4gICAgLy8gNi5cbiAgICBjb25zdCBwID0gUHJvbWlzZS5hbGwocmVzcG9uc2VQcm9taXNlcylcblxuICAgIC8vIDcuXG4gICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgcFxuXG4gICAgLy8gNy4xXG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IFtdXG5cbiAgICAvLyA3LjJcbiAgICBsZXQgaW5kZXggPSAwXG5cbiAgICAvLyA3LjNcbiAgICBmb3IgKGNvbnN0IHJlc3BvbnNlIG9mIHJlc3BvbnNlcykge1xuICAgICAgLy8gNy4zLjFcbiAgICAgIC8qKiBAdHlwZSB7Q2FjaGVCYXRjaE9wZXJhdGlvbn0gKi9cbiAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICAgICAgdHlwZTogJ3B1dCcsIC8vIDcuMy4yXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RMaXN0W2luZGV4XSwgLy8gNy4zLjNcbiAgICAgICAgcmVzcG9uc2UgLy8gNy4zLjRcbiAgICAgIH1cblxuICAgICAgb3BlcmF0aW9ucy5wdXNoKG9wZXJhdGlvbikgLy8gNy4zLjVcblxuICAgICAgaW5kZXgrKyAvLyA3LjMuNlxuICAgIH1cblxuICAgIC8vIDcuNVxuICAgIGNvbnN0IGNhY2hlSm9iUHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgICAvLyA3LjYuMVxuICAgIGxldCBlcnJvckRhdGEgPSBudWxsXG5cbiAgICAvLyA3LjYuMlxuICAgIHRyeSB7XG4gICAgICB0aGlzLiNiYXRjaENhY2hlT3BlcmF0aW9ucyhvcGVyYXRpb25zKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yRGF0YSA9IGVcbiAgICB9XG5cbiAgICAvLyA3LjYuM1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIC8vIDcuNi4zLjFcbiAgICAgIGlmIChlcnJvckRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgY2FjaGVKb2JQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gNy42LjMuMlxuICAgICAgICBjYWNoZUpvYlByb21pc2UucmVqZWN0KGVycm9yRGF0YSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gNy43XG4gICAgcmV0dXJuIGNhY2hlSm9iUHJvbWlzZS5wcm9taXNlXG4gIH1cblxuICBhc3luYyBwdXQgKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGUpXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCB7IGhlYWRlcjogJ0NhY2hlLnB1dCcgfSlcblxuICAgIHJlcXVlc3QgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhyZXF1ZXN0KVxuICAgIHJlc3BvbnNlID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVzcG9uc2UocmVzcG9uc2UpXG5cbiAgICAvLyAxLlxuICAgIGxldCBpbm5lclJlcXVlc3QgPSBudWxsXG5cbiAgICAvLyAyLlxuICAgIGlmIChyZXF1ZXN0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgaW5uZXJSZXF1ZXN0ID0gcmVxdWVzdFtrU3RhdGVdXG4gICAgfSBlbHNlIHsgLy8gMy5cbiAgICAgIGlubmVyUmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QpW2tTdGF0ZV1cbiAgICB9XG5cbiAgICAvLyA0LlxuICAgIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUoaW5uZXJSZXF1ZXN0LnVybCkgfHwgaW5uZXJSZXF1ZXN0Lm1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnQ2FjaGUucHV0JyxcbiAgICAgICAgbWVzc2FnZTogJ0V4cGVjdGVkIGFuIGh0dHAvcyBzY2hlbWUgd2hlbiBtZXRob2QgaXMgbm90IEdFVCdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gNS5cbiAgICBjb25zdCBpbm5lclJlc3BvbnNlID0gcmVzcG9uc2Vba1N0YXRlXVxuXG4gICAgLy8gNi5cbiAgICBpZiAoaW5uZXJSZXNwb25zZS5zdGF0dXMgPT09IDIwNikge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6ICdDYWNoZS5wdXQnLFxuICAgICAgICBtZXNzYWdlOiAnR290IDIwNiBzdGF0dXMnXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDcuXG4gICAgaWYgKGlubmVyUmVzcG9uc2UuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3ZhcnknKSkge1xuICAgICAgLy8gNy4xLlxuICAgICAgY29uc3QgZmllbGRWYWx1ZXMgPSBnZXRGaWVsZFZhbHVlcyhpbm5lclJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgndmFyeScpKVxuXG4gICAgICAvLyA3LjIuXG4gICAgICBmb3IgKGNvbnN0IGZpZWxkVmFsdWUgb2YgZmllbGRWYWx1ZXMpIHtcbiAgICAgICAgLy8gNy4yLjFcbiAgICAgICAgaWYgKGZpZWxkVmFsdWUgPT09ICcqJykge1xuICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLnB1dCcsXG4gICAgICAgICAgICBtZXNzYWdlOiAnR290ICogdmFyeSBmaWVsZCB2YWx1ZSdcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gOC5cbiAgICBpZiAoaW5uZXJSZXNwb25zZS5ib2R5ICYmIChpc0Rpc3R1cmJlZChpbm5lclJlc3BvbnNlLmJvZHkuc3RyZWFtKSB8fCBpbm5lclJlc3BvbnNlLmJvZHkuc3RyZWFtLmxvY2tlZCkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnQ2FjaGUucHV0JyxcbiAgICAgICAgbWVzc2FnZTogJ1Jlc3BvbnNlIGJvZHkgaXMgbG9ja2VkIG9yIGRpc3R1cmJlZCdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gOS5cbiAgICBjb25zdCBjbG9uZWRSZXNwb25zZSA9IGNsb25lUmVzcG9uc2UoaW5uZXJSZXNwb25zZSlcblxuICAgIC8vIDEwLlxuICAgIGNvbnN0IGJvZHlSZWFkUHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgICAvLyAxMS5cbiAgICBpZiAoaW5uZXJSZXNwb25zZS5ib2R5ICE9IG51bGwpIHtcbiAgICAgIC8vIDExLjFcbiAgICAgIGNvbnN0IHN0cmVhbSA9IGlubmVyUmVzcG9uc2UuYm9keS5zdHJlYW1cblxuICAgICAgLy8gMTEuMlxuICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpXG5cbiAgICAgIC8vIDExLjNcbiAgICAgIHJlYWRBbGxCeXRlcyhyZWFkZXIpLnRoZW4oYm9keVJlYWRQcm9taXNlLnJlc29sdmUsIGJvZHlSZWFkUHJvbWlzZS5yZWplY3QpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJvZHlSZWFkUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZClcbiAgICB9XG5cbiAgICAvLyAxMi5cbiAgICAvKiogQHR5cGUge0NhY2hlQmF0Y2hPcGVyYXRpb25bXX0gKi9cbiAgICBjb25zdCBvcGVyYXRpb25zID0gW11cblxuICAgIC8vIDEzLlxuICAgIC8qKiBAdHlwZSB7Q2FjaGVCYXRjaE9wZXJhdGlvbn0gKi9cbiAgICBjb25zdCBvcGVyYXRpb24gPSB7XG4gICAgICB0eXBlOiAncHV0JywgLy8gMTQuXG4gICAgICByZXF1ZXN0OiBpbm5lclJlcXVlc3QsIC8vIDE1LlxuICAgICAgcmVzcG9uc2U6IGNsb25lZFJlc3BvbnNlIC8vIDE2LlxuICAgIH1cblxuICAgIC8vIDE3LlxuICAgIG9wZXJhdGlvbnMucHVzaChvcGVyYXRpb24pXG5cbiAgICAvLyAxOS5cbiAgICBjb25zdCBieXRlcyA9IGF3YWl0IGJvZHlSZWFkUHJvbWlzZS5wcm9taXNlXG5cbiAgICBpZiAoY2xvbmVkUmVzcG9uc2UuYm9keSAhPSBudWxsKSB7XG4gICAgICBjbG9uZWRSZXNwb25zZS5ib2R5LnNvdXJjZSA9IGJ5dGVzXG4gICAgfVxuXG4gICAgLy8gMTkuMVxuICAgIGNvbnN0IGNhY2hlSm9iUHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgICAvLyAxOS4yLjFcbiAgICBsZXQgZXJyb3JEYXRhID0gbnVsbFxuXG4gICAgLy8gMTkuMi4yXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuI2JhdGNoQ2FjaGVPcGVyYXRpb25zKG9wZXJhdGlvbnMpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3JEYXRhID0gZVxuICAgIH1cblxuICAgIC8vIDE5LjIuM1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIC8vIDE5LjIuMy4xXG4gICAgICBpZiAoZXJyb3JEYXRhID09PSBudWxsKSB7XG4gICAgICAgIGNhY2hlSm9iUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIH0gZWxzZSB7IC8vIDE5LjIuMy4yXG4gICAgICAgIGNhY2hlSm9iUHJvbWlzZS5yZWplY3QoZXJyb3JEYXRhKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gY2FjaGVKb2JQcm9taXNlLnByb21pc2VcbiAgfVxuXG4gIGFzeW5jIGRlbGV0ZSAocmVxdWVzdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGUpXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0NhY2hlLmRlbGV0ZScgfSlcblxuICAgIHJlcXVlc3QgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhyZXF1ZXN0KVxuICAgIG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVycy5DYWNoZVF1ZXJ5T3B0aW9ucyhvcHRpb25zKVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1JlcXVlc3R9XG4gICAgICovXG4gICAgbGV0IHIgPSBudWxsXG5cbiAgICBpZiAocmVxdWVzdCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIHIgPSByZXF1ZXN0W2tTdGF0ZV1cblxuICAgICAgaWYgKHIubWV0aG9kICE9PSAnR0VUJyAmJiAhb3B0aW9ucy5pZ25vcmVNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydCh0eXBlb2YgcmVxdWVzdCA9PT0gJ3N0cmluZycpXG5cbiAgICAgIHIgPSBuZXcgUmVxdWVzdChyZXF1ZXN0KVtrU3RhdGVdXG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHtDYWNoZUJhdGNoT3BlcmF0aW9uW119ICovXG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IFtdXG5cbiAgICAvKiogQHR5cGUge0NhY2hlQmF0Y2hPcGVyYXRpb259ICovXG4gICAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgICAgdHlwZTogJ2RlbGV0ZScsXG4gICAgICByZXF1ZXN0OiByLFxuICAgICAgb3B0aW9uc1xuICAgIH1cblxuICAgIG9wZXJhdGlvbnMucHVzaChvcGVyYXRpb24pXG5cbiAgICBjb25zdCBjYWNoZUpvYlByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gICAgbGV0IGVycm9yRGF0YSA9IG51bGxcbiAgICBsZXQgcmVxdWVzdFJlc3BvbnNlc1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlcXVlc3RSZXNwb25zZXMgPSB0aGlzLiNiYXRjaENhY2hlT3BlcmF0aW9ucyhvcGVyYXRpb25zKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yRGF0YSA9IGVcbiAgICB9XG5cbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICBpZiAoZXJyb3JEYXRhID09PSBudWxsKSB7XG4gICAgICAgIGNhY2hlSm9iUHJvbWlzZS5yZXNvbHZlKCEhcmVxdWVzdFJlc3BvbnNlcz8ubGVuZ3RoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FjaGVKb2JQcm9taXNlLnJlamVjdChlcnJvckRhdGEpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBjYWNoZUpvYlByb21pc2UucHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2RvbS1jYWNoZS1rZXlzXG4gICAqIEBwYXJhbSB7YW55fSByZXF1ZXN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZScpLkNhY2hlUXVlcnlPcHRpb25zfSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtyZWFkb25seSBSZXF1ZXN0W119XG4gICAqL1xuICBhc3luYyBrZXlzIChyZXF1ZXN0ID0gdW5kZWZpbmVkLCBvcHRpb25zID0ge30pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcblxuICAgIGlmIChyZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHJlcXVlc3QgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhyZXF1ZXN0KVxuICAgIG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVycy5DYWNoZVF1ZXJ5T3B0aW9ucyhvcHRpb25zKVxuXG4gICAgLy8gMS5cbiAgICBsZXQgciA9IG51bGxcblxuICAgIC8vIDIuXG4gICAgaWYgKHJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gMi4xXG4gICAgICBpZiAocmVxdWVzdCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgICAgLy8gMi4xLjFcbiAgICAgICAgciA9IHJlcXVlc3Rba1N0YXRlXVxuXG4gICAgICAgIC8vIDIuMS4yXG4gICAgICAgIGlmIChyLm1ldGhvZCAhPT0gJ0dFVCcgJiYgIW9wdGlvbnMuaWdub3JlTWV0aG9kKSB7XG4gICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlcXVlc3QgPT09ICdzdHJpbmcnKSB7IC8vIDIuMlxuICAgICAgICByID0gbmV3IFJlcXVlc3QocmVxdWVzdClba1N0YXRlXVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDQuXG4gICAgY29uc3QgcHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgICAvLyA1LlxuICAgIC8vIDUuMVxuICAgIGNvbnN0IHJlcXVlc3RzID0gW11cblxuICAgIC8vIDUuMlxuICAgIGlmIChyZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIDUuMi4xXG4gICAgICBmb3IgKGNvbnN0IHJlcXVlc3RSZXNwb25zZSBvZiB0aGlzLiNyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3QpIHtcbiAgICAgICAgLy8gNS4yLjEuMVxuICAgICAgICByZXF1ZXN0cy5wdXNoKHJlcXVlc3RSZXNwb25zZVswXSlcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyA1LjNcbiAgICAgIC8vIDUuMy4xXG4gICAgICBjb25zdCByZXF1ZXN0UmVzcG9uc2VzID0gdGhpcy4jcXVlcnlDYWNoZShyLCBvcHRpb25zKVxuXG4gICAgICAvLyA1LjMuMlxuICAgICAgZm9yIChjb25zdCByZXF1ZXN0UmVzcG9uc2Ugb2YgcmVxdWVzdFJlc3BvbnNlcykge1xuICAgICAgICAvLyA1LjMuMi4xXG4gICAgICAgIHJlcXVlc3RzLnB1c2gocmVxdWVzdFJlc3BvbnNlWzBdKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDUuNFxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIC8vIDUuNC4xXG4gICAgICBjb25zdCByZXF1ZXN0TGlzdCA9IFtdXG5cbiAgICAgIC8vIDUuNC4yXG4gICAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgcmVxdWVzdHMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdE9iamVjdCA9IG5ldyBSZXF1ZXN0KCdodHRwczovL2EnKVxuICAgICAgICByZXF1ZXN0T2JqZWN0W2tTdGF0ZV0gPSByZXF1ZXN0XG4gICAgICAgIHJlcXVlc3RPYmplY3Rba0hlYWRlcnNdW2tIZWFkZXJzTGlzdF0gPSByZXF1ZXN0LmhlYWRlcnNMaXN0XG4gICAgICAgIHJlcXVlc3RPYmplY3Rba0hlYWRlcnNdW2tHdWFyZF0gPSAnaW1tdXRhYmxlJ1xuICAgICAgICByZXF1ZXN0T2JqZWN0W2tSZWFsbV0gPSByZXF1ZXN0LmNsaWVudFxuXG4gICAgICAgIC8vIDUuNC4yLjFcbiAgICAgICAgcmVxdWVzdExpc3QucHVzaChyZXF1ZXN0T2JqZWN0KVxuICAgICAgfVxuXG4gICAgICAvLyA1LjQuM1xuICAgICAgcHJvbWlzZS5yZXNvbHZlKE9iamVjdC5mcmVlemUocmVxdWVzdExpc3QpKVxuICAgIH0pXG5cbiAgICByZXR1cm4gcHJvbWlzZS5wcm9taXNlXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jYmF0Y2gtY2FjaGUtb3BlcmF0aW9ucy1hbGdvcml0aG1cbiAgICogQHBhcmFtIHtDYWNoZUJhdGNoT3BlcmF0aW9uW119IG9wZXJhdGlvbnNcbiAgICogQHJldHVybnMge3JlcXVlc3RSZXNwb25zZUxpc3R9XG4gICAqL1xuICAjYmF0Y2hDYWNoZU9wZXJhdGlvbnMgKG9wZXJhdGlvbnMpIHtcbiAgICAvLyAxLlxuICAgIGNvbnN0IGNhY2hlID0gdGhpcy4jcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0XG5cbiAgICAvLyAyLlxuICAgIGNvbnN0IGJhY2t1cENhY2hlID0gWy4uLmNhY2hlXVxuXG4gICAgLy8gMy5cbiAgICBjb25zdCBhZGRlZEl0ZW1zID0gW11cblxuICAgIC8vIDQuMVxuICAgIGNvbnN0IHJlc3VsdExpc3QgPSBbXVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIDQuMlxuICAgICAgZm9yIChjb25zdCBvcGVyYXRpb24gb2Ygb3BlcmF0aW9ucykge1xuICAgICAgICAvLyA0LjIuMVxuICAgICAgICBpZiAob3BlcmF0aW9uLnR5cGUgIT09ICdkZWxldGUnICYmIG9wZXJhdGlvbi50eXBlICE9PSAncHV0Jykge1xuICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLiNiYXRjaENhY2hlT3BlcmF0aW9ucycsXG4gICAgICAgICAgICBtZXNzYWdlOiAnb3BlcmF0aW9uIHR5cGUgZG9lcyBub3QgbWF0Y2ggXCJkZWxldGVcIiBvciBcInB1dFwiJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyA0LjIuMlxuICAgICAgICBpZiAob3BlcmF0aW9uLnR5cGUgPT09ICdkZWxldGUnICYmIG9wZXJhdGlvbi5yZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuI2JhdGNoQ2FjaGVPcGVyYXRpb25zJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdkZWxldGUgb3BlcmF0aW9uIHNob3VsZCBub3QgaGF2ZSBhbiBhc3NvY2lhdGVkIHJlc3BvbnNlJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyA0LjIuM1xuICAgICAgICBpZiAodGhpcy4jcXVlcnlDYWNoZShvcGVyYXRpb24ucmVxdWVzdCwgb3BlcmF0aW9uLm9wdGlvbnMsIGFkZGVkSXRlbXMpLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJz8/PycsICdJbnZhbGlkU3RhdGVFcnJvcicpXG4gICAgICAgIH1cblxuICAgICAgICAvLyA0LjIuNFxuICAgICAgICBsZXQgcmVxdWVzdFJlc3BvbnNlc1xuXG4gICAgICAgIC8vIDQuMi41XG4gICAgICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAvLyA0LjIuNS4xXG4gICAgICAgICAgcmVxdWVzdFJlc3BvbnNlcyA9IHRoaXMuI3F1ZXJ5Q2FjaGUob3BlcmF0aW9uLnJlcXVlc3QsIG9wZXJhdGlvbi5vcHRpb25zKVxuXG4gICAgICAgICAgLy8gVE9ETzogdGhlIHNwZWMgaXMgd3JvbmcsIHRoaXMgaXMgbmVlZGVkIHRvIHBhc3MgV1BUc1xuICAgICAgICAgIGlmIChyZXF1ZXN0UmVzcG9uc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gNC4yLjUuMlxuICAgICAgICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHJlcXVlc3RSZXNwb25zZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IGNhY2hlLmluZGV4T2YocmVxdWVzdFJlc3BvbnNlKVxuICAgICAgICAgICAgYXNzZXJ0KGlkeCAhPT0gLTEpXG5cbiAgICAgICAgICAgIC8vIDQuMi41LjIuMVxuICAgICAgICAgICAgY2FjaGUuc3BsaWNlKGlkeCwgMSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uLnR5cGUgPT09ICdwdXQnKSB7IC8vIDQuMi42XG4gICAgICAgICAgLy8gNC4yLjYuMVxuICAgICAgICAgIGlmIChvcGVyYXRpb24ucmVzcG9uc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAncHV0IG9wZXJhdGlvbiBzaG91bGQgaGF2ZSBhbiBhc3NvY2lhdGVkIHJlc3BvbnNlJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LjIuNi4yXG4gICAgICAgICAgY29uc3QgciA9IG9wZXJhdGlvbi5yZXF1ZXN0XG5cbiAgICAgICAgICAvLyA0LjIuNi4zXG4gICAgICAgICAgaWYgKCF1cmxJc0h0dHBIdHRwc1NjaGVtZShyLnVybCkpIHtcbiAgICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuI2JhdGNoQ2FjaGVPcGVyYXRpb25zJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ2V4cGVjdGVkIGh0dHAgb3IgaHR0cHMgc2NoZW1lJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LjIuNi40XG4gICAgICAgICAgaWYgKHIubWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnbm90IGdldCBtZXRob2QnXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDQuMi42LjVcbiAgICAgICAgICBpZiAob3BlcmF0aW9uLm9wdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnb3B0aW9ucyBtdXN0IG5vdCBiZSBkZWZpbmVkJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LjIuNi42XG4gICAgICAgICAgcmVxdWVzdFJlc3BvbnNlcyA9IHRoaXMuI3F1ZXJ5Q2FjaGUob3BlcmF0aW9uLnJlcXVlc3QpXG5cbiAgICAgICAgICAvLyA0LjIuNi43XG4gICAgICAgICAgZm9yIChjb25zdCByZXF1ZXN0UmVzcG9uc2Ugb2YgcmVxdWVzdFJlc3BvbnNlcykge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gY2FjaGUuaW5kZXhPZihyZXF1ZXN0UmVzcG9uc2UpXG4gICAgICAgICAgICBhc3NlcnQoaWR4ICE9PSAtMSlcblxuICAgICAgICAgICAgLy8gNC4yLjYuNy4xXG4gICAgICAgICAgICBjYWNoZS5zcGxpY2UoaWR4LCAxKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDQuMi42LjhcbiAgICAgICAgICBjYWNoZS5wdXNoKFtvcGVyYXRpb24ucmVxdWVzdCwgb3BlcmF0aW9uLnJlc3BvbnNlXSlcblxuICAgICAgICAgIC8vIDQuMi42LjEwXG4gICAgICAgICAgYWRkZWRJdGVtcy5wdXNoKFtvcGVyYXRpb24ucmVxdWVzdCwgb3BlcmF0aW9uLnJlc3BvbnNlXSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDQuMi43XG4gICAgICAgIHJlc3VsdExpc3QucHVzaChbb3BlcmF0aW9uLnJlcXVlc3QsIG9wZXJhdGlvbi5yZXNwb25zZV0pXG4gICAgICB9XG5cbiAgICAgIC8vIDQuM1xuICAgICAgcmV0dXJuIHJlc3VsdExpc3RcbiAgICB9IGNhdGNoIChlKSB7IC8vIDUuXG4gICAgICAvLyA1LjFcbiAgICAgIHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdC5sZW5ndGggPSAwXG5cbiAgICAgIC8vIDUuMlxuICAgICAgdGhpcy4jcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0ID0gYmFja3VwQ2FjaGVcblxuICAgICAgLy8gNS4zXG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI3F1ZXJ5LWNhY2hlXG4gICAqIEBwYXJhbSB7YW55fSByZXF1ZXN0UXVlcnlcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlJykuQ2FjaGVRdWVyeU9wdGlvbnN9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtyZXF1ZXN0UmVzcG9uc2VMaXN0fSB0YXJnZXRTdG9yYWdlXG4gICAqIEByZXR1cm5zIHtyZXF1ZXN0UmVzcG9uc2VMaXN0fVxuICAgKi9cbiAgI3F1ZXJ5Q2FjaGUgKHJlcXVlc3RRdWVyeSwgb3B0aW9ucywgdGFyZ2V0U3RvcmFnZSkge1xuICAgIC8qKiBAdHlwZSB7cmVxdWVzdFJlc3BvbnNlTGlzdH0gKi9cbiAgICBjb25zdCByZXN1bHRMaXN0ID0gW11cblxuICAgIGNvbnN0IHN0b3JhZ2UgPSB0YXJnZXRTdG9yYWdlID8/IHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdFxuXG4gICAgZm9yIChjb25zdCByZXF1ZXN0UmVzcG9uc2Ugb2Ygc3RvcmFnZSkge1xuICAgICAgY29uc3QgW2NhY2hlZFJlcXVlc3QsIGNhY2hlZFJlc3BvbnNlXSA9IHJlcXVlc3RSZXNwb25zZVxuICAgICAgaWYgKHRoaXMuI3JlcXVlc3RNYXRjaGVzQ2FjaGVkSXRlbShyZXF1ZXN0UXVlcnksIGNhY2hlZFJlcXVlc3QsIGNhY2hlZFJlc3BvbnNlLCBvcHRpb25zKSkge1xuICAgICAgICByZXN1bHRMaXN0LnB1c2gocmVxdWVzdFJlc3BvbnNlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRMaXN0XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jcmVxdWVzdC1tYXRjaGVzLWNhY2hlZC1pdGVtLWFsZ29yaXRobVxuICAgKiBAcGFyYW0ge2FueX0gcmVxdWVzdFF1ZXJ5XG4gICAqIEBwYXJhbSB7YW55fSByZXF1ZXN0XG4gICAqIEBwYXJhbSB7YW55IHwgbnVsbH0gcmVzcG9uc2VcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlJykuQ2FjaGVRdWVyeU9wdGlvbnMgfCB1bmRlZmluZWR9IG9wdGlvbnNcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICAjcmVxdWVzdE1hdGNoZXNDYWNoZWRJdGVtIChyZXF1ZXN0UXVlcnksIHJlcXVlc3QsIHJlc3BvbnNlID0gbnVsbCwgb3B0aW9ucykge1xuICAgIC8vIGlmIChvcHRpb25zPy5pZ25vcmVNZXRob2QgPT09IGZhbHNlICYmIHJlcXVlc3QubWV0aG9kID09PSAnR0VUJykge1xuICAgIC8vICAgcmV0dXJuIGZhbHNlXG4gICAgLy8gfVxuXG4gICAgY29uc3QgcXVlcnlVUkwgPSBuZXcgVVJMKHJlcXVlc3RRdWVyeS51cmwpXG5cbiAgICBjb25zdCBjYWNoZWRVUkwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKVxuXG4gICAgaWYgKG9wdGlvbnM/Lmlnbm9yZVNlYXJjaCkge1xuICAgICAgY2FjaGVkVVJMLnNlYXJjaCA9ICcnXG5cbiAgICAgIHF1ZXJ5VVJMLnNlYXJjaCA9ICcnXG4gICAgfVxuXG4gICAgaWYgKCF1cmxFcXVhbHMocXVlcnlVUkwsIGNhY2hlZFVSTCwgdHJ1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHJlc3BvbnNlID09IG51bGwgfHxcbiAgICAgIG9wdGlvbnM/Lmlnbm9yZVZhcnkgfHxcbiAgICAgICFyZXNwb25zZS5oZWFkZXJzTGlzdC5jb250YWlucygndmFyeScpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IGZpZWxkVmFsdWVzID0gZ2V0RmllbGRWYWx1ZXMocmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCd2YXJ5JykpXG5cbiAgICBmb3IgKGNvbnN0IGZpZWxkVmFsdWUgb2YgZmllbGRWYWx1ZXMpIHtcbiAgICAgIGlmIChmaWVsZFZhbHVlID09PSAnKicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlcXVlc3RWYWx1ZSA9IHJlcXVlc3QuaGVhZGVyc0xpc3QuZ2V0KGZpZWxkVmFsdWUpXG4gICAgICBjb25zdCBxdWVyeVZhbHVlID0gcmVxdWVzdFF1ZXJ5LmhlYWRlcnNMaXN0LmdldChmaWVsZFZhbHVlKVxuXG4gICAgICAvLyBJZiBvbmUgaGFzIHRoZSBoZWFkZXIgYW5kIHRoZSBvdGhlciBkb2Vzbid0LCBvciBvbmUgaGFzXG4gICAgICAvLyBhIGRpZmZlcmVudCB2YWx1ZSB0aGFuIHRoZSBvdGhlciwgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAocmVxdWVzdFZhbHVlICE9PSBxdWVyeVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2FjaGUucHJvdG90eXBlLCB7XG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdDYWNoZScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0sXG4gIG1hdGNoOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBtYXRjaEFsbDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYWRkOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBhZGRBbGw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHB1dDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZGVsZXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBrZXlzOiBrRW51bWVyYWJsZVByb3BlcnR5XG59KVxuXG5jb25zdCBjYWNoZVF1ZXJ5T3B0aW9uQ29udmVydGVycyA9IFtcbiAge1xuICAgIGtleTogJ2lnbm9yZVNlYXJjaCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2lnbm9yZU1ldGhvZCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2lnbm9yZVZhcnknLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6IGZhbHNlXG4gIH1cbl1cblxud2ViaWRsLmNvbnZlcnRlcnMuQ2FjaGVRdWVyeU9wdGlvbnMgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihjYWNoZVF1ZXJ5T3B0aW9uQ29udmVydGVycylcblxud2ViaWRsLmNvbnZlcnRlcnMuTXVsdGlDYWNoZVF1ZXJ5T3B0aW9ucyA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAgLi4uY2FjaGVRdWVyeU9wdGlvbkNvbnZlcnRlcnMsXG4gIHtcbiAgICBrZXk6ICdjYWNoZU5hbWUnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nXG4gIH1cbl0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLlJlc3BvbnNlID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihSZXNwb25zZSlcblxud2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPFJlcXVlc3RJbmZvPiddID0gd2ViaWRsLnNlcXVlbmNlQ29udmVydGVyKFxuICB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mb1xuKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ2FjaGVcbn1cbiJdLCJuYW1lcyI6WyJrQ29uc3RydWN0IiwicmVxdWlyZSIsInVybEVxdWFscyIsImZpZWxkVmFsdWVzIiwiZ2V0RmllbGRWYWx1ZXMiLCJrRW51bWVyYWJsZVByb3BlcnR5IiwiaXNEaXN0dXJiZWQiLCJrSGVhZGVyc0xpc3QiLCJ3ZWJpZGwiLCJSZXNwb25zZSIsImNsb25lUmVzcG9uc2UiLCJSZXF1ZXN0Iiwia1N0YXRlIiwia0hlYWRlcnMiLCJrR3VhcmQiLCJrUmVhbG0iLCJmZXRjaGluZyIsInVybElzSHR0cEh0dHBzU2NoZW1lIiwiY3JlYXRlRGVmZXJyZWRQcm9taXNlIiwicmVhZEFsbEJ5dGVzIiwiYXNzZXJ0IiwiZ2V0R2xvYmFsRGlzcGF0Y2hlciIsIkNhY2hlIiwicmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0IiwiY29uc3RydWN0b3IiLCJhcmd1bWVudHMiLCJpbGxlZ2FsQ29uc3RydWN0b3IiLCJtYXRjaCIsInJlcXVlc3QiLCJvcHRpb25zIiwiYnJhbmRDaGVjayIsImFyZ3VtZW50TGVuZ3RoQ2hlY2siLCJoZWFkZXIiLCJjb252ZXJ0ZXJzIiwiUmVxdWVzdEluZm8iLCJDYWNoZVF1ZXJ5T3B0aW9ucyIsInAiLCJtYXRjaEFsbCIsImxlbmd0aCIsInVuZGVmaW5lZCIsInIiLCJtZXRob2QiLCJpZ25vcmVNZXRob2QiLCJyZXNwb25zZXMiLCJyZXF1ZXN0UmVzcG9uc2UiLCJwdXNoIiwicmVxdWVzdFJlc3BvbnNlcyIsInF1ZXJ5Q2FjaGUiLCJyZXNwb25zZUxpc3QiLCJyZXNwb25zZSIsInJlc3BvbnNlT2JqZWN0IiwiYm9keSIsInNvdXJjZSIsImhlYWRlcnNMaXN0IiwiT2JqZWN0IiwiZnJlZXplIiwiYWRkIiwicmVxdWVzdHMiLCJyZXNwb25zZUFycmF5UHJvbWlzZSIsImFkZEFsbCIsInJlc3BvbnNlUHJvbWlzZXMiLCJyZXF1ZXN0TGlzdCIsInVybCIsImVycm9ycyIsImV4Y2VwdGlvbiIsIm1lc3NhZ2UiLCJmZXRjaENvbnRyb2xsZXJzIiwiaW5pdGlhdG9yIiwiZGVzdGluYXRpb24iLCJyZXNwb25zZVByb21pc2UiLCJkaXNwYXRjaGVyIiwicHJvY2Vzc1Jlc3BvbnNlIiwidHlwZSIsInN0YXR1cyIsInJlamVjdCIsImNvbnRhaW5zIiwiZ2V0IiwiZmllbGRWYWx1ZSIsImNvbnRyb2xsZXIiLCJhYm9ydCIsInByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSIsImFib3J0ZWQiLCJET01FeGNlcHRpb24iLCJyZXNvbHZlIiwicHJvbWlzZSIsIlByb21pc2UiLCJhbGwiLCJvcGVyYXRpb25zIiwiaW5kZXgiLCJvcGVyYXRpb24iLCJjYWNoZUpvYlByb21pc2UiLCJlcnJvckRhdGEiLCJiYXRjaENhY2hlT3BlcmF0aW9ucyIsImUiLCJxdWV1ZU1pY3JvdGFzayIsInB1dCIsImlubmVyUmVxdWVzdCIsImlubmVyUmVzcG9uc2UiLCJzdHJlYW0iLCJsb2NrZWQiLCJjbG9uZWRSZXNwb25zZSIsImJvZHlSZWFkUHJvbWlzZSIsInJlYWRlciIsImdldFJlYWRlciIsInRoZW4iLCJieXRlcyIsImRlbGV0ZSIsImtleXMiLCJyZXF1ZXN0T2JqZWN0IiwiY2xpZW50IiwiY2FjaGUiLCJiYWNrdXBDYWNoZSIsImFkZGVkSXRlbXMiLCJyZXN1bHRMaXN0IiwiaWR4IiwiaW5kZXhPZiIsInNwbGljZSIsInJlcXVlc3RRdWVyeSIsInRhcmdldFN0b3JhZ2UiLCJzdG9yYWdlIiwiY2FjaGVkUmVxdWVzdCIsImNhY2hlZFJlc3BvbnNlIiwicmVxdWVzdE1hdGNoZXNDYWNoZWRJdGVtIiwicXVlcnlVUkwiLCJVUkwiLCJjYWNoZWRVUkwiLCJpZ25vcmVTZWFyY2giLCJzZWFyY2giLCJpZ25vcmVWYXJ5IiwicmVxdWVzdFZhbHVlIiwicXVlcnlWYWx1ZSIsImRlZmluZVByb3BlcnRpZXMiLCJwcm90b3R5cGUiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwiY2FjaGVRdWVyeU9wdGlvbkNvbnZlcnRlcnMiLCJrZXkiLCJjb252ZXJ0ZXIiLCJib29sZWFuIiwiZGVmYXVsdFZhbHVlIiwiZGljdGlvbmFyeUNvbnZlcnRlciIsIk11bHRpQ2FjaGVRdWVyeU9wdGlvbnMiLCJET01TdHJpbmciLCJpbnRlcmZhY2VDb252ZXJ0ZXIiLCJzZXF1ZW5jZUNvbnZlcnRlciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/cache/cache.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/cache/cachestorage.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/cache/cachestorage.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kConstruct } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/cache/symbols.js\");\nconst { Cache } = __webpack_require__(/*! ./cache */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/cache/cache.js\");\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/webidl.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nclass CacheStorage {\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map\n   * @type {Map<string, import('./cache').requestResponseList}\n   */ #caches;\n    constructor(){\n        this.#caches = new Map();\n        if (arguments[0] !== kConstruct) {\n            webidl.illegalConstructor();\n        }\n    }\n    async match(request, options = {}) {\n        webidl.brandCheck(this, CacheStorage);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"CacheStorage.match\"\n        });\n        request = webidl.converters.RequestInfo(request);\n        options = webidl.converters.MultiCacheQueryOptions(options);\n        // 1.\n        if (options.cacheName != null) {\n            // 1.1.1.1\n            if (this.#caches.has(options.cacheName)) {\n                // 1.1.1.1.1\n                const cacheList = this.#caches.get(options.cacheName);\n                const cache = new Cache(kConstruct, cacheList);\n                return await cache.match(request, options);\n            }\n        } else {\n            // 2.2\n            for (const cacheList of this.#caches.values()){\n                const cache = new Cache(kConstruct, cacheList);\n                // 2.2.1.2\n                const response = await cache.match(request, options);\n                if (response !== undefined) {\n                    return response;\n                }\n            }\n        }\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-has\n   * @param {string} cacheName\n   * @returns {Promise<boolean>}\n   */ async has(cacheName) {\n        webidl.brandCheck(this, CacheStorage);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"CacheStorage.has\"\n        });\n        cacheName = webidl.converters.DOMString(cacheName);\n        // 2.1.1\n        // 2.2\n        return this.#caches.has(cacheName);\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open\n   * @param {string} cacheName\n   * @returns {Promise<Cache>}\n   */ async open(cacheName) {\n        webidl.brandCheck(this, CacheStorage);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"CacheStorage.open\"\n        });\n        cacheName = webidl.converters.DOMString(cacheName);\n        // 2.1\n        if (this.#caches.has(cacheName)) {\n            // await caches.open('v1') !== await caches.open('v1')\n            // 2.1.1\n            const cache = this.#caches.get(cacheName);\n            // 2.1.1.1\n            return new Cache(kConstruct, cache);\n        }\n        // 2.2\n        const cache = [];\n        // 2.3\n        this.#caches.set(cacheName, cache);\n        // 2.4\n        return new Cache(kConstruct, cache);\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete\n   * @param {string} cacheName\n   * @returns {Promise<boolean>}\n   */ async delete(cacheName) {\n        webidl.brandCheck(this, CacheStorage);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"CacheStorage.delete\"\n        });\n        cacheName = webidl.converters.DOMString(cacheName);\n        return this.#caches.delete(cacheName);\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys\n   * @returns {string[]}\n   */ async keys() {\n        webidl.brandCheck(this, CacheStorage);\n        // 2.1\n        const keys = this.#caches.keys();\n        // 2.2\n        return [\n            ...keys\n        ];\n    }\n}\nObject.defineProperties(CacheStorage.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"CacheStorage\",\n        configurable: true\n    },\n    match: kEnumerableProperty,\n    has: kEnumerableProperty,\n    open: kEnumerableProperty,\n    delete: kEnumerableProperty,\n    keys: kEnumerableProperty\n});\nmodule.exports = {\n    CacheStorage\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY2FjaGUvY2FjaGVzdG9yYWdlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxVQUFVLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDL0IsTUFBTSxFQUFFQyxLQUFLLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFDMUIsTUFBTSxFQUFFRSxNQUFNLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFRyxtQkFBbUIsRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQztBQUV4QyxNQUFNSTtJQUNKOzs7R0FHQyxHQUNELENBQUNDLE1BQU0sQ0FBWTtJQUVuQkMsYUFBZTthQUZmLENBQUNELE1BQU0sR0FBRyxJQUFJRTtRQUdaLElBQUlDLFNBQVMsQ0FBQyxFQUFFLEtBQUtULFlBQVk7WUFDL0JHLE9BQU9PLGtCQUFrQjtRQUMzQjtJQUNGO0lBRUEsTUFBTUMsTUFBT0MsT0FBTyxFQUFFQyxVQUFVLENBQUMsQ0FBQyxFQUFFO1FBQ2xDVixPQUFPVyxVQUFVLENBQUMsSUFBSSxFQUFFVDtRQUN4QkYsT0FBT1ksbUJBQW1CLENBQUNOLFdBQVcsR0FBRztZQUFFTyxRQUFRO1FBQXFCO1FBRXhFSixVQUFVVCxPQUFPYyxVQUFVLENBQUNDLFdBQVcsQ0FBQ047UUFDeENDLFVBQVVWLE9BQU9jLFVBQVUsQ0FBQ0Usc0JBQXNCLENBQUNOO1FBRW5ELEtBQUs7UUFDTCxJQUFJQSxRQUFRTyxTQUFTLElBQUksTUFBTTtZQUM3QixVQUFVO1lBQ1YsSUFBSSxJQUFJLENBQUMsQ0FBQ2QsTUFBTSxDQUFDZSxHQUFHLENBQUNSLFFBQVFPLFNBQVMsR0FBRztnQkFDdkMsWUFBWTtnQkFDWixNQUFNRSxZQUFZLElBQUksQ0FBQyxDQUFDaEIsTUFBTSxDQUFDaUIsR0FBRyxDQUFDVixRQUFRTyxTQUFTO2dCQUNwRCxNQUFNSSxRQUFRLElBQUl0QixNQUFNRixZQUFZc0I7Z0JBRXBDLE9BQU8sTUFBTUUsTUFBTWIsS0FBSyxDQUFDQyxTQUFTQztZQUNwQztRQUNGLE9BQU87WUFDTCxNQUFNO1lBQ04sS0FBSyxNQUFNUyxhQUFhLElBQUksQ0FBQyxDQUFDaEIsTUFBTSxDQUFDbUIsTUFBTSxHQUFJO2dCQUM3QyxNQUFNRCxRQUFRLElBQUl0QixNQUFNRixZQUFZc0I7Z0JBRXBDLFVBQVU7Z0JBQ1YsTUFBTUksV0FBVyxNQUFNRixNQUFNYixLQUFLLENBQUNDLFNBQVNDO2dCQUU1QyxJQUFJYSxhQUFhQyxXQUFXO29CQUMxQixPQUFPRDtnQkFDVDtZQUNGO1FBQ0Y7SUFDRjtJQUVBOzs7O0dBSUMsR0FDRCxNQUFNTCxJQUFLRCxTQUFTLEVBQUU7UUFDcEJqQixPQUFPVyxVQUFVLENBQUMsSUFBSSxFQUFFVDtRQUN4QkYsT0FBT1ksbUJBQW1CLENBQUNOLFdBQVcsR0FBRztZQUFFTyxRQUFRO1FBQW1CO1FBRXRFSSxZQUFZakIsT0FBT2MsVUFBVSxDQUFDVyxTQUFTLENBQUNSO1FBRXhDLFFBQVE7UUFDUixNQUFNO1FBQ04sT0FBTyxJQUFJLENBQUMsQ0FBQ2QsTUFBTSxDQUFDZSxHQUFHLENBQUNEO0lBQzFCO0lBRUE7Ozs7R0FJQyxHQUNELE1BQU1TLEtBQU1ULFNBQVMsRUFBRTtRQUNyQmpCLE9BQU9XLFVBQVUsQ0FBQyxJQUFJLEVBQUVUO1FBQ3hCRixPQUFPWSxtQkFBbUIsQ0FBQ04sV0FBVyxHQUFHO1lBQUVPLFFBQVE7UUFBb0I7UUFFdkVJLFlBQVlqQixPQUFPYyxVQUFVLENBQUNXLFNBQVMsQ0FBQ1I7UUFFeEMsTUFBTTtRQUNOLElBQUksSUFBSSxDQUFDLENBQUNkLE1BQU0sQ0FBQ2UsR0FBRyxDQUFDRCxZQUFZO1lBQy9CLHNEQUFzRDtZQUV0RCxRQUFRO1lBQ1IsTUFBTUksUUFBUSxJQUFJLENBQUMsQ0FBQ2xCLE1BQU0sQ0FBQ2lCLEdBQUcsQ0FBQ0g7WUFFL0IsVUFBVTtZQUNWLE9BQU8sSUFBSWxCLE1BQU1GLFlBQVl3QjtRQUMvQjtRQUVBLE1BQU07UUFDTixNQUFNQSxRQUFRLEVBQUU7UUFFaEIsTUFBTTtRQUNOLElBQUksQ0FBQyxDQUFDbEIsTUFBTSxDQUFDd0IsR0FBRyxDQUFDVixXQUFXSTtRQUU1QixNQUFNO1FBQ04sT0FBTyxJQUFJdEIsTUFBTUYsWUFBWXdCO0lBQy9CO0lBRUE7Ozs7R0FJQyxHQUNELE1BQU1PLE9BQVFYLFNBQVMsRUFBRTtRQUN2QmpCLE9BQU9XLFVBQVUsQ0FBQyxJQUFJLEVBQUVUO1FBQ3hCRixPQUFPWSxtQkFBbUIsQ0FBQ04sV0FBVyxHQUFHO1lBQUVPLFFBQVE7UUFBc0I7UUFFekVJLFlBQVlqQixPQUFPYyxVQUFVLENBQUNXLFNBQVMsQ0FBQ1I7UUFFeEMsT0FBTyxJQUFJLENBQUMsQ0FBQ2QsTUFBTSxDQUFDeUIsTUFBTSxDQUFDWDtJQUM3QjtJQUVBOzs7R0FHQyxHQUNELE1BQU1ZLE9BQVE7UUFDWjdCLE9BQU9XLFVBQVUsQ0FBQyxJQUFJLEVBQUVUO1FBRXhCLE1BQU07UUFDTixNQUFNMkIsT0FBTyxJQUFJLENBQUMsQ0FBQzFCLE1BQU0sQ0FBQzBCLElBQUk7UUFFOUIsTUFBTTtRQUNOLE9BQU87ZUFBSUE7U0FBSztJQUNsQjtBQUNGO0FBRUFDLE9BQU9DLGdCQUFnQixDQUFDN0IsYUFBYThCLFNBQVMsRUFBRTtJQUM5QyxDQUFDQyxPQUFPQyxXQUFXLENBQUMsRUFBRTtRQUNwQkMsT0FBTztRQUNQQyxjQUFjO0lBQ2hCO0lBQ0E1QixPQUFPUDtJQUNQaUIsS0FBS2pCO0lBQ0x5QixNQUFNekI7SUFDTjJCLFFBQVEzQjtJQUNSNEIsTUFBTTVCO0FBQ1I7QUFFQW9DLE9BQU9DLE9BQU8sR0FBRztJQUNmcEM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NhY2hlL2NhY2hlc3RvcmFnZS5qcz84NWFjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGtDb25zdHJ1Y3QgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IENhY2hlIH0gPSByZXF1aXJlKCcuL2NhY2hlJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi9mZXRjaC93ZWJpZGwnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuXG5jbGFzcyBDYWNoZVN0b3JhZ2Uge1xuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZGZuLXJlbGV2YW50LW5hbWUtdG8tY2FjaGUtbWFwXG4gICAqIEB0eXBlIHtNYXA8c3RyaW5nLCBpbXBvcnQoJy4vY2FjaGUnKS5yZXF1ZXN0UmVzcG9uc2VMaXN0fVxuICAgKi9cbiAgI2NhY2hlcyA9IG5ldyBNYXAoKVxuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdICE9PSBrQ29uc3RydWN0KSB7XG4gICAgICB3ZWJpZGwuaWxsZWdhbENvbnN0cnVjdG9yKClcbiAgICB9XG4gIH1cblxuICBhc3luYyBtYXRjaCAocmVxdWVzdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGVTdG9yYWdlKVxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdDYWNoZVN0b3JhZ2UubWF0Y2gnIH0pXG5cbiAgICByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdClcbiAgICBvcHRpb25zID0gd2ViaWRsLmNvbnZlcnRlcnMuTXVsdGlDYWNoZVF1ZXJ5T3B0aW9ucyhvcHRpb25zKVxuXG4gICAgLy8gMS5cbiAgICBpZiAob3B0aW9ucy5jYWNoZU5hbWUgIT0gbnVsbCkge1xuICAgICAgLy8gMS4xLjEuMVxuICAgICAgaWYgKHRoaXMuI2NhY2hlcy5oYXMob3B0aW9ucy5jYWNoZU5hbWUpKSB7XG4gICAgICAgIC8vIDEuMS4xLjEuMVxuICAgICAgICBjb25zdCBjYWNoZUxpc3QgPSB0aGlzLiNjYWNoZXMuZ2V0KG9wdGlvbnMuY2FjaGVOYW1lKVxuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBDYWNoZShrQ29uc3RydWN0LCBjYWNoZUxpc3QpXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IGNhY2hlLm1hdGNoKHJlcXVlc3QsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gMi5cbiAgICAgIC8vIDIuMlxuICAgICAgZm9yIChjb25zdCBjYWNoZUxpc3Qgb2YgdGhpcy4jY2FjaGVzLnZhbHVlcygpKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gbmV3IENhY2hlKGtDb25zdHJ1Y3QsIGNhY2hlTGlzdClcblxuICAgICAgICAvLyAyLjIuMS4yXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2FjaGUubWF0Y2gocmVxdWVzdCwgb3B0aW9ucylcblxuICAgICAgICBpZiAocmVzcG9uc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiByZXNwb25zZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2NhY2hlLXN0b3JhZ2UtaGFzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWVcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAqL1xuICBhc3luYyBoYXMgKGNhY2hlTmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlU3RvcmFnZSlcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnQ2FjaGVTdG9yYWdlLmhhcycgfSlcblxuICAgIGNhY2hlTmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhjYWNoZU5hbWUpXG5cbiAgICAvLyAyLjEuMVxuICAgIC8vIDIuMlxuICAgIHJldHVybiB0aGlzLiNjYWNoZXMuaGFzKGNhY2hlTmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNkb20tY2FjaGVzdG9yYWdlLW9wZW5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZT59XG4gICAqL1xuICBhc3luYyBvcGVuIChjYWNoZU5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZVN0b3JhZ2UpXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0NhY2hlU3RvcmFnZS5vcGVuJyB9KVxuXG4gICAgY2FjaGVOYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKGNhY2hlTmFtZSlcblxuICAgIC8vIDIuMVxuICAgIGlmICh0aGlzLiNjYWNoZXMuaGFzKGNhY2hlTmFtZSkpIHtcbiAgICAgIC8vIGF3YWl0IGNhY2hlcy5vcGVuKCd2MScpICE9PSBhd2FpdCBjYWNoZXMub3BlbigndjEnKVxuXG4gICAgICAvLyAyLjEuMVxuICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLiNjYWNoZXMuZ2V0KGNhY2hlTmFtZSlcblxuICAgICAgLy8gMi4xLjEuMVxuICAgICAgcmV0dXJuIG5ldyBDYWNoZShrQ29uc3RydWN0LCBjYWNoZSlcbiAgICB9XG5cbiAgICAvLyAyLjJcbiAgICBjb25zdCBjYWNoZSA9IFtdXG5cbiAgICAvLyAyLjNcbiAgICB0aGlzLiNjYWNoZXMuc2V0KGNhY2hlTmFtZSwgY2FjaGUpXG5cbiAgICAvLyAyLjRcbiAgICByZXR1cm4gbmV3IENhY2hlKGtDb25zdHJ1Y3QsIGNhY2hlKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2NhY2hlLXN0b3JhZ2UtZGVsZXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWVcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAqL1xuICBhc3luYyBkZWxldGUgKGNhY2hlTmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlU3RvcmFnZSlcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnQ2FjaGVTdG9yYWdlLmRlbGV0ZScgfSlcblxuICAgIGNhY2hlTmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhjYWNoZU5hbWUpXG5cbiAgICByZXR1cm4gdGhpcy4jY2FjaGVzLmRlbGV0ZShjYWNoZU5hbWUpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jY2FjaGUtc3RvcmFnZS1rZXlzXG4gICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICovXG4gIGFzeW5jIGtleXMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlU3RvcmFnZSlcblxuICAgIC8vIDIuMVxuICAgIGNvbnN0IGtleXMgPSB0aGlzLiNjYWNoZXMua2V5cygpXG5cbiAgICAvLyAyLjJcbiAgICByZXR1cm4gWy4uLmtleXNdXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2FjaGVTdG9yYWdlLnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnQ2FjaGVTdG9yYWdlJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSxcbiAgbWF0Y2g6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGhhczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb3Blbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZGVsZXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBrZXlzOiBrRW51bWVyYWJsZVByb3BlcnR5XG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ2FjaGVTdG9yYWdlXG59XG4iXSwibmFtZXMiOlsia0NvbnN0cnVjdCIsInJlcXVpcmUiLCJDYWNoZSIsIndlYmlkbCIsImtFbnVtZXJhYmxlUHJvcGVydHkiLCJDYWNoZVN0b3JhZ2UiLCJjYWNoZXMiLCJjb25zdHJ1Y3RvciIsIk1hcCIsImFyZ3VtZW50cyIsImlsbGVnYWxDb25zdHJ1Y3RvciIsIm1hdGNoIiwicmVxdWVzdCIsIm9wdGlvbnMiLCJicmFuZENoZWNrIiwiYXJndW1lbnRMZW5ndGhDaGVjayIsImhlYWRlciIsImNvbnZlcnRlcnMiLCJSZXF1ZXN0SW5mbyIsIk11bHRpQ2FjaGVRdWVyeU9wdGlvbnMiLCJjYWNoZU5hbWUiLCJoYXMiLCJjYWNoZUxpc3QiLCJnZXQiLCJjYWNoZSIsInZhbHVlcyIsInJlc3BvbnNlIiwidW5kZWZpbmVkIiwiRE9NU3RyaW5nIiwib3BlbiIsInNldCIsImRlbGV0ZSIsImtleXMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJvdG90eXBlIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsImNvbmZpZ3VyYWJsZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/cache/cachestorage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/cache/symbols.js":
/*!************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/cache/symbols.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = {\n    kConstruct: (__webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\").kConstruct)\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY2FjaGUvc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSxPQUFPQyxPQUFPLEdBQUc7SUFDZkMsWUFBWUMsZ0lBQXFDO0FBQ25EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1maWdodGVyLWFjYWRlbXkvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY2FjaGUvc3ltYm9scy5qcz83ZmI5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAga0NvbnN0cnVjdDogcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJykua0NvbnN0cnVjdFxufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJrQ29uc3RydWN0IiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/cache/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/cache/util.js":
/*!*********************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/cache/util.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { URLSerializer } = __webpack_require__(/*! ../fetch/dataURL */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/dataURL.js\");\nconst { isValidHeaderName } = __webpack_require__(/*! ../fetch/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/util.js\");\n/**\n * @see https://url.spec.whatwg.org/#concept-url-equals\n * @param {URL} A\n * @param {URL} B\n * @param {boolean | undefined} excludeFragment\n * @returns {boolean}\n */ function urlEquals(A, B, excludeFragment = false) {\n    const serializedA = URLSerializer(A, excludeFragment);\n    const serializedB = URLSerializer(B, excludeFragment);\n    return serializedA === serializedB;\n}\n/**\n * @see https://github.com/chromium/chromium/blob/694d20d134cb553d8d89e5500b9148012b1ba299/content/browser/cache_storage/cache_storage_cache.cc#L260-L262\n * @param {string} header\n */ function fieldValues(header) {\n    assert(header !== null);\n    const values = [];\n    for (let value of header.split(\",\")){\n        value = value.trim();\n        if (!value.length) {\n            continue;\n        } else if (!isValidHeaderName(value)) {\n            continue;\n        }\n        values.push(value);\n    }\n    return values;\n}\nmodule.exports = {\n    urlEquals,\n    fieldValues\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY2FjaGUvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRUMsYUFBYSxFQUFFLEdBQUdELG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU0sRUFBRUUsaUJBQWlCLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFFdEM7Ozs7OztDQU1DLEdBQ0QsU0FBU0csVUFBV0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLGtCQUFrQixLQUFLO0lBQy9DLE1BQU1DLGNBQWNOLGNBQWNHLEdBQUdFO0lBRXJDLE1BQU1FLGNBQWNQLGNBQWNJLEdBQUdDO0lBRXJDLE9BQU9DLGdCQUFnQkM7QUFDekI7QUFFQTs7O0NBR0MsR0FDRCxTQUFTQyxZQUFhQyxNQUFNO0lBQzFCWCxPQUFPVyxXQUFXO0lBRWxCLE1BQU1DLFNBQVMsRUFBRTtJQUVqQixLQUFLLElBQUlDLFNBQVNGLE9BQU9HLEtBQUssQ0FBQyxLQUFNO1FBQ25DRCxRQUFRQSxNQUFNRSxJQUFJO1FBRWxCLElBQUksQ0FBQ0YsTUFBTUcsTUFBTSxFQUFFO1lBQ2pCO1FBQ0YsT0FBTyxJQUFJLENBQUNiLGtCQUFrQlUsUUFBUTtZQUNwQztRQUNGO1FBRUFELE9BQU9LLElBQUksQ0FBQ0o7SUFDZDtJQUVBLE9BQU9EO0FBQ1Q7QUFFQU0sT0FBT0MsT0FBTyxHQUFHO0lBQ2ZmO0lBQ0FNO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jYWNoZS91dGlsLmpzP2RiMzUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCB7IFVSTFNlcmlhbGl6ZXIgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2RhdGFVUkwnKVxuY29uc3QgeyBpc1ZhbGlkSGVhZGVyTmFtZSB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvdXRpbCcpXG5cbi8qKlxuICogQHNlZSBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtdXJsLWVxdWFsc1xuICogQHBhcmFtIHtVUkx9IEFcbiAqIEBwYXJhbSB7VVJMfSBCXG4gKiBAcGFyYW0ge2Jvb2xlYW4gfCB1bmRlZmluZWR9IGV4Y2x1ZGVGcmFnbWVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHVybEVxdWFscyAoQSwgQiwgZXhjbHVkZUZyYWdtZW50ID0gZmFsc2UpIHtcbiAgY29uc3Qgc2VyaWFsaXplZEEgPSBVUkxTZXJpYWxpemVyKEEsIGV4Y2x1ZGVGcmFnbWVudClcblxuICBjb25zdCBzZXJpYWxpemVkQiA9IFVSTFNlcmlhbGl6ZXIoQiwgZXhjbHVkZUZyYWdtZW50KVxuXG4gIHJldHVybiBzZXJpYWxpemVkQSA9PT0gc2VyaWFsaXplZEJcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaHJvbWl1bS9jaHJvbWl1bS9ibG9iLzY5NGQyMGQxMzRjYjU1M2Q4ZDg5ZTU1MDBiOTE0ODAxMmIxYmEyOTkvY29udGVudC9icm93c2VyL2NhY2hlX3N0b3JhZ2UvY2FjaGVfc3RvcmFnZV9jYWNoZS5jYyNMMjYwLUwyNjJcbiAqIEBwYXJhbSB7c3RyaW5nfSBoZWFkZXJcbiAqL1xuZnVuY3Rpb24gZmllbGRWYWx1ZXMgKGhlYWRlcikge1xuICBhc3NlcnQoaGVhZGVyICE9PSBudWxsKVxuXG4gIGNvbnN0IHZhbHVlcyA9IFtdXG5cbiAgZm9yIChsZXQgdmFsdWUgb2YgaGVhZGVyLnNwbGl0KCcsJykpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKVxuXG4gICAgaWYgKCF2YWx1ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfSBlbHNlIGlmICghaXNWYWxpZEhlYWRlck5hbWUodmFsdWUpKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHZhbHVlcy5wdXNoKHZhbHVlKVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlc1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdXJsRXF1YWxzLFxuICBmaWVsZFZhbHVlc1xufVxuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJVUkxTZXJpYWxpemVyIiwiaXNWYWxpZEhlYWRlck5hbWUiLCJ1cmxFcXVhbHMiLCJBIiwiQiIsImV4Y2x1ZGVGcmFnbWVudCIsInNlcmlhbGl6ZWRBIiwic2VyaWFsaXplZEIiLCJmaWVsZFZhbHVlcyIsImhlYWRlciIsInZhbHVlcyIsInZhbHVlIiwic3BsaXQiLCJ0cmltIiwibGVuZ3RoIiwicHVzaCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/cache/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/client.js":
/*!*****************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/client.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// @ts-check\n\n/* global WebAssembly */ const assert = __webpack_require__(/*! assert */ \"assert\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst { pipeline } = __webpack_require__(/*! stream */ \"stream\");\nconst util = __webpack_require__(/*! ./core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst timers = __webpack_require__(/*! ./timers */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/timers.js\");\nconst Request = __webpack_require__(/*! ./core/request */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/request.js\");\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/dispatcher-base.js\");\nconst { RequestContentLengthMismatchError, ResponseContentLengthMismatchError, InvalidArgumentError, RequestAbortedError, HeadersTimeoutError, HeadersOverflowError, SocketError, InformationalError, BodyTimeoutError, HTTPParserError, ResponseExceededMaxSizeError, ClientDestroyedError } = __webpack_require__(/*! ./core/errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\nconst buildConnector = __webpack_require__(/*! ./core/connect */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/connect.js\");\nconst { kUrl, kReset, kServerName, kClient, kBusy, kParser, kConnect, kBlocking, kResuming, kRunning, kPending, kSize, kWriting, kQueue, kConnected, kConnecting, kNeedDrain, kNoRef, kKeepAliveDefaultTimeout, kHostHeader, kPendingIdx, kRunningIdx, kError, kPipelining, kSocket, kKeepAliveTimeoutValue, kMaxHeadersSize, kKeepAliveMaxTimeout, kKeepAliveTimeoutThreshold, kHeadersTimeout, kBodyTimeout, kStrictContentLength, kConnector, kMaxRedirections, kMaxRequests, kCounter, kClose, kDestroy, kDispatch, kInterceptors, kLocalAddress, kMaxResponseSize, kHTTPConnVersion, // HTTP2\nkHost, kHTTP2Session, kHTTP2SessionState, kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = __webpack_require__(/*! ./core/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\");\n/** @type {import('http2')} */ let http2;\ntry {\n    http2 = __webpack_require__(/*! http2 */ \"http2\");\n} catch  {\n    // @ts-ignore\n    http2 = {\n        constants: {}\n    };\n}\nconst { constants: { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_SCHEME, HTTP2_HEADER_CONTENT_LENGTH, HTTP2_HEADER_EXPECT, HTTP2_HEADER_STATUS } } = http2;\n// Experimental\nlet h2ExperimentalWarned = false;\nconst FastBuffer = Buffer[Symbol.species];\nconst kClosedResolve = Symbol(\"kClosedResolve\");\nconst channels = {};\ntry {\n    const diagnosticsChannel = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\");\n    channels.sendHeaders = diagnosticsChannel.channel(\"undici:client:sendHeaders\");\n    channels.beforeConnect = diagnosticsChannel.channel(\"undici:client:beforeConnect\");\n    channels.connectError = diagnosticsChannel.channel(\"undici:client:connectError\");\n    channels.connected = diagnosticsChannel.channel(\"undici:client:connected\");\n} catch  {\n    channels.sendHeaders = {\n        hasSubscribers: false\n    };\n    channels.beforeConnect = {\n        hasSubscribers: false\n    };\n    channels.connectError = {\n        hasSubscribers: false\n    };\n    channels.connected = {\n        hasSubscribers: false\n    };\n}\n/**\n * @type {import('../types/client').default}\n */ class Client extends DispatcherBase {\n    /**\n   *\n   * @param {string|URL} url\n   * @param {import('../types/client').Client.Options} options\n   */ constructor(url, { interceptors, maxHeaderSize, headersTimeout, socketTimeout, requestTimeout, connectTimeout, bodyTimeout, idleTimeout, keepAlive, keepAliveTimeout, maxKeepAliveTimeout, keepAliveMaxTimeout, keepAliveTimeoutThreshold, socketPath, pipelining, tls, strictContentLength, maxCachedSessions, maxRedirections, connect, maxRequestsPerClient, localAddress, maxResponseSize, autoSelectFamily, autoSelectFamilyAttemptTimeout, // h2\n    allowH2, maxConcurrentStreams } = {}){\n        super();\n        if (keepAlive !== undefined) {\n            throw new InvalidArgumentError(\"unsupported keepAlive, use pipelining=0 instead\");\n        }\n        if (socketTimeout !== undefined) {\n            throw new InvalidArgumentError(\"unsupported socketTimeout, use headersTimeout & bodyTimeout instead\");\n        }\n        if (requestTimeout !== undefined) {\n            throw new InvalidArgumentError(\"unsupported requestTimeout, use headersTimeout & bodyTimeout instead\");\n        }\n        if (idleTimeout !== undefined) {\n            throw new InvalidArgumentError(\"unsupported idleTimeout, use keepAliveTimeout instead\");\n        }\n        if (maxKeepAliveTimeout !== undefined) {\n            throw new InvalidArgumentError(\"unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead\");\n        }\n        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n            throw new InvalidArgumentError(\"invalid maxHeaderSize\");\n        }\n        if (socketPath != null && typeof socketPath !== \"string\") {\n            throw new InvalidArgumentError(\"invalid socketPath\");\n        }\n        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n            throw new InvalidArgumentError(\"invalid connectTimeout\");\n        }\n        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n            throw new InvalidArgumentError(\"invalid keepAliveTimeout\");\n        }\n        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n            throw new InvalidArgumentError(\"invalid keepAliveMaxTimeout\");\n        }\n        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n            throw new InvalidArgumentError(\"invalid keepAliveTimeoutThreshold\");\n        }\n        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n            throw new InvalidArgumentError(\"headersTimeout must be a positive integer or zero\");\n        }\n        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n            throw new InvalidArgumentError(\"bodyTimeout must be a positive integer or zero\");\n        }\n        if (connect != null && typeof connect !== \"function\" && typeof connect !== \"object\") {\n            throw new InvalidArgumentError(\"connect must be a function or an object\");\n        }\n        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n            throw new InvalidArgumentError(\"maxRedirections must be a positive number\");\n        }\n        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n            throw new InvalidArgumentError(\"maxRequestsPerClient must be a positive number\");\n        }\n        if (localAddress != null && (typeof localAddress !== \"string\" || net.isIP(localAddress) === 0)) {\n            throw new InvalidArgumentError(\"localAddress must be valid string IP address\");\n        }\n        if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {\n            throw new InvalidArgumentError(\"maxResponseSize must be a positive number\");\n        }\n        if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {\n            throw new InvalidArgumentError(\"autoSelectFamilyAttemptTimeout must be a positive number\");\n        }\n        // h2\n        if (allowH2 != null && typeof allowH2 !== \"boolean\") {\n            throw new InvalidArgumentError(\"allowH2 must be a valid boolean value\");\n        }\n        if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== \"number\" || maxConcurrentStreams < 1)) {\n            throw new InvalidArgumentError(\"maxConcurrentStreams must be a possitive integer, greater than 0\");\n        }\n        if (typeof connect !== \"function\") {\n            connect = buildConnector({\n                ...tls,\n                maxCachedSessions,\n                allowH2,\n                socketPath,\n                timeout: connectTimeout,\n                ...util.nodeHasAutoSelectFamily && autoSelectFamily ? {\n                    autoSelectFamily,\n                    autoSelectFamilyAttemptTimeout\n                } : undefined,\n                ...connect\n            });\n        }\n        this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [\n            createRedirectInterceptor({\n                maxRedirections\n            })\n        ];\n        this[kUrl] = util.parseOrigin(url);\n        this[kConnector] = connect;\n        this[kSocket] = null;\n        this[kPipelining] = pipelining != null ? pipelining : 1;\n        this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;\n        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;\n        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout;\n        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;\n        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];\n        this[kServerName] = null;\n        this[kLocalAddress] = localAddress != null ? localAddress : null;\n        this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming\n        ;\n        this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming\n        ;\n        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : \"\"}\\r\\n`;\n        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3;\n        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3;\n        this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;\n        this[kMaxRedirections] = maxRedirections;\n        this[kMaxRequests] = maxRequestsPerClient;\n        this[kClosedResolve] = null;\n        this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;\n        this[kHTTPConnVersion] = \"h1\";\n        // HTTP/2\n        this[kHTTP2Session] = null;\n        this[kHTTP2SessionState] = !allowH2 ? null : {\n            // streams: null, // Fixed queue of streams - For future support of `push`\n            openStreams: 0,\n            maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100 // Max peerConcurrentStreams for a Node h2 server\n        };\n        this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : \"\"}`;\n        // kQueue is built up of 3 sections separated by\n        // the kRunningIdx and kPendingIdx indices.\n        // |   complete   |   running   |   pending   |\n        //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n        // kRunningIdx points to the first running element.\n        // kPendingIdx points to the first pending element.\n        // This implements a fast queue with an amortized\n        // time of O(1).\n        this[kQueue] = [];\n        this[kRunningIdx] = 0;\n        this[kPendingIdx] = 0;\n    }\n    get pipelining() {\n        return this[kPipelining];\n    }\n    set pipelining(value) {\n        this[kPipelining] = value;\n        resume(this, true);\n    }\n    get [kPending]() {\n        return this[kQueue].length - this[kPendingIdx];\n    }\n    get [kRunning]() {\n        return this[kPendingIdx] - this[kRunningIdx];\n    }\n    get [kSize]() {\n        return this[kQueue].length - this[kRunningIdx];\n    }\n    get [kConnected]() {\n        return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;\n    }\n    get [kBusy]() {\n        const socket = this[kSocket];\n        return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;\n    }\n    /* istanbul ignore: only used for test */ [kConnect](cb) {\n        connect(this);\n        this.once(\"connect\", cb);\n    }\n    [kDispatch](opts, handler) {\n        const origin = opts.origin || this[kUrl].origin;\n        const request = this[kHTTPConnVersion] === \"h2\" ? Request[kHTTP2BuildRequest](origin, opts, handler) : Request[kHTTP1BuildRequest](origin, opts, handler);\n        this[kQueue].push(request);\n        if (this[kResuming]) {\n        // Do nothing.\n        } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n            // Wait a tick in case stream/iterator is ended in the same tick.\n            this[kResuming] = 1;\n            process.nextTick(resume, this);\n        } else {\n            resume(this, true);\n        }\n        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n            this[kNeedDrain] = 2;\n        }\n        return this[kNeedDrain] < 2;\n    }\n    async [kClose]() {\n        // TODO: for H2 we need to gracefully flush the remaining enqueued\n        // request and close each stream.\n        return new Promise((resolve)=>{\n            if (!this[kSize]) {\n                resolve(null);\n            } else {\n                this[kClosedResolve] = resolve;\n            }\n        });\n    }\n    async [kDestroy](err) {\n        return new Promise((resolve)=>{\n            const requests = this[kQueue].splice(this[kPendingIdx]);\n            for(let i = 0; i < requests.length; i++){\n                const request = requests[i];\n                errorRequest(this, request, err);\n            }\n            const callback = ()=>{\n                if (this[kClosedResolve]) {\n                    // TODO (fix): Should we error here with ClientDestroyedError?\n                    this[kClosedResolve]();\n                    this[kClosedResolve] = null;\n                }\n                resolve();\n            };\n            if (this[kHTTP2Session] != null) {\n                util.destroy(this[kHTTP2Session], err);\n                this[kHTTP2Session] = null;\n                this[kHTTP2SessionState] = null;\n            }\n            if (!this[kSocket]) {\n                queueMicrotask(callback);\n            } else {\n                util.destroy(this[kSocket].on(\"close\", callback), err);\n            }\n            resume(this);\n        });\n    }\n}\nfunction onHttp2SessionError(err) {\n    assert(err.code !== \"ERR_TLS_CERT_ALTNAME_INVALID\");\n    this[kSocket][kError] = err;\n    onError(this[kClient], err);\n}\nfunction onHttp2FrameError(type, code, id) {\n    const err = new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`);\n    if (id === 0) {\n        this[kSocket][kError] = err;\n        onError(this[kClient], err);\n    }\n}\nfunction onHttp2SessionEnd() {\n    util.destroy(this, new SocketError(\"other side closed\"));\n    util.destroy(this[kSocket], new SocketError(\"other side closed\"));\n}\nfunction onHTTP2GoAway(code) {\n    const client = this[kClient];\n    const err = new InformationalError(`HTTP/2: \"GOAWAY\" frame received with code ${code}`);\n    client[kSocket] = null;\n    client[kHTTP2Session] = null;\n    if (client.destroyed) {\n        assert(this[kPending] === 0);\n        // Fail entire queue.\n        const requests = client[kQueue].splice(client[kRunningIdx]);\n        for(let i = 0; i < requests.length; i++){\n            const request = requests[i];\n            errorRequest(this, request, err);\n        }\n    } else if (client[kRunning] > 0) {\n        // Fail head of pipeline.\n        const request = client[kQueue][client[kRunningIdx]];\n        client[kQueue][client[kRunningIdx]++] = null;\n        errorRequest(client, request, err);\n    }\n    client[kPendingIdx] = client[kRunningIdx];\n    assert(client[kRunning] === 0);\n    client.emit(\"disconnect\", client[kUrl], [\n        client\n    ], err);\n    resume(client);\n}\nconst constants = __webpack_require__(/*! ./llhttp/constants */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/llhttp/constants.js\");\nconst createRedirectInterceptor = __webpack_require__(/*! ./interceptor/redirectInterceptor */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/interceptor/redirectInterceptor.js\");\nconst EMPTY_BUF = Buffer.alloc(0);\nasync function lazyllhttp() {\n    const llhttpWasmData = process.env.JEST_WORKER_ID ? __webpack_require__(/*! ./llhttp/llhttp-wasm.js */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/llhttp/llhttp-wasm.js\") : undefined;\n    let mod;\n    try {\n        mod = await WebAssembly.compile(Buffer.from(__webpack_require__(/*! ./llhttp/llhttp_simd-wasm.js */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js\"), \"base64\"));\n    } catch (e) {\n        /* istanbul ignore next */ // We could check if the error was caused by the simd option not\n        // being enabled, but the occurring of this other error\n        // * https://github.com/emscripten-core/emscripten/issues/11495\n        // got me to remove that check to avoid breaking Node 12.\n        mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || __webpack_require__(/*! ./llhttp/llhttp-wasm.js */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/llhttp/llhttp-wasm.js\"), \"base64\"));\n    }\n    return await WebAssembly.instantiate(mod, {\n        env: {\n            /* eslint-disable camelcase */ wasm_on_url: (p, at, len)=>{\n                /* istanbul ignore next */ return 0;\n            },\n            wasm_on_status: (p, at, len)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n                return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n            },\n            wasm_on_message_begin: (p)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                return currentParser.onMessageBegin() || 0;\n            },\n            wasm_on_header_field: (p, at, len)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n                return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n            },\n            wasm_on_header_value: (p, at, len)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n                return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n            },\n            wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;\n            },\n            wasm_on_body: (p, at, len)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n                return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n            },\n            wasm_on_message_complete: (p)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                return currentParser.onMessageComplete() || 0;\n            }\n        }\n    });\n}\nlet llhttpInstance = null;\nlet llhttpPromise = lazyllhttp();\nllhttpPromise.catch();\nlet currentParser = null;\nlet currentBufferRef = null;\nlet currentBufferSize = 0;\nlet currentBufferPtr = null;\nconst TIMEOUT_HEADERS = 1;\nconst TIMEOUT_BODY = 2;\nconst TIMEOUT_IDLE = 3;\nclass Parser {\n    constructor(client, socket, { exports }){\n        assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);\n        this.llhttp = exports;\n        this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);\n        this.client = client;\n        this.socket = socket;\n        this.timeout = null;\n        this.timeoutValue = null;\n        this.timeoutType = null;\n        this.statusCode = null;\n        this.statusText = \"\";\n        this.upgrade = false;\n        this.headers = [];\n        this.headersSize = 0;\n        this.headersMaxSize = client[kMaxHeadersSize];\n        this.shouldKeepAlive = false;\n        this.paused = false;\n        this.resume = this.resume.bind(this);\n        this.bytesRead = 0;\n        this.keepAlive = \"\";\n        this.contentLength = \"\";\n        this.connection = \"\";\n        this.maxResponseSize = client[kMaxResponseSize];\n    }\n    setTimeout(value, type) {\n        this.timeoutType = type;\n        if (value !== this.timeoutValue) {\n            timers.clearTimeout(this.timeout);\n            if (value) {\n                this.timeout = timers.setTimeout(onParserTimeout, value, this);\n                // istanbul ignore else: only for jest\n                if (this.timeout.unref) {\n                    this.timeout.unref();\n                }\n            } else {\n                this.timeout = null;\n            }\n            this.timeoutValue = value;\n        } else if (this.timeout) {\n            // istanbul ignore else: only for jest\n            if (this.timeout.refresh) {\n                this.timeout.refresh();\n            }\n        }\n    }\n    resume() {\n        if (this.socket.destroyed || !this.paused) {\n            return;\n        }\n        assert(this.ptr != null);\n        assert(currentParser == null);\n        this.llhttp.llhttp_resume(this.ptr);\n        assert(this.timeoutType === TIMEOUT_BODY);\n        if (this.timeout) {\n            // istanbul ignore else: only for jest\n            if (this.timeout.refresh) {\n                this.timeout.refresh();\n            }\n        }\n        this.paused = false;\n        this.execute(this.socket.read() || EMPTY_BUF) // Flush parser.\n        ;\n        this.readMore();\n    }\n    readMore() {\n        while(!this.paused && this.ptr){\n            const chunk = this.socket.read();\n            if (chunk === null) {\n                break;\n            }\n            this.execute(chunk);\n        }\n    }\n    execute(data) {\n        assert(this.ptr != null);\n        assert(currentParser == null);\n        assert(!this.paused);\n        const { socket, llhttp } = this;\n        if (data.length > currentBufferSize) {\n            if (currentBufferPtr) {\n                llhttp.free(currentBufferPtr);\n            }\n            currentBufferSize = Math.ceil(data.length / 4096) * 4096;\n            currentBufferPtr = llhttp.malloc(currentBufferSize);\n        }\n        new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);\n        // Call `execute` on the wasm parser.\n        // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n        // and finally the length of bytes to parse.\n        // The return value is an error code or `constants.ERROR.OK`.\n        try {\n            let ret;\n            try {\n                currentBufferRef = data;\n                currentParser = this;\n                ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);\n            /* eslint-disable-next-line no-useless-catch */ } catch (err) {\n                /* istanbul ignore next: difficult to make a test case for */ throw err;\n            } finally{\n                currentParser = null;\n                currentBufferRef = null;\n            }\n            const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;\n            if (ret === constants.ERROR.PAUSED_UPGRADE) {\n                this.onUpgrade(data.slice(offset));\n            } else if (ret === constants.ERROR.PAUSED) {\n                this.paused = true;\n                socket.unshift(data.slice(offset));\n            } else if (ret !== constants.ERROR.OK) {\n                const ptr = llhttp.llhttp_get_error_reason(this.ptr);\n                let message = \"\";\n                /* istanbul ignore else: difficult to make a test case for */ if (ptr) {\n                    const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);\n                    message = \"Response does not match the HTTP/1.1 protocol (\" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + \")\";\n                }\n                throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));\n            }\n        } catch (err) {\n            util.destroy(socket, err);\n        }\n    }\n    destroy() {\n        assert(this.ptr != null);\n        assert(currentParser == null);\n        this.llhttp.llhttp_free(this.ptr);\n        this.ptr = null;\n        timers.clearTimeout(this.timeout);\n        this.timeout = null;\n        this.timeoutValue = null;\n        this.timeoutType = null;\n        this.paused = false;\n    }\n    onStatus(buf) {\n        this.statusText = buf.toString();\n    }\n    onMessageBegin() {\n        const { socket, client } = this;\n        /* istanbul ignore next: difficult to make a test case for */ if (socket.destroyed) {\n            return -1;\n        }\n        const request = client[kQueue][client[kRunningIdx]];\n        if (!request) {\n            return -1;\n        }\n    }\n    onHeaderField(buf) {\n        const len = this.headers.length;\n        if ((len & 1) === 0) {\n            this.headers.push(buf);\n        } else {\n            this.headers[len - 1] = Buffer.concat([\n                this.headers[len - 1],\n                buf\n            ]);\n        }\n        this.trackHeader(buf.length);\n    }\n    onHeaderValue(buf) {\n        let len = this.headers.length;\n        if ((len & 1) === 1) {\n            this.headers.push(buf);\n            len += 1;\n        } else {\n            this.headers[len - 1] = Buffer.concat([\n                this.headers[len - 1],\n                buf\n            ]);\n        }\n        const key = this.headers[len - 2];\n        if (key.length === 10 && key.toString().toLowerCase() === \"keep-alive\") {\n            this.keepAlive += buf.toString();\n        } else if (key.length === 10 && key.toString().toLowerCase() === \"connection\") {\n            this.connection += buf.toString();\n        } else if (key.length === 14 && key.toString().toLowerCase() === \"content-length\") {\n            this.contentLength += buf.toString();\n        }\n        this.trackHeader(buf.length);\n    }\n    trackHeader(len) {\n        this.headersSize += len;\n        if (this.headersSize >= this.headersMaxSize) {\n            util.destroy(this.socket, new HeadersOverflowError());\n        }\n    }\n    onUpgrade(head) {\n        const { upgrade, client, socket, headers, statusCode } = this;\n        assert(upgrade);\n        const request = client[kQueue][client[kRunningIdx]];\n        assert(request);\n        assert(!socket.destroyed);\n        assert(socket === client[kSocket]);\n        assert(!this.paused);\n        assert(request.upgrade || request.method === \"CONNECT\");\n        this.statusCode = null;\n        this.statusText = \"\";\n        this.shouldKeepAlive = null;\n        assert(this.headers.length % 2 === 0);\n        this.headers = [];\n        this.headersSize = 0;\n        socket.unshift(head);\n        socket[kParser].destroy();\n        socket[kParser] = null;\n        socket[kClient] = null;\n        socket[kError] = null;\n        socket.removeListener(\"error\", onSocketError).removeListener(\"readable\", onSocketReadable).removeListener(\"end\", onSocketEnd).removeListener(\"close\", onSocketClose);\n        client[kSocket] = null;\n        client[kQueue][client[kRunningIdx]++] = null;\n        client.emit(\"disconnect\", client[kUrl], [\n            client\n        ], new InformationalError(\"upgrade\"));\n        try {\n            request.onUpgrade(statusCode, headers, socket);\n        } catch (err) {\n            util.destroy(socket, err);\n        }\n        resume(client);\n    }\n    onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {\n        const { client, socket, headers, statusText } = this;\n        /* istanbul ignore next: difficult to make a test case for */ if (socket.destroyed) {\n            return -1;\n        }\n        const request = client[kQueue][client[kRunningIdx]];\n        /* istanbul ignore next: difficult to make a test case for */ if (!request) {\n            return -1;\n        }\n        assert(!this.upgrade);\n        assert(this.statusCode < 200);\n        if (statusCode === 100) {\n            util.destroy(socket, new SocketError(\"bad response\", util.getSocketInfo(socket)));\n            return -1;\n        }\n        /* this can only happen if server is misbehaving */ if (upgrade && !request.upgrade) {\n            util.destroy(socket, new SocketError(\"bad upgrade\", util.getSocketInfo(socket)));\n            return -1;\n        }\n        assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);\n        this.statusCode = statusCode;\n        this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.\n        request.method === \"HEAD\" && !socket[kReset] && this.connection.toLowerCase() === \"keep-alive\";\n        if (this.statusCode >= 200) {\n            const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];\n            this.setTimeout(bodyTimeout, TIMEOUT_BODY);\n        } else if (this.timeout) {\n            // istanbul ignore else: only for jest\n            if (this.timeout.refresh) {\n                this.timeout.refresh();\n            }\n        }\n        if (request.method === \"CONNECT\") {\n            assert(client[kRunning] === 1);\n            this.upgrade = true;\n            return 2;\n        }\n        if (upgrade) {\n            assert(client[kRunning] === 1);\n            this.upgrade = true;\n            return 2;\n        }\n        assert(this.headers.length % 2 === 0);\n        this.headers = [];\n        this.headersSize = 0;\n        if (this.shouldKeepAlive && client[kPipelining]) {\n            const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;\n            if (keepAliveTimeout != null) {\n                const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);\n                if (timeout <= 0) {\n                    socket[kReset] = true;\n                } else {\n                    client[kKeepAliveTimeoutValue] = timeout;\n                }\n            } else {\n                client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];\n            }\n        } else {\n            // Stop more requests from being dispatched.\n            socket[kReset] = true;\n        }\n        const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;\n        if (request.aborted) {\n            return -1;\n        }\n        if (request.method === \"HEAD\") {\n            return 1;\n        }\n        if (statusCode < 200) {\n            return 1;\n        }\n        if (socket[kBlocking]) {\n            socket[kBlocking] = false;\n            resume(client);\n        }\n        return pause ? constants.ERROR.PAUSED : 0;\n    }\n    onBody(buf) {\n        const { client, socket, statusCode, maxResponseSize } = this;\n        if (socket.destroyed) {\n            return -1;\n        }\n        const request = client[kQueue][client[kRunningIdx]];\n        assert(request);\n        assert.strictEqual(this.timeoutType, TIMEOUT_BODY);\n        if (this.timeout) {\n            // istanbul ignore else: only for jest\n            if (this.timeout.refresh) {\n                this.timeout.refresh();\n            }\n        }\n        assert(statusCode >= 200);\n        if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {\n            util.destroy(socket, new ResponseExceededMaxSizeError());\n            return -1;\n        }\n        this.bytesRead += buf.length;\n        if (request.onData(buf) === false) {\n            return constants.ERROR.PAUSED;\n        }\n    }\n    onMessageComplete() {\n        const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;\n        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n            return -1;\n        }\n        if (upgrade) {\n            return;\n        }\n        const request = client[kQueue][client[kRunningIdx]];\n        assert(request);\n        assert(statusCode >= 100);\n        this.statusCode = null;\n        this.statusText = \"\";\n        this.bytesRead = 0;\n        this.contentLength = \"\";\n        this.keepAlive = \"\";\n        this.connection = \"\";\n        assert(this.headers.length % 2 === 0);\n        this.headers = [];\n        this.headersSize = 0;\n        if (statusCode < 200) {\n            return;\n        }\n        /* istanbul ignore next: should be handled by llhttp? */ if (request.method !== \"HEAD\" && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n            util.destroy(socket, new ResponseContentLengthMismatchError());\n            return -1;\n        }\n        request.onComplete(headers);\n        client[kQueue][client[kRunningIdx]++] = null;\n        if (socket[kWriting]) {\n            assert.strictEqual(client[kRunning], 0);\n            // Response completed before request.\n            util.destroy(socket, new InformationalError(\"reset\"));\n            return constants.ERROR.PAUSED;\n        } else if (!shouldKeepAlive) {\n            util.destroy(socket, new InformationalError(\"reset\"));\n            return constants.ERROR.PAUSED;\n        } else if (socket[kReset] && client[kRunning] === 0) {\n            // Destroy socket once all requests have completed.\n            // The request at the tail of the pipeline is the one\n            // that requested reset and no further requests should\n            // have been queued since then.\n            util.destroy(socket, new InformationalError(\"reset\"));\n            return constants.ERROR.PAUSED;\n        } else if (client[kPipelining] === 1) {\n            // We must wait a full event loop cycle to reuse this socket to make sure\n            // that non-spec compliant servers are not closing the connection even if they\n            // said they won't.\n            setImmediate(resume, client);\n        } else {\n            resume(client);\n        }\n    }\n}\nfunction onParserTimeout(parser) {\n    const { socket, timeoutType, client } = parser;\n    /* istanbul ignore else */ if (timeoutType === TIMEOUT_HEADERS) {\n        if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n            assert(!parser.paused, \"cannot be paused while waiting for headers\");\n            util.destroy(socket, new HeadersTimeoutError());\n        }\n    } else if (timeoutType === TIMEOUT_BODY) {\n        if (!parser.paused) {\n            util.destroy(socket, new BodyTimeoutError());\n        }\n    } else if (timeoutType === TIMEOUT_IDLE) {\n        assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);\n        util.destroy(socket, new InformationalError(\"socket idle timeout\"));\n    }\n}\nfunction onSocketReadable() {\n    const { [kParser]: parser } = this;\n    if (parser) {\n        parser.readMore();\n    }\n}\nfunction onSocketError(err) {\n    const { [kClient]: client, [kParser]: parser } = this;\n    assert(err.code !== \"ERR_TLS_CERT_ALTNAME_INVALID\");\n    if (client[kHTTPConnVersion] !== \"h2\") {\n        // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n        // to the user.\n        if (err.code === \"ECONNRESET\" && parser.statusCode && !parser.shouldKeepAlive) {\n            // We treat all incoming data so for as a valid response.\n            parser.onMessageComplete();\n            return;\n        }\n    }\n    this[kError] = err;\n    onError(this[kClient], err);\n}\nfunction onError(client, err) {\n    if (client[kRunning] === 0 && err.code !== \"UND_ERR_INFO\" && err.code !== \"UND_ERR_SOCKET\") {\n        // Error is not caused by running request and not a recoverable\n        // socket error.\n        assert(client[kPendingIdx] === client[kRunningIdx]);\n        const requests = client[kQueue].splice(client[kRunningIdx]);\n        for(let i = 0; i < requests.length; i++){\n            const request = requests[i];\n            errorRequest(client, request, err);\n        }\n        assert(client[kSize] === 0);\n    }\n}\nfunction onSocketEnd() {\n    const { [kParser]: parser, [kClient]: client } = this;\n    if (client[kHTTPConnVersion] !== \"h2\") {\n        if (parser.statusCode && !parser.shouldKeepAlive) {\n            // We treat all incoming data so far as a valid response.\n            parser.onMessageComplete();\n            return;\n        }\n    }\n    util.destroy(this, new SocketError(\"other side closed\", util.getSocketInfo(this)));\n}\nfunction onSocketClose() {\n    const { [kClient]: client, [kParser]: parser } = this;\n    if (client[kHTTPConnVersion] === \"h1\" && parser) {\n        if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {\n            // We treat all incoming data so far as a valid response.\n            parser.onMessageComplete();\n        }\n        this[kParser].destroy();\n        this[kParser] = null;\n    }\n    const err = this[kError] || new SocketError(\"closed\", util.getSocketInfo(this));\n    client[kSocket] = null;\n    if (client.destroyed) {\n        assert(client[kPending] === 0);\n        // Fail entire queue.\n        const requests = client[kQueue].splice(client[kRunningIdx]);\n        for(let i = 0; i < requests.length; i++){\n            const request = requests[i];\n            errorRequest(client, request, err);\n        }\n    } else if (client[kRunning] > 0 && err.code !== \"UND_ERR_INFO\") {\n        // Fail head of pipeline.\n        const request = client[kQueue][client[kRunningIdx]];\n        client[kQueue][client[kRunningIdx]++] = null;\n        errorRequest(client, request, err);\n    }\n    client[kPendingIdx] = client[kRunningIdx];\n    assert(client[kRunning] === 0);\n    client.emit(\"disconnect\", client[kUrl], [\n        client\n    ], err);\n    resume(client);\n}\nasync function connect(client) {\n    assert(!client[kConnecting]);\n    assert(!client[kSocket]);\n    let { host, hostname, protocol, port } = client[kUrl];\n    // Resolve ipv6\n    if (hostname[0] === \"[\") {\n        const idx = hostname.indexOf(\"]\");\n        assert(idx !== -1);\n        const ip = hostname.substring(1, idx);\n        assert(net.isIP(ip));\n        hostname = ip;\n    }\n    client[kConnecting] = true;\n    if (channels.beforeConnect.hasSubscribers) {\n        channels.beforeConnect.publish({\n            connectParams: {\n                host,\n                hostname,\n                protocol,\n                port,\n                servername: client[kServerName],\n                localAddress: client[kLocalAddress]\n            },\n            connector: client[kConnector]\n        });\n    }\n    try {\n        const socket = await new Promise((resolve, reject)=>{\n            client[kConnector]({\n                host,\n                hostname,\n                protocol,\n                port,\n                servername: client[kServerName],\n                localAddress: client[kLocalAddress]\n            }, (err, socket)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(socket);\n                }\n            });\n        });\n        if (client.destroyed) {\n            util.destroy(socket.on(\"error\", ()=>{}), new ClientDestroyedError());\n            return;\n        }\n        client[kConnecting] = false;\n        assert(socket);\n        const isH2 = socket.alpnProtocol === \"h2\";\n        if (isH2) {\n            if (!h2ExperimentalWarned) {\n                h2ExperimentalWarned = true;\n                process.emitWarning(\"H2 support is experimental, expect them to change at any time.\", {\n                    code: \"UNDICI-H2\"\n                });\n            }\n            const session = http2.connect(client[kUrl], {\n                createConnection: ()=>socket,\n                peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams\n            });\n            client[kHTTPConnVersion] = \"h2\";\n            session[kClient] = client;\n            session[kSocket] = socket;\n            session.on(\"error\", onHttp2SessionError);\n            session.on(\"frameError\", onHttp2FrameError);\n            session.on(\"end\", onHttp2SessionEnd);\n            session.on(\"goaway\", onHTTP2GoAway);\n            session.on(\"close\", onSocketClose);\n            session.unref();\n            client[kHTTP2Session] = session;\n            socket[kHTTP2Session] = session;\n        } else {\n            if (!llhttpInstance) {\n                llhttpInstance = await llhttpPromise;\n                llhttpPromise = null;\n            }\n            socket[kNoRef] = false;\n            socket[kWriting] = false;\n            socket[kReset] = false;\n            socket[kBlocking] = false;\n            socket[kParser] = new Parser(client, socket, llhttpInstance);\n        }\n        socket[kCounter] = 0;\n        socket[kMaxRequests] = client[kMaxRequests];\n        socket[kClient] = client;\n        socket[kError] = null;\n        socket.on(\"error\", onSocketError).on(\"readable\", onSocketReadable).on(\"end\", onSocketEnd).on(\"close\", onSocketClose);\n        client[kSocket] = socket;\n        if (channels.connected.hasSubscribers) {\n            channels.connected.publish({\n                connectParams: {\n                    host,\n                    hostname,\n                    protocol,\n                    port,\n                    servername: client[kServerName],\n                    localAddress: client[kLocalAddress]\n                },\n                connector: client[kConnector],\n                socket\n            });\n        }\n        client.emit(\"connect\", client[kUrl], [\n            client\n        ]);\n    } catch (err) {\n        if (client.destroyed) {\n            return;\n        }\n        client[kConnecting] = false;\n        if (channels.connectError.hasSubscribers) {\n            channels.connectError.publish({\n                connectParams: {\n                    host,\n                    hostname,\n                    protocol,\n                    port,\n                    servername: client[kServerName],\n                    localAddress: client[kLocalAddress]\n                },\n                connector: client[kConnector],\n                error: err\n            });\n        }\n        if (err.code === \"ERR_TLS_CERT_ALTNAME_INVALID\") {\n            assert(client[kRunning] === 0);\n            while(client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]){\n                const request = client[kQueue][client[kPendingIdx]++];\n                errorRequest(client, request, err);\n            }\n        } else {\n            onError(client, err);\n        }\n        client.emit(\"connectionError\", client[kUrl], [\n            client\n        ], err);\n    }\n    resume(client);\n}\nfunction emitDrain(client) {\n    client[kNeedDrain] = 0;\n    client.emit(\"drain\", client[kUrl], [\n        client\n    ]);\n}\nfunction resume(client, sync) {\n    if (client[kResuming] === 2) {\n        return;\n    }\n    client[kResuming] = 2;\n    _resume(client, sync);\n    client[kResuming] = 0;\n    if (client[kRunningIdx] > 256) {\n        client[kQueue].splice(0, client[kRunningIdx]);\n        client[kPendingIdx] -= client[kRunningIdx];\n        client[kRunningIdx] = 0;\n    }\n}\nfunction _resume(client, sync) {\n    while(true){\n        if (client.destroyed) {\n            assert(client[kPending] === 0);\n            return;\n        }\n        if (client[kClosedResolve] && !client[kSize]) {\n            client[kClosedResolve]();\n            client[kClosedResolve] = null;\n            return;\n        }\n        const socket = client[kSocket];\n        if (socket && !socket.destroyed && socket.alpnProtocol !== \"h2\") {\n            if (client[kSize] === 0) {\n                if (!socket[kNoRef] && socket.unref) {\n                    socket.unref();\n                    socket[kNoRef] = true;\n                }\n            } else if (socket[kNoRef] && socket.ref) {\n                socket.ref();\n                socket[kNoRef] = false;\n            }\n            if (client[kSize] === 0) {\n                if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n                    socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);\n                }\n            } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n                if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n                    const request = client[kQueue][client[kRunningIdx]];\n                    const headersTimeout = request.headersTimeout != null ? request.headersTimeout : client[kHeadersTimeout];\n                    socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);\n                }\n            }\n        }\n        if (client[kBusy]) {\n            client[kNeedDrain] = 2;\n        } else if (client[kNeedDrain] === 2) {\n            if (sync) {\n                client[kNeedDrain] = 1;\n                process.nextTick(emitDrain, client);\n            } else {\n                emitDrain(client);\n            }\n            continue;\n        }\n        if (client[kPending] === 0) {\n            return;\n        }\n        if (client[kRunning] >= (client[kPipelining] || 1)) {\n            return;\n        }\n        const request = client[kQueue][client[kPendingIdx]];\n        if (client[kUrl].protocol === \"https:\" && client[kServerName] !== request.servername) {\n            if (client[kRunning] > 0) {\n                return;\n            }\n            client[kServerName] = request.servername;\n            if (socket && socket.servername !== request.servername) {\n                util.destroy(socket, new InformationalError(\"servername changed\"));\n                return;\n            }\n        }\n        if (client[kConnecting]) {\n            return;\n        }\n        if (!socket && !client[kHTTP2Session]) {\n            connect(client);\n            return;\n        }\n        if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n            return;\n        }\n        if (client[kRunning] > 0 && !request.idempotent) {\n            // Non-idempotent request cannot be retried.\n            // Ensure that no other requests are inflight and\n            // could cause failure.\n            return;\n        }\n        if (client[kRunning] > 0 && (request.upgrade || request.method === \"CONNECT\")) {\n            // Don't dispatch an upgrade until all preceding requests have completed.\n            // A misbehaving server might upgrade the connection before all pipelined\n            // request has completed.\n            return;\n        }\n        if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body))) {\n            // Request with stream or iterator body can error while other requests\n            // are inflight and indirectly error those as well.\n            // Ensure this doesn't happen by waiting for inflight\n            // to complete before dispatching.\n            // Request with stream or iterator body cannot be retried.\n            // Ensure that no other requests are inflight and\n            // could cause failure.\n            return;\n        }\n        if (!request.aborted && write(client, request)) {\n            client[kPendingIdx]++;\n        } else {\n            client[kQueue].splice(client[kPendingIdx], 1);\n        }\n    }\n}\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength(method) {\n    return method !== \"GET\" && method !== \"HEAD\" && method !== \"OPTIONS\" && method !== \"TRACE\" && method !== \"CONNECT\";\n}\nfunction write(client, request) {\n    if (client[kHTTPConnVersion] === \"h2\") {\n        writeH2(client, client[kHTTP2Session], request);\n        return;\n    }\n    const { body, method, path, host, upgrade, headers, blocking, reset } = request;\n    // https://tools.ietf.org/html/rfc7231#section-4.3.1\n    // https://tools.ietf.org/html/rfc7231#section-4.3.2\n    // https://tools.ietf.org/html/rfc7231#section-4.3.5\n    // Sending a payload body on a request that does not\n    // expect it can cause undefined behavior on some\n    // servers and corrupt connection state. Do not\n    // re-use the connection for further requests.\n    const expectsPayload = method === \"PUT\" || method === \"POST\" || method === \"PATCH\";\n    if (body && typeof body.read === \"function\") {\n        // Try to read EOF in order to get length.\n        body.read(0);\n    }\n    const bodyLength = util.bodyLength(body);\n    let contentLength = bodyLength;\n    if (contentLength === null) {\n        contentLength = request.contentLength;\n    }\n    if (contentLength === 0 && !expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD NOT send a Content-Length header field when\n        // the request message does not contain a payload body and the method\n        // semantics do not anticipate such a body.\n        contentLength = null;\n    }\n    // https://github.com/nodejs/undici/issues/2046\n    // A user agent may send a Content-Length header with 0 value, this should be allowed.\n    if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {\n        if (client[kStrictContentLength]) {\n            errorRequest(client, request, new RequestContentLengthMismatchError());\n            return false;\n        }\n        process.emitWarning(new RequestContentLengthMismatchError());\n    }\n    const socket = client[kSocket];\n    try {\n        request.onConnect((err)=>{\n            if (request.aborted || request.completed) {\n                return;\n            }\n            errorRequest(client, request, err || new RequestAbortedError());\n            util.destroy(socket, new InformationalError(\"aborted\"));\n        });\n    } catch (err) {\n        errorRequest(client, request, err);\n    }\n    if (request.aborted) {\n        return false;\n    }\n    if (method === \"HEAD\") {\n        // https://github.com/mcollina/undici/issues/258\n        // Close after a HEAD request to interop with misbehaving servers\n        // that may send a body in the response.\n        socket[kReset] = true;\n    }\n    if (upgrade || method === \"CONNECT\") {\n        // On CONNECT or upgrade, block pipeline from dispatching further\n        // requests on this connection.\n        socket[kReset] = true;\n    }\n    if (reset != null) {\n        socket[kReset] = reset;\n    }\n    if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n        socket[kReset] = true;\n    }\n    if (blocking) {\n        socket[kBlocking] = true;\n    }\n    let header = `${method} ${path} HTTP/1.1\\r\\n`;\n    if (typeof host === \"string\") {\n        header += `host: ${host}\\r\\n`;\n    } else {\n        header += client[kHostHeader];\n    }\n    if (upgrade) {\n        header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`;\n    } else if (client[kPipelining] && !socket[kReset]) {\n        header += \"connection: keep-alive\\r\\n\";\n    } else {\n        header += \"connection: close\\r\\n\";\n    }\n    if (headers) {\n        header += headers;\n    }\n    if (channels.sendHeaders.hasSubscribers) {\n        channels.sendHeaders.publish({\n            request,\n            headers: header,\n            socket\n        });\n    }\n    /* istanbul ignore else: assertion */ if (!body || bodyLength === 0) {\n        if (contentLength === 0) {\n            socket.write(`${header}content-length: 0\\r\\n\\r\\n`, \"latin1\");\n        } else {\n            assert(contentLength === null, \"no body must not have content length\");\n            socket.write(`${header}\\r\\n`, \"latin1\");\n        }\n        request.onRequestSent();\n    } else if (util.isBuffer(body)) {\n        assert(contentLength === body.byteLength, \"buffer body must have content length\");\n        socket.cork();\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, \"latin1\");\n        socket.write(body);\n        socket.uncork();\n        request.onBodySent(body);\n        request.onRequestSent();\n        if (!expectsPayload) {\n            socket[kReset] = true;\n        }\n    } else if (util.isBlobLike(body)) {\n        if (typeof body.stream === \"function\") {\n            writeIterable({\n                body: body.stream(),\n                client,\n                request,\n                socket,\n                contentLength,\n                header,\n                expectsPayload\n            });\n        } else {\n            writeBlob({\n                body,\n                client,\n                request,\n                socket,\n                contentLength,\n                header,\n                expectsPayload\n            });\n        }\n    } else if (util.isStream(body)) {\n        writeStream({\n            body,\n            client,\n            request,\n            socket,\n            contentLength,\n            header,\n            expectsPayload\n        });\n    } else if (util.isIterable(body)) {\n        writeIterable({\n            body,\n            client,\n            request,\n            socket,\n            contentLength,\n            header,\n            expectsPayload\n        });\n    } else {\n        assert(false);\n    }\n    return true;\n}\nfunction writeH2(client, session, request) {\n    const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;\n    let headers;\n    if (typeof reqHeaders === \"string\") headers = Request[kHTTP2CopyHeaders](reqHeaders.trim());\n    else headers = reqHeaders;\n    if (upgrade) {\n        errorRequest(client, request, new Error(\"Upgrade not supported for H2\"));\n        return false;\n    }\n    try {\n        // TODO(HTTP/2): Should we call onConnect immediately or on stream ready event?\n        request.onConnect((err)=>{\n            if (request.aborted || request.completed) {\n                return;\n            }\n            errorRequest(client, request, err || new RequestAbortedError());\n        });\n    } catch (err) {\n        errorRequest(client, request, err);\n    }\n    if (request.aborted) {\n        return false;\n    }\n    /** @type {import('node:http2').ClientHttp2Stream} */ let stream;\n    const h2State = client[kHTTP2SessionState];\n    headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];\n    headers[HTTP2_HEADER_METHOD] = method;\n    if (method === \"CONNECT\") {\n        session.ref();\n        // we are already connected, streams are pending, first request\n        // will create a new stream. We trigger a request to create the stream and wait until\n        // `ready` event is triggered\n        // We disabled endStream to allow the user to write to the stream\n        stream = session.request(headers, {\n            endStream: false,\n            signal\n        });\n        if (stream.id && !stream.pending) {\n            request.onUpgrade(null, null, stream);\n            ++h2State.openStreams;\n        } else {\n            stream.once(\"ready\", ()=>{\n                request.onUpgrade(null, null, stream);\n                ++h2State.openStreams;\n            });\n        }\n        stream.once(\"close\", ()=>{\n            h2State.openStreams -= 1;\n            // TODO(HTTP/2): unref only if current streams count is 0\n            if (h2State.openStreams === 0) session.unref();\n        });\n        return true;\n    }\n    // https://tools.ietf.org/html/rfc7540#section-8.3\n    // :path and :scheme headers must be omited when sending CONNECT\n    headers[HTTP2_HEADER_PATH] = path;\n    headers[HTTP2_HEADER_SCHEME] = \"https\";\n    // https://tools.ietf.org/html/rfc7231#section-4.3.1\n    // https://tools.ietf.org/html/rfc7231#section-4.3.2\n    // https://tools.ietf.org/html/rfc7231#section-4.3.5\n    // Sending a payload body on a request that does not\n    // expect it can cause undefined behavior on some\n    // servers and corrupt connection state. Do not\n    // re-use the connection for further requests.\n    const expectsPayload = method === \"PUT\" || method === \"POST\" || method === \"PATCH\";\n    if (body && typeof body.read === \"function\") {\n        // Try to read EOF in order to get length.\n        body.read(0);\n    }\n    let contentLength = util.bodyLength(body);\n    if (contentLength == null) {\n        contentLength = request.contentLength;\n    }\n    if (contentLength === 0 || !expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD NOT send a Content-Length header field when\n        // the request message does not contain a payload body and the method\n        // semantics do not anticipate such a body.\n        contentLength = null;\n    }\n    // https://github.com/nodejs/undici/issues/2046\n    // A user agent may send a Content-Length header with 0 value, this should be allowed.\n    if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {\n        if (client[kStrictContentLength]) {\n            errorRequest(client, request, new RequestContentLengthMismatchError());\n            return false;\n        }\n        process.emitWarning(new RequestContentLengthMismatchError());\n    }\n    if (contentLength != null) {\n        assert(body, \"no body must not have content length\");\n        headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;\n    }\n    session.ref();\n    const shouldEndStream = method === \"GET\" || method === \"HEAD\";\n    if (expectContinue) {\n        headers[HTTP2_HEADER_EXPECT] = \"100-continue\";\n        stream = session.request(headers, {\n            endStream: shouldEndStream,\n            signal\n        });\n        stream.once(\"continue\", writeBodyH2);\n    } else {\n        stream = session.request(headers, {\n            endStream: shouldEndStream,\n            signal\n        });\n        writeBodyH2();\n    }\n    // Increment counter as we have new several streams open\n    ++h2State.openStreams;\n    stream.once(\"response\", (headers)=>{\n        const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers;\n        if (request.onHeaders(Number(statusCode), realHeaders, stream.resume.bind(stream), \"\") === false) {\n            stream.pause();\n        }\n    });\n    stream.once(\"end\", ()=>{\n        request.onComplete([]);\n    });\n    stream.on(\"data\", (chunk)=>{\n        if (request.onData(chunk) === false) {\n            stream.pause();\n        }\n    });\n    stream.once(\"close\", ()=>{\n        h2State.openStreams -= 1;\n        // TODO(HTTP/2): unref only if current streams count is 0\n        if (h2State.openStreams === 0) {\n            session.unref();\n        }\n    });\n    stream.once(\"error\", function(err) {\n        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {\n            h2State.streams -= 1;\n            util.destroy(stream, err);\n        }\n    });\n    stream.once(\"frameError\", (type, code)=>{\n        const err = new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`);\n        errorRequest(client, request, err);\n        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {\n            h2State.streams -= 1;\n            util.destroy(stream, err);\n        }\n    });\n    // stream.on('aborted', () => {\n    //   // TODO(HTTP/2): Support aborted\n    // })\n    // stream.on('timeout', () => {\n    //   // TODO(HTTP/2): Support timeout\n    // })\n    // stream.on('push', headers => {\n    //   // TODO(HTTP/2): Suppor push\n    // })\n    // stream.on('trailers', headers => {\n    //   // TODO(HTTP/2): Support trailers\n    // })\n    return true;\n    function writeBodyH2() {\n        /* istanbul ignore else: assertion */ if (!body) {\n            request.onRequestSent();\n        } else if (util.isBuffer(body)) {\n            assert(contentLength === body.byteLength, \"buffer body must have content length\");\n            stream.cork();\n            stream.write(body);\n            stream.uncork();\n            stream.end();\n            request.onBodySent(body);\n            request.onRequestSent();\n        } else if (util.isBlobLike(body)) {\n            if (typeof body.stream === \"function\") {\n                writeIterable({\n                    client,\n                    request,\n                    contentLength,\n                    h2stream: stream,\n                    expectsPayload,\n                    body: body.stream(),\n                    socket: client[kSocket],\n                    header: \"\"\n                });\n            } else {\n                writeBlob({\n                    body,\n                    client,\n                    request,\n                    contentLength,\n                    expectsPayload,\n                    h2stream: stream,\n                    header: \"\",\n                    socket: client[kSocket]\n                });\n            }\n        } else if (util.isStream(body)) {\n            writeStream({\n                body,\n                client,\n                request,\n                contentLength,\n                expectsPayload,\n                socket: client[kSocket],\n                h2stream: stream,\n                header: \"\"\n            });\n        } else if (util.isIterable(body)) {\n            writeIterable({\n                body,\n                client,\n                request,\n                contentLength,\n                expectsPayload,\n                header: \"\",\n                h2stream: stream,\n                socket: client[kSocket]\n            });\n        } else {\n            assert(false);\n        }\n    }\n}\nfunction writeStream({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {\n    assert(contentLength !== 0 || client[kRunning] === 0, \"stream body cannot be pipelined\");\n    if (client[kHTTPConnVersion] === \"h2\") {\n        // For HTTP/2, is enough to pipe the stream\n        const pipe = pipeline(body, h2stream, (err)=>{\n            if (err) {\n                util.destroy(body, err);\n                util.destroy(h2stream, err);\n            } else {\n                request.onRequestSent();\n            }\n        });\n        pipe.on(\"data\", onPipeData);\n        pipe.once(\"end\", ()=>{\n            pipe.removeListener(\"data\", onPipeData);\n            util.destroy(pipe);\n        });\n        function onPipeData(chunk) {\n            request.onBodySent(chunk);\n        }\n        return;\n    }\n    let finished = false;\n    const writer = new AsyncWriter({\n        socket,\n        request,\n        contentLength,\n        client,\n        expectsPayload,\n        header\n    });\n    const onData = function(chunk) {\n        if (finished) {\n            return;\n        }\n        try {\n            if (!writer.write(chunk) && this.pause) {\n                this.pause();\n            }\n        } catch (err) {\n            util.destroy(this, err);\n        }\n    };\n    const onDrain = function() {\n        if (finished) {\n            return;\n        }\n        if (body.resume) {\n            body.resume();\n        }\n    };\n    const onAbort = function() {\n        if (finished) {\n            return;\n        }\n        const err = new RequestAbortedError();\n        queueMicrotask(()=>onFinished(err));\n    };\n    const onFinished = function(err) {\n        if (finished) {\n            return;\n        }\n        finished = true;\n        assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);\n        socket.off(\"drain\", onDrain).off(\"error\", onFinished);\n        body.removeListener(\"data\", onData).removeListener(\"end\", onFinished).removeListener(\"error\", onFinished).removeListener(\"close\", onAbort);\n        if (!err) {\n            try {\n                writer.end();\n            } catch (er) {\n                err = er;\n            }\n        }\n        writer.destroy(err);\n        if (err && (err.code !== \"UND_ERR_INFO\" || err.message !== \"reset\")) {\n            util.destroy(body, err);\n        } else {\n            util.destroy(body);\n        }\n    };\n    body.on(\"data\", onData).on(\"end\", onFinished).on(\"error\", onFinished).on(\"close\", onAbort);\n    if (body.resume) {\n        body.resume();\n    }\n    socket.on(\"drain\", onDrain).on(\"error\", onFinished);\n}\nasync function writeBlob({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {\n    assert(contentLength === body.size, \"blob body must have content length\");\n    const isH2 = client[kHTTPConnVersion] === \"h2\";\n    try {\n        if (contentLength != null && contentLength !== body.size) {\n            throw new RequestContentLengthMismatchError();\n        }\n        const buffer = Buffer.from(await body.arrayBuffer());\n        if (isH2) {\n            h2stream.cork();\n            h2stream.write(buffer);\n            h2stream.uncork();\n        } else {\n            socket.cork();\n            socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, \"latin1\");\n            socket.write(buffer);\n            socket.uncork();\n        }\n        request.onBodySent(buffer);\n        request.onRequestSent();\n        if (!expectsPayload) {\n            socket[kReset] = true;\n        }\n        resume(client);\n    } catch (err) {\n        util.destroy(isH2 ? h2stream : socket, err);\n    }\n}\nasync function writeIterable({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {\n    assert(contentLength !== 0 || client[kRunning] === 0, \"iterator body cannot be pipelined\");\n    let callback = null;\n    function onDrain() {\n        if (callback) {\n            const cb = callback;\n            callback = null;\n            cb();\n        }\n    }\n    const waitForDrain = ()=>new Promise((resolve, reject)=>{\n            assert(callback === null);\n            if (socket[kError]) {\n                reject(socket[kError]);\n            } else {\n                callback = resolve;\n            }\n        });\n    if (client[kHTTPConnVersion] === \"h2\") {\n        h2stream.on(\"close\", onDrain).on(\"drain\", onDrain);\n        try {\n            // It's up to the user to somehow abort the async iterable.\n            for await (const chunk of body){\n                if (socket[kError]) {\n                    throw socket[kError];\n                }\n                const res = h2stream.write(chunk);\n                request.onBodySent(chunk);\n                if (!res) {\n                    await waitForDrain();\n                }\n            }\n        } catch (err) {\n            h2stream.destroy(err);\n        } finally{\n            request.onRequestSent();\n            h2stream.end();\n            h2stream.off(\"close\", onDrain).off(\"drain\", onDrain);\n        }\n        return;\n    }\n    socket.on(\"close\", onDrain).on(\"drain\", onDrain);\n    const writer = new AsyncWriter({\n        socket,\n        request,\n        contentLength,\n        client,\n        expectsPayload,\n        header\n    });\n    try {\n        // It's up to the user to somehow abort the async iterable.\n        for await (const chunk of body){\n            if (socket[kError]) {\n                throw socket[kError];\n            }\n            if (!writer.write(chunk)) {\n                await waitForDrain();\n            }\n        }\n        writer.end();\n    } catch (err) {\n        writer.destroy(err);\n    } finally{\n        socket.off(\"close\", onDrain).off(\"drain\", onDrain);\n    }\n}\nclass AsyncWriter {\n    constructor({ socket, request, contentLength, client, expectsPayload, header }){\n        this.socket = socket;\n        this.request = request;\n        this.contentLength = contentLength;\n        this.client = client;\n        this.bytesWritten = 0;\n        this.expectsPayload = expectsPayload;\n        this.header = header;\n        socket[kWriting] = true;\n    }\n    write(chunk) {\n        const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;\n        if (socket[kError]) {\n            throw socket[kError];\n        }\n        if (socket.destroyed) {\n            return false;\n        }\n        const len = Buffer.byteLength(chunk);\n        if (!len) {\n            return true;\n        }\n        // We should defer writing chunks.\n        if (contentLength !== null && bytesWritten + len > contentLength) {\n            if (client[kStrictContentLength]) {\n                throw new RequestContentLengthMismatchError();\n            }\n            process.emitWarning(new RequestContentLengthMismatchError());\n        }\n        socket.cork();\n        if (bytesWritten === 0) {\n            if (!expectsPayload) {\n                socket[kReset] = true;\n            }\n            if (contentLength === null) {\n                socket.write(`${header}transfer-encoding: chunked\\r\\n`, \"latin1\");\n            } else {\n                socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, \"latin1\");\n            }\n        }\n        if (contentLength === null) {\n            socket.write(`\\r\\n${len.toString(16)}\\r\\n`, \"latin1\");\n        }\n        this.bytesWritten += len;\n        const ret = socket.write(chunk);\n        socket.uncork();\n        request.onBodySent(chunk);\n        if (!ret) {\n            if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n                // istanbul ignore else: only for jest\n                if (socket[kParser].timeout.refresh) {\n                    socket[kParser].timeout.refresh();\n                }\n            }\n        }\n        return ret;\n    }\n    end() {\n        const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;\n        request.onRequestSent();\n        socket[kWriting] = false;\n        if (socket[kError]) {\n            throw socket[kError];\n        }\n        if (socket.destroyed) {\n            return;\n        }\n        if (bytesWritten === 0) {\n            if (expectsPayload) {\n                // https://tools.ietf.org/html/rfc7230#section-3.3.2\n                // A user agent SHOULD send a Content-Length in a request message when\n                // no Transfer-Encoding is sent and the request method defines a meaning\n                // for an enclosed payload body.\n                socket.write(`${header}content-length: 0\\r\\n\\r\\n`, \"latin1\");\n            } else {\n                socket.write(`${header}\\r\\n`, \"latin1\");\n            }\n        } else if (contentLength === null) {\n            socket.write(\"\\r\\n0\\r\\n\\r\\n\", \"latin1\");\n        }\n        if (contentLength !== null && bytesWritten !== contentLength) {\n            if (client[kStrictContentLength]) {\n                throw new RequestContentLengthMismatchError();\n            } else {\n                process.emitWarning(new RequestContentLengthMismatchError());\n            }\n        }\n        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n            // istanbul ignore else: only for jest\n            if (socket[kParser].timeout.refresh) {\n                socket[kParser].timeout.refresh();\n            }\n        }\n        resume(client);\n    }\n    destroy(err) {\n        const { socket, client } = this;\n        socket[kWriting] = false;\n        if (err) {\n            assert(client[kRunning] <= 1, \"pipeline should only contain this request\");\n            util.destroy(socket, err);\n        }\n    }\n}\nfunction errorRequest(client, request, err) {\n    try {\n        request.onError(err);\n        assert(request.aborted);\n    } catch (err) {\n        client.emit(\"error\", err);\n    }\n}\nmodule.exports = Client;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBLFlBQVk7QUFFWjtBQUVBLHNCQUFzQixHQUV0QixNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUN2QixNQUFNQyxNQUFNRCxtQkFBT0EsQ0FBQztBQUNwQixNQUFNRSxPQUFPRixtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQUVHLFFBQVEsRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQztBQUM3QixNQUFNSSxPQUFPSixtQkFBT0EsQ0FBQztBQUNyQixNQUFNSyxTQUFTTCxtQkFBT0EsQ0FBQztBQUN2QixNQUFNTSxVQUFVTixtQkFBT0EsQ0FBQztBQUN4QixNQUFNTyxpQkFBaUJQLG1CQUFPQSxDQUFDO0FBQy9CLE1BQU0sRUFDSlEsaUNBQWlDLEVBQ2pDQyxrQ0FBa0MsRUFDbENDLG9CQUFvQixFQUNwQkMsbUJBQW1CLEVBQ25CQyxtQkFBbUIsRUFDbkJDLG9CQUFvQixFQUNwQkMsV0FBVyxFQUNYQyxrQkFBa0IsRUFDbEJDLGdCQUFnQixFQUNoQkMsZUFBZSxFQUNmQyw0QkFBNEIsRUFDNUJDLG9CQUFvQixFQUNyQixHQUFHbkIsbUJBQU9BLENBQUM7QUFDWixNQUFNb0IsaUJBQWlCcEIsbUJBQU9BLENBQUM7QUFDL0IsTUFBTSxFQUNKcUIsSUFBSSxFQUNKQyxNQUFNLEVBQ05DLFdBQVcsRUFDWEMsT0FBTyxFQUNQQyxLQUFLLEVBQ0xDLE9BQU8sRUFDUEMsUUFBUSxFQUNSQyxTQUFTLEVBQ1RDLFNBQVMsRUFDVEMsUUFBUSxFQUNSQyxRQUFRLEVBQ1JDLEtBQUssRUFDTEMsUUFBUSxFQUNSQyxNQUFNLEVBQ05DLFVBQVUsRUFDVkMsV0FBVyxFQUNYQyxVQUFVLEVBQ1ZDLE1BQU0sRUFDTkMsd0JBQXdCLEVBQ3hCQyxXQUFXLEVBQ1hDLFdBQVcsRUFDWEMsV0FBVyxFQUNYQyxNQUFNLEVBQ05DLFdBQVcsRUFDWEMsT0FB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QUFFQTBOLE9BQU9ySixPQUFPLEdBQUdwSSIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NsaWVudC5qcz9iYWViIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1jaGVja1xuXG4ndXNlIHN0cmljdCdcblxuLyogZ2xvYmFsIFdlYkFzc2VtYmx5ICovXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKVxuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKVxuY29uc3QgeyBwaXBlbGluZSB9ID0gcmVxdWlyZSgnc3RyZWFtJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpXG5jb25zdCB0aW1lcnMgPSByZXF1aXJlKCcuL3RpbWVycycpXG5jb25zdCBSZXF1ZXN0ID0gcmVxdWlyZSgnLi9jb3JlL3JlcXVlc3QnKVxuY29uc3QgRGlzcGF0Y2hlckJhc2UgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXItYmFzZScpXG5jb25zdCB7XG4gIFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcixcbiAgUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcixcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIFJlcXVlc3RBYm9ydGVkRXJyb3IsXG4gIEhlYWRlcnNUaW1lb3V0RXJyb3IsXG4gIEhlYWRlcnNPdmVyZmxvd0Vycm9yLFxuICBTb2NrZXRFcnJvcixcbiAgSW5mb3JtYXRpb25hbEVycm9yLFxuICBCb2R5VGltZW91dEVycm9yLFxuICBIVFRQUGFyc2VyRXJyb3IsXG4gIFJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IsXG4gIENsaWVudERlc3Ryb3llZEVycm9yXG59ID0gcmVxdWlyZSgnLi9jb3JlL2Vycm9ycycpXG5jb25zdCBidWlsZENvbm5lY3RvciA9IHJlcXVpcmUoJy4vY29yZS9jb25uZWN0JylcbmNvbnN0IHtcbiAga1VybCxcbiAga1Jlc2V0LFxuICBrU2VydmVyTmFtZSxcbiAga0NsaWVudCxcbiAga0J1c3ksXG4gIGtQYXJzZXIsXG4gIGtDb25uZWN0LFxuICBrQmxvY2tpbmcsXG4gIGtSZXN1bWluZyxcbiAga1J1bm5pbmcsXG4gIGtQZW5kaW5nLFxuICBrU2l6ZSxcbiAga1dyaXRpbmcsXG4gIGtRdWV1ZSxcbiAga0Nvbm5lY3RlZCxcbiAga0Nvbm5lY3RpbmcsXG4gIGtOZWVkRHJhaW4sXG4gIGtOb1JlZixcbiAga0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0LFxuICBrSG9zdEhlYWRlcixcbiAga1BlbmRpbmdJZHgsXG4gIGtSdW5uaW5nSWR4LFxuICBrRXJyb3IsXG4gIGtQaXBlbGluaW5nLFxuICBrU29ja2V0LFxuICBrS2VlcEFsaXZlVGltZW91dFZhbHVlLFxuICBrTWF4SGVhZGVyc1NpemUsXG4gIGtLZWVwQWxpdmVNYXhUaW1lb3V0LFxuICBrS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCxcbiAga0hlYWRlcnNUaW1lb3V0LFxuICBrQm9keVRpbWVvdXQsXG4gIGtTdHJpY3RDb250ZW50TGVuZ3RoLFxuICBrQ29ubmVjdG9yLFxuICBrTWF4UmVkaXJlY3Rpb25zLFxuICBrTWF4UmVxdWVzdHMsXG4gIGtDb3VudGVyLFxuICBrQ2xvc2UsXG4gIGtEZXN0cm95LFxuICBrRGlzcGF0Y2gsXG4gIGtJbnRlcmNlcHRvcnMsXG4gIGtMb2NhbEFkZHJlc3MsXG4gIGtNYXhSZXNwb25zZVNpemUsXG4gIGtIVFRQQ29ublZlcnNpb24sXG4gIC8vIEhUVFAyXG4gIGtIb3N0LFxuICBrSFRUUDJTZXNzaW9uLFxuICBrSFRUUDJTZXNzaW9uU3RhdGUsXG4gIGtIVFRQMkJ1aWxkUmVxdWVzdCxcbiAga0hUVFAyQ29weUhlYWRlcnMsXG4gIGtIVFRQMUJ1aWxkUmVxdWVzdFxufSA9IHJlcXVpcmUoJy4vY29yZS9zeW1ib2xzJylcblxuLyoqIEB0eXBlIHtpbXBvcnQoJ2h0dHAyJyl9ICovXG5sZXQgaHR0cDJcbnRyeSB7XG4gIGh0dHAyID0gcmVxdWlyZSgnaHR0cDInKVxufSBjYXRjaCB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgaHR0cDIgPSB7IGNvbnN0YW50czoge30gfVxufVxuXG5jb25zdCB7XG4gIGNvbnN0YW50czoge1xuICAgIEhUVFAyX0hFQURFUl9BVVRIT1JJVFksXG4gICAgSFRUUDJfSEVBREVSX01FVEhPRCxcbiAgICBIVFRQMl9IRUFERVJfUEFUSCxcbiAgICBIVFRQMl9IRUFERVJfU0NIRU1FLFxuICAgIEhUVFAyX0hFQURFUl9DT05URU5UX0xFTkdUSCxcbiAgICBIVFRQMl9IRUFERVJfRVhQRUNULFxuICAgIEhUVFAyX0hFQURFUl9TVEFUVVNcbiAgfVxufSA9IGh0dHAyXG5cbi8vIEV4cGVyaW1lbnRhbFxubGV0IGgyRXhwZXJpbWVudGFsV2FybmVkID0gZmFsc2VcblxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc11cblxuY29uc3Qga0Nsb3NlZFJlc29sdmUgPSBTeW1ib2woJ2tDbG9zZWRSZXNvbHZlJylcblxuY29uc3QgY2hhbm5lbHMgPSB7fVxuXG50cnkge1xuICBjb25zdCBkaWFnbm9zdGljc0NoYW5uZWwgPSByZXF1aXJlKCdkaWFnbm9zdGljc19jaGFubmVsJylcbiAgY2hhbm5lbHMuc2VuZEhlYWRlcnMgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpzZW5kSGVhZGVycycpXG4gIGNoYW5uZWxzLmJlZm9yZUNvbm5lY3QgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpiZWZvcmVDb25uZWN0JylcbiAgY2hhbm5lbHMuY29ubmVjdEVycm9yID0gZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpjbGllbnQ6Y29ubmVjdEVycm9yJylcbiAgY2hhbm5lbHMuY29ubmVjdGVkID0gZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpjbGllbnQ6Y29ubmVjdGVkJylcbn0gY2F0Y2gge1xuICBjaGFubmVscy5zZW5kSGVhZGVycyA9IHsgaGFzU3Vic2NyaWJlcnM6IGZhbHNlIH1cbiAgY2hhbm5lbHMuYmVmb3JlQ29ubmVjdCA9IHsgaGFzU3Vic2NyaWJlcnM6IGZhbHNlIH1cbiAgY2hhbm5lbHMuY29ubmVjdEVycm9yID0geyBoYXNTdWJzY3JpYmVyczogZmFsc2UgfVxuICBjaGFubmVscy5jb25uZWN0ZWQgPSB7IGhhc1N1YnNjcmliZXJzOiBmYWxzZSB9XG59XG5cbi8qKlxuICogQHR5cGUge2ltcG9ydCgnLi4vdHlwZXMvY2xpZW50JykuZGVmYXVsdH1cbiAqL1xuY2xhc3MgQ2xpZW50IGV4dGVuZHMgRGlzcGF0Y2hlckJhc2Uge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8VVJMfSB1cmxcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL2NsaWVudCcpLkNsaWVudC5PcHRpb25zfSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodXJsLCB7XG4gICAgaW50ZXJjZXB0b3JzLFxuICAgIG1heEhlYWRlclNpemUsXG4gICAgaGVhZGVyc1RpbWVvdXQsXG4gICAgc29ja2V0VGltZW91dCxcbiAgICByZXF1ZXN0VGltZW91dCxcbiAgICBjb25uZWN0VGltZW91dCxcbiAgICBib2R5VGltZW91dCxcbiAgICBpZGxlVGltZW91dCxcbiAgICBrZWVwQWxpdmUsXG4gICAga2VlcEFsaXZlVGltZW91dCxcbiAgICBtYXhLZWVwQWxpdmVUaW1lb3V0LFxuICAgIGtlZXBBbGl2ZU1heFRpbWVvdXQsXG4gICAga2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCxcbiAgICBzb2NrZXRQYXRoLFxuICAgIHBpcGVsaW5pbmcsXG4gICAgdGxzLFxuICAgIHN0cmljdENvbnRlbnRMZW5ndGgsXG4gICAgbWF4Q2FjaGVkU2Vzc2lvbnMsXG4gICAgbWF4UmVkaXJlY3Rpb25zLFxuICAgIGNvbm5lY3QsXG4gICAgbWF4UmVxdWVzdHNQZXJDbGllbnQsXG4gICAgbG9jYWxBZGRyZXNzLFxuICAgIG1heFJlc3BvbnNlU2l6ZSxcbiAgICBhdXRvU2VsZWN0RmFtaWx5LFxuICAgIGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCxcbiAgICAvLyBoMlxuICAgIGFsbG93SDIsXG4gICAgbWF4Q29uY3VycmVudFN0cmVhbXNcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoKVxuXG4gICAgaWYgKGtlZXBBbGl2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Vuc3VwcG9ydGVkIGtlZXBBbGl2ZSwgdXNlIHBpcGVsaW5pbmc9MCBpbnN0ZWFkJylcbiAgICB9XG5cbiAgICBpZiAoc29ja2V0VGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Vuc3VwcG9ydGVkIHNvY2tldFRpbWVvdXQsIHVzZSBoZWFkZXJzVGltZW91dCAmIGJvZHlUaW1lb3V0IGluc3RlYWQnKVxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0VGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Vuc3VwcG9ydGVkIHJlcXVlc3RUaW1lb3V0LCB1c2UgaGVhZGVyc1RpbWVvdXQgJiBib2R5VGltZW91dCBpbnN0ZWFkJylcbiAgICB9XG5cbiAgICBpZiAoaWRsZVRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1bnN1cHBvcnRlZCBpZGxlVGltZW91dCwgdXNlIGtlZXBBbGl2ZVRpbWVvdXQgaW5zdGVhZCcpXG4gICAgfVxuXG4gICAgaWYgKG1heEtlZXBBbGl2ZVRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1bnN1cHBvcnRlZCBtYXhLZWVwQWxpdmVUaW1lb3V0LCB1c2Uga2VlcEFsaXZlTWF4VGltZW91dCBpbnN0ZWFkJylcbiAgICB9XG5cbiAgICBpZiAobWF4SGVhZGVyU2l6ZSAhPSBudWxsICYmICFOdW1iZXIuaXNGaW5pdGUobWF4SGVhZGVyU2l6ZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBtYXhIZWFkZXJTaXplJylcbiAgICB9XG5cbiAgICBpZiAoc29ja2V0UGF0aCAhPSBudWxsICYmIHR5cGVvZiBzb2NrZXRQYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHNvY2tldFBhdGgnKVxuICAgIH1cblxuICAgIGlmIChjb25uZWN0VGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGNvbm5lY3RUaW1lb3V0KSB8fCBjb25uZWN0VGltZW91dCA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY29ubmVjdFRpbWVvdXQnKVxuICAgIH1cblxuICAgIGlmIChrZWVwQWxpdmVUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNGaW5pdGUoa2VlcEFsaXZlVGltZW91dCkgfHwga2VlcEFsaXZlVGltZW91dCA8PSAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGtlZXBBbGl2ZVRpbWVvdXQnKVxuICAgIH1cblxuICAgIGlmIChrZWVwQWxpdmVNYXhUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNGaW5pdGUoa2VlcEFsaXZlTWF4VGltZW91dCkgfHwga2VlcEFsaXZlTWF4VGltZW91dCA8PSAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGtlZXBBbGl2ZU1heFRpbWVvdXQnKVxuICAgIH1cblxuICAgIGlmIChrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkICE9IG51bGwgJiYgIU51bWJlci5pc0Zpbml0ZShrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQnKVxuICAgIH1cblxuICAgIGlmIChoZWFkZXJzVGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihoZWFkZXJzVGltZW91dCkgfHwgaGVhZGVyc1RpbWVvdXQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdoZWFkZXJzVGltZW91dCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBvciB6ZXJvJylcbiAgICB9XG5cbiAgICBpZiAoYm9keVRpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIoYm9keVRpbWVvdXQpIHx8IGJvZHlUaW1lb3V0IDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignYm9keVRpbWVvdXQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgemVybycpXG4gICAgfVxuXG4gICAgaWYgKGNvbm5lY3QgIT0gbnVsbCAmJiB0eXBlb2YgY29ubmVjdCAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY29ubmVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignY29ubmVjdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0JylcbiAgICB9XG5cbiAgICBpZiAobWF4UmVkaXJlY3Rpb25zICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJlZGlyZWN0aW9ucykgfHwgbWF4UmVkaXJlY3Rpb25zIDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWF4UmVkaXJlY3Rpb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKVxuICAgIH1cblxuICAgIGlmIChtYXhSZXF1ZXN0c1BlckNsaWVudCAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZXF1ZXN0c1BlckNsaWVudCkgfHwgbWF4UmVxdWVzdHNQZXJDbGllbnQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtYXhSZXF1ZXN0c1BlckNsaWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICBpZiAobG9jYWxBZGRyZXNzICE9IG51bGwgJiYgKHR5cGVvZiBsb2NhbEFkZHJlc3MgIT09ICdzdHJpbmcnIHx8IG5ldC5pc0lQKGxvY2FsQWRkcmVzcykgPT09IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2xvY2FsQWRkcmVzcyBtdXN0IGJlIHZhbGlkIHN0cmluZyBJUCBhZGRyZXNzJylcbiAgICB9XG5cbiAgICBpZiAobWF4UmVzcG9uc2VTaXplICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJlc3BvbnNlU2l6ZSkgfHwgbWF4UmVzcG9uc2VTaXplIDwgLTEpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heFJlc3BvbnNlU2l6ZSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQgIT0gbnVsbCAmJlxuICAgICAgKCFOdW1iZXIuaXNJbnRlZ2VyKGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCkgfHwgYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0IDwgLTEpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2F1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICAvLyBoMlxuICAgIGlmIChhbGxvd0gyICE9IG51bGwgJiYgdHlwZW9mIGFsbG93SDIgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdhbGxvd0gyIG11c3QgYmUgYSB2YWxpZCBib29sZWFuIHZhbHVlJylcbiAgICB9XG5cbiAgICBpZiAobWF4Q29uY3VycmVudFN0cmVhbXMgIT0gbnVsbCAmJiAodHlwZW9mIG1heENvbmN1cnJlbnRTdHJlYW1zICE9PSAnbnVtYmVyJyB8fCBtYXhDb25jdXJyZW50U3RyZWFtcyA8IDEpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heENvbmN1cnJlbnRTdHJlYW1zIG11c3QgYmUgYSBwb3NzaXRpdmUgaW50ZWdlciwgZ3JlYXRlciB0aGFuIDAnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29ubmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29ubmVjdCA9IGJ1aWxkQ29ubmVjdG9yKHtcbiAgICAgICAgLi4udGxzLFxuICAgICAgICBtYXhDYWNoZWRTZXNzaW9ucyxcbiAgICAgICAgYWxsb3dIMixcbiAgICAgICAgc29ja2V0UGF0aCxcbiAgICAgICAgdGltZW91dDogY29ubmVjdFRpbWVvdXQsXG4gICAgICAgIC4uLih1dGlsLm5vZGVIYXNBdXRvU2VsZWN0RmFtaWx5ICYmIGF1dG9TZWxlY3RGYW1pbHkgPyB7IGF1dG9TZWxlY3RGYW1pbHksIGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCB9IDogdW5kZWZpbmVkKSxcbiAgICAgICAgLi4uY29ubmVjdFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzW2tJbnRlcmNlcHRvcnNdID0gaW50ZXJjZXB0b3JzICYmIGludGVyY2VwdG9ycy5DbGllbnQgJiYgQXJyYXkuaXNBcnJheShpbnRlcmNlcHRvcnMuQ2xpZW50KVxuICAgICAgPyBpbnRlcmNlcHRvcnMuQ2xpZW50XG4gICAgICA6IFtjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yKHsgbWF4UmVkaXJlY3Rpb25zIH0pXVxuICAgIHRoaXNba1VybF0gPSB1dGlsLnBhcnNlT3JpZ2luKHVybClcbiAgICB0aGlzW2tDb25uZWN0b3JdID0gY29ubmVjdFxuICAgIHRoaXNba1NvY2tldF0gPSBudWxsXG4gICAgdGhpc1trUGlwZWxpbmluZ10gPSBwaXBlbGluaW5nICE9IG51bGwgPyBwaXBlbGluaW5nIDogMVxuICAgIHRoaXNba01heEhlYWRlcnNTaXplXSA9IG1heEhlYWRlclNpemUgfHwgaHR0cC5tYXhIZWFkZXJTaXplXG4gICAgdGhpc1trS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXRdID0ga2VlcEFsaXZlVGltZW91dCA9PSBudWxsID8gNGUzIDoga2VlcEFsaXZlVGltZW91dFxuICAgIHRoaXNba0tlZXBBbGl2ZU1heFRpbWVvdXRdID0ga2VlcEFsaXZlTWF4VGltZW91dCA9PSBudWxsID8gNjAwZTMgOiBrZWVwQWxpdmVNYXhUaW1lb3V0XG4gICAgdGhpc1trS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZF0gPSBrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkID09IG51bGwgPyAxZTMgOiBrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkXG4gICAgdGhpc1trS2VlcEFsaXZlVGltZW91dFZhbHVlXSA9IHRoaXNba0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0XVxuICAgIHRoaXNba1NlcnZlck5hbWVdID0gbnVsbFxuICAgIHRoaXNba0xvY2FsQWRkcmVzc10gPSBsb2NhbEFkZHJlc3MgIT0gbnVsbCA/IGxvY2FsQWRkcmVzcyA6IG51bGxcbiAgICB0aGlzW2tSZXN1bWluZ10gPSAwIC8vIDAsIGlkbGUsIDEsIHNjaGVkdWxlZCwgMiByZXN1bWluZ1xuICAgIHRoaXNba05lZWREcmFpbl0gPSAwIC8vIDAsIGlkbGUsIDEsIHNjaGVkdWxlZCwgMiByZXN1bWluZ1xuICAgIHRoaXNba0hvc3RIZWFkZXJdID0gYGhvc3Q6ICR7dGhpc1trVXJsXS5ob3N0bmFtZX0ke3RoaXNba1VybF0ucG9ydCA/IGA6JHt0aGlzW2tVcmxdLnBvcnR9YCA6ICcnfVxcclxcbmBcbiAgICB0aGlzW2tCb2R5VGltZW91dF0gPSBib2R5VGltZW91dCAhPSBudWxsID8gYm9keVRpbWVvdXQgOiAzMDBlM1xuICAgIHRoaXNba0hlYWRlcnNUaW1lb3V0XSA9IGhlYWRlcnNUaW1lb3V0ICE9IG51bGwgPyBoZWFkZXJzVGltZW91dCA6IDMwMGUzXG4gICAgdGhpc1trU3RyaWN0Q29udGVudExlbmd0aF0gPSBzdHJpY3RDb250ZW50TGVuZ3RoID09IG51bGwgPyB0cnVlIDogc3RyaWN0Q29udGVudExlbmd0aFxuICAgIHRoaXNba01heFJlZGlyZWN0aW9uc10gPSBtYXhSZWRpcmVjdGlvbnNcbiAgICB0aGlzW2tNYXhSZXF1ZXN0c10gPSBtYXhSZXF1ZXN0c1BlckNsaWVudFxuICAgIHRoaXNba0Nsb3NlZFJlc29sdmVdID0gbnVsbFxuICAgIHRoaXNba01heFJlc3BvbnNlU2l6ZV0gPSBtYXhSZXNwb25zZVNpemUgPiAtMSA/IG1heFJlc3BvbnNlU2l6ZSA6IC0xXG4gICAgdGhpc1trSFRUUENvbm5WZXJzaW9uXSA9ICdoMSdcblxuICAgIC8vIEhUVFAvMlxuICAgIHRoaXNba0hUVFAyU2Vzc2lvbl0gPSBudWxsXG4gICAgdGhpc1trSFRUUDJTZXNzaW9uU3RhdGVdID0gIWFsbG93SDJcbiAgICAgID8gbnVsbFxuICAgICAgOiB7XG4gICAgICAgIC8vIHN0cmVhbXM6IG51bGwsIC8vIEZpeGVkIHF1ZXVlIG9mIHN0cmVhbXMgLSBGb3IgZnV0dXJlIHN1cHBvcnQgb2YgYHB1c2hgXG4gICAgICAgICAgb3BlblN0cmVhbXM6IDAsIC8vIEtlZXAgdHJhY2sgb2YgdGhlbSB0byBkZWNpZGUgd2V0aGVyIG9yIG5vdCB1bnJlZiB0aGUgc2Vzc2lvblxuICAgICAgICAgIG1heENvbmN1cnJlbnRTdHJlYW1zOiBtYXhDb25jdXJyZW50U3RyZWFtcyAhPSBudWxsID8gbWF4Q29uY3VycmVudFN0cmVhbXMgOiAxMDAgLy8gTWF4IHBlZXJDb25jdXJyZW50U3RyZWFtcyBmb3IgYSBOb2RlIGgyIHNlcnZlclxuICAgICAgICB9XG4gICAgdGhpc1trSG9zdF0gPSBgJHt0aGlzW2tVcmxdLmhvc3RuYW1lfSR7dGhpc1trVXJsXS5wb3J0ID8gYDoke3RoaXNba1VybF0ucG9ydH1gIDogJyd9YFxuXG4gICAgLy8ga1F1ZXVlIGlzIGJ1aWx0IHVwIG9mIDMgc2VjdGlvbnMgc2VwYXJhdGVkIGJ5XG4gICAgLy8gdGhlIGtSdW5uaW5nSWR4IGFuZCBrUGVuZGluZ0lkeCBpbmRpY2VzLlxuICAgIC8vIHwgICBjb21wbGV0ZSAgIHwgICBydW5uaW5nICAgfCAgIHBlbmRpbmcgICB8XG4gICAgLy8gICAgICAgICAgICAgICAgXiBrUnVubmluZ0lkeCBeIGtQZW5kaW5nSWR4IF4ga1F1ZXVlLmxlbmd0aFxuICAgIC8vIGtSdW5uaW5nSWR4IHBvaW50cyB0byB0aGUgZmlyc3QgcnVubmluZyBlbGVtZW50LlxuICAgIC8vIGtQZW5kaW5nSWR4IHBvaW50cyB0byB0aGUgZmlyc3QgcGVuZGluZyBlbGVtZW50LlxuICAgIC8vIFRoaXMgaW1wbGVtZW50cyBhIGZhc3QgcXVldWUgd2l0aCBhbiBhbW9ydGl6ZWRcbiAgICAvLyB0aW1lIG9mIE8oMSkuXG5cbiAgICB0aGlzW2tRdWV1ZV0gPSBbXVxuICAgIHRoaXNba1J1bm5pbmdJZHhdID0gMFxuICAgIHRoaXNba1BlbmRpbmdJZHhdID0gMFxuICB9XG5cbiAgZ2V0IHBpcGVsaW5pbmcgKCkge1xuICAgIHJldHVybiB0aGlzW2tQaXBlbGluaW5nXVxuICB9XG5cbiAgc2V0IHBpcGVsaW5pbmcgKHZhbHVlKSB7XG4gICAgdGhpc1trUGlwZWxpbmluZ10gPSB2YWx1ZVxuICAgIHJlc3VtZSh0aGlzLCB0cnVlKVxuICB9XG5cbiAgZ2V0IFtrUGVuZGluZ10gKCkge1xuICAgIHJldHVybiB0aGlzW2tRdWV1ZV0ubGVuZ3RoIC0gdGhpc1trUGVuZGluZ0lkeF1cbiAgfVxuXG4gIGdldCBba1J1bm5pbmddICgpIHtcbiAgICByZXR1cm4gdGhpc1trUGVuZGluZ0lkeF0gLSB0aGlzW2tSdW5uaW5nSWR4XVxuICB9XG5cbiAgZ2V0IFtrU2l6ZV0gKCkge1xuICAgIHJldHVybiB0aGlzW2tRdWV1ZV0ubGVuZ3RoIC0gdGhpc1trUnVubmluZ0lkeF1cbiAgfVxuXG4gIGdldCBba0Nvbm5lY3RlZF0gKCkge1xuICAgIHJldHVybiAhIXRoaXNba1NvY2tldF0gJiYgIXRoaXNba0Nvbm5lY3RpbmddICYmICF0aGlzW2tTb2NrZXRdLmRlc3Ryb3llZFxuICB9XG5cbiAgZ2V0IFtrQnVzeV0gKCkge1xuICAgIGNvbnN0IHNvY2tldCA9IHRoaXNba1NvY2tldF1cbiAgICByZXR1cm4gKFxuICAgICAgKHNvY2tldCAmJiAoc29ja2V0W2tSZXNldF0gfHwgc29ja2V0W2tXcml0aW5nXSB8fCBzb2NrZXRba0Jsb2NraW5nXSkpIHx8XG4gICAgICAodGhpc1trU2l6ZV0gPj0gKHRoaXNba1BpcGVsaW5pbmddIHx8IDEpKSB8fFxuICAgICAgdGhpc1trUGVuZGluZ10gPiAwXG4gICAgKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlOiBvbmx5IHVzZWQgZm9yIHRlc3QgKi9cbiAgW2tDb25uZWN0XSAoY2IpIHtcbiAgICBjb25uZWN0KHRoaXMpXG4gICAgdGhpcy5vbmNlKCdjb25uZWN0JywgY2IpXG4gIH1cblxuICBba0Rpc3BhdGNoXSAob3B0cywgaGFuZGxlcikge1xuICAgIGNvbnN0IG9yaWdpbiA9IG9wdHMub3JpZ2luIHx8IHRoaXNba1VybF0ub3JpZ2luXG5cbiAgICBjb25zdCByZXF1ZXN0ID0gdGhpc1trSFRUUENvbm5WZXJzaW9uXSA9PT0gJ2gyJ1xuICAgICAgPyBSZXF1ZXN0W2tIVFRQMkJ1aWxkUmVxdWVzdF0ob3JpZ2luLCBvcHRzLCBoYW5kbGVyKVxuICAgICAgOiBSZXF1ZXN0W2tIVFRQMUJ1aWxkUmVxdWVzdF0ob3JpZ2luLCBvcHRzLCBoYW5kbGVyKVxuXG4gICAgdGhpc1trUXVldWVdLnB1c2gocmVxdWVzdClcbiAgICBpZiAodGhpc1trUmVzdW1pbmddKSB7XG4gICAgICAvLyBEbyBub3RoaW5nLlxuICAgIH0gZWxzZSBpZiAodXRpbC5ib2R5TGVuZ3RoKHJlcXVlc3QuYm9keSkgPT0gbnVsbCAmJiB1dGlsLmlzSXRlcmFibGUocmVxdWVzdC5ib2R5KSkge1xuICAgICAgLy8gV2FpdCBhIHRpY2sgaW4gY2FzZSBzdHJlYW0vaXRlcmF0b3IgaXMgZW5kZWQgaW4gdGhlIHNhbWUgdGljay5cbiAgICAgIHRoaXNba1Jlc3VtaW5nXSA9IDFcbiAgICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB0aGlzKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bWUodGhpcywgdHJ1ZSlcbiAgICB9XG5cbiAgICBpZiAodGhpc1trUmVzdW1pbmddICYmIHRoaXNba05lZWREcmFpbl0gIT09IDIgJiYgdGhpc1trQnVzeV0pIHtcbiAgICAgIHRoaXNba05lZWREcmFpbl0gPSAyXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNba05lZWREcmFpbl0gPCAyXG4gIH1cblxuICBhc3luYyBba0Nsb3NlXSAoKSB7XG4gICAgLy8gVE9ETzogZm9yIEgyIHdlIG5lZWQgdG8gZ3JhY2VmdWxseSBmbHVzaCB0aGUgcmVtYWluaW5nIGVucXVldWVkXG4gICAgLy8gcmVxdWVzdCBhbmQgY2xvc2UgZWFjaCBzdHJlYW0uXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBpZiAoIXRoaXNba1NpemVdKSB7XG4gICAgICAgIHJlc29sdmUobnVsbClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNba0Nsb3NlZFJlc29sdmVdID0gcmVzb2x2ZVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBhc3luYyBba0Rlc3Ryb3ldIChlcnIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3RzID0gdGhpc1trUXVldWVdLnNwbGljZSh0aGlzW2tQZW5kaW5nSWR4XSlcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzW2ldXG4gICAgICAgIGVycm9yUmVxdWVzdCh0aGlzLCByZXF1ZXN0LCBlcnIpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpc1trQ2xvc2VkUmVzb2x2ZV0pIHtcbiAgICAgICAgICAvLyBUT0RPIChmaXgpOiBTaG91bGQgd2UgZXJyb3IgaGVyZSB3aXRoIENsaWVudERlc3Ryb3llZEVycm9yP1xuICAgICAgICAgIHRoaXNba0Nsb3NlZFJlc29sdmVdKClcbiAgICAgICAgICB0aGlzW2tDbG9zZWRSZXNvbHZlXSA9IG51bGxcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNba0hUVFAyU2Vzc2lvbl0gIT0gbnVsbCkge1xuICAgICAgICB1dGlsLmRlc3Ryb3kodGhpc1trSFRUUDJTZXNzaW9uXSwgZXJyKVxuICAgICAgICB0aGlzW2tIVFRQMlNlc3Npb25dID0gbnVsbFxuICAgICAgICB0aGlzW2tIVFRQMlNlc3Npb25TdGF0ZV0gPSBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpc1trU29ja2V0XSkge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzayhjYWxsYmFjaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwuZGVzdHJveSh0aGlzW2tTb2NrZXRdLm9uKCdjbG9zZScsIGNhbGxiYWNrKSwgZXJyKVxuICAgICAgfVxuXG4gICAgICByZXN1bWUodGhpcylcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uSHR0cDJTZXNzaW9uRXJyb3IgKGVycikge1xuICBhc3NlcnQoZXJyLmNvZGUgIT09ICdFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEJylcblxuICB0aGlzW2tTb2NrZXRdW2tFcnJvcl0gPSBlcnJcblxuICBvbkVycm9yKHRoaXNba0NsaWVudF0sIGVycilcbn1cblxuZnVuY3Rpb24gb25IdHRwMkZyYW1lRXJyb3IgKHR5cGUsIGNvZGUsIGlkKSB7XG4gIGNvbnN0IGVyciA9IG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoYEhUVFAvMjogXCJmcmFtZUVycm9yXCIgcmVjZWl2ZWQgLSB0eXBlICR7dHlwZX0sIGNvZGUgJHtjb2RlfWApXG5cbiAgaWYgKGlkID09PSAwKSB7XG4gICAgdGhpc1trU29ja2V0XVtrRXJyb3JdID0gZXJyXG4gICAgb25FcnJvcih0aGlzW2tDbGllbnRdLCBlcnIpXG4gIH1cbn1cblxuZnVuY3Rpb24gb25IdHRwMlNlc3Npb25FbmQgKCkge1xuICB1dGlsLmRlc3Ryb3kodGhpcywgbmV3IFNvY2tldEVycm9yKCdvdGhlciBzaWRlIGNsb3NlZCcpKVxuICB1dGlsLmRlc3Ryb3kodGhpc1trU29ja2V0XSwgbmV3IFNvY2tldEVycm9yKCdvdGhlciBzaWRlIGNsb3NlZCcpKVxufVxuXG5mdW5jdGlvbiBvbkhUVFAyR29Bd2F5IChjb2RlKSB7XG4gIGNvbnN0IGNsaWVudCA9IHRoaXNba0NsaWVudF1cbiAgY29uc3QgZXJyID0gbmV3IEluZm9ybWF0aW9uYWxFcnJvcihgSFRUUC8yOiBcIkdPQVdBWVwiIGZyYW1lIHJlY2VpdmVkIHdpdGggY29kZSAke2NvZGV9YClcbiAgY2xpZW50W2tTb2NrZXRdID0gbnVsbFxuICBjbGllbnRba0hUVFAyU2Vzc2lvbl0gPSBudWxsXG5cbiAgaWYgKGNsaWVudC5kZXN0cm95ZWQpIHtcbiAgICBhc3NlcnQodGhpc1trUGVuZGluZ10gPT09IDApXG5cbiAgICAvLyBGYWlsIGVudGlyZSBxdWV1ZS5cbiAgICBjb25zdCByZXF1ZXN0cyA9IGNsaWVudFtrUXVldWVdLnNwbGljZShjbGllbnRba1J1bm5pbmdJZHhdKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0c1tpXVxuICAgICAgZXJyb3JSZXF1ZXN0KHRoaXMsIHJlcXVlc3QsIGVycilcbiAgICB9XG4gIH0gZWxzZSBpZiAoY2xpZW50W2tSdW5uaW5nXSA+IDApIHtcbiAgICAvLyBGYWlsIGhlYWQgb2YgcGlwZWxpbmUuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG4gICAgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XSsrXSA9IG51bGxcblxuICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgfVxuXG4gIGNsaWVudFtrUGVuZGluZ0lkeF0gPSBjbGllbnRba1J1bm5pbmdJZHhdXG5cbiAgYXNzZXJ0KGNsaWVudFtrUnVubmluZ10gPT09IDApXG5cbiAgY2xpZW50LmVtaXQoJ2Rpc2Nvbm5lY3QnLFxuICAgIGNsaWVudFtrVXJsXSxcbiAgICBbY2xpZW50XSxcbiAgICBlcnJcbiAgKVxuXG4gIHJlc3VtZShjbGllbnQpXG59XG5cbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vbGxodHRwL2NvbnN0YW50cycpXG5jb25zdCBjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yID0gcmVxdWlyZSgnLi9pbnRlcmNlcHRvci9yZWRpcmVjdEludGVyY2VwdG9yJylcbmNvbnN0IEVNUFRZX0JVRiA9IEJ1ZmZlci5hbGxvYygwKVxuXG5hc3luYyBmdW5jdGlvbiBsYXp5bGxodHRwICgpIHtcbiAgY29uc3QgbGxodHRwV2FzbURhdGEgPSBwcm9jZXNzLmVudi5KRVNUX1dPUktFUl9JRCA/IHJlcXVpcmUoJy4vbGxodHRwL2xsaHR0cC13YXNtLmpzJykgOiB1bmRlZmluZWRcblxuICBsZXQgbW9kXG4gIHRyeSB7XG4gICAgbW9kID0gYXdhaXQgV2ViQXNzZW1ibHkuY29tcGlsZShCdWZmZXIuZnJvbShyZXF1aXJlKCcuL2xsaHR0cC9sbGh0dHBfc2ltZC13YXNtLmpzJyksICdiYXNlNjQnKSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICAvLyBXZSBjb3VsZCBjaGVjayBpZiB0aGUgZXJyb3Igd2FzIGNhdXNlZCBieSB0aGUgc2ltZCBvcHRpb24gbm90XG4gICAgLy8gYmVpbmcgZW5hYmxlZCwgYnV0IHRoZSBvY2N1cnJpbmcgb2YgdGhpcyBvdGhlciBlcnJvclxuICAgIC8vICogaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL2lzc3Vlcy8xMTQ5NVxuICAgIC8vIGdvdCBtZSB0byByZW1vdmUgdGhhdCBjaGVjayB0byBhdm9pZCBicmVha2luZyBOb2RlIDEyLlxuICAgIG1vZCA9IGF3YWl0IFdlYkFzc2VtYmx5LmNvbXBpbGUoQnVmZmVyLmZyb20obGxodHRwV2FzbURhdGEgfHwgcmVxdWlyZSgnLi9sbGh0dHAvbGxodHRwLXdhc20uanMnKSwgJ2Jhc2U2NCcpKVxuICB9XG5cbiAgcmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKG1vZCwge1xuICAgIGVudjoge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG5cbiAgICAgIHdhc21fb25fdXJsOiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSxcbiAgICAgIHdhc21fb25fc3RhdHVzOiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY3VycmVudFBhcnNlci5wdHIsIHApXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gYXQgLSBjdXJyZW50QnVmZmVyUHRyICsgY3VycmVudEJ1ZmZlclJlZi5ieXRlT2Zmc2V0XG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uU3RhdHVzKG5ldyBGYXN0QnVmZmVyKGN1cnJlbnRCdWZmZXJSZWYuYnVmZmVyLCBzdGFydCwgbGVuKSkgfHwgMFxuICAgICAgfSxcbiAgICAgIHdhc21fb25fbWVzc2FnZV9iZWdpbjogKHApID0+IHtcbiAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGN1cnJlbnRQYXJzZXIucHRyLCBwKVxuICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbk1lc3NhZ2VCZWdpbigpIHx8IDBcbiAgICAgIH0sXG4gICAgICB3YXNtX29uX2hlYWRlcl9maWVsZDogKHAsIGF0LCBsZW4pID0+IHtcbiAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGN1cnJlbnRQYXJzZXIucHRyLCBwKVxuICAgICAgICBjb25zdCBzdGFydCA9IGF0IC0gY3VycmVudEJ1ZmZlclB0ciArIGN1cnJlbnRCdWZmZXJSZWYuYnl0ZU9mZnNldFxuICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbkhlYWRlckZpZWxkKG5ldyBGYXN0QnVmZmVyKGN1cnJlbnRCdWZmZXJSZWYuYnVmZmVyLCBzdGFydCwgbGVuKSkgfHwgMFxuICAgICAgfSxcbiAgICAgIHdhc21fb25faGVhZGVyX3ZhbHVlOiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY3VycmVudFBhcnNlci5wdHIsIHApXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gYXQgLSBjdXJyZW50QnVmZmVyUHRyICsgY3VycmVudEJ1ZmZlclJlZi5ieXRlT2Zmc2V0XG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uSGVhZGVyVmFsdWUobmV3IEZhc3RCdWZmZXIoY3VycmVudEJ1ZmZlclJlZi5idWZmZXIsIHN0YXJ0LCBsZW4pKSB8fCAwXG4gICAgICB9LFxuICAgICAgd2FzbV9vbl9oZWFkZXJzX2NvbXBsZXRlOiAocCwgc3RhdHVzQ29kZSwgdXBncmFkZSwgc2hvdWxkS2VlcEFsaXZlKSA9PiB7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0ciwgcClcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25IZWFkZXJzQ29tcGxldGUoc3RhdHVzQ29kZSwgQm9vbGVhbih1cGdyYWRlKSwgQm9vbGVhbihzaG91bGRLZWVwQWxpdmUpKSB8fCAwXG4gICAgICB9LFxuICAgICAgd2FzbV9vbl9ib2R5OiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY3VycmVudFBhcnNlci5wdHIsIHApXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gYXQgLSBjdXJyZW50QnVmZmVyUHRyICsgY3VycmVudEJ1ZmZlclJlZi5ieXRlT2Zmc2V0XG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uQm9keShuZXcgRmFzdEJ1ZmZlcihjdXJyZW50QnVmZmVyUmVmLmJ1ZmZlciwgc3RhcnQsIGxlbikpIHx8IDBcbiAgICAgIH0sXG4gICAgICB3YXNtX29uX21lc3NhZ2VfY29tcGxldGU6IChwKSA9PiB7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0ciwgcClcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25NZXNzYWdlQ29tcGxldGUoKSB8fCAwXG4gICAgICB9XG5cbiAgICAgIC8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG4gICAgfVxuICB9KVxufVxuXG5sZXQgbGxodHRwSW5zdGFuY2UgPSBudWxsXG5sZXQgbGxodHRwUHJvbWlzZSA9IGxhenlsbGh0dHAoKVxubGxodHRwUHJvbWlzZS5jYXRjaCgpXG5cbmxldCBjdXJyZW50UGFyc2VyID0gbnVsbFxubGV0IGN1cnJlbnRCdWZmZXJSZWYgPSBudWxsXG5sZXQgY3VycmVudEJ1ZmZlclNpemUgPSAwXG5sZXQgY3VycmVudEJ1ZmZlclB0ciA9IG51bGxcblxuY29uc3QgVElNRU9VVF9IRUFERVJTID0gMVxuY29uc3QgVElNRU9VVF9CT0RZID0gMlxuY29uc3QgVElNRU9VVF9JRExFID0gM1xuXG5jbGFzcyBQYXJzZXIge1xuICBjb25zdHJ1Y3RvciAoY2xpZW50LCBzb2NrZXQsIHsgZXhwb3J0cyB9KSB7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShjbGllbnRba01heEhlYWRlcnNTaXplXSkgJiYgY2xpZW50W2tNYXhIZWFkZXJzU2l6ZV0gPiAwKVxuXG4gICAgdGhpcy5sbGh0dHAgPSBleHBvcnRzXG4gICAgdGhpcy5wdHIgPSB0aGlzLmxsaHR0cC5sbGh0dHBfYWxsb2MoY29uc3RhbnRzLlRZUEUuUkVTUE9OU0UpXG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnRcbiAgICB0aGlzLnNvY2tldCA9IHNvY2tldFxuICAgIHRoaXMudGltZW91dCA9IG51bGxcbiAgICB0aGlzLnRpbWVvdXRWYWx1ZSA9IG51bGxcbiAgICB0aGlzLnRpbWVvdXRUeXBlID0gbnVsbFxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IG51bGxcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnJ1xuICAgIHRoaXMudXBncmFkZSA9IGZhbHNlXG4gICAgdGhpcy5oZWFkZXJzID0gW11cbiAgICB0aGlzLmhlYWRlcnNTaXplID0gMFxuICAgIHRoaXMuaGVhZGVyc01heFNpemUgPSBjbGllbnRba01heEhlYWRlcnNTaXplXVxuICAgIHRoaXMuc2hvdWxkS2VlcEFsaXZlID0gZmFsc2VcbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlXG4gICAgdGhpcy5yZXN1bWUgPSB0aGlzLnJlc3VtZS5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLmJ5dGVzUmVhZCA9IDBcblxuICAgIHRoaXMua2VlcEFsaXZlID0gJydcbiAgICB0aGlzLmNvbnRlbnRMZW5ndGggPSAnJ1xuICAgIHRoaXMuY29ubmVjdGlvbiA9ICcnXG4gICAgdGhpcy5tYXhSZXNwb25zZVNpemUgPSBjbGllbnRba01heFJlc3BvbnNlU2l6ZV1cbiAgfVxuXG4gIHNldFRpbWVvdXQgKHZhbHVlLCB0eXBlKSB7XG4gICAgdGhpcy50aW1lb3V0VHlwZSA9IHR5cGVcbiAgICBpZiAodmFsdWUgIT09IHRoaXMudGltZW91dFZhbHVlKSB7XG4gICAgICB0aW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dClcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lcnMuc2V0VGltZW91dChvblBhcnNlclRpbWVvdXQsIHZhbHVlLCB0aGlzKVxuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogb25seSBmb3IgamVzdFxuICAgICAgICBpZiAodGhpcy50aW1lb3V0LnVucmVmKSB7XG4gICAgICAgICAgdGhpcy50aW1lb3V0LnVucmVmKClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gbnVsbFxuICAgICAgfVxuICAgICAgdGhpcy50aW1lb3V0VmFsdWUgPSB2YWx1ZVxuICAgIH0gZWxzZSBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogb25seSBmb3IgamVzdFxuICAgICAgaWYgKHRoaXMudGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgIHRoaXMudGltZW91dC5yZWZyZXNoKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXN1bWUgKCkge1xuICAgIGlmICh0aGlzLnNvY2tldC5kZXN0cm95ZWQgfHwgIXRoaXMucGF1c2VkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhc3NlcnQodGhpcy5wdHIgIT0gbnVsbClcbiAgICBhc3NlcnQoY3VycmVudFBhcnNlciA9PSBudWxsKVxuXG4gICAgdGhpcy5sbGh0dHAubGxodHRwX3Jlc3VtZSh0aGlzLnB0cilcblxuICAgIGFzc2VydCh0aGlzLnRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0JPRFkpXG4gICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U6IG9ubHkgZm9yIGplc3RcbiAgICAgIGlmICh0aGlzLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICB0aGlzLnRpbWVvdXQucmVmcmVzaCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZVxuICAgIHRoaXMuZXhlY3V0ZSh0aGlzLnNvY2tldC5yZWFkKCkgfHwgRU1QVFlfQlVGKSAvLyBGbHVzaCBwYXJzZXIuXG4gICAgdGhpcy5yZWFkTW9yZSgpXG4gIH1cblxuICByZWFkTW9yZSAoKSB7XG4gICAgd2hpbGUgKCF0aGlzLnBhdXNlZCAmJiB0aGlzLnB0cikge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLnNvY2tldC5yZWFkKClcbiAgICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgdGhpcy5leGVjdXRlKGNodW5rKVxuICAgIH1cbiAgfVxuXG4gIGV4ZWN1dGUgKGRhdGEpIHtcbiAgICBhc3NlcnQodGhpcy5wdHIgIT0gbnVsbClcbiAgICBhc3NlcnQoY3VycmVudFBhcnNlciA9PSBudWxsKVxuICAgIGFzc2VydCghdGhpcy5wYXVzZWQpXG5cbiAgICBjb25zdCB7IHNvY2tldCwgbGxodHRwIH0gPSB0aGlzXG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPiBjdXJyZW50QnVmZmVyU2l6ZSkge1xuICAgICAgaWYgKGN1cnJlbnRCdWZmZXJQdHIpIHtcbiAgICAgICAgbGxodHRwLmZyZWUoY3VycmVudEJ1ZmZlclB0cilcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRCdWZmZXJTaXplID0gTWF0aC5jZWlsKGRhdGEubGVuZ3RoIC8gNDA5NikgKiA0MDk2XG4gICAgICBjdXJyZW50QnVmZmVyUHRyID0gbGxodHRwLm1hbGxvYyhjdXJyZW50QnVmZmVyU2l6ZSlcbiAgICB9XG5cbiAgICBuZXcgVWludDhBcnJheShsbGh0dHAubWVtb3J5LmJ1ZmZlciwgY3VycmVudEJ1ZmZlclB0ciwgY3VycmVudEJ1ZmZlclNpemUpLnNldChkYXRhKVxuXG4gICAgLy8gQ2FsbCBgZXhlY3V0ZWAgb24gdGhlIHdhc20gcGFyc2VyLlxuICAgIC8vIFdlIHBhc3MgdGhlIGBsbGh0dHBfcGFyc2VyYCBwb2ludGVyIGFkZHJlc3MsIHRoZSBwb2ludGVyIGFkZHJlc3Mgb2YgYnVmZmVyIHZpZXcgZGF0YSxcbiAgICAvLyBhbmQgZmluYWxseSB0aGUgbGVuZ3RoIG9mIGJ5dGVzIHRvIHBhcnNlLlxuICAgIC8vIFRoZSByZXR1cm4gdmFsdWUgaXMgYW4gZXJyb3IgY29kZSBvciBgY29uc3RhbnRzLkVSUk9SLk9LYC5cbiAgICB0cnkge1xuICAgICAgbGV0IHJldFxuXG4gICAgICB0cnkge1xuICAgICAgICBjdXJyZW50QnVmZmVyUmVmID0gZGF0YVxuICAgICAgICBjdXJyZW50UGFyc2VyID0gdGhpc1xuICAgICAgICByZXQgPSBsbGh0dHAubGxodHRwX2V4ZWN1dGUodGhpcy5wdHIsIGN1cnJlbnRCdWZmZXJQdHIsIGRhdGEubGVuZ3RoKVxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYXRjaCAqL1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkaWZmaWN1bHQgdG8gbWFrZSBhIHRlc3QgY2FzZSBmb3IgKi9cbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50UGFyc2VyID0gbnVsbFxuICAgICAgICBjdXJyZW50QnVmZmVyUmVmID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBjb25zdCBvZmZzZXQgPSBsbGh0dHAubGxodHRwX2dldF9lcnJvcl9wb3ModGhpcy5wdHIpIC0gY3VycmVudEJ1ZmZlclB0clxuXG4gICAgICBpZiAocmV0ID09PSBjb25zdGFudHMuRVJST1IuUEFVU0VEX1VQR1JBREUpIHtcbiAgICAgICAgdGhpcy5vblVwZ3JhZGUoZGF0YS5zbGljZShvZmZzZXQpKVxuICAgICAgfSBlbHNlIGlmIChyZXQgPT09IGNvbnN0YW50cy5FUlJPUi5QQVVTRUQpIHtcbiAgICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlXG4gICAgICAgIHNvY2tldC51bnNoaWZ0KGRhdGEuc2xpY2Uob2Zmc2V0KSlcbiAgICAgIH0gZWxzZSBpZiAocmV0ICE9PSBjb25zdGFudHMuRVJST1IuT0spIHtcbiAgICAgICAgY29uc3QgcHRyID0gbGxodHRwLmxsaHR0cF9nZXRfZXJyb3JfcmVhc29uKHRoaXMucHRyKVxuICAgICAgICBsZXQgbWVzc2FnZSA9ICcnXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBkaWZmaWN1bHQgdG8gbWFrZSBhIHRlc3QgY2FzZSBmb3IgKi9cbiAgICAgICAgaWYgKHB0cikge1xuICAgICAgICAgIGNvbnN0IGxlbiA9IG5ldyBVaW50OEFycmF5KGxsaHR0cC5tZW1vcnkuYnVmZmVyLCBwdHIpLmluZGV4T2YoMClcbiAgICAgICAgICBtZXNzYWdlID1cbiAgICAgICAgICAgICdSZXNwb25zZSBkb2VzIG5vdCBtYXRjaCB0aGUgSFRUUC8xLjEgcHJvdG9jb2wgKCcgK1xuICAgICAgICAgICAgQnVmZmVyLmZyb20obGxodHRwLm1lbW9yeS5idWZmZXIsIHB0ciwgbGVuKS50b1N0cmluZygpICtcbiAgICAgICAgICAgICcpJ1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBIVFRQUGFyc2VyRXJyb3IobWVzc2FnZSwgY29uc3RhbnRzLkVSUk9SW3JldF0sIGRhdGEuc2xpY2Uob2Zmc2V0KSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIGVycilcbiAgICB9XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBhc3NlcnQodGhpcy5wdHIgIT0gbnVsbClcbiAgICBhc3NlcnQoY3VycmVudFBhcnNlciA9PSBudWxsKVxuXG4gICAgdGhpcy5sbGh0dHAubGxodHRwX2ZyZWUodGhpcy5wdHIpXG4gICAgdGhpcy5wdHIgPSBudWxsXG5cbiAgICB0aW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dClcbiAgICB0aGlzLnRpbWVvdXQgPSBudWxsXG4gICAgdGhpcy50aW1lb3V0VmFsdWUgPSBudWxsXG4gICAgdGhpcy50aW1lb3V0VHlwZSA9IG51bGxcblxuICAgIHRoaXMucGF1c2VkID0gZmFsc2VcbiAgfVxuXG4gIG9uU3RhdHVzIChidWYpIHtcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBidWYudG9TdHJpbmcoKVxuICB9XG5cbiAgb25NZXNzYWdlQmVnaW4gKCkge1xuICAgIGNvbnN0IHsgc29ja2V0LCBjbGllbnQgfSA9IHRoaXNcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkaWZmaWN1bHQgdG8gbWFrZSBhIHRlc3QgY2FzZSBmb3IgKi9cbiAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG4gICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gIH1cblxuICBvbkhlYWRlckZpZWxkIChidWYpIHtcbiAgICBjb25zdCBsZW4gPSB0aGlzLmhlYWRlcnMubGVuZ3RoXG5cbiAgICBpZiAoKGxlbiAmIDEpID09PSAwKSB7XG4gICAgICB0aGlzLmhlYWRlcnMucHVzaChidWYpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVhZGVyc1tsZW4gLSAxXSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuaGVhZGVyc1tsZW4gLSAxXSwgYnVmXSlcbiAgICB9XG5cbiAgICB0aGlzLnRyYWNrSGVhZGVyKGJ1Zi5sZW5ndGgpXG4gIH1cblxuICBvbkhlYWRlclZhbHVlIChidWYpIHtcbiAgICBsZXQgbGVuID0gdGhpcy5oZWFkZXJzLmxlbmd0aFxuXG4gICAgaWYgKChsZW4gJiAxKSA9PT0gMSkge1xuICAgICAgdGhpcy5oZWFkZXJzLnB1c2goYnVmKVxuICAgICAgbGVuICs9IDFcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWFkZXJzW2xlbiAtIDFdID0gQnVmZmVyLmNvbmNhdChbdGhpcy5oZWFkZXJzW2xlbiAtIDFdLCBidWZdKVxuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IHRoaXMuaGVhZGVyc1tsZW4gLSAyXVxuICAgIGlmIChrZXkubGVuZ3RoID09PSAxMCAmJiBrZXkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSAna2VlcC1hbGl2ZScpIHtcbiAgICAgIHRoaXMua2VlcEFsaXZlICs9IGJ1Zi50b1N0cmluZygpXG4gICAgfSBlbHNlIGlmIChrZXkubGVuZ3RoID09PSAxMCAmJiBrZXkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSAnY29ubmVjdGlvbicpIHtcbiAgICAgIHRoaXMuY29ubmVjdGlvbiArPSBidWYudG9TdHJpbmcoKVxuICAgIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA9PT0gMTQgJiYga2V5LnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtbGVuZ3RoJykge1xuICAgICAgdGhpcy5jb250ZW50TGVuZ3RoICs9IGJ1Zi50b1N0cmluZygpXG4gICAgfVxuXG4gICAgdGhpcy50cmFja0hlYWRlcihidWYubGVuZ3RoKVxuICB9XG5cbiAgdHJhY2tIZWFkZXIgKGxlbikge1xuICAgIHRoaXMuaGVhZGVyc1NpemUgKz0gbGVuXG4gICAgaWYgKHRoaXMuaGVhZGVyc1NpemUgPj0gdGhpcy5oZWFkZXJzTWF4U2l6ZSkge1xuICAgICAgdXRpbC5kZXN0cm95KHRoaXMuc29ja2V0LCBuZXcgSGVhZGVyc092ZXJmbG93RXJyb3IoKSlcbiAgICB9XG4gIH1cblxuICBvblVwZ3JhZGUgKGhlYWQpIHtcbiAgICBjb25zdCB7IHVwZ3JhZGUsIGNsaWVudCwgc29ja2V0LCBoZWFkZXJzLCBzdGF0dXNDb2RlIH0gPSB0aGlzXG5cbiAgICBhc3NlcnQodXBncmFkZSlcblxuICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdXVxuICAgIGFzc2VydChyZXF1ZXN0KVxuXG4gICAgYXNzZXJ0KCFzb2NrZXQuZGVzdHJveWVkKVxuICAgIGFzc2VydChzb2NrZXQgPT09IGNsaWVudFtrU29ja2V0XSlcbiAgICBhc3NlcnQoIXRoaXMucGF1c2VkKVxuICAgIGFzc2VydChyZXF1ZXN0LnVwZ3JhZGUgfHwgcmVxdWVzdC5tZXRob2QgPT09ICdDT05ORUNUJylcblxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IG51bGxcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnJ1xuICAgIHRoaXMuc2hvdWxkS2VlcEFsaXZlID0gbnVsbFxuXG4gICAgYXNzZXJ0KHRoaXMuaGVhZGVycy5sZW5ndGggJSAyID09PSAwKVxuICAgIHRoaXMuaGVhZGVycyA9IFtdXG4gICAgdGhpcy5oZWFkZXJzU2l6ZSA9IDBcblxuICAgIHNvY2tldC51bnNoaWZ0KGhlYWQpXG5cbiAgICBzb2NrZXRba1BhcnNlcl0uZGVzdHJveSgpXG4gICAgc29ja2V0W2tQYXJzZXJdID0gbnVsbFxuXG4gICAgc29ja2V0W2tDbGllbnRdID0gbnVsbFxuICAgIHNvY2tldFtrRXJyb3JdID0gbnVsbFxuICAgIHNvY2tldFxuICAgICAgLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uU29ja2V0RXJyb3IpXG4gICAgICAucmVtb3ZlTGlzdGVuZXIoJ3JlYWRhYmxlJywgb25Tb2NrZXRSZWFkYWJsZSlcbiAgICAgIC5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25Tb2NrZXRFbmQpXG4gICAgICAucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25Tb2NrZXRDbG9zZSlcblxuICAgIGNsaWVudFtrU29ja2V0XSA9IG51bGxcbiAgICBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdKytdID0gbnVsbFxuICAgIGNsaWVudC5lbWl0KCdkaXNjb25uZWN0JywgY2xpZW50W2tVcmxdLCBbY2xpZW50XSwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcigndXBncmFkZScpKVxuXG4gICAgdHJ5IHtcbiAgICAgIHJlcXVlc3Qub25VcGdyYWRlKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHNvY2tldClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIGVycilcbiAgICB9XG5cbiAgICByZXN1bWUoY2xpZW50KVxuICB9XG5cbiAgb25IZWFkZXJzQ29tcGxldGUgKHN0YXR1c0NvZGUsIHVwZ3JhZGUsIHNob3VsZEtlZXBBbGl2ZSkge1xuICAgIGNvbnN0IHsgY2xpZW50LCBzb2NrZXQsIGhlYWRlcnMsIHN0YXR1c1RleHQgfSA9IHRoaXNcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkaWZmaWN1bHQgdG8gbWFrZSBhIHRlc3QgY2FzZSBmb3IgKi9cbiAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZGlmZmljdWx0IHRvIG1ha2UgYSB0ZXN0IGNhc2UgZm9yICovXG4gICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBhc3NlcnQoIXRoaXMudXBncmFkZSlcbiAgICBhc3NlcnQodGhpcy5zdGF0dXNDb2RlIDwgMjAwKVxuXG4gICAgaWYgKHN0YXR1c0NvZGUgPT09IDEwMCkge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IFNvY2tldEVycm9yKCdiYWQgcmVzcG9uc2UnLCB1dGlsLmdldFNvY2tldEluZm8oc29ja2V0KSkpXG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICAvKiB0aGlzIGNhbiBvbmx5IGhhcHBlbiBpZiBzZXJ2ZXIgaXMgbWlzYmVoYXZpbmcgKi9cbiAgICBpZiAodXBncmFkZSAmJiAhcmVxdWVzdC51cGdyYWRlKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgU29ja2V0RXJyb3IoJ2JhZCB1cGdyYWRlJywgdXRpbC5nZXRTb2NrZXRJbmZvKHNvY2tldCkpKVxuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgYXNzZXJ0LnN0cmljdEVxdWFsKHRoaXMudGltZW91dFR5cGUsIFRJTUVPVVRfSEVBREVSUylcblxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGVcbiAgICB0aGlzLnNob3VsZEtlZXBBbGl2ZSA9IChcbiAgICAgIHNob3VsZEtlZXBBbGl2ZSB8fFxuICAgICAgLy8gT3ZlcnJpZGUgbGxodHRwIHZhbHVlIHdoaWNoIGRvZXMgbm90IGFsbG93IGtlZXBBbGl2ZSBmb3IgSEVBRC5cbiAgICAgIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0hFQUQnICYmICFzb2NrZXRba1Jlc2V0XSAmJiB0aGlzLmNvbm5lY3Rpb24udG9Mb3dlckNhc2UoKSA9PT0gJ2tlZXAtYWxpdmUnKVxuICAgIClcblxuICAgIGlmICh0aGlzLnN0YXR1c0NvZGUgPj0gMjAwKSB7XG4gICAgICBjb25zdCBib2R5VGltZW91dCA9IHJlcXVlc3QuYm9keVRpbWVvdXQgIT0gbnVsbFxuICAgICAgICA/IHJlcXVlc3QuYm9keVRpbWVvdXRcbiAgICAgICAgOiBjbGllbnRba0JvZHlUaW1lb3V0XVxuICAgICAgdGhpcy5zZXRUaW1lb3V0KGJvZHlUaW1lb3V0LCBUSU1FT1VUX0JPRFkpXG4gICAgfSBlbHNlIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBvbmx5IGZvciBqZXN0XG4gICAgICBpZiAodGhpcy50aW1lb3V0LnJlZnJlc2gpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0LnJlZnJlc2goKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMSlcbiAgICAgIHRoaXMudXBncmFkZSA9IHRydWVcbiAgICAgIHJldHVybiAyXG4gICAgfVxuXG4gICAgaWYgKHVwZ3JhZGUpIHtcbiAgICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddID09PSAxKVxuICAgICAgdGhpcy51cGdyYWRlID0gdHJ1ZVxuICAgICAgcmV0dXJuIDJcbiAgICB9XG5cbiAgICBhc3NlcnQodGhpcy5oZWFkZXJzLmxlbmd0aCAlIDIgPT09IDApXG4gICAgdGhpcy5oZWFkZXJzID0gW11cbiAgICB0aGlzLmhlYWRlcnNTaXplID0gMFxuXG4gICAgaWYgKHRoaXMuc2hvdWxkS2VlcEFsaXZlICYmIGNsaWVudFtrUGlwZWxpbmluZ10pIHtcbiAgICAgIGNvbnN0IGtlZXBBbGl2ZVRpbWVvdXQgPSB0aGlzLmtlZXBBbGl2ZSA/IHV0aWwucGFyc2VLZWVwQWxpdmVUaW1lb3V0KHRoaXMua2VlcEFsaXZlKSA6IG51bGxcblxuICAgICAgaWYgKGtlZXBBbGl2ZVRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gTWF0aC5taW4oXG4gICAgICAgICAga2VlcEFsaXZlVGltZW91dCAtIGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZF0sXG4gICAgICAgICAgY2xpZW50W2tLZWVwQWxpdmVNYXhUaW1lb3V0XVxuICAgICAgICApXG4gICAgICAgIGlmICh0aW1lb3V0IDw9IDApIHtcbiAgICAgICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGllbnRba0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZV0gPSB0aW1lb3V0XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFZhbHVlXSA9IGNsaWVudFtrS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXRdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0b3AgbW9yZSByZXF1ZXN0cyBmcm9tIGJlaW5nIGRpc3BhdGNoZWQuXG4gICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICB9XG5cbiAgICBjb25zdCBwYXVzZSA9IHJlcXVlc3Qub25IZWFkZXJzKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHRoaXMucmVzdW1lLCBzdGF0dXNUZXh0KSA9PT0gZmFsc2VcblxuICAgIGlmIChyZXF1ZXN0LmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGlmIChzdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGlmIChzb2NrZXRba0Jsb2NraW5nXSkge1xuICAgICAgc29ja2V0W2tCbG9ja2luZ10gPSBmYWxzZVxuICAgICAgcmVzdW1lKGNsaWVudClcbiAgICB9XG5cbiAgICByZXR1cm4gcGF1c2UgPyBjb25zdGFudHMuRVJST1IuUEFVU0VEIDogMFxuICB9XG5cbiAgb25Cb2R5IChidWYpIHtcbiAgICBjb25zdCB7IGNsaWVudCwgc29ja2V0LCBzdGF0dXNDb2RlLCBtYXhSZXNwb25zZVNpemUgfSA9IHRoaXNcblxuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICBhc3NlcnQocmVxdWVzdClcblxuICAgIGFzc2VydC5zdHJpY3RFcXVhbCh0aGlzLnRpbWVvdXRUeXBlLCBUSU1FT1VUX0JPRFkpXG4gICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U6IG9ubHkgZm9yIGplc3RcbiAgICAgIGlmICh0aGlzLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICB0aGlzLnRpbWVvdXQucmVmcmVzaCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgYXNzZXJ0KHN0YXR1c0NvZGUgPj0gMjAwKVxuXG4gICAgaWYgKG1heFJlc3BvbnNlU2l6ZSA+IC0xICYmIHRoaXMuYnl0ZXNSZWFkICsgYnVmLmxlbmd0aCA+IG1heFJlc3BvbnNlU2l6ZSkge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IFJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IoKSlcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIHRoaXMuYnl0ZXNSZWFkICs9IGJ1Zi5sZW5ndGhcblxuICAgIGlmIChyZXF1ZXN0Lm9uRGF0YShidWYpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGNvbnN0YW50cy5FUlJPUi5QQVVTRURcbiAgICB9XG4gIH1cblxuICBvbk1lc3NhZ2VDb21wbGV0ZSAoKSB7XG4gICAgY29uc3QgeyBjbGllbnQsIHNvY2tldCwgc3RhdHVzQ29kZSwgdXBncmFkZSwgaGVhZGVycywgY29udGVudExlbmd0aCwgYnl0ZXNSZWFkLCBzaG91bGRLZWVwQWxpdmUgfSA9IHRoaXNcblxuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkICYmICghc3RhdHVzQ29kZSB8fCBzaG91bGRLZWVwQWxpdmUpKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBpZiAodXBncmFkZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG4gICAgYXNzZXJ0KHJlcXVlc3QpXG5cbiAgICBhc3NlcnQoc3RhdHVzQ29kZSA+PSAxMDApXG5cbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBudWxsXG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJydcbiAgICB0aGlzLmJ5dGVzUmVhZCA9IDBcbiAgICB0aGlzLmNvbnRlbnRMZW5ndGggPSAnJ1xuICAgIHRoaXMua2VlcEFsaXZlID0gJydcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSAnJ1xuXG4gICAgYXNzZXJ0KHRoaXMuaGVhZGVycy5sZW5ndGggJSAyID09PSAwKVxuICAgIHRoaXMuaGVhZGVycyA9IFtdXG4gICAgdGhpcy5oZWFkZXJzU2l6ZSA9IDBcblxuICAgIGlmIChzdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2hvdWxkIGJlIGhhbmRsZWQgYnkgbGxodHRwPyAqL1xuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gJ0hFQUQnICYmIGNvbnRlbnRMZW5ndGggJiYgYnl0ZXNSZWFkICE9PSBwYXJzZUludChjb250ZW50TGVuZ3RoLCAxMCkpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpXG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICByZXF1ZXN0Lm9uQ29tcGxldGUoaGVhZGVycylcblxuICAgIGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF0rK10gPSBudWxsXG5cbiAgICBpZiAoc29ja2V0W2tXcml0aW5nXSkge1xuICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGNsaWVudFtrUnVubmluZ10sIDApXG4gICAgICAvLyBSZXNwb25zZSBjb21wbGV0ZWQgYmVmb3JlIHJlcXVlc3QuXG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgSW5mb3JtYXRpb25hbEVycm9yKCdyZXNldCcpKVxuICAgICAgcmV0dXJuIGNvbnN0YW50cy5FUlJPUi5QQVVTRURcbiAgICB9IGVsc2UgaWYgKCFzaG91bGRLZWVwQWxpdmUpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ3Jlc2V0JykpXG4gICAgICByZXR1cm4gY29uc3RhbnRzLkVSUk9SLlBBVVNFRFxuICAgIH0gZWxzZSBpZiAoc29ja2V0W2tSZXNldF0gJiYgY2xpZW50W2tSdW5uaW5nXSA9PT0gMCkge1xuICAgICAgLy8gRGVzdHJveSBzb2NrZXQgb25jZSBhbGwgcmVxdWVzdHMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICAvLyBUaGUgcmVxdWVzdCBhdCB0aGUgdGFpbCBvZiB0aGUgcGlwZWxpbmUgaXMgdGhlIG9uZVxuICAgICAgLy8gdGhhdCByZXF1ZXN0ZWQgcmVzZXQgYW5kIG5vIGZ1cnRoZXIgcmVxdWVzdHMgc2hvdWxkXG4gICAgICAvLyBoYXZlIGJlZW4gcXVldWVkIHNpbmNlIHRoZW4uXG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgSW5mb3JtYXRpb25hbEVycm9yKCdyZXNldCcpKVxuICAgICAgcmV0dXJuIGNvbnN0YW50cy5FUlJPUi5QQVVTRURcbiAgICB9IGVsc2UgaWYgKGNsaWVudFtrUGlwZWxpbmluZ10gPT09IDEpIHtcbiAgICAgIC8vIFdlIG11c3Qgd2FpdCBhIGZ1bGwgZXZlbnQgbG9vcCBjeWNsZSB0byByZXVzZSB0aGlzIHNvY2tldCB0byBtYWtlIHN1cmVcbiAgICAgIC8vIHRoYXQgbm9uLXNwZWMgY29tcGxpYW50IHNlcnZlcnMgYXJlIG5vdCBjbG9zaW5nIHRoZSBjb25uZWN0aW9uIGV2ZW4gaWYgdGhleVxuICAgICAgLy8gc2FpZCB0aGV5IHdvbid0LlxuICAgICAgc2V0SW1tZWRpYXRlKHJlc3VtZSwgY2xpZW50KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bWUoY2xpZW50KVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvblBhcnNlclRpbWVvdXQgKHBhcnNlcikge1xuICBjb25zdCB7IHNvY2tldCwgdGltZW91dFR5cGUsIGNsaWVudCB9ID0gcGFyc2VyXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0hFQURFUlMpIHtcbiAgICBpZiAoIXNvY2tldFtrV3JpdGluZ10gfHwgc29ja2V0LndyaXRhYmxlTmVlZERyYWluIHx8IGNsaWVudFtrUnVubmluZ10gPiAxKSB7XG4gICAgICBhc3NlcnQoIXBhcnNlci5wYXVzZWQsICdjYW5ub3QgYmUgcGF1c2VkIHdoaWxlIHdhaXRpbmcgZm9yIGhlYWRlcnMnKVxuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEhlYWRlcnNUaW1lb3V0RXJyb3IoKSlcbiAgICB9XG4gIH0gZWxzZSBpZiAodGltZW91dFR5cGUgPT09IFRJTUVPVVRfQk9EWSkge1xuICAgIGlmICghcGFyc2VyLnBhdXNlZCkge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEJvZHlUaW1lb3V0RXJyb3IoKSlcbiAgICB9XG4gIH0gZWxzZSBpZiAodGltZW91dFR5cGUgPT09IFRJTUVPVVRfSURMRSkge1xuICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddID09PSAwICYmIGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFZhbHVlXSlcbiAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgSW5mb3JtYXRpb25hbEVycm9yKCdzb2NrZXQgaWRsZSB0aW1lb3V0JykpXG4gIH1cbn1cblxuZnVuY3Rpb24gb25Tb2NrZXRSZWFkYWJsZSAoKSB7XG4gIGNvbnN0IHsgW2tQYXJzZXJdOiBwYXJzZXIgfSA9IHRoaXNcbiAgaWYgKHBhcnNlcikge1xuICAgIHBhcnNlci5yZWFkTW9yZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gb25Tb2NrZXRFcnJvciAoZXJyKSB7XG4gIGNvbnN0IHsgW2tDbGllbnRdOiBjbGllbnQsIFtrUGFyc2VyXTogcGFyc2VyIH0gPSB0aGlzXG5cbiAgYXNzZXJ0KGVyci5jb2RlICE9PSAnRVJSX1RMU19DRVJUX0FMVE5BTUVfSU5WQUxJRCcpXG5cbiAgaWYgKGNsaWVudFtrSFRUUENvbm5WZXJzaW9uXSAhPT0gJ2gyJykge1xuICAgIC8vIE9uIE1hYyBPUywgd2UgZ2V0IGFuIEVDT05OUkVTRVQgZXZlbiBpZiB0aGVyZSBpcyBhIGZ1bGwgYm9keSB0byBiZSBmb3J3YXJkZWRcbiAgICAvLyB0byB0aGUgdXNlci5cbiAgICBpZiAoZXJyLmNvZGUgPT09ICdFQ09OTlJFU0VUJyAmJiBwYXJzZXIuc3RhdHVzQ29kZSAmJiAhcGFyc2VyLnNob3VsZEtlZXBBbGl2ZSkge1xuICAgICAgLy8gV2UgdHJlYXQgYWxsIGluY29taW5nIGRhdGEgc28gZm9yIGFzIGEgdmFsaWQgcmVzcG9uc2UuXG4gICAgICBwYXJzZXIub25NZXNzYWdlQ29tcGxldGUoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgdGhpc1trRXJyb3JdID0gZXJyXG5cbiAgb25FcnJvcih0aGlzW2tDbGllbnRdLCBlcnIpXG59XG5cbmZ1bmN0aW9uIG9uRXJyb3IgKGNsaWVudCwgZXJyKSB7XG4gIGlmIChcbiAgICBjbGllbnRba1J1bm5pbmddID09PSAwICYmXG4gICAgZXJyLmNvZGUgIT09ICdVTkRfRVJSX0lORk8nICYmXG4gICAgZXJyLmNvZGUgIT09ICdVTkRfRVJSX1NPQ0tFVCdcbiAgKSB7XG4gICAgLy8gRXJyb3IgaXMgbm90IGNhdXNlZCBieSBydW5uaW5nIHJlcXVlc3QgYW5kIG5vdCBhIHJlY292ZXJhYmxlXG4gICAgLy8gc29ja2V0IGVycm9yLlxuXG4gICAgYXNzZXJ0KGNsaWVudFtrUGVuZGluZ0lkeF0gPT09IGNsaWVudFtrUnVubmluZ0lkeF0pXG5cbiAgICBjb25zdCByZXF1ZXN0cyA9IGNsaWVudFtrUXVldWVdLnNwbGljZShjbGllbnRba1J1bm5pbmdJZHhdKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0c1tpXVxuICAgICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICAgIH1cbiAgICBhc3NlcnQoY2xpZW50W2tTaXplXSA9PT0gMClcbiAgfVxufVxuXG5mdW5jdGlvbiBvblNvY2tldEVuZCAoKSB7XG4gIGNvbnN0IHsgW2tQYXJzZXJdOiBwYXJzZXIsIFtrQ2xpZW50XTogY2xpZW50IH0gPSB0aGlzXG5cbiAgaWYgKGNsaWVudFtrSFRUUENvbm5WZXJzaW9uXSAhPT0gJ2gyJykge1xuICAgIGlmIChwYXJzZXIuc3RhdHVzQ29kZSAmJiAhcGFyc2VyLnNob3VsZEtlZXBBbGl2ZSkge1xuICAgICAgLy8gV2UgdHJlYXQgYWxsIGluY29taW5nIGRhdGEgc28gZmFyIGFzIGEgdmFsaWQgcmVzcG9uc2UuXG4gICAgICBwYXJzZXIub25NZXNzYWdlQ29tcGxldGUoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgdXRpbC5kZXN0cm95KHRoaXMsIG5ldyBTb2NrZXRFcnJvcignb3RoZXIgc2lkZSBjbG9zZWQnLCB1dGlsLmdldFNvY2tldEluZm8odGhpcykpKVxufVxuXG5mdW5jdGlvbiBvblNvY2tldENsb3NlICgpIHtcbiAgY29uc3QgeyBba0NsaWVudF06IGNsaWVudCwgW2tQYXJzZXJdOiBwYXJzZXIgfSA9IHRoaXNcblxuICBpZiAoY2xpZW50W2tIVFRQQ29ublZlcnNpb25dID09PSAnaDEnICYmIHBhcnNlcikge1xuICAgIGlmICghdGhpc1trRXJyb3JdICYmIHBhcnNlci5zdGF0dXNDb2RlICYmICFwYXJzZXIuc2hvdWxkS2VlcEFsaXZlKSB7XG4gICAgICAvLyBXZSB0cmVhdCBhbGwgaW5jb21pbmcgZGF0YSBzbyBmYXIgYXMgYSB2YWxpZCByZXNwb25zZS5cbiAgICAgIHBhcnNlci5vbk1lc3NhZ2VDb21wbGV0ZSgpXG4gICAgfVxuXG4gICAgdGhpc1trUGFyc2VyXS5kZXN0cm95KClcbiAgICB0aGlzW2tQYXJzZXJdID0gbnVsbFxuICB9XG5cbiAgY29uc3QgZXJyID0gdGhpc1trRXJyb3JdIHx8IG5ldyBTb2NrZXRFcnJvcignY2xvc2VkJywgdXRpbC5nZXRTb2NrZXRJbmZvKHRoaXMpKVxuXG4gIGNsaWVudFtrU29ja2V0XSA9IG51bGxcblxuICBpZiAoY2xpZW50LmRlc3Ryb3llZCkge1xuICAgIGFzc2VydChjbGllbnRba1BlbmRpbmddID09PSAwKVxuXG4gICAgLy8gRmFpbCBlbnRpcmUgcXVldWUuXG4gICAgY29uc3QgcmVxdWVzdHMgPSBjbGllbnRba1F1ZXVlXS5zcGxpY2UoY2xpZW50W2tSdW5uaW5nSWR4XSlcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHNbaV1cbiAgICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgICB9XG4gIH0gZWxzZSBpZiAoY2xpZW50W2tSdW5uaW5nXSA+IDAgJiYgZXJyLmNvZGUgIT09ICdVTkRfRVJSX0lORk8nKSB7XG4gICAgLy8gRmFpbCBoZWFkIG9mIHBpcGVsaW5lLlxuICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdXVxuICAgIGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF0rK10gPSBudWxsXG5cbiAgICBlcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gIH1cblxuICBjbGllbnRba1BlbmRpbmdJZHhdID0gY2xpZW50W2tSdW5uaW5nSWR4XVxuXG4gIGFzc2VydChjbGllbnRba1J1bm5pbmddID09PSAwKVxuXG4gIGNsaWVudC5lbWl0KCdkaXNjb25uZWN0JywgY2xpZW50W2tVcmxdLCBbY2xpZW50XSwgZXJyKVxuXG4gIHJlc3VtZShjbGllbnQpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbm5lY3QgKGNsaWVudCkge1xuICBhc3NlcnQoIWNsaWVudFtrQ29ubmVjdGluZ10pXG4gIGFzc2VydCghY2xpZW50W2tTb2NrZXRdKVxuXG4gIGxldCB7IGhvc3QsIGhvc3RuYW1lLCBwcm90b2NvbCwgcG9ydCB9ID0gY2xpZW50W2tVcmxdXG5cbiAgLy8gUmVzb2x2ZSBpcHY2XG4gIGlmIChob3N0bmFtZVswXSA9PT0gJ1snKSB7XG4gICAgY29uc3QgaWR4ID0gaG9zdG5hbWUuaW5kZXhPZignXScpXG5cbiAgICBhc3NlcnQoaWR4ICE9PSAtMSlcbiAgICBjb25zdCBpcCA9IGhvc3RuYW1lLnN1YnN0cmluZygxLCBpZHgpXG5cbiAgICBhc3NlcnQobmV0LmlzSVAoaXApKVxuICAgIGhvc3RuYW1lID0gaXBcbiAgfVxuXG4gIGNsaWVudFtrQ29ubmVjdGluZ10gPSB0cnVlXG5cbiAgaWYgKGNoYW5uZWxzLmJlZm9yZUNvbm5lY3QuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICBjaGFubmVscy5iZWZvcmVDb25uZWN0LnB1Ymxpc2goe1xuICAgICAgY29ubmVjdFBhcmFtczoge1xuICAgICAgICBob3N0LFxuICAgICAgICBob3N0bmFtZSxcbiAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIHBvcnQsXG4gICAgICAgIHNlcnZlcm5hbWU6IGNsaWVudFtrU2VydmVyTmFtZV0sXG4gICAgICAgIGxvY2FsQWRkcmVzczogY2xpZW50W2tMb2NhbEFkZHJlc3NdXG4gICAgICB9LFxuICAgICAgY29ubmVjdG9yOiBjbGllbnRba0Nvbm5lY3Rvcl1cbiAgICB9KVxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBzb2NrZXQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjbGllbnRba0Nvbm5lY3Rvcl0oe1xuICAgICAgICBob3N0LFxuICAgICAgICBob3N0bmFtZSxcbiAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIHBvcnQsXG4gICAgICAgIHNlcnZlcm5hbWU6IGNsaWVudFtrU2VydmVyTmFtZV0sXG4gICAgICAgIGxvY2FsQWRkcmVzczogY2xpZW50W2tMb2NhbEFkZHJlc3NdXG4gICAgICB9LCAoZXJyLCBzb2NrZXQpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShzb2NrZXQpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGlmIChjbGllbnQuZGVzdHJveWVkKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0Lm9uKCdlcnJvcicsICgpID0+IHt9KSwgbmV3IENsaWVudERlc3Ryb3llZEVycm9yKCkpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjbGllbnRba0Nvbm5lY3RpbmddID0gZmFsc2VcblxuICAgIGFzc2VydChzb2NrZXQpXG5cbiAgICBjb25zdCBpc0gyID0gc29ja2V0LmFscG5Qcm90b2NvbCA9PT0gJ2gyJ1xuICAgIGlmIChpc0gyKSB7XG4gICAgICBpZiAoIWgyRXhwZXJpbWVudGFsV2FybmVkKSB7XG4gICAgICAgIGgyRXhwZXJpbWVudGFsV2FybmVkID0gdHJ1ZVxuICAgICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKCdIMiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbCwgZXhwZWN0IHRoZW0gdG8gY2hhbmdlIGF0IGFueSB0aW1lLicsIHtcbiAgICAgICAgICBjb2RlOiAnVU5ESUNJLUgyJ1xuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzZXNzaW9uID0gaHR0cDIuY29ubmVjdChjbGllbnRba1VybF0sIHtcbiAgICAgICAgY3JlYXRlQ29ubmVjdGlvbjogKCkgPT4gc29ja2V0LFxuICAgICAgICBwZWVyTWF4Q29uY3VycmVudFN0cmVhbXM6IGNsaWVudFtrSFRUUDJTZXNzaW9uU3RhdGVdLm1heENvbmN1cnJlbnRTdHJlYW1zXG4gICAgICB9KVxuXG4gICAgICBjbGllbnRba0hUVFBDb25uVmVyc2lvbl0gPSAnaDInXG4gICAgICBzZXNzaW9uW2tDbGllbnRdID0gY2xpZW50XG4gICAgICBzZXNzaW9uW2tTb2NrZXRdID0gc29ja2V0XG4gICAgICBzZXNzaW9uLm9uKCdlcnJvcicsIG9uSHR0cDJTZXNzaW9uRXJyb3IpXG4gICAgICBzZXNzaW9uLm9uKCdmcmFtZUVycm9yJywgb25IdHRwMkZyYW1lRXJyb3IpXG4gICAgICBzZXNzaW9uLm9uKCdlbmQnLCBvbkh0dHAyU2Vzc2lvbkVuZClcbiAgICAgIHNlc3Npb24ub24oJ2dvYXdheScsIG9uSFRUUDJHb0F3YXkpXG4gICAgICBzZXNzaW9uLm9uKCdjbG9zZScsIG9uU29ja2V0Q2xvc2UpXG4gICAgICBzZXNzaW9uLnVucmVmKClcblxuICAgICAgY2xpZW50W2tIVFRQMlNlc3Npb25dID0gc2Vzc2lvblxuICAgICAgc29ja2V0W2tIVFRQMlNlc3Npb25dID0gc2Vzc2lvblxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWxsaHR0cEluc3RhbmNlKSB7XG4gICAgICAgIGxsaHR0cEluc3RhbmNlID0gYXdhaXQgbGxodHRwUHJvbWlzZVxuICAgICAgICBsbGh0dHBQcm9taXNlID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBzb2NrZXRba05vUmVmXSA9IGZhbHNlXG4gICAgICBzb2NrZXRba1dyaXRpbmddID0gZmFsc2VcbiAgICAgIHNvY2tldFtrUmVzZXRdID0gZmFsc2VcbiAgICAgIHNvY2tldFtrQmxvY2tpbmddID0gZmFsc2VcbiAgICAgIHNvY2tldFtrUGFyc2VyXSA9IG5ldyBQYXJzZXIoY2xpZW50LCBzb2NrZXQsIGxsaHR0cEluc3RhbmNlKVxuICAgIH1cblxuICAgIHNvY2tldFtrQ291bnRlcl0gPSAwXG4gICAgc29ja2V0W2tNYXhSZXF1ZXN0c10gPSBjbGllbnRba01heFJlcXVlc3RzXVxuICAgIHNvY2tldFtrQ2xpZW50XSA9IGNsaWVudFxuICAgIHNvY2tldFtrRXJyb3JdID0gbnVsbFxuXG4gICAgc29ja2V0XG4gICAgICAub24oJ2Vycm9yJywgb25Tb2NrZXRFcnJvcilcbiAgICAgIC5vbigncmVhZGFibGUnLCBvblNvY2tldFJlYWRhYmxlKVxuICAgICAgLm9uKCdlbmQnLCBvblNvY2tldEVuZClcbiAgICAgIC5vbignY2xvc2UnLCBvblNvY2tldENsb3NlKVxuXG4gICAgY2xpZW50W2tTb2NrZXRdID0gc29ja2V0XG5cbiAgICBpZiAoY2hhbm5lbHMuY29ubmVjdGVkLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy5jb25uZWN0ZWQucHVibGlzaCh7XG4gICAgICAgIGNvbm5lY3RQYXJhbXM6IHtcbiAgICAgICAgICBob3N0LFxuICAgICAgICAgIGhvc3RuYW1lLFxuICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICAgIHBvcnQsXG4gICAgICAgICAgc2VydmVybmFtZTogY2xpZW50W2tTZXJ2ZXJOYW1lXSxcbiAgICAgICAgICBsb2NhbEFkZHJlc3M6IGNsaWVudFtrTG9jYWxBZGRyZXNzXVxuICAgICAgICB9LFxuICAgICAgICBjb25uZWN0b3I6IGNsaWVudFtrQ29ubmVjdG9yXSxcbiAgICAgICAgc29ja2V0XG4gICAgICB9KVxuICAgIH1cbiAgICBjbGllbnQuZW1pdCgnY29ubmVjdCcsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChjbGllbnQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjbGllbnRba0Nvbm5lY3RpbmddID0gZmFsc2VcblxuICAgIGlmIChjaGFubmVscy5jb25uZWN0RXJyb3IuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLmNvbm5lY3RFcnJvci5wdWJsaXNoKHtcbiAgICAgICAgY29ubmVjdFBhcmFtczoge1xuICAgICAgICAgIGhvc3QsXG4gICAgICAgICAgaG9zdG5hbWUsXG4gICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgICAgcG9ydCxcbiAgICAgICAgICBzZXJ2ZXJuYW1lOiBjbGllbnRba1NlcnZlck5hbWVdLFxuICAgICAgICAgIGxvY2FsQWRkcmVzczogY2xpZW50W2tMb2NhbEFkZHJlc3NdXG4gICAgICAgIH0sXG4gICAgICAgIGNvbm5lY3RvcjogY2xpZW50W2tDb25uZWN0b3JdLFxuICAgICAgICBlcnJvcjogZXJyXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChlcnIuY29kZSA9PT0gJ0VSUl9UTFNfQ0VSVF9BTFROQU1FX0lOVkFMSUQnKSB7XG4gICAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMClcbiAgICAgIHdoaWxlIChjbGllbnRba1BlbmRpbmddID4gMCAmJiBjbGllbnRba1F1ZXVlXVtjbGllbnRba1BlbmRpbmdJZHhdXS5zZXJ2ZXJuYW1lID09PSBjbGllbnRba1NlcnZlck5hbWVdKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1BlbmRpbmdJZHhdKytdXG4gICAgICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb25FcnJvcihjbGllbnQsIGVycilcbiAgICB9XG5cbiAgICBjbGllbnQuZW1pdCgnY29ubmVjdGlvbkVycm9yJywgY2xpZW50W2tVcmxdLCBbY2xpZW50XSwgZXJyKVxuICB9XG5cbiAgcmVzdW1lKGNsaWVudClcbn1cblxuZnVuY3Rpb24gZW1pdERyYWluIChjbGllbnQpIHtcbiAgY2xpZW50W2tOZWVkRHJhaW5dID0gMFxuICBjbGllbnQuZW1pdCgnZHJhaW4nLCBjbGllbnRba1VybF0sIFtjbGllbnRdKVxufVxuXG5mdW5jdGlvbiByZXN1bWUgKGNsaWVudCwgc3luYykge1xuICBpZiAoY2xpZW50W2tSZXN1bWluZ10gPT09IDIpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNsaWVudFtrUmVzdW1pbmddID0gMlxuXG4gIF9yZXN1bWUoY2xpZW50LCBzeW5jKVxuICBjbGllbnRba1Jlc3VtaW5nXSA9IDBcblxuICBpZiAoY2xpZW50W2tSdW5uaW5nSWR4XSA+IDI1Nikge1xuICAgIGNsaWVudFtrUXVldWVdLnNwbGljZSgwLCBjbGllbnRba1J1bm5pbmdJZHhdKVxuICAgIGNsaWVudFtrUGVuZGluZ0lkeF0gLT0gY2xpZW50W2tSdW5uaW5nSWR4XVxuICAgIGNsaWVudFtrUnVubmluZ0lkeF0gPSAwXG4gIH1cbn1cblxuZnVuY3Rpb24gX3Jlc3VtZSAoY2xpZW50LCBzeW5jKSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGNsaWVudC5kZXN0cm95ZWQpIHtcbiAgICAgIGFzc2VydChjbGllbnRba1BlbmRpbmddID09PSAwKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrQ2xvc2VkUmVzb2x2ZV0gJiYgIWNsaWVudFtrU2l6ZV0pIHtcbiAgICAgIGNsaWVudFtrQ2xvc2VkUmVzb2x2ZV0oKVxuICAgICAgY2xpZW50W2tDbG9zZWRSZXNvbHZlXSA9IG51bGxcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHNvY2tldCA9IGNsaWVudFtrU29ja2V0XVxuXG4gICAgaWYgKHNvY2tldCAmJiAhc29ja2V0LmRlc3Ryb3llZCAmJiBzb2NrZXQuYWxwblByb3RvY29sICE9PSAnaDInKSB7XG4gICAgICBpZiAoY2xpZW50W2tTaXplXSA9PT0gMCkge1xuICAgICAgICBpZiAoIXNvY2tldFtrTm9SZWZdICYmIHNvY2tldC51bnJlZikge1xuICAgICAgICAgIHNvY2tldC51bnJlZigpXG4gICAgICAgICAgc29ja2V0W2tOb1JlZl0gPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc29ja2V0W2tOb1JlZl0gJiYgc29ja2V0LnJlZikge1xuICAgICAgICBzb2NrZXQucmVmKClcbiAgICAgICAgc29ja2V0W2tOb1JlZl0gPSBmYWxzZVxuICAgICAgfVxuXG4gICAgICBpZiAoY2xpZW50W2tTaXplXSA9PT0gMCkge1xuICAgICAgICBpZiAoc29ja2V0W2tQYXJzZXJdLnRpbWVvdXRUeXBlICE9PSBUSU1FT1VUX0lETEUpIHtcbiAgICAgICAgICBzb2NrZXRba1BhcnNlcl0uc2V0VGltZW91dChjbGllbnRba0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZV0sIFRJTUVPVVRfSURMRSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiBzb2NrZXRba1BhcnNlcl0uc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgICBpZiAoc29ja2V0W2tQYXJzZXJdLnRpbWVvdXRUeXBlICE9PSBUSU1FT1VUX0hFQURFUlMpIHtcbiAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICAgICAgICBjb25zdCBoZWFkZXJzVGltZW91dCA9IHJlcXVlc3QuaGVhZGVyc1RpbWVvdXQgIT0gbnVsbFxuICAgICAgICAgICAgPyByZXF1ZXN0LmhlYWRlcnNUaW1lb3V0XG4gICAgICAgICAgICA6IGNsaWVudFtrSGVhZGVyc1RpbWVvdXRdXG4gICAgICAgICAgc29ja2V0W2tQYXJzZXJdLnNldFRpbWVvdXQoaGVhZGVyc1RpbWVvdXQsIFRJTUVPVVRfSEVBREVSUylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjbGllbnRba0J1c3ldKSB7XG4gICAgICBjbGllbnRba05lZWREcmFpbl0gPSAyXG4gICAgfSBlbHNlIGlmIChjbGllbnRba05lZWREcmFpbl0gPT09IDIpIHtcbiAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgIGNsaWVudFtrTmVlZERyYWluXSA9IDFcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RHJhaW4sIGNsaWVudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVtaXREcmFpbihjbGllbnQpXG4gICAgICB9XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmIChjbGllbnRba1BlbmRpbmddID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tSdW5uaW5nXSA+PSAoY2xpZW50W2tQaXBlbGluaW5nXSB8fCAxKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUGVuZGluZ0lkeF1dXG5cbiAgICBpZiAoY2xpZW50W2tVcmxdLnByb3RvY29sID09PSAnaHR0cHM6JyAmJiBjbGllbnRba1NlcnZlck5hbWVdICE9PSByZXF1ZXN0LnNlcnZlcm5hbWUpIHtcbiAgICAgIGlmIChjbGllbnRba1J1bm5pbmddID4gMCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY2xpZW50W2tTZXJ2ZXJOYW1lXSA9IHJlcXVlc3Quc2VydmVybmFtZVxuXG4gICAgICBpZiAoc29ja2V0ICYmIHNvY2tldC5zZXJ2ZXJuYW1lICE9PSByZXF1ZXN0LnNlcnZlcm5hbWUpIHtcbiAgICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcignc2VydmVybmFtZSBjaGFuZ2VkJykpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjbGllbnRba0Nvbm5lY3RpbmddKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIXNvY2tldCAmJiAhY2xpZW50W2tIVFRQMlNlc3Npb25dKSB7XG4gICAgICBjb25uZWN0KGNsaWVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkIHx8IHNvY2tldFtrV3JpdGluZ10gfHwgc29ja2V0W2tSZXNldF0gfHwgc29ja2V0W2tCbG9ja2luZ10pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiAhcmVxdWVzdC5pZGVtcG90ZW50KSB7XG4gICAgICAvLyBOb24taWRlbXBvdGVudCByZXF1ZXN0IGNhbm5vdCBiZSByZXRyaWVkLlxuICAgICAgLy8gRW5zdXJlIHRoYXQgbm8gb3RoZXIgcmVxdWVzdHMgYXJlIGluZmxpZ2h0IGFuZFxuICAgICAgLy8gY291bGQgY2F1c2UgZmFpbHVyZS5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiAocmVxdWVzdC51cGdyYWRlIHx8IHJlcXVlc3QubWV0aG9kID09PSAnQ09OTkVDVCcpKSB7XG4gICAgICAvLyBEb24ndCBkaXNwYXRjaCBhbiB1cGdyYWRlIHVudGlsIGFsbCBwcmVjZWRpbmcgcmVxdWVzdHMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICAvLyBBIG1pc2JlaGF2aW5nIHNlcnZlciBtaWdodCB1cGdyYWRlIHRoZSBjb25uZWN0aW9uIGJlZm9yZSBhbGwgcGlwZWxpbmVkXG4gICAgICAvLyByZXF1ZXN0IGhhcyBjb21wbGV0ZWQuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tSdW5uaW5nXSA+IDAgJiYgdXRpbC5ib2R5TGVuZ3RoKHJlcXVlc3QuYm9keSkgIT09IDAgJiZcbiAgICAgICh1dGlsLmlzU3RyZWFtKHJlcXVlc3QuYm9keSkgfHwgdXRpbC5pc0FzeW5jSXRlcmFibGUocmVxdWVzdC5ib2R5KSkpIHtcbiAgICAgIC8vIFJlcXVlc3Qgd2l0aCBzdHJlYW0gb3IgaXRlcmF0b3IgYm9keSBjYW4gZXJyb3Igd2hpbGUgb3RoZXIgcmVxdWVzdHNcbiAgICAgIC8vIGFyZSBpbmZsaWdodCBhbmQgaW5kaXJlY3RseSBlcnJvciB0aG9zZSBhcyB3ZWxsLlxuICAgICAgLy8gRW5zdXJlIHRoaXMgZG9lc24ndCBoYXBwZW4gYnkgd2FpdGluZyBmb3IgaW5mbGlnaHRcbiAgICAgIC8vIHRvIGNvbXBsZXRlIGJlZm9yZSBkaXNwYXRjaGluZy5cblxuICAgICAgLy8gUmVxdWVzdCB3aXRoIHN0cmVhbSBvciBpdGVyYXRvciBib2R5IGNhbm5vdCBiZSByZXRyaWVkLlxuICAgICAgLy8gRW5zdXJlIHRoYXQgbm8gb3RoZXIgcmVxdWVzdHMgYXJlIGluZmxpZ2h0IGFuZFxuICAgICAgLy8gY291bGQgY2F1c2UgZmFpbHVyZS5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghcmVxdWVzdC5hYm9ydGVkICYmIHdyaXRlKGNsaWVudCwgcmVxdWVzdCkpIHtcbiAgICAgIGNsaWVudFtrUGVuZGluZ0lkeF0rK1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGllbnRba1F1ZXVlXS5zcGxpY2UoY2xpZW50W2tQZW5kaW5nSWR4XSwgMSlcbiAgICB9XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzcyMzAjc2VjdGlvbi0zLjMuMlxuZnVuY3Rpb24gc2hvdWxkU2VuZENvbnRlbnRMZW5ndGggKG1ldGhvZCkge1xuICByZXR1cm4gbWV0aG9kICE9PSAnR0VUJyAmJiBtZXRob2QgIT09ICdIRUFEJyAmJiBtZXRob2QgIT09ICdPUFRJT05TJyAmJiBtZXRob2QgIT09ICdUUkFDRScgJiYgbWV0aG9kICE9PSAnQ09OTkVDVCdcbn1cblxuZnVuY3Rpb24gd3JpdGUgKGNsaWVudCwgcmVxdWVzdCkge1xuICBpZiAoY2xpZW50W2tIVFRQQ29ublZlcnNpb25dID09PSAnaDInKSB7XG4gICAgd3JpdGVIMihjbGllbnQsIGNsaWVudFtrSFRUUDJTZXNzaW9uXSwgcmVxdWVzdClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHsgYm9keSwgbWV0aG9kLCBwYXRoLCBob3N0LCB1cGdyYWRlLCBoZWFkZXJzLCBibG9ja2luZywgcmVzZXQgfSA9IHJlcXVlc3RcblxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTQuMy4xXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNC4zLjJcbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi00LjMuNVxuXG4gIC8vIFNlbmRpbmcgYSBwYXlsb2FkIGJvZHkgb24gYSByZXF1ZXN0IHRoYXQgZG9lcyBub3RcbiAgLy8gZXhwZWN0IGl0IGNhbiBjYXVzZSB1bmRlZmluZWQgYmVoYXZpb3Igb24gc29tZVxuICAvLyBzZXJ2ZXJzIGFuZCBjb3JydXB0IGNvbm5lY3Rpb24gc3RhdGUuIERvIG5vdFxuICAvLyByZS11c2UgdGhlIGNvbm5lY3Rpb24gZm9yIGZ1cnRoZXIgcmVxdWVzdHMuXG5cbiAgY29uc3QgZXhwZWN0c1BheWxvYWQgPSAoXG4gICAgbWV0aG9kID09PSAnUFVUJyB8fFxuICAgIG1ldGhvZCA9PT0gJ1BPU1QnIHx8XG4gICAgbWV0aG9kID09PSAnUEFUQ0gnXG4gIClcblxuICBpZiAoYm9keSAmJiB0eXBlb2YgYm9keS5yZWFkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVHJ5IHRvIHJlYWQgRU9GIGluIG9yZGVyIHRvIGdldCBsZW5ndGguXG4gICAgYm9keS5yZWFkKDApXG4gIH1cblxuICBjb25zdCBib2R5TGVuZ3RoID0gdXRpbC5ib2R5TGVuZ3RoKGJvZHkpXG5cbiAgbGV0IGNvbnRlbnRMZW5ndGggPSBib2R5TGVuZ3RoXG5cbiAgaWYgKGNvbnRlbnRMZW5ndGggPT09IG51bGwpIHtcbiAgICBjb250ZW50TGVuZ3RoID0gcmVxdWVzdC5jb250ZW50TGVuZ3RoXG4gIH1cblxuICBpZiAoY29udGVudExlbmd0aCA9PT0gMCAmJiAhZXhwZWN0c1BheWxvYWQpIHtcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMy4yXG4gICAgLy8gQSB1c2VyIGFnZW50IFNIT1VMRCBOT1Qgc2VuZCBhIENvbnRlbnQtTGVuZ3RoIGhlYWRlciBmaWVsZCB3aGVuXG4gICAgLy8gdGhlIHJlcXVlc3QgbWVzc2FnZSBkb2VzIG5vdCBjb250YWluIGEgcGF5bG9hZCBib2R5IGFuZCB0aGUgbWV0aG9kXG4gICAgLy8gc2VtYW50aWNzIGRvIG5vdCBhbnRpY2lwYXRlIHN1Y2ggYSBib2R5LlxuXG4gICAgY29udGVudExlbmd0aCA9IG51bGxcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yMDQ2XG4gIC8vIEEgdXNlciBhZ2VudCBtYXkgc2VuZCBhIENvbnRlbnQtTGVuZ3RoIGhlYWRlciB3aXRoIDAgdmFsdWUsIHRoaXMgc2hvdWxkIGJlIGFsbG93ZWQuXG4gIGlmIChzaG91bGRTZW5kQ29udGVudExlbmd0aChtZXRob2QpICYmIGNvbnRlbnRMZW5ndGggPiAwICYmIHJlcXVlc3QuY29udGVudExlbmd0aCAhPT0gbnVsbCAmJiByZXF1ZXN0LmNvbnRlbnRMZW5ndGggIT09IGNvbnRlbnRMZW5ndGgpIHtcbiAgICBpZiAoY2xpZW50W2tTdHJpY3RDb250ZW50TGVuZ3RoXSkge1xuICAgICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgbmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcHJvY2Vzcy5lbWl0V2FybmluZyhuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpXG4gIH1cblxuICBjb25zdCBzb2NrZXQgPSBjbGllbnRba1NvY2tldF1cblxuICB0cnkge1xuICAgIHJlcXVlc3Qub25Db25uZWN0KChlcnIpID0+IHtcbiAgICAgIGlmIChyZXF1ZXN0LmFib3J0ZWQgfHwgcmVxdWVzdC5jb21wbGV0ZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVyciB8fCBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpKVxuXG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgSW5mb3JtYXRpb25hbEVycm9yKCdhYm9ydGVkJykpXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICB9XG5cbiAgaWYgKHJlcXVlc3QuYWJvcnRlZCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKG1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21jb2xsaW5hL3VuZGljaS9pc3N1ZXMvMjU4XG4gICAgLy8gQ2xvc2UgYWZ0ZXIgYSBIRUFEIHJlcXVlc3QgdG8gaW50ZXJvcCB3aXRoIG1pc2JlaGF2aW5nIHNlcnZlcnNcbiAgICAvLyB0aGF0IG1heSBzZW5kIGEgYm9keSBpbiB0aGUgcmVzcG9uc2UuXG5cbiAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgfVxuXG4gIGlmICh1cGdyYWRlIHx8IG1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgLy8gT24gQ09OTkVDVCBvciB1cGdyYWRlLCBibG9jayBwaXBlbGluZSBmcm9tIGRpc3BhdGNoaW5nIGZ1cnRoZXJcbiAgICAvLyByZXF1ZXN0cyBvbiB0aGlzIGNvbm5lY3Rpb24uXG5cbiAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgfVxuXG4gIGlmIChyZXNldCAhPSBudWxsKSB7XG4gICAgc29ja2V0W2tSZXNldF0gPSByZXNldFxuICB9XG5cbiAgaWYgKGNsaWVudFtrTWF4UmVxdWVzdHNdICYmIHNvY2tldFtrQ291bnRlcl0rKyA+PSBjbGllbnRba01heFJlcXVlc3RzXSkge1xuICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICB9XG5cbiAgaWYgKGJsb2NraW5nKSB7XG4gICAgc29ja2V0W2tCbG9ja2luZ10gPSB0cnVlXG4gIH1cblxuICBsZXQgaGVhZGVyID0gYCR7bWV0aG9kfSAke3BhdGh9IEhUVFAvMS4xXFxyXFxuYFxuXG4gIGlmICh0eXBlb2YgaG9zdCA9PT0gJ3N0cmluZycpIHtcbiAgICBoZWFkZXIgKz0gYGhvc3Q6ICR7aG9zdH1cXHJcXG5gXG4gIH0gZWxzZSB7XG4gICAgaGVhZGVyICs9IGNsaWVudFtrSG9zdEhlYWRlcl1cbiAgfVxuXG4gIGlmICh1cGdyYWRlKSB7XG4gICAgaGVhZGVyICs9IGBjb25uZWN0aW9uOiB1cGdyYWRlXFxyXFxudXBncmFkZTogJHt1cGdyYWRlfVxcclxcbmBcbiAgfSBlbHNlIGlmIChjbGllbnRba1BpcGVsaW5pbmddICYmICFzb2NrZXRba1Jlc2V0XSkge1xuICAgIGhlYWRlciArPSAnY29ubmVjdGlvbjoga2VlcC1hbGl2ZVxcclxcbidcbiAgfSBlbHNlIHtcbiAgICBoZWFkZXIgKz0gJ2Nvbm5lY3Rpb246IGNsb3NlXFxyXFxuJ1xuICB9XG5cbiAgaWYgKGhlYWRlcnMpIHtcbiAgICBoZWFkZXIgKz0gaGVhZGVyc1xuICB9XG5cbiAgaWYgKGNoYW5uZWxzLnNlbmRIZWFkZXJzLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgY2hhbm5lbHMuc2VuZEhlYWRlcnMucHVibGlzaCh7IHJlcXVlc3QsIGhlYWRlcnM6IGhlYWRlciwgc29ja2V0IH0pXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogYXNzZXJ0aW9uICovXG4gIGlmICghYm9keSB8fCBib2R5TGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGNvbnRlbnRMZW5ndGggPT09IDApIHtcbiAgICAgIHNvY2tldC53cml0ZShgJHtoZWFkZXJ9Y29udGVudC1sZW5ndGg6IDBcXHJcXG5cXHJcXG5gLCAnbGF0aW4xJylcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggPT09IG51bGwsICdubyBib2R5IG11c3Qgbm90IGhhdmUgY29udGVudCBsZW5ndGgnKVxuICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1cXHJcXG5gLCAnbGF0aW4xJylcbiAgICB9XG4gICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcbiAgfSBlbHNlIGlmICh1dGlsLmlzQnVmZmVyKGJvZHkpKSB7XG4gICAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggPT09IGJvZHkuYnl0ZUxlbmd0aCwgJ2J1ZmZlciBib2R5IG11c3QgaGF2ZSBjb250ZW50IGxlbmd0aCcpXG5cbiAgICBzb2NrZXQuY29yaygpXG4gICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1jb250ZW50LWxlbmd0aDogJHtjb250ZW50TGVuZ3RofVxcclxcblxcclxcbmAsICdsYXRpbjEnKVxuICAgIHNvY2tldC53cml0ZShib2R5KVxuICAgIHNvY2tldC51bmNvcmsoKVxuICAgIHJlcXVlc3Qub25Cb2R5U2VudChib2R5KVxuICAgIHJlcXVlc3Qub25SZXF1ZXN0U2VudCgpXG4gICAgaWYgKCFleHBlY3RzUGF5bG9hZCkge1xuICAgICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gICAgfVxuICB9IGVsc2UgaWYgKHV0aWwuaXNCbG9iTGlrZShib2R5KSkge1xuICAgIGlmICh0eXBlb2YgYm9keS5zdHJlYW0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdyaXRlSXRlcmFibGUoeyBib2R5OiBib2R5LnN0cmVhbSgpLCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB3cml0ZUJsb2IoeyBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCB9KVxuICAgIH1cbiAgfSBlbHNlIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgd3JpdGVTdHJlYW0oeyBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCB9KVxuICB9IGVsc2UgaWYgKHV0aWwuaXNJdGVyYWJsZShib2R5KSkge1xuICAgIHdyaXRlSXRlcmFibGUoeyBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCB9KVxuICB9IGVsc2Uge1xuICAgIGFzc2VydChmYWxzZSlcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIHdyaXRlSDIgKGNsaWVudCwgc2Vzc2lvbiwgcmVxdWVzdCkge1xuICBjb25zdCB7IGJvZHksIG1ldGhvZCwgcGF0aCwgaG9zdCwgdXBncmFkZSwgZXhwZWN0Q29udGludWUsIHNpZ25hbCwgaGVhZGVyczogcmVxSGVhZGVycyB9ID0gcmVxdWVzdFxuXG4gIGxldCBoZWFkZXJzXG4gIGlmICh0eXBlb2YgcmVxSGVhZGVycyA9PT0gJ3N0cmluZycpIGhlYWRlcnMgPSBSZXF1ZXN0W2tIVFRQMkNvcHlIZWFkZXJzXShyZXFIZWFkZXJzLnRyaW0oKSlcbiAgZWxzZSBoZWFkZXJzID0gcmVxSGVhZGVyc1xuXG4gIGlmICh1cGdyYWRlKSB7XG4gICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgbmV3IEVycm9yKCdVcGdyYWRlIG5vdCBzdXBwb3J0ZWQgZm9yIEgyJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRPRE8oSFRUUC8yKTogU2hvdWxkIHdlIGNhbGwgb25Db25uZWN0IGltbWVkaWF0ZWx5IG9yIG9uIHN0cmVhbSByZWFkeSBldmVudD9cbiAgICByZXF1ZXN0Lm9uQ29ubmVjdCgoZXJyKSA9PiB7XG4gICAgICBpZiAocmVxdWVzdC5hYm9ydGVkIHx8IHJlcXVlc3QuY29tcGxldGVkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBlcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIgfHwgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKSlcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gIH1cblxuICBpZiAocmVxdWVzdC5hYm9ydGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKiogQHR5cGUge2ltcG9ydCgnbm9kZTpodHRwMicpLkNsaWVudEh0dHAyU3RyZWFtfSAqL1xuICBsZXQgc3RyZWFtXG4gIGNvbnN0IGgyU3RhdGUgPSBjbGllbnRba0hUVFAyU2Vzc2lvblN0YXRlXVxuXG4gIGhlYWRlcnNbSFRUUDJfSEVBREVSX0FVVEhPUklUWV0gPSBob3N0IHx8IGNsaWVudFtrSG9zdF1cbiAgaGVhZGVyc1tIVFRQMl9IRUFERVJfTUVUSE9EXSA9IG1ldGhvZFxuXG4gIGlmIChtZXRob2QgPT09ICdDT05ORUNUJykge1xuICAgIHNlc3Npb24ucmVmKClcbiAgICAvLyB3ZSBhcmUgYWxyZWFkeSBjb25uZWN0ZWQsIHN0cmVhbXMgYXJlIHBlbmRpbmcsIGZpcnN0IHJlcXVlc3RcbiAgICAvLyB3aWxsIGNyZWF0ZSBhIG5ldyBzdHJlYW0uIFdlIHRyaWdnZXIgYSByZXF1ZXN0IHRvIGNyZWF0ZSB0aGUgc3RyZWFtIGFuZCB3YWl0IHVudGlsXG4gICAgLy8gYHJlYWR5YCBldmVudCBpcyB0cmlnZ2VyZWRcbiAgICAvLyBXZSBkaXNhYmxlZCBlbmRTdHJlYW0gdG8gYWxsb3cgdGhlIHVzZXIgdG8gd3JpdGUgdG8gdGhlIHN0cmVhbVxuICAgIHN0cmVhbSA9IHNlc3Npb24ucmVxdWVzdChoZWFkZXJzLCB7IGVuZFN0cmVhbTogZmFsc2UsIHNpZ25hbCB9KVxuXG4gICAgaWYgKHN0cmVhbS5pZCAmJiAhc3RyZWFtLnBlbmRpbmcpIHtcbiAgICAgIHJlcXVlc3Qub25VcGdyYWRlKG51bGwsIG51bGwsIHN0cmVhbSlcbiAgICAgICsraDJTdGF0ZS5vcGVuU3RyZWFtc1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0ub25jZSgncmVhZHknLCAoKSA9PiB7XG4gICAgICAgIHJlcXVlc3Qub25VcGdyYWRlKG51bGwsIG51bGwsIHN0cmVhbSlcbiAgICAgICAgKytoMlN0YXRlLm9wZW5TdHJlYW1zXG4gICAgICB9KVxuICAgIH1cblxuICAgIHN0cmVhbS5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICAgIGgyU3RhdGUub3BlblN0cmVhbXMgLT0gMVxuICAgICAgLy8gVE9ETyhIVFRQLzIpOiB1bnJlZiBvbmx5IGlmIGN1cnJlbnQgc3RyZWFtcyBjb3VudCBpcyAwXG4gICAgICBpZiAoaDJTdGF0ZS5vcGVuU3RyZWFtcyA9PT0gMCkgc2Vzc2lvbi51bnJlZigpXG4gICAgfSlcblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzU0MCNzZWN0aW9uLTguM1xuICAvLyA6cGF0aCBhbmQgOnNjaGVtZSBoZWFkZXJzIG11c3QgYmUgb21pdGVkIHdoZW4gc2VuZGluZyBDT05ORUNUXG5cbiAgaGVhZGVyc1tIVFRQMl9IRUFERVJfUEFUSF0gPSBwYXRoXG4gIGhlYWRlcnNbSFRUUDJfSEVBREVSX1NDSEVNRV0gPSAnaHR0cHMnXG5cbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi00LjMuMVxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTQuMy4yXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNC4zLjVcblxuICAvLyBTZW5kaW5nIGEgcGF5bG9hZCBib2R5IG9uIGEgcmVxdWVzdCB0aGF0IGRvZXMgbm90XG4gIC8vIGV4cGVjdCBpdCBjYW4gY2F1c2UgdW5kZWZpbmVkIGJlaGF2aW9yIG9uIHNvbWVcbiAgLy8gc2VydmVycyBhbmQgY29ycnVwdCBjb25uZWN0aW9uIHN0YXRlLiBEbyBub3RcbiAgLy8gcmUtdXNlIHRoZSBjb25uZWN0aW9uIGZvciBmdXJ0aGVyIHJlcXVlc3RzLlxuXG4gIGNvbnN0IGV4cGVjdHNQYXlsb2FkID0gKFxuICAgIG1ldGhvZCA9PT0gJ1BVVCcgfHxcbiAgICBtZXRob2QgPT09ICdQT1NUJyB8fFxuICAgIG1ldGhvZCA9PT0gJ1BBVENIJ1xuICApXG5cbiAgaWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkucmVhZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFRyeSB0byByZWFkIEVPRiBpbiBvcmRlciB0byBnZXQgbGVuZ3RoLlxuICAgIGJvZHkucmVhZCgwKVxuICB9XG5cbiAgbGV0IGNvbnRlbnRMZW5ndGggPSB1dGlsLmJvZHlMZW5ndGgoYm9keSlcblxuICBpZiAoY29udGVudExlbmd0aCA9PSBudWxsKSB7XG4gICAgY29udGVudExlbmd0aCA9IHJlcXVlc3QuY29udGVudExlbmd0aFxuICB9XG5cbiAgaWYgKGNvbnRlbnRMZW5ndGggPT09IDAgfHwgIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjMuMlxuICAgIC8vIEEgdXNlciBhZ2VudCBTSE9VTEQgTk9UIHNlbmQgYSBDb250ZW50LUxlbmd0aCBoZWFkZXIgZmllbGQgd2hlblxuICAgIC8vIHRoZSByZXF1ZXN0IG1lc3NhZ2UgZG9lcyBub3QgY29udGFpbiBhIHBheWxvYWQgYm9keSBhbmQgdGhlIG1ldGhvZFxuICAgIC8vIHNlbWFudGljcyBkbyBub3QgYW50aWNpcGF0ZSBzdWNoIGEgYm9keS5cblxuICAgIGNvbnRlbnRMZW5ndGggPSBudWxsXG4gIH1cblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMjA0NlxuICAvLyBBIHVzZXIgYWdlbnQgbWF5IHNlbmQgYSBDb250ZW50LUxlbmd0aCBoZWFkZXIgd2l0aCAwIHZhbHVlLCB0aGlzIHNob3VsZCBiZSBhbGxvd2VkLlxuICBpZiAoc2hvdWxkU2VuZENvbnRlbnRMZW5ndGgobWV0aG9kKSAmJiBjb250ZW50TGVuZ3RoID4gMCAmJiByZXF1ZXN0LmNvbnRlbnRMZW5ndGggIT0gbnVsbCAmJiByZXF1ZXN0LmNvbnRlbnRMZW5ndGggIT09IGNvbnRlbnRMZW5ndGgpIHtcbiAgICBpZiAoY2xpZW50W2tTdHJpY3RDb250ZW50TGVuZ3RoXSkge1xuICAgICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgbmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcHJvY2Vzcy5lbWl0V2FybmluZyhuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpXG4gIH1cblxuICBpZiAoY29udGVudExlbmd0aCAhPSBudWxsKSB7XG4gICAgYXNzZXJ0KGJvZHksICdubyBib2R5IG11c3Qgbm90IGhhdmUgY29udGVudCBsZW5ndGgnKVxuICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX0NPTlRFTlRfTEVOR1RIXSA9IGAke2NvbnRlbnRMZW5ndGh9YFxuICB9XG5cbiAgc2Vzc2lvbi5yZWYoKVxuXG4gIGNvbnN0IHNob3VsZEVuZFN0cmVhbSA9IG1ldGhvZCA9PT0gJ0dFVCcgfHwgbWV0aG9kID09PSAnSEVBRCdcbiAgaWYgKGV4cGVjdENvbnRpbnVlKSB7XG4gICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfRVhQRUNUXSA9ICcxMDAtY29udGludWUnXG4gICAgc3RyZWFtID0gc2Vzc2lvbi5yZXF1ZXN0KGhlYWRlcnMsIHsgZW5kU3RyZWFtOiBzaG91bGRFbmRTdHJlYW0sIHNpZ25hbCB9KVxuXG4gICAgc3RyZWFtLm9uY2UoJ2NvbnRpbnVlJywgd3JpdGVCb2R5SDIpXG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtID0gc2Vzc2lvbi5yZXF1ZXN0KGhlYWRlcnMsIHtcbiAgICAgIGVuZFN0cmVhbTogc2hvdWxkRW5kU3RyZWFtLFxuICAgICAgc2lnbmFsXG4gICAgfSlcbiAgICB3cml0ZUJvZHlIMigpXG4gIH1cblxuICAvLyBJbmNyZW1lbnQgY291bnRlciBhcyB3ZSBoYXZlIG5ldyBzZXZlcmFsIHN0cmVhbXMgb3BlblxuICArK2gyU3RhdGUub3BlblN0cmVhbXNcblxuICBzdHJlYW0ub25jZSgncmVzcG9uc2UnLCBoZWFkZXJzID0+IHtcbiAgICBjb25zdCB7IFtIVFRQMl9IRUFERVJfU1RBVFVTXTogc3RhdHVzQ29kZSwgLi4ucmVhbEhlYWRlcnMgfSA9IGhlYWRlcnNcblxuICAgIGlmIChyZXF1ZXN0Lm9uSGVhZGVycyhOdW1iZXIoc3RhdHVzQ29kZSksIHJlYWxIZWFkZXJzLCBzdHJlYW0ucmVzdW1lLmJpbmQoc3RyZWFtKSwgJycpID09PSBmYWxzZSkge1xuICAgICAgc3RyZWFtLnBhdXNlKClcbiAgICB9XG4gIH0pXG5cbiAgc3RyZWFtLm9uY2UoJ2VuZCcsICgpID0+IHtcbiAgICByZXF1ZXN0Lm9uQ29tcGxldGUoW10pXG4gIH0pXG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgaWYgKHJlcXVlc3Qub25EYXRhKGNodW5rKSA9PT0gZmFsc2UpIHtcbiAgICAgIHN0cmVhbS5wYXVzZSgpXG4gICAgfVxuICB9KVxuXG4gIHN0cmVhbS5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICBoMlN0YXRlLm9wZW5TdHJlYW1zIC09IDFcbiAgICAvLyBUT0RPKEhUVFAvMik6IHVucmVmIG9ubHkgaWYgY3VycmVudCBzdHJlYW1zIGNvdW50IGlzIDBcbiAgICBpZiAoaDJTdGF0ZS5vcGVuU3RyZWFtcyA9PT0gMCkge1xuICAgICAgc2Vzc2lvbi51bnJlZigpXG4gICAgfVxuICB9KVxuXG4gIHN0cmVhbS5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoY2xpZW50W2tIVFRQMlNlc3Npb25dICYmICFjbGllbnRba0hUVFAyU2Vzc2lvbl0uZGVzdHJveWVkICYmICF0aGlzLmNsb3NlZCAmJiAhdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIGgyU3RhdGUuc3RyZWFtcyAtPSAxXG4gICAgICB1dGlsLmRlc3Ryb3koc3RyZWFtLCBlcnIpXG4gICAgfVxuICB9KVxuXG4gIHN0cmVhbS5vbmNlKCdmcmFtZUVycm9yJywgKHR5cGUsIGNvZGUpID0+IHtcbiAgICBjb25zdCBlcnIgPSBuZXcgSW5mb3JtYXRpb25hbEVycm9yKGBIVFRQLzI6IFwiZnJhbWVFcnJvclwiIHJlY2VpdmVkIC0gdHlwZSAke3R5cGV9LCBjb2RlICR7Y29kZX1gKVxuICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcblxuICAgIGlmIChjbGllbnRba0hUVFAyU2Vzc2lvbl0gJiYgIWNsaWVudFtrSFRUUDJTZXNzaW9uXS5kZXN0cm95ZWQgJiYgIXRoaXMuY2xvc2VkICYmICF0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgaDJTdGF0ZS5zdHJlYW1zIC09IDFcbiAgICAgIHV0aWwuZGVzdHJveShzdHJlYW0sIGVycilcbiAgICB9XG4gIH0pXG5cbiAgLy8gc3RyZWFtLm9uKCdhYm9ydGVkJywgKCkgPT4ge1xuICAvLyAgIC8vIFRPRE8oSFRUUC8yKTogU3VwcG9ydCBhYm9ydGVkXG4gIC8vIH0pXG5cbiAgLy8gc3RyZWFtLm9uKCd0aW1lb3V0JywgKCkgPT4ge1xuICAvLyAgIC8vIFRPRE8oSFRUUC8yKTogU3VwcG9ydCB0aW1lb3V0XG4gIC8vIH0pXG5cbiAgLy8gc3RyZWFtLm9uKCdwdXNoJywgaGVhZGVycyA9PiB7XG4gIC8vICAgLy8gVE9ETyhIVFRQLzIpOiBTdXBwb3IgcHVzaFxuICAvLyB9KVxuXG4gIC8vIHN0cmVhbS5vbigndHJhaWxlcnMnLCBoZWFkZXJzID0+IHtcbiAgLy8gICAvLyBUT0RPKEhUVFAvMik6IFN1cHBvcnQgdHJhaWxlcnNcbiAgLy8gfSlcblxuICByZXR1cm4gdHJ1ZVxuXG4gIGZ1bmN0aW9uIHdyaXRlQm9keUgyICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogYXNzZXJ0aW9uICovXG4gICAgaWYgKCFib2R5KSB7XG4gICAgICByZXF1ZXN0Lm9uUmVxdWVzdFNlbnQoKVxuICAgIH0gZWxzZSBpZiAodXRpbC5pc0J1ZmZlcihib2R5KSkge1xuICAgICAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggPT09IGJvZHkuYnl0ZUxlbmd0aCwgJ2J1ZmZlciBib2R5IG11c3QgaGF2ZSBjb250ZW50IGxlbmd0aCcpXG4gICAgICBzdHJlYW0uY29yaygpXG4gICAgICBzdHJlYW0ud3JpdGUoYm9keSlcbiAgICAgIHN0cmVhbS51bmNvcmsoKVxuICAgICAgc3RyZWFtLmVuZCgpXG4gICAgICByZXF1ZXN0Lm9uQm9keVNlbnQoYm9keSlcbiAgICAgIHJlcXVlc3Qub25SZXF1ZXN0U2VudCgpXG4gICAgfSBlbHNlIGlmICh1dGlsLmlzQmxvYkxpa2UoYm9keSkpIHtcbiAgICAgIGlmICh0eXBlb2YgYm9keS5zdHJlYW0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd3JpdGVJdGVyYWJsZSh7XG4gICAgICAgICAgY2xpZW50LFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgY29udGVudExlbmd0aCxcbiAgICAgICAgICBoMnN0cmVhbTogc3RyZWFtLFxuICAgICAgICAgIGV4cGVjdHNQYXlsb2FkLFxuICAgICAgICAgIGJvZHk6IGJvZHkuc3RyZWFtKCksXG4gICAgICAgICAgc29ja2V0OiBjbGllbnRba1NvY2tldF0sXG4gICAgICAgICAgaGVhZGVyOiAnJ1xuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVCbG9iKHtcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIGNsaWVudCxcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIGNvbnRlbnRMZW5ndGgsXG4gICAgICAgICAgZXhwZWN0c1BheWxvYWQsXG4gICAgICAgICAgaDJzdHJlYW06IHN0cmVhbSxcbiAgICAgICAgICBoZWFkZXI6ICcnLFxuICAgICAgICAgIHNvY2tldDogY2xpZW50W2tTb2NrZXRdXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgICB3cml0ZVN0cmVhbSh7XG4gICAgICAgIGJvZHksXG4gICAgICAgIGNsaWVudCxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgY29udGVudExlbmd0aCxcbiAgICAgICAgZXhwZWN0c1BheWxvYWQsXG4gICAgICAgIHNvY2tldDogY2xpZW50W2tTb2NrZXRdLFxuICAgICAgICBoMnN0cmVhbTogc3RyZWFtLFxuICAgICAgICBoZWFkZXI6ICcnXG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAodXRpbC5pc0l0ZXJhYmxlKGJvZHkpKSB7XG4gICAgICB3cml0ZUl0ZXJhYmxlKHtcbiAgICAgICAgYm9keSxcbiAgICAgICAgY2xpZW50LFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBjb250ZW50TGVuZ3RoLFxuICAgICAgICBleHBlY3RzUGF5bG9hZCxcbiAgICAgICAgaGVhZGVyOiAnJyxcbiAgICAgICAgaDJzdHJlYW06IHN0cmVhbSxcbiAgICAgICAgc29ja2V0OiBjbGllbnRba1NvY2tldF1cbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChmYWxzZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd3JpdGVTdHJlYW0gKHsgaDJzdHJlYW0sIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkIH0pIHtcbiAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggIT09IDAgfHwgY2xpZW50W2tSdW5uaW5nXSA9PT0gMCwgJ3N0cmVhbSBib2R5IGNhbm5vdCBiZSBwaXBlbGluZWQnKVxuXG4gIGlmIChjbGllbnRba0hUVFBDb25uVmVyc2lvbl0gPT09ICdoMicpIHtcbiAgICAvLyBGb3IgSFRUUC8yLCBpcyBlbm91Z2ggdG8gcGlwZSB0aGUgc3RyZWFtXG4gICAgY29uc3QgcGlwZSA9IHBpcGVsaW5lKFxuICAgICAgYm9keSxcbiAgICAgIGgyc3RyZWFtLFxuICAgICAgKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgdXRpbC5kZXN0cm95KGJvZHksIGVycilcbiAgICAgICAgICB1dGlsLmRlc3Ryb3koaDJzdHJlYW0sIGVycilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXF1ZXN0Lm9uUmVxdWVzdFNlbnQoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKVxuXG4gICAgcGlwZS5vbignZGF0YScsIG9uUGlwZURhdGEpXG4gICAgcGlwZS5vbmNlKCdlbmQnLCAoKSA9PiB7XG4gICAgICBwaXBlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25QaXBlRGF0YSlcbiAgICAgIHV0aWwuZGVzdHJveShwaXBlKVxuICAgIH0pXG5cbiAgICBmdW5jdGlvbiBvblBpcGVEYXRhIChjaHVuaykge1xuICAgICAgcmVxdWVzdC5vbkJvZHlTZW50KGNodW5rKVxuICAgIH1cblxuICAgIHJldHVyblxuICB9XG5cbiAgbGV0IGZpbmlzaGVkID0gZmFsc2VcblxuICBjb25zdCB3cml0ZXIgPSBuZXcgQXN5bmNXcml0ZXIoeyBzb2NrZXQsIHJlcXVlc3QsIGNvbnRlbnRMZW5ndGgsIGNsaWVudCwgZXhwZWN0c1BheWxvYWQsIGhlYWRlciB9KVxuXG4gIGNvbnN0IG9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICghd3JpdGVyLndyaXRlKGNodW5rKSAmJiB0aGlzLnBhdXNlKSB7XG4gICAgICAgIHRoaXMucGF1c2UoKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdXRpbC5kZXN0cm95KHRoaXMsIGVycilcbiAgICB9XG4gIH1cbiAgY29uc3Qgb25EcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChib2R5LnJlc3VtZSkge1xuICAgICAgYm9keS5yZXN1bWUoKVxuICAgIH1cbiAgfVxuICBjb25zdCBvbkFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IGVyciA9IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBvbkZpbmlzaGVkKGVycikpXG4gIH1cbiAgY29uc3Qgb25GaW5pc2hlZCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGZpbmlzaGVkID0gdHJ1ZVxuXG4gICAgYXNzZXJ0KHNvY2tldC5kZXN0cm95ZWQgfHwgKHNvY2tldFtrV3JpdGluZ10gJiYgY2xpZW50W2tSdW5uaW5nXSA8PSAxKSlcblxuICAgIHNvY2tldFxuICAgICAgLm9mZignZHJhaW4nLCBvbkRyYWluKVxuICAgICAgLm9mZignZXJyb3InLCBvbkZpbmlzaGVkKVxuXG4gICAgYm9keVxuICAgICAgLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25EYXRhKVxuICAgICAgLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbkZpbmlzaGVkKVxuICAgICAgLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRmluaXNoZWQpXG4gICAgICAucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25BYm9ydClcblxuICAgIGlmICghZXJyKSB7XG4gICAgICB0cnkge1xuICAgICAgICB3cml0ZXIuZW5kKClcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGVyciA9IGVyXG4gICAgICB9XG4gICAgfVxuXG4gICAgd3JpdGVyLmRlc3Ryb3koZXJyKVxuXG4gICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgIT09ICdVTkRfRVJSX0lORk8nIHx8IGVyci5tZXNzYWdlICE9PSAncmVzZXQnKSkge1xuICAgICAgdXRpbC5kZXN0cm95KGJvZHksIGVycilcbiAgICB9IGVsc2Uge1xuICAgICAgdXRpbC5kZXN0cm95KGJvZHkpXG4gICAgfVxuICB9XG5cbiAgYm9keVxuICAgIC5vbignZGF0YScsIG9uRGF0YSlcbiAgICAub24oJ2VuZCcsIG9uRmluaXNoZWQpXG4gICAgLm9uKCdlcnJvcicsIG9uRmluaXNoZWQpXG4gICAgLm9uKCdjbG9zZScsIG9uQWJvcnQpXG5cbiAgaWYgKGJvZHkucmVzdW1lKSB7XG4gICAgYm9keS5yZXN1bWUoKVxuICB9XG5cbiAgc29ja2V0XG4gICAgLm9uKCdkcmFpbicsIG9uRHJhaW4pXG4gICAgLm9uKCdlcnJvcicsIG9uRmluaXNoZWQpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlQmxvYiAoeyBoMnN0cmVhbSwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQgfSkge1xuICBhc3NlcnQoY29udGVudExlbmd0aCA9PT0gYm9keS5zaXplLCAnYmxvYiBib2R5IG11c3QgaGF2ZSBjb250ZW50IGxlbmd0aCcpXG5cbiAgY29uc3QgaXNIMiA9IGNsaWVudFtrSFRUUENvbm5WZXJzaW9uXSA9PT0gJ2gyJ1xuICB0cnkge1xuICAgIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwgJiYgY29udGVudExlbmd0aCAhPT0gYm9keS5zaXplKSB7XG4gICAgICB0aHJvdyBuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKClcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShhd2FpdCBib2R5LmFycmF5QnVmZmVyKCkpXG5cbiAgICBpZiAoaXNIMikge1xuICAgICAgaDJzdHJlYW0uY29yaygpXG4gICAgICBoMnN0cmVhbS53cml0ZShidWZmZXIpXG4gICAgICBoMnN0cmVhbS51bmNvcmsoKVxuICAgIH0gZWxzZSB7XG4gICAgICBzb2NrZXQuY29yaygpXG4gICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAke2NvbnRlbnRMZW5ndGh9XFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICBzb2NrZXQud3JpdGUoYnVmZmVyKVxuICAgICAgc29ja2V0LnVuY29yaygpXG4gICAgfVxuXG4gICAgcmVxdWVzdC5vbkJvZHlTZW50KGJ1ZmZlcilcbiAgICByZXF1ZXN0Lm9uUmVxdWVzdFNlbnQoKVxuXG4gICAgaWYgKCFleHBlY3RzUGF5bG9hZCkge1xuICAgICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gICAgfVxuXG4gICAgcmVzdW1lKGNsaWVudClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdXRpbC5kZXN0cm95KGlzSDIgPyBoMnN0cmVhbSA6IHNvY2tldCwgZXJyKVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlSXRlcmFibGUgKHsgaDJzdHJlYW0sIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkIH0pIHtcbiAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggIT09IDAgfHwgY2xpZW50W2tSdW5uaW5nXSA9PT0gMCwgJ2l0ZXJhdG9yIGJvZHkgY2Fubm90IGJlIHBpcGVsaW5lZCcpXG5cbiAgbGV0IGNhbGxiYWNrID0gbnVsbFxuICBmdW5jdGlvbiBvbkRyYWluICgpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2tcbiAgICAgIGNhbGxiYWNrID0gbnVsbFxuICAgICAgY2IoKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHdhaXRGb3JEcmFpbiA9ICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBhc3NlcnQoY2FsbGJhY2sgPT09IG51bGwpXG5cbiAgICBpZiAoc29ja2V0W2tFcnJvcl0pIHtcbiAgICAgIHJlamVjdChzb2NrZXRba0Vycm9yXSlcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sgPSByZXNvbHZlXG4gICAgfVxuICB9KVxuXG4gIGlmIChjbGllbnRba0hUVFBDb25uVmVyc2lvbl0gPT09ICdoMicpIHtcbiAgICBoMnN0cmVhbVxuICAgICAgLm9uKCdjbG9zZScsIG9uRHJhaW4pXG4gICAgICAub24oJ2RyYWluJywgb25EcmFpbilcblxuICAgIHRyeSB7XG4gICAgICAvLyBJdCdzIHVwIHRvIHRoZSB1c2VyIHRvIHNvbWVob3cgYWJvcnQgdGhlIGFzeW5jIGl0ZXJhYmxlLlxuICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBib2R5KSB7XG4gICAgICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgICAgIHRocm93IHNvY2tldFtrRXJyb3JdXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXMgPSBoMnN0cmVhbS53cml0ZShjaHVuaylcbiAgICAgICAgcmVxdWVzdC5vbkJvZHlTZW50KGNodW5rKVxuICAgICAgICBpZiAoIXJlcykge1xuICAgICAgICAgIGF3YWl0IHdhaXRGb3JEcmFpbigpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGgyc3RyZWFtLmRlc3Ryb3koZXJyKVxuICAgIH0gZmluYWxseSB7XG4gICAgICByZXF1ZXN0Lm9uUmVxdWVzdFNlbnQoKVxuICAgICAgaDJzdHJlYW0uZW5kKClcbiAgICAgIGgyc3RyZWFtXG4gICAgICAgIC5vZmYoJ2Nsb3NlJywgb25EcmFpbilcbiAgICAgICAgLm9mZignZHJhaW4nLCBvbkRyYWluKVxuICAgIH1cblxuICAgIHJldHVyblxuICB9XG5cbiAgc29ja2V0XG4gICAgLm9uKCdjbG9zZScsIG9uRHJhaW4pXG4gICAgLm9uKCdkcmFpbicsIG9uRHJhaW4pXG5cbiAgY29uc3Qgd3JpdGVyID0gbmV3IEFzeW5jV3JpdGVyKHsgc29ja2V0LCByZXF1ZXN0LCBjb250ZW50TGVuZ3RoLCBjbGllbnQsIGV4cGVjdHNQYXlsb2FkLCBoZWFkZXIgfSlcbiAgdHJ5IHtcbiAgICAvLyBJdCdzIHVwIHRvIHRoZSB1c2VyIHRvIHNvbWVob3cgYWJvcnQgdGhlIGFzeW5jIGl0ZXJhYmxlLlxuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgYm9keSkge1xuICAgICAgaWYgKHNvY2tldFtrRXJyb3JdKSB7XG4gICAgICAgIHRocm93IHNvY2tldFtrRXJyb3JdXG4gICAgICB9XG5cbiAgICAgIGlmICghd3JpdGVyLndyaXRlKGNodW5rKSkge1xuICAgICAgICBhd2FpdCB3YWl0Rm9yRHJhaW4oKVxuICAgICAgfVxuICAgIH1cblxuICAgIHdyaXRlci5lbmQoKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB3cml0ZXIuZGVzdHJveShlcnIpXG4gIH0gZmluYWxseSB7XG4gICAgc29ja2V0XG4gICAgICAub2ZmKCdjbG9zZScsIG9uRHJhaW4pXG4gICAgICAub2ZmKCdkcmFpbicsIG9uRHJhaW4pXG4gIH1cbn1cblxuY2xhc3MgQXN5bmNXcml0ZXIge1xuICBjb25zdHJ1Y3RvciAoeyBzb2NrZXQsIHJlcXVlc3QsIGNvbnRlbnRMZW5ndGgsIGNsaWVudCwgZXhwZWN0c1BheWxvYWQsIGhlYWRlciB9KSB7XG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXRcbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0XG4gICAgdGhpcy5jb250ZW50TGVuZ3RoID0gY29udGVudExlbmd0aFxuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50XG4gICAgdGhpcy5ieXRlc1dyaXR0ZW4gPSAwXG4gICAgdGhpcy5leHBlY3RzUGF5bG9hZCA9IGV4cGVjdHNQYXlsb2FkXG4gICAgdGhpcy5oZWFkZXIgPSBoZWFkZXJcblxuICAgIHNvY2tldFtrV3JpdGluZ10gPSB0cnVlXG4gIH1cblxuICB3cml0ZSAoY2h1bmspIHtcbiAgICBjb25zdCB7IHNvY2tldCwgcmVxdWVzdCwgY29udGVudExlbmd0aCwgY2xpZW50LCBieXRlc1dyaXR0ZW4sIGV4cGVjdHNQYXlsb2FkLCBoZWFkZXIgfSA9IHRoaXNcblxuICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgdGhyb3cgc29ja2V0W2tFcnJvcl1cbiAgICB9XG5cbiAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgoY2h1bmspXG4gICAgaWYgKCFsZW4pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gV2Ugc2hvdWxkIGRlZmVyIHdyaXRpbmcgY2h1bmtzLlxuICAgIGlmIChjb250ZW50TGVuZ3RoICE9PSBudWxsICYmIGJ5dGVzV3JpdHRlbiArIGxlbiA+IGNvbnRlbnRMZW5ndGgpIHtcbiAgICAgIGlmIChjbGllbnRba1N0cmljdENvbnRlbnRMZW5ndGhdKSB7XG4gICAgICAgIHRocm93IG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKVxuICAgICAgfVxuXG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSlcbiAgICB9XG5cbiAgICBzb2NrZXQuY29yaygpXG5cbiAgICBpZiAoYnl0ZXNXcml0dGVuID09PSAwKSB7XG4gICAgICBpZiAoIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAoY29udGVudExlbmd0aCA9PT0gbnVsbCkge1xuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfXRyYW5zZmVyLWVuY29kaW5nOiBjaHVua2VkXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAke2NvbnRlbnRMZW5ndGh9XFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvbnRlbnRMZW5ndGggPT09IG51bGwpIHtcbiAgICAgIHNvY2tldC53cml0ZShgXFxyXFxuJHtsZW4udG9TdHJpbmcoMTYpfVxcclxcbmAsICdsYXRpbjEnKVxuICAgIH1cblxuICAgIHRoaXMuYnl0ZXNXcml0dGVuICs9IGxlblxuXG4gICAgY29uc3QgcmV0ID0gc29ja2V0LndyaXRlKGNodW5rKVxuXG4gICAgc29ja2V0LnVuY29yaygpXG5cbiAgICByZXF1ZXN0Lm9uQm9keVNlbnQoY2h1bmspXG5cbiAgICBpZiAoIXJldCkge1xuICAgICAgaWYgKHNvY2tldFtrUGFyc2VyXS50aW1lb3V0ICYmIHNvY2tldFtrUGFyc2VyXS50aW1lb3V0VHlwZSA9PT0gVElNRU9VVF9IRUFERVJTKSB7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBvbmx5IGZvciBqZXN0XG4gICAgICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgICAgc29ja2V0W2tQYXJzZXJdLnRpbWVvdXQucmVmcmVzaCgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBlbmQgKCkge1xuICAgIGNvbnN0IHsgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBjbGllbnQsIGJ5dGVzV3JpdHRlbiwgZXhwZWN0c1BheWxvYWQsIGhlYWRlciwgcmVxdWVzdCB9ID0gdGhpc1xuICAgIHJlcXVlc3Qub25SZXF1ZXN0U2VudCgpXG5cbiAgICBzb2NrZXRba1dyaXRpbmddID0gZmFsc2VcblxuICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgdGhyb3cgc29ja2V0W2tFcnJvcl1cbiAgICB9XG5cbiAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGJ5dGVzV3JpdHRlbiA9PT0gMCkge1xuICAgICAgaWYgKGV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4zLjJcbiAgICAgICAgLy8gQSB1c2VyIGFnZW50IFNIT1VMRCBzZW5kIGEgQ29udGVudC1MZW5ndGggaW4gYSByZXF1ZXN0IG1lc3NhZ2Ugd2hlblxuICAgICAgICAvLyBubyBUcmFuc2Zlci1FbmNvZGluZyBpcyBzZW50IGFuZCB0aGUgcmVxdWVzdCBtZXRob2QgZGVmaW5lcyBhIG1lYW5pbmdcbiAgICAgICAgLy8gZm9yIGFuIGVuY2xvc2VkIHBheWxvYWQgYm9keS5cblxuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAwXFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfVxcclxcbmAsICdsYXRpbjEnKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29udGVudExlbmd0aCA9PT0gbnVsbCkge1xuICAgICAgc29ja2V0LndyaXRlKCdcXHJcXG4wXFxyXFxuXFxyXFxuJywgJ2xhdGluMScpXG4gICAgfVxuXG4gICAgaWYgKGNvbnRlbnRMZW5ndGggIT09IG51bGwgJiYgYnl0ZXNXcml0dGVuICE9PSBjb250ZW50TGVuZ3RoKSB7XG4gICAgICBpZiAoY2xpZW50W2tTdHJpY3RDb250ZW50TGVuZ3RoXSkge1xuICAgICAgICB0aHJvdyBuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcobmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dCAmJiBzb2NrZXRba1BhcnNlcl0udGltZW91dFR5cGUgPT09IFRJTUVPVVRfSEVBREVSUykge1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U6IG9ubHkgZm9yIGplc3RcbiAgICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgIHNvY2tldFtrUGFyc2VyXS50aW1lb3V0LnJlZnJlc2goKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VtZShjbGllbnQpXG4gIH1cblxuICBkZXN0cm95IChlcnIpIHtcbiAgICBjb25zdCB7IHNvY2tldCwgY2xpZW50IH0gPSB0aGlzXG5cbiAgICBzb2NrZXRba1dyaXRpbmddID0gZmFsc2VcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddIDw9IDEsICdwaXBlbGluZSBzaG91bGQgb25seSBjb250YWluIHRoaXMgcmVxdWVzdCcpXG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBlcnIpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGVycm9yUmVxdWVzdCAoY2xpZW50LCByZXF1ZXN0LCBlcnIpIHtcbiAgdHJ5IHtcbiAgICByZXF1ZXN0Lm9uRXJyb3IoZXJyKVxuICAgIGFzc2VydChyZXF1ZXN0LmFib3J0ZWQpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNsaWVudC5lbWl0KCdlcnJvcicsIGVycilcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENsaWVudFxuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJuZXQiLCJodHRwIiwicGlwZWxpbmUiLCJ1dGlsIiwidGltZXJzIiwiUmVxdWVzdCIsIkRpc3BhdGNoZXJCYXNlIiwiUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yIiwiUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvciIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiUmVxdWVzdEFib3J0ZWRFcnJvciIsIkhlYWRlcnNUaW1lb3V0RXJyb3IiLCJIZWFkZXJzT3ZlcmZsb3dFcnJvciIsIlNvY2tldEVycm9yIiwiSW5mb3JtYXRpb25hbEVycm9yIiwiQm9keVRpbWVvdXRFcnJvciIsIkhUVFBQYXJzZXJFcnJvciIsIlJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IiLCJDbGllbnREZXN0cm95ZWRFcnJvciIsImJ1aWxkQ29ubmVjdG9yIiwia1VybCIsImtSZXNldCIsImtTZXJ2ZXJOYW1lIiwia0NsaWVudCIsImtCdXN5Iiwia1BhcnNlciIsImtDb25uZWN0Iiwia0Jsb2NraW5nIiwia1Jlc3VtaW5nIiwia1J1bm5pbmciLCJrUGVuZGluZyIsImtTaXplIiwia1dyaXRpbmciLCJrUXVldWUiLCJrQ29ubmVjdGVkIiwia0Nvbm5lY3RpbmciLCJrTmVlZERyYWluIiwia05vUmVmIiwia0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0Iiwia0hvc3RIZWFkZXIiLCJrUGVuZGluZ0lkeCIsImtSdW5uaW5nSWR4Iiwia0Vycm9yIiwia1BpcGVsaW5pbmciLCJrU29ja2V0Iiwia0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZSIsImtNYXhIZWFkZXJzU2l6ZSIsImtLZWVwQWxpdmVNYXhUaW1lb3V0Iiwia0tlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQiLCJrSGVhZGVyc1RpbWVvdXQiLCJrQm9keVRpbWVvdXQiLCJrU3RyaWN0Q29udGVudExlbmd0aCIsImtDb25uZWN0b3IiLCJrTWF4UmVkaXJlY3Rpb25zIiwia01heFJlcXVlc3RzIiwia0NvdW50ZXIiLCJrQ2xvc2UiLCJrRGVzdHJveSIsImtEaXNwYXRjaCIsImtJbnRlcmNlcHRvcnMiLCJrTG9jYWxBZGRyZXNzIiwia01heFJlc3BvbnNlU2l6ZSIsImtIVFRQQ29ublZlcnNpb24iLCJrSG9zdCIsImtIVFRQMlNlc3Npb24iLCJrSFRUUDJTZXNzaW9uU3RhdGUiLCJrSFRUUDJCdWlsZFJlcXVlc3QiLCJrSFRUUDJDb3B5SGVhZGVycyIsImtIVFRQMUJ1aWxkUmVxdWVzdCIsImh0dHAyIiwiY29uc3RhbnRzIiwiSFRUUDJfSEVBREVSX0FVVEhPUklUWSIsIkhUVFAyX0hFQURFUl9NRVRIT0QiLCJIVFRQMl9IRUFERVJfUEFUSCIsIkhUVFAyX0hFQURFUl9TQ0hFTUUiLCJIVFRQMl9IRUFERVJfQ09OVEVOVF9MRU5HVEgiLCJIVFRQMl9IRUFERVJfRVhQRUNUIiwiSFRUUDJfSEVBREVSX1NUQVRVUyIsImgyRXhwZXJpbWVudGFsV2FybmVkIiwiRmFzdEJ1ZmZlciIsIkJ1ZmZlciIsIlN5bWJvbCIsInNwZWNpZXMiLCJrQ2xvc2VkUmVzb2x2ZSIsImNoYW5uZWxzIiwiZGlhZ25vc3RpY3NDaGFubmVsIiwic2VuZEhlYWRlcnMiLCJjaGFubmVsIiwiYmVmb3JlQ29ubmVjdCIsImNvbm5lY3RFcnJvciIsImNvbm5lY3RlZCIsImhhc1N1YnNjcmliZXJzIiwiQ2xpZW50IiwiY29uc3RydWN0b3IiLCJ1cmwiLCJpbnRlcmNlcHRvcnMiLCJtYXhIZWFkZXJTaXplIiwiaGVhZGVyc1RpbWVvdXQiLCJzb2NrZXRUaW1lb3V0IiwicmVxdWVzdFRpbWVvdXQiLCJjb25uZWN0VGltZW91dCIsImJvZHlUaW1lb3V0IiwiaWRsZVRpbWVvdXQiLCJrZWVwQWxpdmUiLCJrZWVwQWxpdmVUaW1lb3V0IiwibWF4S2VlcEFsaXZlVGltZW91dCIsImtlZXBBbGl2ZU1heFRpbWVvdXQiLCJrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkIiwic29ja2V0UGF0aCIsInBpcGVsaW5pbmciLCJ0bHMiLCJzdHJpY3RDb250ZW50TGVuZ3RoIiwibWF4Q2FjaGVkU2Vzc2lvbnMiLCJtYXhSZWRpcmVjdGlvbnMiLCJjb25uZWN0IiwibWF4UmVxdWVzdHNQZXJDbGllbnQiLCJsb2NhbEFkZHJlc3MiLCJtYXhSZXNwb25zZVNpemUiLCJhdXRvU2VsZWN0RmFtaWx5IiwiYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0IiwiYWxsb3dIMiIsIm1heENvbmN1cnJlbnRTdHJlYW1zIiwidW5kZWZpbmVkIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJpc0ludGVnZXIiLCJpc0lQIiwidGltZW91dCIsIm5vZGVIYXNBdXRvU2VsZWN0RmFtaWx5IiwiQXJyYXkiLCJpc0FycmF5IiwiY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvciIsInBhcnNlT3JpZ2luIiwiaG9zdG5hbWUiLCJwb3J0Iiwib3BlblN0cmVhbXMiLCJ2YWx1ZSIsInJlc3VtZSIsImxlbmd0aCIsImRlc3Ryb3llZCIsInNvY2tldCIsImNiIiwib25jZSIsIm9wdHMiLCJoYW5kbGVyIiwib3JpZ2luIiwicmVxdWVzdCIsInB1c2giLCJib2R5TGVuZ3RoIiwiYm9keSIsImlzSXRlcmFibGUiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJQcm9taXNlIiwicmVzb2x2ZSIsImVyciIsInJlcXVlc3RzIiwic3BsaWNlIiwiaSIsImVycm9yUmVxdWVzdCIsImNhbGxiYWNrIiwiZGVzdHJveSIsInF1ZXVlTWljcm90YXNrIiwib24iLCJvbkh0dHAyU2Vzc2lvbkVycm9yIiwiY29kZSIsIm9uRXJyb3IiLCJvbkh0dHAyRnJhbWVFcnJvciIsInR5cGUiLCJpZCIsIm9uSHR0cDJTZXNzaW9uRW5kIiwib25IVFRQMkdvQXdheSIsImNsaWVudCIsImVtaXQiLCJFTVBUWV9CVUYiLCJhbGxvYyIsImxhenlsbGh0dHAiLCJsbGh0dHBXYXNtRGF0YSIsImVudiIsIkpFU1RfV09SS0VSX0lEIiwibW9kIiwiV2ViQXNzZW1ibHkiLCJjb21waWxlIiwiZnJvbSIsImUiLCJpbnN0YW50aWF0ZSIsIndhc21fb25fdXJsIiwicCIsImF0IiwibGVuIiwid2FzbV9vbl9zdGF0dXMiLCJzdHJpY3RFcXVhbCIsImN1cnJlbnRQYXJzZXIiLCJwdHIiLCJzdGFydCIsImN1cnJlbnRCdWZmZXJQdHIiLCJjdXJyZW50QnVmZmVyUmVmIiwiYnl0ZU9mZnNldCIsIm9uU3RhdHVzIiwiYnVmZmVyIiwid2FzbV9vbl9tZXNzYWdlX2JlZ2luIiwib25NZXNzYWdlQmVnaW4iLCJ3YXNtX29uX2hlYWRlcl9maWVsZCIsIm9uSGVhZGVyRmllbGQiLCJ3YXNtX29uX2hlYWRlcl92YWx1ZSIsIm9uSGVhZGVyVmFsdWUiLCJ3YXNtX29uX2hlYWRlcnNfY29tcGxldGUiLCJzdGF0dXNDb2RlIiwidXBncmFkZSIsInNob3VsZEtlZXBBbGl2ZSIsIm9uSGVhZGVyc0NvbXBsZXRlIiwiQm9vbGVhbiIsIndhc21fb25fYm9keSIsIm9uQm9keSIsIndhc21fb25fbWVzc2FnZV9jb21wbGV0ZSIsIm9uTWVzc2FnZUNvbXBsZXRlIiwibGxodHRwSW5zdGFuY2UiLCJsbGh0dHBQcm9taXNlIiwiY2F0Y2giLCJjdXJyZW50QnVmZmVyU2l6ZSIsIlRJTUVPVVRfSEVBREVSUyIsIlRJTUVPVVRfQk9EWSIsIlRJTUVPVVRfSURMRSIsIlBhcnNlciIsImV4cG9ydHMiLCJsbGh0dHAiLCJsbGh0dHBfYWxsb2MiLCJUWVBFIiwiUkVTUE9OU0UiLCJ0aW1lb3V0VmFsdWUiLCJ0aW1lb3V0VHlwZSIsInN0YXR1c1RleHQiLCJoZWFkZXJzIiwiaGVhZGVyc1NpemUiLCJoZWFkZXJzTWF4U2l6ZSIsInBhdXNlZCIsImJpbmQiLCJieXRlc1JlYWQiLCJjb250ZW50TGVuZ3RoIiwiY29ubmVjdGlvbiIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJvblBhcnNlclRpbWVvdXQiLCJ1bnJlZiIsInJlZnJlc2giLCJsbGh0dHBfcmVzdW1lIiwiZXhlY3V0ZSIsInJlYWQiLCJyZWFkTW9yZSIsImNodW5rIiwiZGF0YSIsImZyZWUiLCJNYXRoIiwiY2VpbCIsIm1hbGxvYyIsIlVpbnQ4QXJyYXkiLCJtZW1vcnkiLCJzZXQiLCJyZXQiLCJsbGh0dHBfZXhlY3V0ZSIsIm9mZnNldCIsImxsaHR0cF9nZXRfZXJyb3JfcG9zIiwiRVJST1IiLCJQQVVTRURfVVBHUkFERSIsIm9uVXBncmFkZSIsInNsaWNlIiwiUEFVU0VEIiwidW5zaGlmdCIsIk9LIiwibGxodHRwX2dldF9lcnJvcl9yZWFzb24iLCJtZXNzYWdlIiwiaW5kZXhPZiIsInRvU3RyaW5nIiwibGxodHRwX2ZyZWUiLCJidWYiLCJjb25jYXQiLCJ0cmFja0hlYWRlciIsImtleSIsInRvTG93ZXJDYXNlIiwiaGVhZCIsIm1ldGhvZCIsInJlbW92ZUxpc3RlbmVyIiwib25Tb2NrZXRFcnJvciIsIm9uU29ja2V0UmVhZGFibGUiLCJvblNvY2tldEVuZCIsIm9uU29ja2V0Q2xvc2UiLCJnZXRTb2NrZXRJbmZvIiwicGFyc2VLZWVwQWxpdmVUaW1lb3V0IiwibWluIiwicGF1c2UiLCJvbkhlYWRlcnMiLCJhYm9ydGVkIiwib25EYXRhIiwicGFyc2VJbnQiLCJvbkNvbXBsZXRlIiwic2V0SW1tZWRpYXRlIiwicGFyc2VyIiwid3JpdGFibGVOZWVkRHJhaW4iLCJob3N0IiwicHJvdG9jb2wiLCJpZHgiLCJpcCIsInN1YnN0cmluZyIsInB1Ymxpc2giLCJjb25uZWN0UGFyYW1zIiwic2VydmVybmFtZSIsImNvbm5lY3RvciIsInJlamVjdCIsImlzSDIiLCJhbHBuUHJvdG9jb2wiLCJlbWl0V2FybmluZyIsInNlc3Npb24iLCJjcmVhdGVDb25uZWN0aW9uIiwicGVlck1heENvbmN1cnJlbnRTdHJlYW1zIiwiZXJyb3IiLCJlbWl0RHJhaW4iLCJzeW5jIiwiX3Jlc3VtZSIsInJlZiIsImlkZW1wb3RlbnQiLCJpc1N0cmVhbSIsImlzQXN5bmNJdGVyYWJsZSIsIndyaXRlIiwic2hvdWxkU2VuZENvbnRlbnRMZW5ndGgiLCJ3cml0ZUgyIiwicGF0aCIsImJsb2NraW5nIiwicmVzZXQiLCJleHBlY3RzUGF5bG9hZCIsIm9uQ29ubmVjdCIsImNvbXBsZXRlZCIsImhlYWRlciIsIm9uUmVxdWVzdFNlbnQiLCJpc0J1ZmZlciIsImJ5dGVMZW5ndGgiLCJjb3JrIiwidW5jb3JrIiwib25Cb2R5U2VudCIsImlzQmxvYkxpa2UiLCJzdHJlYW0iLCJ3cml0ZUl0ZXJhYmxlIiwid3JpdGVCbG9iIiwid3JpdGVTdHJlYW0iLCJleHBlY3RDb250aW51ZSIsInNpZ25hbCIsInJlcUhlYWRlcnMiLCJ0cmltIiwiRXJyb3IiLCJoMlN0YXRlIiwiZW5kU3RyZWFtIiwicGVuZGluZyIsInNob3VsZEVuZFN0cmVhbSIsIndyaXRlQm9keUgyIiwicmVhbEhlYWRlcnMiLCJjbG9zZWQiLCJzdHJlYW1zIiwiZW5kIiwiaDJzdHJlYW0iLCJwaXBlIiwib25QaXBlRGF0YSIsImZpbmlzaGVkIiwid3JpdGVyIiwiQXN5bmNXcml0ZXIiLCJvbkRyYWluIiwib25BYm9ydCIsIm9uRmluaXNoZWQiLCJvZmYiLCJlciIsInNpemUiLCJhcnJheUJ1ZmZlciIsIndhaXRGb3JEcmFpbiIsInJlcyIsImJ5dGVzV3JpdHRlbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/compat/dispatcher-weakref.js":
/*!************************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/compat/dispatcher-weakref.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/* istanbul ignore file: only for Node 12 */ const { kConnected, kSize } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\");\nclass CompatWeakRef {\n    constructor(value){\n        this.value = value;\n    }\n    deref() {\n        return this.value[kConnected] === 0 && this.value[kSize] === 0 ? undefined : this.value;\n    }\n}\nclass CompatFinalizer {\n    constructor(finalizer){\n        this.finalizer = finalizer;\n    }\n    register(dispatcher, key) {\n        if (dispatcher.on) {\n            dispatcher.on(\"disconnect\", ()=>{\n                if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {\n                    this.finalizer(key);\n                }\n            });\n        }\n    }\n}\nmodule.exports = function() {\n    // FIXME: remove workaround when the Node bug is fixed\n    // https://github.com/nodejs/node/issues/49344#issuecomment-1741776308\n    if (process.env.NODE_V8_COVERAGE) {\n        return {\n            WeakRef: CompatWeakRef,\n            FinalizationRegistry: CompatFinalizer\n        };\n    }\n    return {\n        WeakRef: global.WeakRef || CompatWeakRef,\n        FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29tcGF0L2Rpc3BhdGNoZXItd2Vha3JlZi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLDBDQUEwQyxHQUUxQyxNQUFNLEVBQUVBLFVBQVUsRUFBRUMsS0FBSyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBRXRDLE1BQU1DO0lBQ0pDLFlBQWFDLEtBQUssQ0FBRTtRQUNsQixJQUFJLENBQUNBLEtBQUssR0FBR0E7SUFDZjtJQUVBQyxRQUFTO1FBQ1AsT0FBTyxJQUFJLENBQUNELEtBQUssQ0FBQ0wsV0FBVyxLQUFLLEtBQUssSUFBSSxDQUFDSyxLQUFLLENBQUNKLE1BQU0sS0FBSyxJQUN6RE0sWUFDQSxJQUFJLENBQUNGLEtBQUs7SUFDaEI7QUFDRjtBQUVBLE1BQU1HO0lBQ0pKLFlBQWFLLFNBQVMsQ0FBRTtRQUN0QixJQUFJLENBQUNBLFNBQVMsR0FBR0E7SUFDbkI7SUFFQUMsU0FBVUMsVUFBVSxFQUFFQyxHQUFHLEVBQUU7UUFDekIsSUFBSUQsV0FBV0UsRUFBRSxFQUFFO1lBQ2pCRixXQUFXRSxFQUFFLENBQUMsY0FBYztnQkFDMUIsSUFBSUYsVUFBVSxDQUFDWCxXQUFXLEtBQUssS0FBS1csVUFBVSxDQUFDVixNQUFNLEtBQUssR0FBRztvQkFDM0QsSUFBSSxDQUFDUSxTQUFTLENBQUNHO2dCQUNqQjtZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBRUFFLE9BQU9DLE9BQU8sR0FBRztJQUNmLHNEQUFzRDtJQUN0RCxzRUFBc0U7SUFDdEUsSUFBSUMsUUFBUUMsR0FBRyxDQUFDQyxnQkFBZ0IsRUFBRTtRQUNoQyxPQUFPO1lBQ0xDLFNBQVNoQjtZQUNUaUIsc0JBQXNCWjtRQUN4QjtJQUNGO0lBQ0EsT0FBTztRQUNMVyxTQUFTRSxPQUFPRixPQUFPLElBQUloQjtRQUMzQmlCLHNCQUFzQkMsT0FBT0Qsb0JBQW9CLElBQUlaO0lBQ3ZEO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb21wYXQvZGlzcGF0Y2hlci13ZWFrcmVmLmpzPzk1MTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBmaWxlOiBvbmx5IGZvciBOb2RlIDEyICovXG5cbmNvbnN0IHsga0Nvbm5lY3RlZCwga1NpemUgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5cbmNsYXNzIENvbXBhdFdlYWtSZWYge1xuICBjb25zdHJ1Y3RvciAodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgfVxuXG4gIGRlcmVmICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVtrQ29ubmVjdGVkXSA9PT0gMCAmJiB0aGlzLnZhbHVlW2tTaXplXSA9PT0gMFxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogdGhpcy52YWx1ZVxuICB9XG59XG5cbmNsYXNzIENvbXBhdEZpbmFsaXplciB7XG4gIGNvbnN0cnVjdG9yIChmaW5hbGl6ZXIpIHtcbiAgICB0aGlzLmZpbmFsaXplciA9IGZpbmFsaXplclxuICB9XG5cbiAgcmVnaXN0ZXIgKGRpc3BhdGNoZXIsIGtleSkge1xuICAgIGlmIChkaXNwYXRjaGVyLm9uKSB7XG4gICAgICBkaXNwYXRjaGVyLm9uKCdkaXNjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBpZiAoZGlzcGF0Y2hlcltrQ29ubmVjdGVkXSA9PT0gMCAmJiBkaXNwYXRjaGVyW2tTaXplXSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuZmluYWxpemVyKGtleSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIEZJWE1FOiByZW1vdmUgd29ya2Fyb3VuZCB3aGVuIHRoZSBOb2RlIGJ1ZyBpcyBmaXhlZFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzQ5MzQ0I2lzc3VlY29tbWVudC0xNzQxNzc2MzA4XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX1Y4X0NPVkVSQUdFKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFdlYWtSZWY6IENvbXBhdFdlYWtSZWYsXG4gICAgICBGaW5hbGl6YXRpb25SZWdpc3RyeTogQ29tcGF0RmluYWxpemVyXG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgV2Vha1JlZjogZ2xvYmFsLldlYWtSZWYgfHwgQ29tcGF0V2Vha1JlZixcbiAgICBGaW5hbGl6YXRpb25SZWdpc3RyeTogZ2xvYmFsLkZpbmFsaXphdGlvblJlZ2lzdHJ5IHx8IENvbXBhdEZpbmFsaXplclxuICB9XG59XG4iXSwibmFtZXMiOlsia0Nvbm5lY3RlZCIsImtTaXplIiwicmVxdWlyZSIsIkNvbXBhdFdlYWtSZWYiLCJjb25zdHJ1Y3RvciIsInZhbHVlIiwiZGVyZWYiLCJ1bmRlZmluZWQiLCJDb21wYXRGaW5hbGl6ZXIiLCJmaW5hbGl6ZXIiLCJyZWdpc3RlciIsImRpc3BhdGNoZXIiLCJrZXkiLCJvbiIsIm1vZHVsZSIsImV4cG9ydHMiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9WOF9DT1ZFUkFHRSIsIldlYWtSZWYiLCJGaW5hbGl6YXRpb25SZWdpc3RyeSIsImdsb2JhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/compat/dispatcher-weakref.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/cookies/constants.js":
/*!****************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/cookies/constants.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\n// https://wicg.github.io/cookie-store/#cookie-maximum-attribute-value-size\nconst maxAttributeValueSize = 1024;\n// https://wicg.github.io/cookie-store/#cookie-maximum-name-value-pair-size\nconst maxNameValuePairSize = 4096;\nmodule.exports = {\n    maxAttributeValueSize,\n    maxNameValuePairSize\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29va2llcy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSwyRUFBMkU7QUFDM0UsTUFBTUEsd0JBQXdCO0FBRTlCLDJFQUEyRTtBQUMzRSxNQUFNQyx1QkFBdUI7QUFFN0JDLE9BQU9DLE9BQU8sR0FBRztJQUNmSDtJQUNBQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1maWdodGVyLWFjYWRlbXkvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29va2llcy9jb25zdGFudHMuanM/NWEwMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9jb29raWUtc3RvcmUvI2Nvb2tpZS1tYXhpbXVtLWF0dHJpYnV0ZS12YWx1ZS1zaXplXG5jb25zdCBtYXhBdHRyaWJ1dGVWYWx1ZVNpemUgPSAxMDI0XG5cbi8vIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vY29va2llLXN0b3JlLyNjb29raWUtbWF4aW11bS1uYW1lLXZhbHVlLXBhaXItc2l6ZVxuY29uc3QgbWF4TmFtZVZhbHVlUGFpclNpemUgPSA0MDk2XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtYXhBdHRyaWJ1dGVWYWx1ZVNpemUsXG4gIG1heE5hbWVWYWx1ZVBhaXJTaXplXG59XG4iXSwibmFtZXMiOlsibWF4QXR0cmlidXRlVmFsdWVTaXplIiwibWF4TmFtZVZhbHVlUGFpclNpemUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/cookies/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/cookies/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/cookies/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { parseSetCookie } = __webpack_require__(/*! ./parse */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/cookies/parse.js\");\nconst { stringify, getHeadersList } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/cookies/util.js\");\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/webidl.js\");\nconst { Headers } = __webpack_require__(/*! ../fetch/headers */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/headers.js\");\n/**\n * @typedef {Object} Cookie\n * @property {string} name\n * @property {string} value\n * @property {Date|number|undefined} expires\n * @property {number|undefined} maxAge\n * @property {string|undefined} domain\n * @property {string|undefined} path\n * @property {boolean|undefined} secure\n * @property {boolean|undefined} httpOnly\n * @property {'Strict'|'Lax'|'None'} sameSite\n * @property {string[]} unparsed\n */ /**\n * @param {Headers} headers\n * @returns {Record<string, string>}\n */ function getCookies(headers) {\n    webidl.argumentLengthCheck(arguments, 1, {\n        header: \"getCookies\"\n    });\n    webidl.brandCheck(headers, Headers, {\n        strict: false\n    });\n    const cookie = headers.get(\"cookie\");\n    const out = {};\n    if (!cookie) {\n        return out;\n    }\n    for (const piece of cookie.split(\";\")){\n        const [name, ...value] = piece.split(\"=\");\n        out[name.trim()] = value.join(\"=\");\n    }\n    return out;\n}\n/**\n * @param {Headers} headers\n * @param {string} name\n * @param {{ path?: string, domain?: string }|undefined} attributes\n * @returns {void}\n */ function deleteCookie(headers, name, attributes) {\n    webidl.argumentLengthCheck(arguments, 2, {\n        header: \"deleteCookie\"\n    });\n    webidl.brandCheck(headers, Headers, {\n        strict: false\n    });\n    name = webidl.converters.DOMString(name);\n    attributes = webidl.converters.DeleteCookieAttributes(attributes);\n    // Matches behavior of\n    // https://github.com/denoland/deno_std/blob/63827b16330b82489a04614027c33b7904e08be5/http/cookie.ts#L278\n    setCookie(headers, {\n        name,\n        value: \"\",\n        expires: new Date(0),\n        ...attributes\n    });\n}\n/**\n * @param {Headers} headers\n * @returns {Cookie[]}\n */ function getSetCookies(headers) {\n    webidl.argumentLengthCheck(arguments, 1, {\n        header: \"getSetCookies\"\n    });\n    webidl.brandCheck(headers, Headers, {\n        strict: false\n    });\n    const cookies = getHeadersList(headers).cookies;\n    if (!cookies) {\n        return [];\n    }\n    // In older versions of undici, cookies is a list of name:value.\n    return cookies.map((pair)=>parseSetCookie(Array.isArray(pair) ? pair[1] : pair));\n}\n/**\n * @param {Headers} headers\n * @param {Cookie} cookie\n * @returns {void}\n */ function setCookie(headers, cookie) {\n    webidl.argumentLengthCheck(arguments, 2, {\n        header: \"setCookie\"\n    });\n    webidl.brandCheck(headers, Headers, {\n        strict: false\n    });\n    cookie = webidl.converters.Cookie(cookie);\n    const str = stringify(cookie);\n    if (str) {\n        headers.append(\"Set-Cookie\", stringify(cookie));\n    }\n}\nwebidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([\n    {\n        converter: webidl.nullableConverter(webidl.converters.DOMString),\n        key: \"path\",\n        defaultValue: null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.DOMString),\n        key: \"domain\",\n        defaultValue: null\n    }\n]);\nwebidl.converters.Cookie = webidl.dictionaryConverter([\n    {\n        converter: webidl.converters.DOMString,\n        key: \"name\"\n    },\n    {\n        converter: webidl.converters.DOMString,\n        key: \"value\"\n    },\n    {\n        converter: webidl.nullableConverter((value)=>{\n            if (typeof value === \"number\") {\n                return webidl.converters[\"unsigned long long\"](value);\n            }\n            return new Date(value);\n        }),\n        key: \"expires\",\n        defaultValue: null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters[\"long long\"]),\n        key: \"maxAge\",\n        defaultValue: null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.DOMString),\n        key: \"domain\",\n        defaultValue: null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.DOMString),\n        key: \"path\",\n        defaultValue: null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.boolean),\n        key: \"secure\",\n        defaultValue: null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.boolean),\n        key: \"httpOnly\",\n        defaultValue: null\n    },\n    {\n        converter: webidl.converters.USVString,\n        key: \"sameSite\",\n        allowedValues: [\n            \"Strict\",\n            \"Lax\",\n            \"None\"\n        ]\n    },\n    {\n        converter: webidl.sequenceConverter(webidl.converters.DOMString),\n        key: \"unparsed\",\n        defaultValue: []\n    }\n]);\nmodule.exports = {\n    getCookies,\n    deleteCookie,\n    getSetCookies,\n    setCookie\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29va2llcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsY0FBYyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ25DLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxjQUFjLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDOUMsTUFBTSxFQUFFRyxNQUFNLEVBQUUsR0FBR0gsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFSSxPQUFPLEVBQUUsR0FBR0osbUJBQU9BLENBQUM7QUFFNUI7Ozs7Ozs7Ozs7OztDQVlDLEdBRUQ7OztDQUdDLEdBQ0QsU0FBU0ssV0FBWUMsT0FBTztJQUMxQkgsT0FBT0ksbUJBQW1CLENBQUNDLFdBQVcsR0FBRztRQUFFQyxRQUFRO0lBQWE7SUFFaEVOLE9BQU9PLFVBQVUsQ0FBQ0osU0FBU0YsU0FBUztRQUFFTyxRQUFRO0lBQU07SUFFcEQsTUFBTUMsU0FBU04sUUFBUU8sR0FBRyxDQUFDO0lBQzNCLE1BQU1DLE1BQU0sQ0FBQztJQUViLElBQUksQ0FBQ0YsUUFBUTtRQUNYLE9BQU9FO0lBQ1Q7SUFFQSxLQUFLLE1BQU1DLFNBQVNILE9BQU9JLEtBQUssQ0FBQyxLQUFNO1FBQ3JDLE1BQU0sQ0FBQ0MsTUFBTSxHQUFHQyxNQUFNLEdBQUdILE1BQU1DLEtBQUssQ0FBQztRQUVyQ0YsR0FBRyxDQUFDRyxLQUFLRSxJQUFJLEdBQUcsR0FBR0QsTUFBTUUsSUFBSSxDQUFDO0lBQ2hDO0lBRUEsT0FBT047QUFDVDtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU08sYUFBY2YsT0FBTyxFQUFFVyxJQUFJLEVBQUVLLFVBQVU7SUFDOUNuQixPQUFPSSxtQkFBbUIsQ0FBQ0MsV0FBVyxHQUFHO1FBQUVDLFFBQVE7SUFBZTtJQUVsRU4sT0FBT08sVUFBVSxDQUFDSixTQUFTRixTQUFTO1FBQUVPLFFBQVE7SUFBTTtJQUVwRE0sT0FB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LENBQUNyQyxPQUFPb0IsVUFBVSxDQUFDb0IsT0FBTztRQUM3REYsS0FBSztRQUNMQyxjQUFjO0lBQ2hCO0lBQ0E7UUFDRUgsV0FBV3BDLE9BQU9vQixVQUFVLENBQUNxQixTQUFTO1FBQ3RDSCxLQUFLO1FBQ0xJLGVBQWU7WUFBQztZQUFVO1lBQU87U0FBTztJQUMxQztJQUNBO1FBQ0VOLFdBQVdwQyxPQUFPMkMsaUJBQWlCLENBQUMzQyxPQUFPb0IsVUFBVSxDQUFDQyxTQUFTO1FBQy9EaUIsS0FBSztRQUNMQyxjQUFjLEVBQUU7SUFDbEI7Q0FDRDtBQUVESyxPQUFPQyxPQUFPLEdBQUc7SUFDZjNDO0lBQ0FnQjtJQUNBUTtJQUNBSDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1maWdodGVyLWFjYWRlbXkvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29va2llcy9pbmRleC5qcz80YjM4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHBhcnNlU2V0Q29va2llIH0gPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHsgc3RyaW5naWZ5LCBnZXRIZWFkZXJzTGlzdCB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi9mZXRjaC93ZWJpZGwnKVxuY29uc3QgeyBIZWFkZXJzIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9oZWFkZXJzJylcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb29raWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdmFsdWVcbiAqIEBwcm9wZXJ0eSB7RGF0ZXxudW1iZXJ8dW5kZWZpbmVkfSBleHBpcmVzXG4gKiBAcHJvcGVydHkge251bWJlcnx1bmRlZmluZWR9IG1heEFnZVxuICogQHByb3BlcnR5IHtzdHJpbmd8dW5kZWZpbmVkfSBkb21haW5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfHVuZGVmaW5lZH0gcGF0aFxuICogQHByb3BlcnR5IHtib29sZWFufHVuZGVmaW5lZH0gc2VjdXJlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW58dW5kZWZpbmVkfSBodHRwT25seVxuICogQHByb3BlcnR5IHsnU3RyaWN0J3wnTGF4J3wnTm9uZSd9IHNhbWVTaXRlXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB1bnBhcnNlZFxuICovXG5cbi8qKlxuICogQHBhcmFtIHtIZWFkZXJzfSBoZWFkZXJzXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29va2llcyAoaGVhZGVycykge1xuICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnZ2V0Q29va2llcycgfSlcblxuICB3ZWJpZGwuYnJhbmRDaGVjayhoZWFkZXJzLCBIZWFkZXJzLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICBjb25zdCBjb29raWUgPSBoZWFkZXJzLmdldCgnY29va2llJylcbiAgY29uc3Qgb3V0ID0ge31cblxuICBpZiAoIWNvb2tpZSkge1xuICAgIHJldHVybiBvdXRcbiAgfVxuXG4gIGZvciAoY29uc3QgcGllY2Ugb2YgY29va2llLnNwbGl0KCc7JykpIHtcbiAgICBjb25zdCBbbmFtZSwgLi4udmFsdWVdID0gcGllY2Uuc3BsaXQoJz0nKVxuXG4gICAgb3V0W25hbWUudHJpbSgpXSA9IHZhbHVlLmpvaW4oJz0nKVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIEBwYXJhbSB7SGVhZGVyc30gaGVhZGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7eyBwYXRoPzogc3RyaW5nLCBkb21haW4/OiBzdHJpbmcgfXx1bmRlZmluZWR9IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBkZWxldGVDb29raWUgKGhlYWRlcnMsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCB7IGhlYWRlcjogJ2RlbGV0ZUNvb2tpZScgfSlcblxuICB3ZWJpZGwuYnJhbmRDaGVjayhoZWFkZXJzLCBIZWFkZXJzLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKG5hbWUpXG4gIGF0dHJpYnV0ZXMgPSB3ZWJpZGwuY29udmVydGVycy5EZWxldGVDb29raWVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpXG5cbiAgLy8gTWF0Y2hlcyBiZWhhdmlvciBvZlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZGVub2xhbmQvZGVub19zdGQvYmxvYi82MzgyN2IxNjMzMGI4MjQ4OWEwNDYxNDAyN2MzM2I3OTA0ZTA4YmU1L2h0dHAvY29va2llLnRzI0wyNzhcbiAgc2V0Q29va2llKGhlYWRlcnMsIHtcbiAgICBuYW1lLFxuICAgIHZhbHVlOiAnJyxcbiAgICBleHBpcmVzOiBuZXcgRGF0ZSgwKSxcbiAgICAuLi5hdHRyaWJ1dGVzXG4gIH0pXG59XG5cbi8qKlxuICogQHBhcmFtIHtIZWFkZXJzfSBoZWFkZXJzXG4gKiBAcmV0dXJucyB7Q29va2llW119XG4gKi9cbmZ1bmN0aW9uIGdldFNldENvb2tpZXMgKGhlYWRlcnMpIHtcbiAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ2dldFNldENvb2tpZXMnIH0pXG5cbiAgd2ViaWRsLmJyYW5kQ2hlY2soaGVhZGVycywgSGVhZGVycywgeyBzdHJpY3Q6IGZhbHNlIH0pXG5cbiAgY29uc3QgY29va2llcyA9IGdldEhlYWRlcnNMaXN0KGhlYWRlcnMpLmNvb2tpZXNcblxuICBpZiAoIWNvb2tpZXMpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIC8vIEluIG9sZGVyIHZlcnNpb25zIG9mIHVuZGljaSwgY29va2llcyBpcyBhIGxpc3Qgb2YgbmFtZTp2YWx1ZS5cbiAgcmV0dXJuIGNvb2tpZXMubWFwKChwYWlyKSA9PiBwYXJzZVNldENvb2tpZShBcnJheS5pc0FycmF5KHBhaXIpID8gcGFpclsxXSA6IHBhaXIpKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SGVhZGVyc30gaGVhZGVyc1xuICogQHBhcmFtIHtDb29raWV9IGNvb2tpZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHNldENvb2tpZSAoaGVhZGVycywgY29va2llKSB7XG4gIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMiwgeyBoZWFkZXI6ICdzZXRDb29raWUnIH0pXG5cbiAgd2ViaWRsLmJyYW5kQ2hlY2soaGVhZGVycywgSGVhZGVycywgeyBzdHJpY3Q6IGZhbHNlIH0pXG5cbiAgY29va2llID0gd2ViaWRsLmNvbnZlcnRlcnMuQ29va2llKGNvb2tpZSlcblxuICBjb25zdCBzdHIgPSBzdHJpbmdpZnkoY29va2llKVxuXG4gIGlmIChzdHIpIHtcbiAgICBoZWFkZXJzLmFwcGVuZCgnU2V0LUNvb2tpZScsIHN0cmluZ2lmeShjb29raWUpKVxuICB9XG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLkRlbGV0ZUNvb2tpZUF0dHJpYnV0ZXMgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcpLFxuICAgIGtleTogJ3BhdGgnLFxuICAgIGRlZmF1bHRWYWx1ZTogbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKSxcbiAgICBrZXk6ICdkb21haW4nLFxuICAgIGRlZmF1bHRWYWx1ZTogbnVsbFxuICB9XG5dKVxuXG53ZWJpZGwuY29udmVydGVycy5Db29raWUgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICBrZXk6ICduYW1lJ1xuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAga2V5OiAndmFsdWUnXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcigodmFsdWUpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyBsb25nJ10odmFsdWUpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSlcbiAgICB9KSxcbiAgICBrZXk6ICdleHBpcmVzJyxcbiAgICBkZWZhdWx0VmFsdWU6IG51bGxcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzWydsb25nIGxvbmcnXSksXG4gICAga2V5OiAnbWF4QWdlJyxcbiAgICBkZWZhdWx0VmFsdWU6IG51bGxcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyksXG4gICAga2V5OiAnZG9tYWluJyxcbiAgICBkZWZhdWx0VmFsdWU6IG51bGxcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyksXG4gICAga2V5OiAncGF0aCcsXG4gICAgZGVmYXVsdFZhbHVlOiBudWxsXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5ib29sZWFuKSxcbiAgICBrZXk6ICdzZWN1cmUnLFxuICAgIGRlZmF1bHRWYWx1ZTogbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbiksXG4gICAga2V5OiAnaHR0cE9ubHknLFxuICAgIGRlZmF1bHRWYWx1ZTogbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcsXG4gICAga2V5OiAnc2FtZVNpdGUnLFxuICAgIGFsbG93ZWRWYWx1ZXM6IFsnU3RyaWN0JywgJ0xheCcsICdOb25lJ11cbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLnNlcXVlbmNlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyksXG4gICAga2V5OiAndW5wYXJzZWQnLFxuICAgIGRlZmF1bHRWYWx1ZTogW11cbiAgfVxuXSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvb2tpZXMsXG4gIGRlbGV0ZUNvb2tpZSxcbiAgZ2V0U2V0Q29va2llcyxcbiAgc2V0Q29va2llXG59XG4iXSwibmFtZXMiOlsicGFyc2VTZXRDb29raWUiLCJyZXF1aXJlIiwic3RyaW5naWZ5IiwiZ2V0SGVhZGVyc0xpc3QiLCJ3ZWJpZGwiLCJIZWFkZXJzIiwiZ2V0Q29va2llcyIsImhlYWRlcnMiLCJhcmd1bWVudExlbmd0aENoZWNrIiwiYXJndW1lbnRzIiwiaGVhZGVyIiwiYnJhbmRDaGVjayIsInN0cmljdCIsImNvb2tpZSIsImdldCIsIm91dCIsInBpZWNlIiwic3BsaXQiLCJuYW1lIiwidmFsdWUiLCJ0cmltIiwiam9pbiIsImRlbGV0ZUNvb2tpZSIsImF0dHJpYnV0ZXMiLCJjb252ZXJ0ZXJzIiwiRE9NU3RyaW5nIiwiRGVsZXRlQ29va2llQXR0cmlidXRlcyIsInNldENvb2tpZSIsImV4cGlyZXMiLCJEYXRlIiwiZ2V0U2V0Q29va2llcyIsImNvb2tpZXMiLCJtYXAiLCJwYWlyIiwiQXJyYXkiLCJpc0FycmF5IiwiQ29va2llIiwic3RyIiwiYXBwZW5kIiwiZGljdGlvbmFyeUNvbnZlcnRlciIsImNvbnZlcnRlciIsIm51bGxhYmxlQ29udmVydGVyIiwia2V5IiwiZGVmYXVsdFZhbHVlIiwiYm9vbGVhbiIsIlVTVlN0cmluZyIsImFsbG93ZWRWYWx1ZXMiLCJzZXF1ZW5jZUNvbnZlcnRlciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/cookies/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/cookies/parse.js":
/*!************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/cookies/parse.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { maxNameValuePairSize, maxAttributeValueSize } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/cookies/constants.js\");\nconst { isCTLExcludingHtab } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/cookies/util.js\");\nconst { collectASequenceOfCodePointsFast } = __webpack_require__(/*! ../fetch/dataURL */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/dataURL.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\n/**\n * @description Parses the field-value attributes of a set-cookie header string.\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} header\n * @returns if the header is invalid, null will be returned\n */ function parseSetCookie(header) {\n    // 1. If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F\n    //    character (CTL characters excluding HTAB): Abort these steps and\n    //    ignore the set-cookie-string entirely.\n    if (isCTLExcludingHtab(header)) {\n        return null;\n    }\n    let nameValuePair = \"\";\n    let unparsedAttributes = \"\";\n    let name = \"\";\n    let value = \"\";\n    // 2. If the set-cookie-string contains a %x3B (\";\") character:\n    if (header.includes(\";\")) {\n        // 1. The name-value-pair string consists of the characters up to,\n        //    but not including, the first %x3B (\";\"), and the unparsed-\n        //    attributes consist of the remainder of the set-cookie-string\n        //    (including the %x3B (\";\") in question).\n        const position = {\n            position: 0\n        };\n        nameValuePair = collectASequenceOfCodePointsFast(\";\", header, position);\n        unparsedAttributes = header.slice(position.position);\n    } else {\n        // Otherwise:\n        // 1. The name-value-pair string consists of all the characters\n        //    contained in the set-cookie-string, and the unparsed-\n        //    attributes is the empty string.\n        nameValuePair = header;\n    }\n    // 3. If the name-value-pair string lacks a %x3D (\"=\") character, then\n    //    the name string is empty, and the value string is the value of\n    //    name-value-pair.\n    if (!nameValuePair.includes(\"=\")) {\n        value = nameValuePair;\n    } else {\n        //    Otherwise, the name string consists of the characters up to, but\n        //    not including, the first %x3D (\"=\") character, and the (possibly\n        //    empty) value string consists of the characters after the first\n        //    %x3D (\"=\") character.\n        const position = {\n            position: 0\n        };\n        name = collectASequenceOfCodePointsFast(\"=\", nameValuePair, position);\n        value = nameValuePair.slice(position.position + 1);\n    }\n    // 4. Remove any leading or trailing WSP characters from the name\n    //    string and the value string.\n    name = name.trim();\n    value = value.trim();\n    // 5. If the sum of the lengths of the name string and the value string\n    //    is more than 4096 octets, abort these steps and ignore the set-\n    //    cookie-string entirely.\n    if (name.length + value.length > maxNameValuePairSize) {\n        return null;\n    }\n    // 6. The cookie-name is the name string, and the cookie-value is the\n    //    value string.\n    return {\n        name,\n        value,\n        ...parseUnparsedAttributes(unparsedAttributes)\n    };\n}\n/**\n * Parses the remaining attributes of a set-cookie header\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} unparsedAttributes\n * @param {[Object.<string, unknown>]={}} cookieAttributeList\n */ function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {\n    // 1. If the unparsed-attributes string is empty, skip the rest of\n    //    these steps.\n    if (unparsedAttributes.length === 0) {\n        return cookieAttributeList;\n    }\n    // 2. Discard the first character of the unparsed-attributes (which\n    //    will be a %x3B (\";\") character).\n    assert(unparsedAttributes[0] === \";\");\n    unparsedAttributes = unparsedAttributes.slice(1);\n    let cookieAv = \"\";\n    // 3. If the remaining unparsed-attributes contains a %x3B (\";\")\n    //    character:\n    if (unparsedAttributes.includes(\";\")) {\n        // 1. Consume the characters of the unparsed-attributes up to, but\n        //    not including, the first %x3B (\";\") character.\n        cookieAv = collectASequenceOfCodePointsFast(\";\", unparsedAttributes, {\n            position: 0\n        });\n        unparsedAttributes = unparsedAttributes.slice(cookieAv.length);\n    } else {\n        // Otherwise:\n        // 1. Consume the remainder of the unparsed-attributes.\n        cookieAv = unparsedAttributes;\n        unparsedAttributes = \"\";\n    }\n    // Let the cookie-av string be the characters consumed in this step.\n    let attributeName = \"\";\n    let attributeValue = \"\";\n    // 4. If the cookie-av string contains a %x3D (\"=\") character:\n    if (cookieAv.includes(\"=\")) {\n        // 1. The (possibly empty) attribute-name string consists of the\n        //    characters up to, but not including, the first %x3D (\"=\")\n        //    character, and the (possibly empty) attribute-value string\n        //    consists of the characters after the first %x3D (\"=\")\n        //    character.\n        const position = {\n            position: 0\n        };\n        attributeName = collectASequenceOfCodePointsFast(\"=\", cookieAv, position);\n        attributeValue = cookieAv.slice(position.position + 1);\n    } else {\n        // Otherwise:\n        // 1. The attribute-name string consists of the entire cookie-av\n        //    string, and the attribute-value string is empty.\n        attributeName = cookieAv;\n    }\n    // 5. Remove any leading or trailing WSP characters from the attribute-\n    //    name string and the attribute-value string.\n    attributeName = attributeName.trim();\n    attributeValue = attributeValue.trim();\n    // 6. If the attribute-value is longer than 1024 octets, ignore the\n    //    cookie-av string and return to Step 1 of this algorithm.\n    if (attributeValue.length > maxAttributeValueSize) {\n        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n    }\n    // 7. Process the attribute-name and attribute-value according to the\n    //    requirements in the following subsections.  (Notice that\n    //    attributes with unrecognized attribute-names are ignored.)\n    const attributeNameLowercase = attributeName.toLowerCase();\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.1\n    // If the attribute-name case-insensitively matches the string\n    // \"Expires\", the user agent MUST process the cookie-av as follows.\n    if (attributeNameLowercase === \"expires\") {\n        // 1. Let the expiry-time be the result of parsing the attribute-value\n        //    as cookie-date (see Section 5.1.1).\n        const expiryTime = new Date(attributeValue);\n        // 2. If the attribute-value failed to parse as a cookie date, ignore\n        //    the cookie-av.\n        cookieAttributeList.expires = expiryTime;\n    } else if (attributeNameLowercase === \"max-age\") {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.2\n        // If the attribute-name case-insensitively matches the string \"Max-\n        // Age\", the user agent MUST process the cookie-av as follows.\n        // 1. If the first character of the attribute-value is not a DIGIT or a\n        //    \"-\" character, ignore the cookie-av.\n        const charCode = attributeValue.charCodeAt(0);\n        if ((charCode < 48 || charCode > 57) && attributeValue[0] !== \"-\") {\n            return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n        }\n        // 2. If the remainder of attribute-value contains a non-DIGIT\n        //    character, ignore the cookie-av.\n        if (!/^\\d+$/.test(attributeValue)) {\n            return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n        }\n        // 3. Let delta-seconds be the attribute-value converted to an integer.\n        const deltaSeconds = Number(attributeValue);\n        // 4. Let cookie-age-limit be the maximum age of the cookie (which\n        //    SHOULD be 400 days or less, see Section 4.1.2.2).\n        // 5. Set delta-seconds to the smaller of its present value and cookie-\n        //    age-limit.\n        // deltaSeconds = Math.min(deltaSeconds * 1000, maxExpiresMs)\n        // 6. If delta-seconds is less than or equal to zero (0), let expiry-\n        //    time be the earliest representable date and time.  Otherwise, let\n        //    the expiry-time be the current date and time plus delta-seconds\n        //    seconds.\n        // const expiryTime = deltaSeconds <= 0 ? Date.now() : Date.now() + deltaSeconds\n        // 7. Append an attribute to the cookie-attribute-list with an\n        //    attribute-name of Max-Age and an attribute-value of expiry-time.\n        cookieAttributeList.maxAge = deltaSeconds;\n    } else if (attributeNameLowercase === \"domain\") {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.3\n        // If the attribute-name case-insensitively matches the string \"Domain\",\n        // the user agent MUST process the cookie-av as follows.\n        // 1. Let cookie-domain be the attribute-value.\n        let cookieDomain = attributeValue;\n        // 2. If cookie-domain starts with %x2E (\".\"), let cookie-domain be\n        //    cookie-domain without its leading %x2E (\".\").\n        if (cookieDomain[0] === \".\") {\n            cookieDomain = cookieDomain.slice(1);\n        }\n        // 3. Convert the cookie-domain to lower case.\n        cookieDomain = cookieDomain.toLowerCase();\n        // 4. Append an attribute to the cookie-attribute-list with an\n        //    attribute-name of Domain and an attribute-value of cookie-domain.\n        cookieAttributeList.domain = cookieDomain;\n    } else if (attributeNameLowercase === \"path\") {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.4\n        // If the attribute-name case-insensitively matches the string \"Path\",\n        // the user agent MUST process the cookie-av as follows.\n        // 1. If the attribute-value is empty or if the first character of the\n        //    attribute-value is not %x2F (\"/\"):\n        let cookiePath = \"\";\n        if (attributeValue.length === 0 || attributeValue[0] !== \"/\") {\n            // 1. Let cookie-path be the default-path.\n            cookiePath = \"/\";\n        } else {\n            // Otherwise:\n            // 1. Let cookie-path be the attribute-value.\n            cookiePath = attributeValue;\n        }\n        // 2. Append an attribute to the cookie-attribute-list with an\n        //    attribute-name of Path and an attribute-value of cookie-path.\n        cookieAttributeList.path = cookiePath;\n    } else if (attributeNameLowercase === \"secure\") {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.5\n        // If the attribute-name case-insensitively matches the string \"Secure\",\n        // the user agent MUST append an attribute to the cookie-attribute-list\n        // with an attribute-name of Secure and an empty attribute-value.\n        cookieAttributeList.secure = true;\n    } else if (attributeNameLowercase === \"httponly\") {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.6\n        // If the attribute-name case-insensitively matches the string\n        // \"HttpOnly\", the user agent MUST append an attribute to the cookie-\n        // attribute-list with an attribute-name of HttpOnly and an empty\n        // attribute-value.\n        cookieAttributeList.httpOnly = true;\n    } else if (attributeNameLowercase === \"samesite\") {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.7\n        // If the attribute-name case-insensitively matches the string\n        // \"SameSite\", the user agent MUST process the cookie-av as follows:\n        // 1. Let enforcement be \"Default\".\n        let enforcement = \"Default\";\n        const attributeValueLowercase = attributeValue.toLowerCase();\n        // 2. If cookie-av's attribute-value is a case-insensitive match for\n        //    \"None\", set enforcement to \"None\".\n        if (attributeValueLowercase.includes(\"none\")) {\n            enforcement = \"None\";\n        }\n        // 3. If cookie-av's attribute-value is a case-insensitive match for\n        //    \"Strict\", set enforcement to \"Strict\".\n        if (attributeValueLowercase.includes(\"strict\")) {\n            enforcement = \"Strict\";\n        }\n        // 4. If cookie-av's attribute-value is a case-insensitive match for\n        //    \"Lax\", set enforcement to \"Lax\".\n        if (attributeValueLowercase.includes(\"lax\")) {\n            enforcement = \"Lax\";\n        }\n        // 5. Append an attribute to the cookie-attribute-list with an\n        //    attribute-name of \"SameSite\" and an attribute-value of\n        //    enforcement.\n        cookieAttributeList.sameSite = enforcement;\n    } else {\n        cookieAttributeList.unparsed ??= [];\n        cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);\n    }\n    // 8. Return to Step 1 of this algorithm.\n    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n}\nmodule.exports = {\n    parseSetCookie,\n    parseUnparsedAttributes\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29va2llcy9wYXJzZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsb0JBQW9CLEVBQUVDLHFCQUFxQixFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ2hFLE1BQU0sRUFBRUMsa0JBQWtCLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFDdkMsTUFBTSxFQUFFRSxnQ0FBZ0MsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUNyRCxNQUFNRyxTQUFTSCxtQkFBT0EsQ0FBQztBQUV2Qjs7Ozs7Q0FLQyxHQUNELFNBQVNJLGVBQWdCQyxNQUFNO0lBQzdCLGtFQUFrRTtJQUNsRSxzRUFBc0U7SUFDdEUsNENBQTRDO0lBQzVDLElBQUlKLG1CQUFtQkksU0FBUztRQUM5QixPQUFPO0lBQ1Q7SUFFQSxJQUFJQyxnQkFBZ0I7SUFDcEIsSUFBSUMscUJBQXFCO0lBQ3pCLElBQUlDLE9BQU87SUFDWCxJQUFJQyxRQUFRO0lBRVosK0RBQStEO0lBQy9ELElBQUlKLE9BQU9LLFFBQVEsQ0FBQyxNQUFNO1FBQ3hCLGtFQUFrRTtRQUNsRSxnRUFBZ0U7UUFDaEUsa0VBQWtFO1FBQ2xFLDZDQUE2QztRQUM3QyxNQUFNQyxXQUFXO1lBQUVBLFVBQVU7UUFBRTtRQUUvQkwsZ0JBQWdCSixpQ0FBaUMsS0FBS0csUUFBUU07UUFDOURKLHFCQUFxQkYsT0FBT08sS0FBSyxDQUFDRCxTQUFTQSxRQUFRO0lBQ3JELE9BQU87UUFDTCxhQUFhO1FBRWIsK0RBQStEO1FBQy9ELDJEQUEyRDtRQUMzRCxxQ0FBcUM7UUFDckNMLGdCQUFnQkQ7SUFDbEI7SUFFQSxzRUFBc0U7SUFDdEUsb0VBQW9FO0lBQ3BFLHNCQUFzQjtJQUN0QixJQUFJLENBQUNDLGNBQWNJLFFBQVEsQ0FBQyxNQUFNO1FBQ2hDRCxRQUFRSDtJQUNWLE9BQU87UUFDTCxzRUFBc0U7UUFDdEUsc0VBQXNFO1FBQ3RFLG9F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UixvQkFBb0JTO0FBQ3JEO0FBRUEwQixPQUFPQyxPQUFPLEdBQUc7SUFDZnZDO0lBQ0FXO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb29raWVzL3BhcnNlLmpzP2Y4N2MiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgbWF4TmFtZVZhbHVlUGFpclNpemUsIG1heEF0dHJpYnV0ZVZhbHVlU2l6ZSB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBpc0NUTEV4Y2x1ZGluZ0h0YWIgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0IH0gPSByZXF1aXJlKCcuLi9mZXRjaC9kYXRhVVJMJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFBhcnNlcyB0aGUgZmllbGQtdmFsdWUgYXR0cmlidXRlcyBvZiBhIHNldC1jb29raWUgaGVhZGVyIHN0cmluZy5cbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNFxuICogQHBhcmFtIHtzdHJpbmd9IGhlYWRlclxuICogQHJldHVybnMgaWYgdGhlIGhlYWRlciBpcyBpbnZhbGlkLCBudWxsIHdpbGwgYmUgcmV0dXJuZWRcbiAqL1xuZnVuY3Rpb24gcGFyc2VTZXRDb29raWUgKGhlYWRlcikge1xuICAvLyAxLiBJZiB0aGUgc2V0LWNvb2tpZS1zdHJpbmcgY29udGFpbnMgYSAleDAwLTA4IC8gJXgwQS0xRiAvICV4N0ZcbiAgLy8gICAgY2hhcmFjdGVyIChDVEwgY2hhcmFjdGVycyBleGNsdWRpbmcgSFRBQik6IEFib3J0IHRoZXNlIHN0ZXBzIGFuZFxuICAvLyAgICBpZ25vcmUgdGhlIHNldC1jb29raWUtc3RyaW5nIGVudGlyZWx5LlxuICBpZiAoaXNDVExFeGNsdWRpbmdIdGFiKGhlYWRlcikpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgbGV0IG5hbWVWYWx1ZVBhaXIgPSAnJ1xuICBsZXQgdW5wYXJzZWRBdHRyaWJ1dGVzID0gJydcbiAgbGV0IG5hbWUgPSAnJ1xuICBsZXQgdmFsdWUgPSAnJ1xuXG4gIC8vIDIuIElmIHRoZSBzZXQtY29va2llLXN0cmluZyBjb250YWlucyBhICV4M0IgKFwiO1wiKSBjaGFyYWN0ZXI6XG4gIGlmIChoZWFkZXIuaW5jbHVkZXMoJzsnKSkge1xuICAgIC8vIDEuIFRoZSBuYW1lLXZhbHVlLXBhaXIgc3RyaW5nIGNvbnNpc3RzIG9mIHRoZSBjaGFyYWN0ZXJzIHVwIHRvLFxuICAgIC8vICAgIGJ1dCBub3QgaW5jbHVkaW5nLCB0aGUgZmlyc3QgJXgzQiAoXCI7XCIpLCBhbmQgdGhlIHVucGFyc2VkLVxuICAgIC8vICAgIGF0dHJpYnV0ZXMgY29uc2lzdCBvZiB0aGUgcmVtYWluZGVyIG9mIHRoZSBzZXQtY29va2llLXN0cmluZ1xuICAgIC8vICAgIChpbmNsdWRpbmcgdGhlICV4M0IgKFwiO1wiKSBpbiBxdWVzdGlvbikuXG4gICAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH1cblxuICAgIG5hbWVWYWx1ZVBhaXIgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdCgnOycsIGhlYWRlciwgcG9zaXRpb24pXG4gICAgdW5wYXJzZWRBdHRyaWJ1dGVzID0gaGVhZGVyLnNsaWNlKHBvc2l0aW9uLnBvc2l0aW9uKVxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZTpcblxuICAgIC8vIDEuIFRoZSBuYW1lLXZhbHVlLXBhaXIgc3RyaW5nIGNvbnNpc3RzIG9mIGFsbCB0aGUgY2hhcmFjdGVyc1xuICAgIC8vICAgIGNvbnRhaW5lZCBpbiB0aGUgc2V0LWNvb2tpZS1zdHJpbmcsIGFuZCB0aGUgdW5wYXJzZWQtXG4gICAgLy8gICAgYXR0cmlidXRlcyBpcyB0aGUgZW1wdHkgc3RyaW5nLlxuICAgIG5hbWVWYWx1ZVBhaXIgPSBoZWFkZXJcbiAgfVxuXG4gIC8vIDMuIElmIHRoZSBuYW1lLXZhbHVlLXBhaXIgc3RyaW5nIGxhY2tzIGEgJXgzRCAoXCI9XCIpIGNoYXJhY3RlciwgdGhlblxuICAvLyAgICB0aGUgbmFtZSBzdHJpbmcgaXMgZW1wdHksIGFuZCB0aGUgdmFsdWUgc3RyaW5nIGlzIHRoZSB2YWx1ZSBvZlxuICAvLyAgICBuYW1lLXZhbHVlLXBhaXIuXG4gIGlmICghbmFtZVZhbHVlUGFpci5pbmNsdWRlcygnPScpKSB7XG4gICAgdmFsdWUgPSBuYW1lVmFsdWVQYWlyXG4gIH0gZWxzZSB7XG4gICAgLy8gICAgT3RoZXJ3aXNlLCB0aGUgbmFtZSBzdHJpbmcgY29uc2lzdHMgb2YgdGhlIGNoYXJhY3RlcnMgdXAgdG8sIGJ1dFxuICAgIC8vICAgIG5vdCBpbmNsdWRpbmcsIHRoZSBmaXJzdCAleDNEIChcIj1cIikgY2hhcmFjdGVyLCBhbmQgdGhlIChwb3NzaWJseVxuICAgIC8vICAgIGVtcHR5KSB2YWx1ZSBzdHJpbmcgY29uc2lzdHMgb2YgdGhlIGNoYXJhY3RlcnMgYWZ0ZXIgdGhlIGZpcnN0XG4gICAgLy8gICAgJXgzRCAoXCI9XCIpIGNoYXJhY3Rlci5cbiAgICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfVxuICAgIG5hbWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAgICc9JyxcbiAgICAgIG5hbWVWYWx1ZVBhaXIsXG4gICAgICBwb3NpdGlvblxuICAgIClcbiAgICB2YWx1ZSA9IG5hbWVWYWx1ZVBhaXIuc2xpY2UocG9zaXRpb24ucG9zaXRpb24gKyAxKVxuICB9XG5cbiAgLy8gNC4gUmVtb3ZlIGFueSBsZWFkaW5nIG9yIHRyYWlsaW5nIFdTUCBjaGFyYWN0ZXJzIGZyb20gdGhlIG5hbWVcbiAgLy8gICAgc3RyaW5nIGFuZCB0aGUgdmFsdWUgc3RyaW5nLlxuICBuYW1lID0gbmFtZS50cmltKClcbiAgdmFsdWUgPSB2YWx1ZS50cmltKClcblxuICAvLyA1LiBJZiB0aGUgc3VtIG9mIHRoZSBsZW5ndGhzIG9mIHRoZSBuYW1lIHN0cmluZyBhbmQgdGhlIHZhbHVlIHN0cmluZ1xuICAvLyAgICBpcyBtb3JlIHRoYW4gNDA5NiBvY3RldHMsIGFib3J0IHRoZXNlIHN0ZXBzIGFuZCBpZ25vcmUgdGhlIHNldC1cbiAgLy8gICAgY29va2llLXN0cmluZyBlbnRpcmVseS5cbiAgaWYgKG5hbWUubGVuZ3RoICsgdmFsdWUubGVuZ3RoID4gbWF4TmFtZVZhbHVlUGFpclNpemUpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gNi4gVGhlIGNvb2tpZS1uYW1lIGlzIHRoZSBuYW1lIHN0cmluZywgYW5kIHRoZSBjb29raWUtdmFsdWUgaXMgdGhlXG4gIC8vICAgIHZhbHVlIHN0cmluZy5cbiAgcmV0dXJuIHtcbiAgICBuYW1lLCB2YWx1ZSwgLi4ucGFyc2VVbnBhcnNlZEF0dHJpYnV0ZXModW5wYXJzZWRBdHRyaWJ1dGVzKVxuICB9XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSByZW1haW5pbmcgYXR0cmlidXRlcyBvZiBhIHNldC1jb29raWUgaGVhZGVyXG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjRcbiAqIEBwYXJhbSB7c3RyaW5nfSB1bnBhcnNlZEF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7W09iamVjdC48c3RyaW5nLCB1bmtub3duPl09e319IGNvb2tpZUF0dHJpYnV0ZUxpc3RcbiAqL1xuZnVuY3Rpb24gcGFyc2VVbnBhcnNlZEF0dHJpYnV0ZXMgKHVucGFyc2VkQXR0cmlidXRlcywgY29va2llQXR0cmlidXRlTGlzdCA9IHt9KSB7XG4gIC8vIDEuIElmIHRoZSB1bnBhcnNlZC1hdHRyaWJ1dGVzIHN0cmluZyBpcyBlbXB0eSwgc2tpcCB0aGUgcmVzdCBvZlxuICAvLyAgICB0aGVzZSBzdGVwcy5cbiAgaWYgKHVucGFyc2VkQXR0cmlidXRlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gY29va2llQXR0cmlidXRlTGlzdFxuICB9XG5cbiAgLy8gMi4gRGlzY2FyZCB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSB1bnBhcnNlZC1hdHRyaWJ1dGVzICh3aGljaFxuICAvLyAgICB3aWxsIGJlIGEgJXgzQiAoXCI7XCIpIGNoYXJhY3RlcikuXG4gIGFzc2VydCh1bnBhcnNlZEF0dHJpYnV0ZXNbMF0gPT09ICc7JylcbiAgdW5wYXJzZWRBdHRyaWJ1dGVzID0gdW5wYXJzZWRBdHRyaWJ1dGVzLnNsaWNlKDEpXG5cbiAgbGV0IGNvb2tpZUF2ID0gJydcblxuICAvLyAzLiBJZiB0aGUgcmVtYWluaW5nIHVucGFyc2VkLWF0dHJpYnV0ZXMgY29udGFpbnMgYSAleDNCIChcIjtcIilcbiAgLy8gICAgY2hhcmFjdGVyOlxuICBpZiAodW5wYXJzZWRBdHRyaWJ1dGVzLmluY2x1ZGVzKCc7JykpIHtcbiAgICAvLyAxLiBDb25zdW1lIHRoZSBjaGFyYWN0ZXJzIG9mIHRoZSB1bnBhcnNlZC1hdHRyaWJ1dGVzIHVwIHRvLCBidXRcbiAgICAvLyAgICBub3QgaW5jbHVkaW5nLCB0aGUgZmlyc3QgJXgzQiAoXCI7XCIpIGNoYXJhY3Rlci5cbiAgICBjb29raWVBdiA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICAgJzsnLFxuICAgICAgdW5wYXJzZWRBdHRyaWJ1dGVzLFxuICAgICAgeyBwb3NpdGlvbjogMCB9XG4gICAgKVxuICAgIHVucGFyc2VkQXR0cmlidXRlcyA9IHVucGFyc2VkQXR0cmlidXRlcy5zbGljZShjb29raWVBdi5sZW5ndGgpXG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlOlxuXG4gICAgLy8gMS4gQ29uc3VtZSB0aGUgcmVtYWluZGVyIG9mIHRoZSB1bnBhcnNlZC1hdHRyaWJ1dGVzLlxuICAgIGNvb2tpZUF2ID0gdW5wYXJzZWRBdHRyaWJ1dGVzXG4gICAgdW5wYXJzZWRBdHRyaWJ1dGVzID0gJydcbiAgfVxuXG4gIC8vIExldCB0aGUgY29va2llLWF2IHN0cmluZyBiZSB0aGUgY2hhcmFjdGVycyBjb25zdW1lZCBpbiB0aGlzIHN0ZXAuXG5cbiAgbGV0IGF0dHJpYnV0ZU5hbWUgPSAnJ1xuICBsZXQgYXR0cmlidXRlVmFsdWUgPSAnJ1xuXG4gIC8vIDQuIElmIHRoZSBjb29raWUtYXYgc3RyaW5nIGNvbnRhaW5zIGEgJXgzRCAoXCI9XCIpIGNoYXJhY3RlcjpcbiAgaWYgKGNvb2tpZUF2LmluY2x1ZGVzKCc9JykpIHtcbiAgICAvLyAxLiBUaGUgKHBvc3NpYmx5IGVtcHR5KSBhdHRyaWJ1dGUtbmFtZSBzdHJpbmcgY29uc2lzdHMgb2YgdGhlXG4gICAgLy8gICAgY2hhcmFjdGVycyB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIHRoZSBmaXJzdCAleDNEIChcIj1cIilcbiAgICAvLyAgICBjaGFyYWN0ZXIsIGFuZCB0aGUgKHBvc3NpYmx5IGVtcHR5KSBhdHRyaWJ1dGUtdmFsdWUgc3RyaW5nXG4gICAgLy8gICAgY29uc2lzdHMgb2YgdGhlIGNoYXJhY3RlcnMgYWZ0ZXIgdGhlIGZpcnN0ICV4M0QgKFwiPVwiKVxuICAgIC8vICAgIGNoYXJhY3Rlci5cbiAgICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfVxuXG4gICAgYXR0cmlidXRlTmFtZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICAgJz0nLFxuICAgICAgY29va2llQXYsXG4gICAgICBwb3NpdGlvblxuICAgIClcbiAgICBhdHRyaWJ1dGVWYWx1ZSA9IGNvb2tpZUF2LnNsaWNlKHBvc2l0aW9uLnBvc2l0aW9uICsgMSlcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2U6XG5cbiAgICAvLyAxLiBUaGUgYXR0cmlidXRlLW5hbWUgc3RyaW5nIGNvbnNpc3RzIG9mIHRoZSBlbnRpcmUgY29va2llLWF2XG4gICAgLy8gICAgc3RyaW5nLCBhbmQgdGhlIGF0dHJpYnV0ZS12YWx1ZSBzdHJpbmcgaXMgZW1wdHkuXG4gICAgYXR0cmlidXRlTmFtZSA9IGNvb2tpZUF2XG4gIH1cblxuICAvLyA1LiBSZW1vdmUgYW55IGxlYWRpbmcgb3IgdHJhaWxpbmcgV1NQIGNoYXJhY3RlcnMgZnJvbSB0aGUgYXR0cmlidXRlLVxuICAvLyAgICBuYW1lIHN0cmluZyBhbmQgdGhlIGF0dHJpYnV0ZS12YWx1ZSBzdHJpbmcuXG4gIGF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lLnRyaW0oKVxuICBhdHRyaWJ1dGVWYWx1ZSA9IGF0dHJpYnV0ZVZhbHVlLnRyaW0oKVxuXG4gIC8vIDYuIElmIHRoZSBhdHRyaWJ1dGUtdmFsdWUgaXMgbG9uZ2VyIHRoYW4gMTAyNCBvY3RldHMsIGlnbm9yZSB0aGVcbiAgLy8gICAgY29va2llLWF2IHN0cmluZyBhbmQgcmV0dXJuIHRvIFN0ZXAgMSBvZiB0aGlzIGFsZ29yaXRobS5cbiAgaWYgKGF0dHJpYnV0ZVZhbHVlLmxlbmd0aCA+IG1heEF0dHJpYnV0ZVZhbHVlU2l6ZSkge1xuICAgIHJldHVybiBwYXJzZVVucGFyc2VkQXR0cmlidXRlcyh1bnBhcnNlZEF0dHJpYnV0ZXMsIGNvb2tpZUF0dHJpYnV0ZUxpc3QpXG4gIH1cblxuICAvLyA3LiBQcm9jZXNzIHRoZSBhdHRyaWJ1dGUtbmFtZSBhbmQgYXR0cmlidXRlLXZhbHVlIGFjY29yZGluZyB0byB0aGVcbiAgLy8gICAgcmVxdWlyZW1lbnRzIGluIHRoZSBmb2xsb3dpbmcgc3Vic2VjdGlvbnMuICAoTm90aWNlIHRoYXRcbiAgLy8gICAgYXR0cmlidXRlcyB3aXRoIHVucmVjb2duaXplZCBhdHRyaWJ1dGUtbmFtZXMgYXJlIGlnbm9yZWQuKVxuICBjb25zdCBhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID0gYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNC4xXG4gIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nXG4gIC8vIFwiRXhwaXJlc1wiLCB0aGUgdXNlciBhZ2VudCBNVVNUIHByb2Nlc3MgdGhlIGNvb2tpZS1hdiBhcyBmb2xsb3dzLlxuICBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ2V4cGlyZXMnKSB7XG4gICAgLy8gMS4gTGV0IHRoZSBleHBpcnktdGltZSBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgdGhlIGF0dHJpYnV0ZS12YWx1ZVxuICAgIC8vICAgIGFzIGNvb2tpZS1kYXRlIChzZWUgU2VjdGlvbiA1LjEuMSkuXG4gICAgY29uc3QgZXhwaXJ5VGltZSA9IG5ldyBEYXRlKGF0dHJpYnV0ZVZhbHVlKVxuXG4gICAgLy8gMi4gSWYgdGhlIGF0dHJpYnV0ZS12YWx1ZSBmYWlsZWQgdG8gcGFyc2UgYXMgYSBjb29raWUgZGF0ZSwgaWdub3JlXG4gICAgLy8gICAgdGhlIGNvb2tpZS1hdi5cblxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QuZXhwaXJlcyA9IGV4cGlyeVRpbWVcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID09PSAnbWF4LWFnZScpIHtcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40LjJcbiAgICAvLyBJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZyBcIk1heC1cbiAgICAvLyBBZ2VcIiwgdGhlIHVzZXIgYWdlbnQgTVVTVCBwcm9jZXNzIHRoZSBjb29raWUtYXYgYXMgZm9sbG93cy5cblxuICAgIC8vIDEuIElmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIGF0dHJpYnV0ZS12YWx1ZSBpcyBub3QgYSBESUdJVCBvciBhXG4gICAgLy8gICAgXCItXCIgY2hhcmFjdGVyLCBpZ25vcmUgdGhlIGNvb2tpZS1hdi5cbiAgICBjb25zdCBjaGFyQ29kZSA9IGF0dHJpYnV0ZVZhbHVlLmNoYXJDb2RlQXQoMClcblxuICAgIGlmICgoY2hhckNvZGUgPCA0OCB8fCBjaGFyQ29kZSA+IDU3KSAmJiBhdHRyaWJ1dGVWYWx1ZVswXSAhPT0gJy0nKSB7XG4gICAgICByZXR1cm4gcGFyc2VVbnBhcnNlZEF0dHJpYnV0ZXModW5wYXJzZWRBdHRyaWJ1dGVzLCBjb29raWVBdHRyaWJ1dGVMaXN0KVxuICAgIH1cblxuICAgIC8vIDIuIElmIHRoZSByZW1haW5kZXIgb2YgYXR0cmlidXRlLXZhbHVlIGNvbnRhaW5zIGEgbm9uLURJR0lUXG4gICAgLy8gICAgY2hhcmFjdGVyLCBpZ25vcmUgdGhlIGNvb2tpZS1hdi5cbiAgICBpZiAoIS9eXFxkKyQvLnRlc3QoYXR0cmlidXRlVmFsdWUpKSB7XG4gICAgICByZXR1cm4gcGFyc2VVbnBhcnNlZEF0dHJpYnV0ZXModW5wYXJzZWRBdHRyaWJ1dGVzLCBjb29raWVBdHRyaWJ1dGVMaXN0KVxuICAgIH1cblxuICAgIC8vIDMuIExldCBkZWx0YS1zZWNvbmRzIGJlIHRoZSBhdHRyaWJ1dGUtdmFsdWUgY29udmVydGVkIHRvIGFuIGludGVnZXIuXG4gICAgY29uc3QgZGVsdGFTZWNvbmRzID0gTnVtYmVyKGF0dHJpYnV0ZVZhbHVlKVxuXG4gICAgLy8gNC4gTGV0IGNvb2tpZS1hZ2UtbGltaXQgYmUgdGhlIG1heGltdW0gYWdlIG9mIHRoZSBjb29raWUgKHdoaWNoXG4gICAgLy8gICAgU0hPVUxEIGJlIDQwMCBkYXlzIG9yIGxlc3MsIHNlZSBTZWN0aW9uIDQuMS4yLjIpLlxuXG4gICAgLy8gNS4gU2V0IGRlbHRhLXNlY29uZHMgdG8gdGhlIHNtYWxsZXIgb2YgaXRzIHByZXNlbnQgdmFsdWUgYW5kIGNvb2tpZS1cbiAgICAvLyAgICBhZ2UtbGltaXQuXG4gICAgLy8gZGVsdGFTZWNvbmRzID0gTWF0aC5taW4oZGVsdGFTZWNvbmRzICogMTAwMCwgbWF4RXhwaXJlc01zKVxuXG4gICAgLy8gNi4gSWYgZGVsdGEtc2Vjb25kcyBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gemVybyAoMCksIGxldCBleHBpcnktXG4gICAgLy8gICAgdGltZSBiZSB0aGUgZWFybGllc3QgcmVwcmVzZW50YWJsZSBkYXRlIGFuZCB0aW1lLiAgT3RoZXJ3aXNlLCBsZXRcbiAgICAvLyAgICB0aGUgZXhwaXJ5LXRpbWUgYmUgdGhlIGN1cnJlbnQgZGF0ZSBhbmQgdGltZSBwbHVzIGRlbHRhLXNlY29uZHNcbiAgICAvLyAgICBzZWNvbmRzLlxuICAgIC8vIGNvbnN0IGV4cGlyeVRpbWUgPSBkZWx0YVNlY29uZHMgPD0gMCA/IERhdGUubm93KCkgOiBEYXRlLm5vdygpICsgZGVsdGFTZWNvbmRzXG5cbiAgICAvLyA3LiBBcHBlbmQgYW4gYXR0cmlidXRlIHRvIHRoZSBjb29raWUtYXR0cmlidXRlLWxpc3Qgd2l0aCBhblxuICAgIC8vICAgIGF0dHJpYnV0ZS1uYW1lIG9mIE1heC1BZ2UgYW5kIGFuIGF0dHJpYnV0ZS12YWx1ZSBvZiBleHBpcnktdGltZS5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0Lm1heEFnZSA9IGRlbHRhU2Vjb25kc1xuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPT09ICdkb21haW4nKSB7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNC4zXG4gICAgLy8gSWYgdGhlIGF0dHJpYnV0ZS1uYW1lIGNhc2UtaW5zZW5zaXRpdmVseSBtYXRjaGVzIHRoZSBzdHJpbmcgXCJEb21haW5cIixcbiAgICAvLyB0aGUgdXNlciBhZ2VudCBNVVNUIHByb2Nlc3MgdGhlIGNvb2tpZS1hdiBhcyBmb2xsb3dzLlxuXG4gICAgLy8gMS4gTGV0IGNvb2tpZS1kb21haW4gYmUgdGhlIGF0dHJpYnV0ZS12YWx1ZS5cbiAgICBsZXQgY29va2llRG9tYWluID0gYXR0cmlidXRlVmFsdWVcblxuICAgIC8vIDIuIElmIGNvb2tpZS1kb21haW4gc3RhcnRzIHdpdGggJXgyRSAoXCIuXCIpLCBsZXQgY29va2llLWRvbWFpbiBiZVxuICAgIC8vICAgIGNvb2tpZS1kb21haW4gd2l0aG91dCBpdHMgbGVhZGluZyAleDJFIChcIi5cIikuXG4gICAgaWYgKGNvb2tpZURvbWFpblswXSA9PT0gJy4nKSB7XG4gICAgICBjb29raWVEb21haW4gPSBjb29raWVEb21haW4uc2xpY2UoMSlcbiAgICB9XG5cbiAgICAvLyAzLiBDb252ZXJ0IHRoZSBjb29raWUtZG9tYWluIHRvIGxvd2VyIGNhc2UuXG4gICAgY29va2llRG9tYWluID0gY29va2llRG9tYWluLnRvTG93ZXJDYXNlKClcblxuICAgIC8vIDQuIEFwcGVuZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIGNvb2tpZS1hdHRyaWJ1dGUtbGlzdCB3aXRoIGFuXG4gICAgLy8gICAgYXR0cmlidXRlLW5hbWUgb2YgRG9tYWluIGFuZCBhbiBhdHRyaWJ1dGUtdmFsdWUgb2YgY29va2llLWRvbWFpbi5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0LmRvbWFpbiA9IGNvb2tpZURvbWFpblxuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPT09ICdwYXRoJykge1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuNFxuICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nIFwiUGF0aFwiLFxuICAgIC8vIHRoZSB1c2VyIGFnZW50IE1VU1QgcHJvY2VzcyB0aGUgY29va2llLWF2IGFzIGZvbGxvd3MuXG5cbiAgICAvLyAxLiBJZiB0aGUgYXR0cmlidXRlLXZhbHVlIGlzIGVtcHR5IG9yIGlmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlXG4gICAgLy8gICAgYXR0cmlidXRlLXZhbHVlIGlzIG5vdCAleDJGIChcIi9cIik6XG4gICAgbGV0IGNvb2tpZVBhdGggPSAnJ1xuICAgIGlmIChhdHRyaWJ1dGVWYWx1ZS5sZW5ndGggPT09IDAgfHwgYXR0cmlidXRlVmFsdWVbMF0gIT09ICcvJykge1xuICAgICAgLy8gMS4gTGV0IGNvb2tpZS1wYXRoIGJlIHRoZSBkZWZhdWx0LXBhdGguXG4gICAgICBjb29raWVQYXRoID0gJy8nXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZTpcblxuICAgICAgLy8gMS4gTGV0IGNvb2tpZS1wYXRoIGJlIHRoZSBhdHRyaWJ1dGUtdmFsdWUuXG4gICAgICBjb29raWVQYXRoID0gYXR0cmlidXRlVmFsdWVcbiAgICB9XG5cbiAgICAvLyAyLiBBcHBlbmQgYW4gYXR0cmlidXRlIHRvIHRoZSBjb29raWUtYXR0cmlidXRlLWxpc3Qgd2l0aCBhblxuICAgIC8vICAgIGF0dHJpYnV0ZS1uYW1lIG9mIFBhdGggYW5kIGFuIGF0dHJpYnV0ZS12YWx1ZSBvZiBjb29raWUtcGF0aC5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0LnBhdGggPSBjb29raWVQYXRoXG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ3NlY3VyZScpIHtcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40LjVcbiAgICAvLyBJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZyBcIlNlY3VyZVwiLFxuICAgIC8vIHRoZSB1c2VyIGFnZW50IE1VU1QgYXBwZW5kIGFuIGF0dHJpYnV0ZSB0byB0aGUgY29va2llLWF0dHJpYnV0ZS1saXN0XG4gICAgLy8gd2l0aCBhbiBhdHRyaWJ1dGUtbmFtZSBvZiBTZWN1cmUgYW5kIGFuIGVtcHR5IGF0dHJpYnV0ZS12YWx1ZS5cblxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3Quc2VjdXJlID0gdHJ1ZVxuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPT09ICdodHRwb25seScpIHtcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40LjZcbiAgICAvLyBJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZ1xuICAgIC8vIFwiSHR0cE9ubHlcIiwgdGhlIHVzZXIgYWdlbnQgTVVTVCBhcHBlbmQgYW4gYXR0cmlidXRlIHRvIHRoZSBjb29raWUtXG4gICAgLy8gYXR0cmlidXRlLWxpc3Qgd2l0aCBhbiBhdHRyaWJ1dGUtbmFtZSBvZiBIdHRwT25seSBhbmQgYW4gZW1wdHlcbiAgICAvLyBhdHRyaWJ1dGUtdmFsdWUuXG5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0Lmh0dHBPbmx5ID0gdHJ1ZVxuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPT09ICdzYW1lc2l0ZScpIHtcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40LjdcbiAgICAvLyBJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZ1xuICAgIC8vIFwiU2FtZVNpdGVcIiwgdGhlIHVzZXIgYWdlbnQgTVVTVCBwcm9jZXNzIHRoZSBjb29raWUtYXYgYXMgZm9sbG93czpcblxuICAgIC8vIDEuIExldCBlbmZvcmNlbWVudCBiZSBcIkRlZmF1bHRcIi5cbiAgICBsZXQgZW5mb3JjZW1lbnQgPSAnRGVmYXVsdCdcblxuICAgIGNvbnN0IGF0dHJpYnV0ZVZhbHVlTG93ZXJjYXNlID0gYXR0cmlidXRlVmFsdWUudG9Mb3dlckNhc2UoKVxuICAgIC8vIDIuIElmIGNvb2tpZS1hdidzIGF0dHJpYnV0ZS12YWx1ZSBpcyBhIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yXG4gICAgLy8gICAgXCJOb25lXCIsIHNldCBlbmZvcmNlbWVudCB0byBcIk5vbmVcIi5cbiAgICBpZiAoYXR0cmlidXRlVmFsdWVMb3dlcmNhc2UuaW5jbHVkZXMoJ25vbmUnKSkge1xuICAgICAgZW5mb3JjZW1lbnQgPSAnTm9uZSdcbiAgICB9XG5cbiAgICAvLyAzLiBJZiBjb29raWUtYXYncyBhdHRyaWJ1dGUtdmFsdWUgaXMgYSBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvclxuICAgIC8vICAgIFwiU3RyaWN0XCIsIHNldCBlbmZvcmNlbWVudCB0byBcIlN0cmljdFwiLlxuICAgIGlmIChhdHRyaWJ1dGVWYWx1ZUxvd2VyY2FzZS5pbmNsdWRlcygnc3RyaWN0JykpIHtcbiAgICAgIGVuZm9yY2VtZW50ID0gJ1N0cmljdCdcbiAgICB9XG5cbiAgICAvLyA0LiBJZiBjb29raWUtYXYncyBhdHRyaWJ1dGUtdmFsdWUgaXMgYSBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvclxuICAgIC8vICAgIFwiTGF4XCIsIHNldCBlbmZvcmNlbWVudCB0byBcIkxheFwiLlxuICAgIGlmIChhdHRyaWJ1dGVWYWx1ZUxvd2VyY2FzZS5pbmNsdWRlcygnbGF4JykpIHtcbiAgICAgIGVuZm9yY2VtZW50ID0gJ0xheCdcbiAgICB9XG5cbiAgICAvLyA1LiBBcHBlbmQgYW4gYXR0cmlidXRlIHRvIHRoZSBjb29raWUtYXR0cmlidXRlLWxpc3Qgd2l0aCBhblxuICAgIC8vICAgIGF0dHJpYnV0ZS1uYW1lIG9mIFwiU2FtZVNpdGVcIiBhbmQgYW4gYXR0cmlidXRlLXZhbHVlIG9mXG4gICAgLy8gICAgZW5mb3JjZW1lbnQuXG4gICAgY29va2llQXR0cmlidXRlTGlzdC5zYW1lU2l0ZSA9IGVuZm9yY2VtZW50XG4gIH0gZWxzZSB7XG4gICAgY29va2llQXR0cmlidXRlTGlzdC51bnBhcnNlZCA/Pz0gW11cblxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QudW5wYXJzZWQucHVzaChgJHthdHRyaWJ1dGVOYW1lfT0ke2F0dHJpYnV0ZVZhbHVlfWApXG4gIH1cblxuICAvLyA4LiBSZXR1cm4gdG8gU3RlcCAxIG9mIHRoaXMgYWxnb3JpdGhtLlxuICByZXR1cm4gcGFyc2VVbnBhcnNlZEF0dHJpYnV0ZXModW5wYXJzZWRBdHRyaWJ1dGVzLCBjb29raWVBdHRyaWJ1dGVMaXN0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2VTZXRDb29raWUsXG4gIHBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzXG59XG4iXSwibmFtZXMiOlsibWF4TmFtZVZhbHVlUGFpclNpemUiLCJtYXhBdHRyaWJ1dGVWYWx1ZVNpemUiLCJyZXF1aXJlIiwiaXNDVExFeGNsdWRpbmdIdGFiIiwiY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QiLCJhc3NlcnQiLCJwYXJzZVNldENvb2tpZSIsImhlYWRlciIsIm5hbWVWYWx1ZVBhaXIiLCJ1bnBhcnNlZEF0dHJpYnV0ZXMiLCJuYW1lIiwidmFsdWUiLCJpbmNsdWRlcyIsInBvc2l0aW9uIiwic2xpY2UiLCJ0cmltIiwibGVuZ3RoIiwicGFyc2VVbnBhcnNlZEF0dHJpYnV0ZXMiLCJjb29raWVBdHRyaWJ1dGVMaXN0IiwiY29va2llQXYiLCJhdHRyaWJ1dGVOYW1lIiwiYXR0cmlidXRlVmFsdWUiLCJhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlIiwidG9Mb3dlckNhc2UiLCJleHBpcnlUaW1lIiwiRGF0ZSIsImV4cGlyZXMiLCJjaGFyQ29kZSIsImNoYXJDb2RlQXQiLCJ0ZXN0IiwiZGVsdGFTZWNvbmRzIiwiTnVtYmVyIiwibWF4QWdlIiwiY29va2llRG9tYWluIiwiZG9tYWluIiwiY29va2llUGF0aCIsInBhdGgiLCJzZWN1cmUiLCJodHRwT25seSIsImVuZm9yY2VtZW50IiwiYXR0cmlidXRlVmFsdWVMb3dlcmNhc2UiLCJzYW1lU2l0ZSIsInVucGFyc2VkIiwicHVzaCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/cookies/parse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/cookies/util.js":
/*!***********************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/cookies/util.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\");\nfunction isCTLExcludingHtab(value) {\n    if (value.length === 0) {\n        return false;\n    }\n    for (const char of value){\n        const code = char.charCodeAt(0);\n        if (code >= 0x00 || code <= 0x08 || code >= 0x0A || code <= 0x1F || code === 0x7F) {\n            return false;\n        }\n    }\n}\n/**\n CHAR           = <any US-ASCII character (octets 0 - 127)>\n token          = 1*<any CHAR except CTLs or separators>\n separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n                | \",\" | \";\" | \":\" | \"\\\" | <\">\n                | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n                | \"{\" | \"}\" | SP | HT\n * @param {string} name\n */ function validateCookieName(name) {\n    for (const char of name){\n        const code = char.charCodeAt(0);\n        if (code <= 0x20 || code > 0x7F || char === \"(\" || char === \")\" || char === \">\" || char === \"<\" || char === \"@\" || char === \",\" || char === \";\" || char === \":\" || char === \"\\\\\" || char === '\"' || char === \"/\" || char === \"[\" || char === \"]\" || char === \"?\" || char === \"=\" || char === \"{\" || char === \"}\") {\n            throw new Error(\"Invalid cookie name\");\n        }\n    }\n}\n/**\n cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\n cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n                       ; US-ASCII characters excluding CTLs,\n                       ; whitespace DQUOTE, comma, semicolon,\n                       ; and backslash\n * @param {string} value\n */ function validateCookieValue(value) {\n    for (const char of value){\n        const code = char.charCodeAt(0);\n        if (code < 0x21 || // exclude CTLs (0-31)\n        code === 0x22 || code === 0x2C || code === 0x3B || code === 0x5C || code > 0x7E // non-ascii\n        ) {\n            throw new Error(\"Invalid header value\");\n        }\n    }\n}\n/**\n * path-value        = <any CHAR except CTLs or \";\">\n * @param {string} path\n */ function validateCookiePath(path) {\n    for (const char of path){\n        const code = char.charCodeAt(0);\n        if (code < 0x21 || char === \";\") {\n            throw new Error(\"Invalid cookie path\");\n        }\n    }\n}\n/**\n * I have no idea why these values aren't allowed to be honest,\n * but Deno tests these. - Khafra\n * @param {string} domain\n */ function validateCookieDomain(domain) {\n    if (domain.startsWith(\"-\") || domain.endsWith(\".\") || domain.endsWith(\"-\")) {\n        throw new Error(\"Invalid cookie domain\");\n    }\n}\n/**\n * @see https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1\n * @param {number|Date} date\n  IMF-fixdate  = day-name \",\" SP date1 SP time-of-day SP GMT\n  ; fixed length/zone/capitalization subset of the format\n  ; see Section 3.3 of [RFC5322]\n\n  day-name     = %x4D.6F.6E ; \"Mon\", case-sensitive\n              / %x54.75.65 ; \"Tue\", case-sensitive\n              / %x57.65.64 ; \"Wed\", case-sensitive\n              / %x54.68.75 ; \"Thu\", case-sensitive\n              / %x46.72.69 ; \"Fri\", case-sensitive\n              / %x53.61.74 ; \"Sat\", case-sensitive\n              / %x53.75.6E ; \"Sun\", case-sensitive\n  date1        = day SP month SP year\n                  ; e.g., 02 Jun 1982\n\n  day          = 2DIGIT\n  month        = %x4A.61.6E ; \"Jan\", case-sensitive\n              / %x46.65.62 ; \"Feb\", case-sensitive\n              / %x4D.61.72 ; \"Mar\", case-sensitive\n              / %x41.70.72 ; \"Apr\", case-sensitive\n              / %x4D.61.79 ; \"May\", case-sensitive\n              / %x4A.75.6E ; \"Jun\", case-sensitive\n              / %x4A.75.6C ; \"Jul\", case-sensitive\n              / %x41.75.67 ; \"Aug\", case-sensitive\n              / %x53.65.70 ; \"Sep\", case-sensitive\n              / %x4F.63.74 ; \"Oct\", case-sensitive\n              / %x4E.6F.76 ; \"Nov\", case-sensitive\n              / %x44.65.63 ; \"Dec\", case-sensitive\n  year         = 4DIGIT\n\n  GMT          = %x47.4D.54 ; \"GMT\", case-sensitive\n\n  time-of-day  = hour \":\" minute \":\" second\n              ; 00:00:00 - 23:59:60 (leap second)\n\n  hour         = 2DIGIT\n  minute       = 2DIGIT\n  second       = 2DIGIT\n */ function toIMFDate(date) {\n    if (typeof date === \"number\") {\n        date = new Date(date);\n    }\n    const days = [\n        \"Sun\",\n        \"Mon\",\n        \"Tue\",\n        \"Wed\",\n        \"Thu\",\n        \"Fri\",\n        \"Sat\"\n    ];\n    const months = [\n        \"Jan\",\n        \"Feb\",\n        \"Mar\",\n        \"Apr\",\n        \"May\",\n        \"Jun\",\n        \"Jul\",\n        \"Aug\",\n        \"Sep\",\n        \"Oct\",\n        \"Nov\",\n        \"Dec\"\n    ];\n    const dayName = days[date.getUTCDay()];\n    const day = date.getUTCDate().toString().padStart(2, \"0\");\n    const month = months[date.getUTCMonth()];\n    const year = date.getUTCFullYear();\n    const hour = date.getUTCHours().toString().padStart(2, \"0\");\n    const minute = date.getUTCMinutes().toString().padStart(2, \"0\");\n    const second = date.getUTCSeconds().toString().padStart(2, \"0\");\n    return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;\n}\n/**\n max-age-av        = \"Max-Age=\" non-zero-digit *DIGIT\n                       ; In practice, both expires-av and max-age-av\n                       ; are limited to dates representable by the\n                       ; user agent.\n * @param {number} maxAge\n */ function validateCookieMaxAge(maxAge) {\n    if (maxAge < 0) {\n        throw new Error(\"Invalid cookie max-age\");\n    }\n}\n/**\n * @see https://www.rfc-editor.org/rfc/rfc6265#section-4.1.1\n * @param {import('./index').Cookie} cookie\n */ function stringify(cookie) {\n    if (cookie.name.length === 0) {\n        return null;\n    }\n    validateCookieName(cookie.name);\n    validateCookieValue(cookie.value);\n    const out = [\n        `${cookie.name}=${cookie.value}`\n    ];\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.1\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.2\n    if (cookie.name.startsWith(\"__Secure-\")) {\n        cookie.secure = true;\n    }\n    if (cookie.name.startsWith(\"__Host-\")) {\n        cookie.secure = true;\n        cookie.domain = null;\n        cookie.path = \"/\";\n    }\n    if (cookie.secure) {\n        out.push(\"Secure\");\n    }\n    if (cookie.httpOnly) {\n        out.push(\"HttpOnly\");\n    }\n    if (typeof cookie.maxAge === \"number\") {\n        validateCookieMaxAge(cookie.maxAge);\n        out.push(`Max-Age=${cookie.maxAge}`);\n    }\n    if (cookie.domain) {\n        validateCookieDomain(cookie.domain);\n        out.push(`Domain=${cookie.domain}`);\n    }\n    if (cookie.path) {\n        validateCookiePath(cookie.path);\n        out.push(`Path=${cookie.path}`);\n    }\n    if (cookie.expires && cookie.expires.toString() !== \"Invalid Date\") {\n        out.push(`Expires=${toIMFDate(cookie.expires)}`);\n    }\n    if (cookie.sameSite) {\n        out.push(`SameSite=${cookie.sameSite}`);\n    }\n    for (const part of cookie.unparsed){\n        if (!part.includes(\"=\")) {\n            throw new Error(\"Invalid unparsed\");\n        }\n        const [key, ...value] = part.split(\"=\");\n        out.push(`${key.trim()}=${value.join(\"=\")}`);\n    }\n    return out.join(\"; \");\n}\nlet kHeadersListNode;\nfunction getHeadersList(headers) {\n    if (headers[kHeadersList]) {\n        return headers[kHeadersList];\n    }\n    if (!kHeadersListNode) {\n        kHeadersListNode = Object.getOwnPropertySymbols(headers).find((symbol)=>symbol.description === \"headers list\");\n        assert(kHeadersListNode, \"Headers cannot be parsed\");\n    }\n    const headersList = headers[kHeadersListNode];\n    assert(headersList);\n    return headersList;\n}\nmodule.exports = {\n    isCTLExcludingHtab,\n    stringify,\n    getHeadersList\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29va2llcy91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFQyxZQUFZLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFFakMsU0FBU0UsbUJBQW9CQyxLQUFLO0lBQ2hDLElBQUlBLE1BQU1DLE1BQU0sS0FBSyxHQUFHO1FBQ3RCLE9BQU87SUFDVDtJQUVBLEtBQUssTUFBTUMsUUFBUUYsTUFBTztRQUN4QixNQUFNRyxPQUFPRCxLQUFLRSxVQUFVLENBQUM7UUFFN0IsSUFDRSxRQUFTLFFBQVFELFFBQVEsUUFDeEJBLFFBQVEsUUFBUUEsUUFBUSxRQUN6QkEsU0FBUyxNQUNUO1lBQ0EsT0FBTztRQUNUO0lBQ0Y7QUFDRjtBQUVBOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU0UsbUJBQW9CQyxJQUFJO0lBQy9CLEtBQUssTUFBTUosUUFBUUksS0FBTTtRQUN2QixNQUFNSCxPQUFPRCxLQUFLRSxVQUFVLENBQUM7UUFFN0IsSUFDRSxRQUFTLFFBQVFELE9BQU8sUUFDeEJELFNBQVMsT0FDVEEsU0FBUyxPQUNUQSxTQUFTLE9BQ1RBLFNBQVMsT0FDVEEsU0FBUyxPQUNUQSxTQUFTLE9BQ1RBLFNBQVMsT0FDVEEsU0FBUyxPQUNUQSxTQUFTLFFBQ1RBLFNBQVMsT0FDVEEsU0FBUyxPQUNUQSxTQUFTLE9BQ1RBLFNBQVMsT0FDVEEsU0FBUyxPQUNUQSxTQUFTLE9BQ1RBLFNBQVMsT0FDVEEsU0FBUyxLQUNUO1lBQ0EsTUFBTSxJQUFJSyxNQUFNO1FBQ2xCO0lBQ0Y7QUFDRjtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTQyxvQkFBcUJSLEtBQUs7SUFDakMsS0FBSyxNQUFNRSxRQUFRRixNQUFPO1FBQ3hCLE1BQU1HLE9BQU9ELEtBQUtFLFVBQVUsQ0FBQztRQUU3QixJQUNFRCxPQUFPLFFBQVEsc0JBQXNC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QUFFbkQsTUFBTW9ELElBQUksQ0FBQyxLQUFLLENBQUM7SUFDN0M7SUFFQSxPQUFPWixJQUFJWSxJQUFJLENBQUM7QUFDbEI7QUFFQSxJQUFJQztBQUVKLFNBQVNDLGVBQWdCQyxPQUFPO0lBQzlCLElBQUlBLE9BQU8sQ0FBQ3pELGFBQWEsRUFBRTtRQUN6QixPQUFPeUQsT0FBTyxDQUFDekQsYUFBYTtJQUM5QjtJQUVBLElBQUksQ0FBQ3VELGtCQUFrQjtRQUNyQkEsbUJBQW1CRyxPQUFPQyxxQkFBcUIsQ0FBQ0YsU0FBU0csSUFBSSxDQUMzRCxDQUFDQyxTQUFXQSxPQUFPQyxXQUFXLEtBQUs7UUFHckNoRSxPQUFPeUQsa0JBQWtCO0lBQzNCO0lBRUEsTUFBTVEsY0FBY04sT0FBTyxDQUFDRixpQkFBaUI7SUFDN0N6RCxPQUFPaUU7SUFFUCxPQUFPQTtBQUNUO0FBRUFDLE9BQU9DLE9BQU8sR0FBRztJQUNmaEU7SUFDQXVDO0lBQ0FnQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1maWdodGVyLWFjYWRlbXkvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29va2llcy91dGlsLmpzP2M4ODkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCB7IGtIZWFkZXJzTGlzdCB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcblxuZnVuY3Rpb24gaXNDVExFeGNsdWRpbmdIdGFiICh2YWx1ZSkge1xuICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmb3IgKGNvbnN0IGNoYXIgb2YgdmFsdWUpIHtcbiAgICBjb25zdCBjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApXG5cbiAgICBpZiAoXG4gICAgICAoY29kZSA+PSAweDAwIHx8IGNvZGUgPD0gMHgwOCkgfHxcbiAgICAgIChjb2RlID49IDB4MEEgfHwgY29kZSA8PSAweDFGKSB8fFxuICAgICAgY29kZSA9PT0gMHg3RlxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG59XG5cbi8qKlxuIENIQVIgICAgICAgICAgID0gPGFueSBVUy1BU0NJSSBjaGFyYWN0ZXIgKG9jdGV0cyAwIC0gMTI3KT5cbiB0b2tlbiAgICAgICAgICA9IDEqPGFueSBDSEFSIGV4Y2VwdCBDVExzIG9yIHNlcGFyYXRvcnM+XG4gc2VwYXJhdG9ycyAgICAgPSBcIihcIiB8IFwiKVwiIHwgXCI8XCIgfCBcIj5cIiB8IFwiQFwiXG4gICAgICAgICAgICAgICAgfCBcIixcIiB8IFwiO1wiIHwgXCI6XCIgfCBcIlxcXCIgfCA8XCI+XG4gICAgICAgICAgICAgICAgfCBcIi9cIiB8IFwiW1wiIHwgXCJdXCIgfCBcIj9cIiB8IFwiPVwiXG4gICAgICAgICAgICAgICAgfCBcIntcIiB8IFwifVwiIHwgU1AgfCBIVFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb29raWVOYW1lIChuYW1lKSB7XG4gIGZvciAoY29uc3QgY2hhciBvZiBuYW1lKSB7XG4gICAgY29uc3QgY29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKVxuXG4gICAgaWYgKFxuICAgICAgKGNvZGUgPD0gMHgyMCB8fCBjb2RlID4gMHg3RikgfHxcbiAgICAgIGNoYXIgPT09ICcoJyB8fFxuICAgICAgY2hhciA9PT0gJyknIHx8XG4gICAgICBjaGFyID09PSAnPicgfHxcbiAgICAgIGNoYXIgPT09ICc8JyB8fFxuICAgICAgY2hhciA9PT0gJ0AnIHx8XG4gICAgICBjaGFyID09PSAnLCcgfHxcbiAgICAgIGNoYXIgPT09ICc7JyB8fFxuICAgICAgY2hhciA9PT0gJzonIHx8XG4gICAgICBjaGFyID09PSAnXFxcXCcgfHxcbiAgICAgIGNoYXIgPT09ICdcIicgfHxcbiAgICAgIGNoYXIgPT09ICcvJyB8fFxuICAgICAgY2hhciA9PT0gJ1snIHx8XG4gICAgICBjaGFyID09PSAnXScgfHxcbiAgICAgIGNoYXIgPT09ICc/JyB8fFxuICAgICAgY2hhciA9PT0gJz0nIHx8XG4gICAgICBjaGFyID09PSAneycgfHxcbiAgICAgIGNoYXIgPT09ICd9J1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvb2tpZSBuYW1lJylcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gY29va2llLXZhbHVlICAgICAgPSAqY29va2llLW9jdGV0IC8gKCBEUVVPVEUgKmNvb2tpZS1vY3RldCBEUVVPVEUgKVxuIGNvb2tpZS1vY3RldCAgICAgID0gJXgyMSAvICV4MjMtMkIgLyAleDJELTNBIC8gJXgzQy01QiAvICV4NUQtN0VcbiAgICAgICAgICAgICAgICAgICAgICAgOyBVUy1BU0NJSSBjaGFyYWN0ZXJzIGV4Y2x1ZGluZyBDVExzLFxuICAgICAgICAgICAgICAgICAgICAgICA7IHdoaXRlc3BhY2UgRFFVT1RFLCBjb21tYSwgc2VtaWNvbG9uLFxuICAgICAgICAgICAgICAgICAgICAgICA7IGFuZCBiYWNrc2xhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvb2tpZVZhbHVlICh2YWx1ZSkge1xuICBmb3IgKGNvbnN0IGNoYXIgb2YgdmFsdWUpIHtcbiAgICBjb25zdCBjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApXG5cbiAgICBpZiAoXG4gICAgICBjb2RlIDwgMHgyMSB8fCAvLyBleGNsdWRlIENUTHMgKDAtMzEpXG4gICAgICBjb2RlID09PSAweDIyIHx8XG4gICAgICBjb2RlID09PSAweDJDIHx8XG4gICAgICBjb2RlID09PSAweDNCIHx8XG4gICAgICBjb2RlID09PSAweDVDIHx8XG4gICAgICBjb2RlID4gMHg3RSAvLyBub24tYXNjaWlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZWFkZXIgdmFsdWUnKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIHBhdGgtdmFsdWUgICAgICAgID0gPGFueSBDSEFSIGV4Y2VwdCBDVExzIG9yIFwiO1wiPlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb29raWVQYXRoIChwYXRoKSB7XG4gIGZvciAoY29uc3QgY2hhciBvZiBwYXRoKSB7XG4gICAgY29uc3QgY29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKVxuXG4gICAgaWYgKGNvZGUgPCAweDIxIHx8IGNoYXIgPT09ICc7Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvb2tpZSBwYXRoJylcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJIGhhdmUgbm8gaWRlYSB3aHkgdGhlc2UgdmFsdWVzIGFyZW4ndCBhbGxvd2VkIHRvIGJlIGhvbmVzdCxcbiAqIGJ1dCBEZW5vIHRlc3RzIHRoZXNlLiAtIEtoYWZyYVxuICogQHBhcmFtIHtzdHJpbmd9IGRvbWFpblxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvb2tpZURvbWFpbiAoZG9tYWluKSB7XG4gIGlmIChcbiAgICBkb21haW4uc3RhcnRzV2l0aCgnLScpIHx8XG4gICAgZG9tYWluLmVuZHNXaXRoKCcuJykgfHxcbiAgICBkb21haW4uZW5kc1dpdGgoJy0nKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29va2llIGRvbWFpbicpXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3MjMxI3NlY3Rpb24tNy4xLjEuMVxuICogQHBhcmFtIHtudW1iZXJ8RGF0ZX0gZGF0ZVxuICBJTUYtZml4ZGF0ZSAgPSBkYXktbmFtZSBcIixcIiBTUCBkYXRlMSBTUCB0aW1lLW9mLWRheSBTUCBHTVRcbiAgOyBmaXhlZCBsZW5ndGgvem9uZS9jYXBpdGFsaXphdGlvbiBzdWJzZXQgb2YgdGhlIGZvcm1hdFxuICA7IHNlZSBTZWN0aW9uIDMuMyBvZiBbUkZDNTMyMl1cblxuICBkYXktbmFtZSAgICAgPSAleDRELjZGLjZFIDsgXCJNb25cIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDU0Ljc1LjY1IDsgXCJUdWVcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDU3LjY1LjY0IDsgXCJXZWRcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDU0LjY4Ljc1IDsgXCJUaHVcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDQ2LjcyLjY5IDsgXCJGcmlcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDUzLjYxLjc0IDsgXCJTYXRcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDUzLjc1LjZFIDsgXCJTdW5cIiwgY2FzZS1zZW5zaXRpdmVcbiAgZGF0ZTEgICAgICAgID0gZGF5IFNQIG1vbnRoIFNQIHllYXJcbiAgICAgICAgICAgICAgICAgIDsgZS5nLiwgMDIgSnVuIDE5ODJcblxuICBkYXkgICAgICAgICAgPSAyRElHSVRcbiAgbW9udGggICAgICAgID0gJXg0QS42MS42RSA7IFwiSmFuXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0Ni42NS42MiA7IFwiRmViXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0RC42MS43MiA7IFwiTWFyXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0MS43MC43MiA7IFwiQXByXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0RC42MS43OSA7IFwiTWF5XCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0QS43NS42RSA7IFwiSnVuXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0QS43NS42QyA7IFwiSnVsXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0MS43NS42NyA7IFwiQXVnXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg1My42NS43MCA7IFwiU2VwXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0Ri42My43NCA7IFwiT2N0XCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0RS42Ri43NiA7IFwiTm92XCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0NC42NS42MyA7IFwiRGVjXCIsIGNhc2Utc2Vuc2l0aXZlXG4gIHllYXIgICAgICAgICA9IDRESUdJVFxuXG4gIEdNVCAgICAgICAgICA9ICV4NDcuNEQuNTQgOyBcIkdNVFwiLCBjYXNlLXNlbnNpdGl2ZVxuXG4gIHRpbWUtb2YtZGF5ICA9IGhvdXIgXCI6XCIgbWludXRlIFwiOlwiIHNlY29uZFxuICAgICAgICAgICAgICA7IDAwOjAwOjAwIC0gMjM6NTk6NjAgKGxlYXAgc2Vjb25kKVxuXG4gIGhvdXIgICAgICAgICA9IDJESUdJVFxuICBtaW51dGUgICAgICAgPSAyRElHSVRcbiAgc2Vjb25kICAgICAgID0gMkRJR0lUXG4gKi9cbmZ1bmN0aW9uIHRvSU1GRGF0ZSAoZGF0ZSkge1xuICBpZiAodHlwZW9mIGRhdGUgPT09ICdudW1iZXInKSB7XG4gICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUpXG4gIH1cblxuICBjb25zdCBkYXlzID0gW1xuICAgICdTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLFxuICAgICdUaHUnLCAnRnJpJywgJ1NhdCdcbiAgXVxuXG4gIGNvbnN0IG1vbnRocyA9IFtcbiAgICAnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLFxuICAgICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYydcbiAgXVxuXG4gIGNvbnN0IGRheU5hbWUgPSBkYXlzW2RhdGUuZ2V0VVRDRGF5KCldXG4gIGNvbnN0IGRheSA9IGRhdGUuZ2V0VVRDRGF0ZSgpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKVxuICBjb25zdCBtb250aCA9IG1vbnRoc1tkYXRlLmdldFVUQ01vbnRoKCldXG4gIGNvbnN0IHllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKClcbiAgY29uc3QgaG91ciA9IGRhdGUuZ2V0VVRDSG91cnMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJylcbiAgY29uc3QgbWludXRlID0gZGF0ZS5nZXRVVENNaW51dGVzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpXG4gIGNvbnN0IHNlY29uZCA9IGRhdGUuZ2V0VVRDU2Vjb25kcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKVxuXG4gIHJldHVybiBgJHtkYXlOYW1lfSwgJHtkYXl9ICR7bW9udGh9ICR7eWVhcn0gJHtob3VyfToke21pbnV0ZX06JHtzZWNvbmR9IEdNVGBcbn1cblxuLyoqXG4gbWF4LWFnZS1hdiAgICAgICAgPSBcIk1heC1BZ2U9XCIgbm9uLXplcm8tZGlnaXQgKkRJR0lUXG4gICAgICAgICAgICAgICAgICAgICAgIDsgSW4gcHJhY3RpY2UsIGJvdGggZXhwaXJlcy1hdiBhbmQgbWF4LWFnZS1hdlxuICAgICAgICAgICAgICAgICAgICAgICA7IGFyZSBsaW1pdGVkIHRvIGRhdGVzIHJlcHJlc2VudGFibGUgYnkgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgIDsgdXNlciBhZ2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhBZ2VcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb29raWVNYXhBZ2UgKG1heEFnZSkge1xuICBpZiAobWF4QWdlIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb29raWUgbWF4LWFnZScpXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM2MjY1I3NlY3Rpb24tNC4xLjFcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuQ29va2llfSBjb29raWVcbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5IChjb29raWUpIHtcbiAgaWYgKGNvb2tpZS5uYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB2YWxpZGF0ZUNvb2tpZU5hbWUoY29va2llLm5hbWUpXG4gIHZhbGlkYXRlQ29va2llVmFsdWUoY29va2llLnZhbHVlKVxuXG4gIGNvbnN0IG91dCA9IFtgJHtjb29raWUubmFtZX09JHtjb29raWUudmFsdWV9YF1cblxuICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1jb29raWUtcHJlZml4ZXMtMDAjc2VjdGlvbi0zLjFcbiAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtY29va2llLXByZWZpeGVzLTAwI3NlY3Rpb24tMy4yXG4gIGlmIChjb29raWUubmFtZS5zdGFydHNXaXRoKCdfX1NlY3VyZS0nKSkge1xuICAgIGNvb2tpZS5zZWN1cmUgPSB0cnVlXG4gIH1cblxuICBpZiAoY29va2llLm5hbWUuc3RhcnRzV2l0aCgnX19Ib3N0LScpKSB7XG4gICAgY29va2llLnNlY3VyZSA9IHRydWVcbiAgICBjb29raWUuZG9tYWluID0gbnVsbFxuICAgIGNvb2tpZS5wYXRoID0gJy8nXG4gIH1cblxuICBpZiAoY29va2llLnNlY3VyZSkge1xuICAgIG91dC5wdXNoKCdTZWN1cmUnKVxuICB9XG5cbiAgaWYgKGNvb2tpZS5odHRwT25seSkge1xuICAgIG91dC5wdXNoKCdIdHRwT25seScpXG4gIH1cblxuICBpZiAodHlwZW9mIGNvb2tpZS5tYXhBZ2UgPT09ICdudW1iZXInKSB7XG4gICAgdmFsaWRhdGVDb29raWVNYXhBZ2UoY29va2llLm1heEFnZSlcbiAgICBvdXQucHVzaChgTWF4LUFnZT0ke2Nvb2tpZS5tYXhBZ2V9YClcbiAgfVxuXG4gIGlmIChjb29raWUuZG9tYWluKSB7XG4gICAgdmFsaWRhdGVDb29raWVEb21haW4oY29va2llLmRvbWFpbilcbiAgICBvdXQucHVzaChgRG9tYWluPSR7Y29va2llLmRvbWFpbn1gKVxuICB9XG5cbiAgaWYgKGNvb2tpZS5wYXRoKSB7XG4gICAgdmFsaWRhdGVDb29raWVQYXRoKGNvb2tpZS5wYXRoKVxuICAgIG91dC5wdXNoKGBQYXRoPSR7Y29va2llLnBhdGh9YClcbiAgfVxuXG4gIGlmIChjb29raWUuZXhwaXJlcyAmJiBjb29raWUuZXhwaXJlcy50b1N0cmluZygpICE9PSAnSW52YWxpZCBEYXRlJykge1xuICAgIG91dC5wdXNoKGBFeHBpcmVzPSR7dG9JTUZEYXRlKGNvb2tpZS5leHBpcmVzKX1gKVxuICB9XG5cbiAgaWYgKGNvb2tpZS5zYW1lU2l0ZSkge1xuICAgIG91dC5wdXNoKGBTYW1lU2l0ZT0ke2Nvb2tpZS5zYW1lU2l0ZX1gKVxuICB9XG5cbiAgZm9yIChjb25zdCBwYXJ0IG9mIGNvb2tpZS51bnBhcnNlZCkge1xuICAgIGlmICghcGFydC5pbmNsdWRlcygnPScpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdW5wYXJzZWQnKVxuICAgIH1cblxuICAgIGNvbnN0IFtrZXksIC4uLnZhbHVlXSA9IHBhcnQuc3BsaXQoJz0nKVxuXG4gICAgb3V0LnB1c2goYCR7a2V5LnRyaW0oKX09JHt2YWx1ZS5qb2luKCc9Jyl9YClcbiAgfVxuXG4gIHJldHVybiBvdXQuam9pbignOyAnKVxufVxuXG5sZXQga0hlYWRlcnNMaXN0Tm9kZVxuXG5mdW5jdGlvbiBnZXRIZWFkZXJzTGlzdCAoaGVhZGVycykge1xuICBpZiAoaGVhZGVyc1trSGVhZGVyc0xpc3RdKSB7XG4gICAgcmV0dXJuIGhlYWRlcnNba0hlYWRlcnNMaXN0XVxuICB9XG5cbiAgaWYgKCFrSGVhZGVyc0xpc3ROb2RlKSB7XG4gICAga0hlYWRlcnNMaXN0Tm9kZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaGVhZGVycykuZmluZChcbiAgICAgIChzeW1ib2wpID0+IHN5bWJvbC5kZXNjcmlwdGlvbiA9PT0gJ2hlYWRlcnMgbGlzdCdcbiAgICApXG5cbiAgICBhc3NlcnQoa0hlYWRlcnNMaXN0Tm9kZSwgJ0hlYWRlcnMgY2Fubm90IGJlIHBhcnNlZCcpXG4gIH1cblxuICBjb25zdCBoZWFkZXJzTGlzdCA9IGhlYWRlcnNba0hlYWRlcnNMaXN0Tm9kZV1cbiAgYXNzZXJ0KGhlYWRlcnNMaXN0KVxuXG4gIHJldHVybiBoZWFkZXJzTGlzdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNDVExFeGNsdWRpbmdIdGFiLFxuICBzdHJpbmdpZnksXG4gIGdldEhlYWRlcnNMaXN0XG59XG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsImtIZWFkZXJzTGlzdCIsImlzQ1RMRXhjbHVkaW5nSHRhYiIsInZhbHVlIiwibGVuZ3RoIiwiY2hhciIsImNvZGUiLCJjaGFyQ29kZUF0IiwidmFsaWRhdGVDb29raWVOYW1lIiwibmFtZSIsIkVycm9yIiwidmFsaWRhdGVDb29raWVWYWx1ZSIsInZhbGlkYXRlQ29va2llUGF0aCIsInBhdGgiLCJ2YWxpZGF0ZUNvb2tpZURvbWFpbiIsImRvbWFpbiIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInRvSU1GRGF0ZSIsImRhdGUiLCJEYXRlIiwiZGF5cyIsIm1vbnRocyIsImRheU5hbWUiLCJnZXRVVENEYXkiLCJkYXkiLCJnZXRVVENEYXRlIiwidG9TdHJpbmciLCJwYWRTdGFydCIsIm1vbnRoIiwiZ2V0VVRDTW9udGgiLCJ5ZWFyIiwiZ2V0VVRDRnVsbFllYXIiLCJob3VyIiwiZ2V0VVRDSG91cnMiLCJtaW51dGUiLCJnZXRVVENNaW51dGVzIiwic2Vjb25kIiwiZ2V0VVRDU2Vjb25kcyIsInZhbGlkYXRlQ29va2llTWF4QWdlIiwibWF4QWdlIiwic3RyaW5naWZ5IiwiY29va2llIiwib3V0Iiwic2VjdXJlIiwicHVzaCIsImh0dHBPbmx5IiwiZXhwaXJlcyIsInNhbWVTaXRlIiwicGFydCIsInVucGFyc2VkIiwiaW5jbHVkZXMiLCJrZXkiLCJzcGxpdCIsInRyaW0iLCJqb2luIiwia0hlYWRlcnNMaXN0Tm9kZSIsImdldEhlYWRlcnNMaXN0IiwiaGVhZGVycyIsIk9iamVjdCIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbmQiLCJzeW1ib2wiLCJkZXNjcmlwdGlvbiIsImhlYWRlcnNMaXN0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/cookies/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/core/connect.js":
/*!***********************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/core/connect.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst net = __webpack_require__(/*! net */ \"net\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst { InvalidArgumentError, ConnectTimeoutError } = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\nlet tls // include tls conditionally since it is not always available\n;\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\nlet SessionCache;\n// FIXME: remove workaround when the Node bug is fixed\n// https://github.com/nodejs/node/issues/49344#issuecomment-1741776308\nif (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {\n    SessionCache = class WeakSessionCache {\n        constructor(maxCachedSessions){\n            this._maxCachedSessions = maxCachedSessions;\n            this._sessionCache = new Map();\n            this._sessionRegistry = new global.FinalizationRegistry((key)=>{\n                if (this._sessionCache.size < this._maxCachedSessions) {\n                    return;\n                }\n                const ref = this._sessionCache.get(key);\n                if (ref !== undefined && ref.deref() === undefined) {\n                    this._sessionCache.delete(key);\n                }\n            });\n        }\n        get(sessionKey) {\n            const ref = this._sessionCache.get(sessionKey);\n            return ref ? ref.deref() : null;\n        }\n        set(sessionKey, session) {\n            if (this._maxCachedSessions === 0) {\n                return;\n            }\n            this._sessionCache.set(sessionKey, new WeakRef(session));\n            this._sessionRegistry.register(session, sessionKey);\n        }\n    };\n} else {\n    SessionCache = class SimpleSessionCache {\n        constructor(maxCachedSessions){\n            this._maxCachedSessions = maxCachedSessions;\n            this._sessionCache = new Map();\n        }\n        get(sessionKey) {\n            return this._sessionCache.get(sessionKey);\n        }\n        set(sessionKey, session) {\n            if (this._maxCachedSessions === 0) {\n                return;\n            }\n            if (this._sessionCache.size >= this._maxCachedSessions) {\n                // remove the oldest session\n                const { value: oldestKey } = this._sessionCache.keys().next();\n                this._sessionCache.delete(oldestKey);\n            }\n            this._sessionCache.set(sessionKey, session);\n        }\n    };\n}\nfunction buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {\n    if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n        throw new InvalidArgumentError(\"maxCachedSessions must be a positive integer or zero\");\n    }\n    const options = {\n        path: socketPath,\n        ...opts\n    };\n    const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);\n    timeout = timeout == null ? 10e3 : timeout;\n    allowH2 = allowH2 != null ? allowH2 : false;\n    return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {\n        let socket;\n        if (protocol === \"https:\") {\n            if (!tls) {\n                tls = __webpack_require__(/*! tls */ \"tls\");\n            }\n            servername = servername || options.servername || util.getServerName(host) || null;\n            const sessionKey = servername || hostname;\n            const session = sessionCache.get(sessionKey) || null;\n            assert(sessionKey);\n            socket = tls.connect({\n                highWaterMark: 16384,\n                ...options,\n                servername,\n                session,\n                localAddress,\n                // TODO(HTTP/2): Add support for h2c\n                ALPNProtocols: allowH2 ? [\n                    \"http/1.1\",\n                    \"h2\"\n                ] : [\n                    \"http/1.1\"\n                ],\n                socket: httpSocket,\n                port: port || 443,\n                host: hostname\n            });\n            socket.on(\"session\", function(session) {\n                // TODO (fix): Can a session become invalid once established? Don't think so?\n                sessionCache.set(sessionKey, session);\n            });\n        } else {\n            assert(!httpSocket, \"httpSocket can only be sent on TLS update\");\n            socket = net.connect({\n                highWaterMark: 64 * 1024,\n                ...options,\n                localAddress,\n                port: port || 80,\n                host: hostname\n            });\n        }\n        // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket\n        if (options.keepAlive == null || options.keepAlive) {\n            const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60e3 : options.keepAliveInitialDelay;\n            socket.setKeepAlive(true, keepAliveInitialDelay);\n        }\n        const cancelTimeout = setupTimeout(()=>onConnectTimeout(socket), timeout);\n        socket.setNoDelay(true).once(protocol === \"https:\" ? \"secureConnect\" : \"connect\", function() {\n            cancelTimeout();\n            if (callback) {\n                const cb = callback;\n                callback = null;\n                cb(null, this);\n            }\n        }).on(\"error\", function(err) {\n            cancelTimeout();\n            if (callback) {\n                const cb = callback;\n                callback = null;\n                cb(err);\n            }\n        });\n        return socket;\n    };\n}\nfunction setupTimeout(onConnectTimeout, timeout) {\n    if (!timeout) {\n        return ()=>{};\n    }\n    let s1 = null;\n    let s2 = null;\n    const timeoutId = setTimeout(()=>{\n        // setImmediate is added to make sure that we priotorise socket error events over timeouts\n        s1 = setImmediate(()=>{\n            if (process.platform === \"win32\") {\n                // Windows needs an extra setImmediate probably due to implementation differences in the socket logic\n                s2 = setImmediate(()=>onConnectTimeout());\n            } else {\n                onConnectTimeout();\n            }\n        });\n    }, timeout);\n    return ()=>{\n        clearTimeout(timeoutId);\n        clearImmediate(s1);\n        clearImmediate(s2);\n    };\n}\nfunction onConnectTimeout(socket) {\n    util.destroy(socket, new ConnectTimeoutError());\n}\nmodule.exports = buildConnector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS9jb25uZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsTUFBTUMsbUJBQU9BLENBQUM7QUFDcEIsTUFBTUMsU0FBU0QsbUJBQU9BLENBQUM7QUFDdkIsTUFBTUUsT0FBT0YsbUJBQU9BLENBQUM7QUFDckIsTUFBTSxFQUFFRyxvQkFBb0IsRUFBRUMsbUJBQW1CLEVBQUUsR0FBR0osbUJBQU9BLENBQUM7QUFFOUQsSUFBSUssSUFBSSw2REFBNkQ7O0FBRXJFLG1EQUFtRDtBQUNuRCx3REFBd0Q7QUFDeEQsdURBQXVEO0FBQ3ZELHFCQUFxQjtBQUVyQixJQUFJQztBQUNKLHNEQUFzRDtBQUN0RCxzRUFBc0U7QUFDdEUsSUFBSUMsT0FBT0Msb0JBQW9CLElBQUksQ0FBQ0MsUUFBUUMsR0FBRyxDQUFDQyxnQkFBZ0IsRUFBRTtJQUNoRUwsZUFBZSxNQUFNTTtRQUNuQkMsWUFBYUMsaUJBQWlCLENBQUU7WUFDOUIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBR0Q7WUFDMUIsSUFBSSxDQUFDRSxhQUFhLEdBQUcsSUFBSUM7WUFDekIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRyxJQUFJWCxPQUFPQyxvQkFBb0IsQ0FBQyxDQUFDVztnQkFDdkQsSUFBSSxJQUFJLENBQUNILGFBQWEsQ0FBQ0ksSUFBSSxHQUFHLElBQUksQ0FBQ0wsa0JBQWtCLEVBQUU7b0JBQ3JEO2dCQUNGO2dCQUVBLE1BQU1NLE1BQU0sSUFBSSxDQUFDTCxhQUFhLENBQUNNLEdBQUcsQ0FBQ0g7Z0JBQ25DLElBQUlFLFFBQVFFLGFBQWFGLElBQUlHLEtBQUssT0FBT0QsV0FBVztvQkFDbEQsSUFBSSxDQUFDUCxhQUFhLENBQUNTLE1BQU0sQ0FBQ047Z0JBQzVCO1lBQ0Y7UUFDRjtRQUVBRyxJQUFLSSxVQUFVLEVBQUU7WUFDZixNQUFNTCxNQUFNLElBQUksQ0FBQ0wsYUFBYSxDQUFDTSxHQUFH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Q0xxQyxhQUFhSjtRQUNiSyxlQUFlUDtRQUNmTyxlQUFlTjtJQUNqQjtBQUNGO0FBRUEsU0FBU04saUJBQWtCVixNQUFNO0lBQy9CckQsS0FBSzRFLE9BQU8sQ0FBQ3ZCLFFBQVEsSUFBSW5EO0FBQzNCO0FBRUEyRSxPQUFPQyxPQUFPLEdBQUc1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NvcmUvY29ubmVjdC5qcz9iNmYzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgQ29ubmVjdFRpbWVvdXRFcnJvciB9ID0gcmVxdWlyZSgnLi9lcnJvcnMnKVxuXG5sZXQgdGxzIC8vIGluY2x1ZGUgdGxzIGNvbmRpdGlvbmFsbHkgc2luY2UgaXQgaXMgbm90IGFsd2F5cyBhdmFpbGFibGVcblxuLy8gVE9ETzogc2Vzc2lvbiByZS11c2UgZG9lcyBub3Qgd2FpdCBmb3IgdGhlIGZpcnN0XG4vLyBjb25uZWN0aW9uIHRvIHJlc29sdmUgdGhlIHNlc3Npb24gYW5kIG1pZ2h0IHRoZXJlZm9yZVxuLy8gcmVzb2x2ZSB0aGUgc2FtZSBzZXJ2ZXJuYW1lIG11bHRpcGxlIHRpbWVzIGV2ZW4gd2hlblxuLy8gcmUtdXNlIGlzIGVuYWJsZWQuXG5cbmxldCBTZXNzaW9uQ2FjaGVcbi8vIEZJWE1FOiByZW1vdmUgd29ya2Fyb3VuZCB3aGVuIHRoZSBOb2RlIGJ1ZyBpcyBmaXhlZFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy80OTM0NCNpc3N1ZWNvbW1lbnQtMTc0MTc3NjMwOFxuaWYgKGdsb2JhbC5GaW5hbGl6YXRpb25SZWdpc3RyeSAmJiAhcHJvY2Vzcy5lbnYuTk9ERV9WOF9DT1ZFUkFHRSkge1xuICBTZXNzaW9uQ2FjaGUgPSBjbGFzcyBXZWFrU2Vzc2lvbkNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvciAobWF4Q2FjaGVkU2Vzc2lvbnMpIHtcbiAgICAgIHRoaXMuX21heENhY2hlZFNlc3Npb25zID0gbWF4Q2FjaGVkU2Vzc2lvbnNcbiAgICAgIHRoaXMuX3Nlc3Npb25DYWNoZSA9IG5ldyBNYXAoKVxuICAgICAgdGhpcy5fc2Vzc2lvblJlZ2lzdHJ5ID0gbmV3IGdsb2JhbC5GaW5hbGl6YXRpb25SZWdpc3RyeSgoa2V5KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9zZXNzaW9uQ2FjaGUuc2l6ZSA8IHRoaXMuX21heENhY2hlZFNlc3Npb25zKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZWYgPSB0aGlzLl9zZXNzaW9uQ2FjaGUuZ2V0KGtleSlcbiAgICAgICAgaWYgKHJlZiAhPT0gdW5kZWZpbmVkICYmIHJlZi5kZXJlZigpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLl9zZXNzaW9uQ2FjaGUuZGVsZXRlKGtleSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBnZXQgKHNlc3Npb25LZXkpIHtcbiAgICAgIGNvbnN0IHJlZiA9IHRoaXMuX3Nlc3Npb25DYWNoZS5nZXQoc2Vzc2lvbktleSlcbiAgICAgIHJldHVybiByZWYgPyByZWYuZGVyZWYoKSA6IG51bGxcbiAgICB9XG5cbiAgICBzZXQgKHNlc3Npb25LZXksIHNlc3Npb24pIHtcbiAgICAgIGlmICh0aGlzLl9tYXhDYWNoZWRTZXNzaW9ucyA9PT0gMCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2Vzc2lvbkNhY2hlLnNldChzZXNzaW9uS2V5LCBuZXcgV2Vha1JlZihzZXNzaW9uKSlcbiAgICAgIHRoaXMuX3Nlc3Npb25SZWdpc3RyeS5yZWdpc3RlcihzZXNzaW9uLCBzZXNzaW9uS2V5KVxuICAgIH1cbiAgfVxufSBlbHNlIHtcbiAgU2Vzc2lvbkNhY2hlID0gY2xhc3MgU2ltcGxlU2Vzc2lvbkNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvciAobWF4Q2FjaGVkU2Vzc2lvbnMpIHtcbiAgICAgIHRoaXMuX21heENhY2hlZFNlc3Npb25zID0gbWF4Q2FjaGVkU2Vzc2lvbnNcbiAgICAgIHRoaXMuX3Nlc3Npb25DYWNoZSA9IG5ldyBNYXAoKVxuICAgIH1cblxuICAgIGdldCAoc2Vzc2lvbktleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Nlc3Npb25DYWNoZS5nZXQoc2Vzc2lvbktleSlcbiAgICB9XG5cbiAgICBzZXQgKHNlc3Npb25LZXksIHNlc3Npb24pIHtcbiAgICAgIGlmICh0aGlzLl9tYXhDYWNoZWRTZXNzaW9ucyA9PT0gMCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3Nlc3Npb25DYWNoZS5zaXplID49IHRoaXMuX21heENhY2hlZFNlc3Npb25zKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgb2xkZXN0IHNlc3Npb25cbiAgICAgICAgY29uc3QgeyB2YWx1ZTogb2xkZXN0S2V5IH0gPSB0aGlzLl9zZXNzaW9uQ2FjaGUua2V5cygpLm5leHQoKVxuICAgICAgICB0aGlzLl9zZXNzaW9uQ2FjaGUuZGVsZXRlKG9sZGVzdEtleSlcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2Vzc2lvbkNhY2hlLnNldChzZXNzaW9uS2V5LCBzZXNzaW9uKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZENvbm5lY3RvciAoeyBhbGxvd0gyLCBtYXhDYWNoZWRTZXNzaW9ucywgc29ja2V0UGF0aCwgdGltZW91dCwgLi4ub3B0cyB9KSB7XG4gIGlmIChtYXhDYWNoZWRTZXNzaW9ucyAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihtYXhDYWNoZWRTZXNzaW9ucykgfHwgbWF4Q2FjaGVkU2Vzc2lvbnMgPCAwKSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWF4Q2FjaGVkU2Vzc2lvbnMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgemVybycpXG4gIH1cblxuICBjb25zdCBvcHRpb25zID0geyBwYXRoOiBzb2NrZXRQYXRoLCAuLi5vcHRzIH1cbiAgY29uc3Qgc2Vzc2lvbkNhY2hlID0gbmV3IFNlc3Npb25DYWNoZShtYXhDYWNoZWRTZXNzaW9ucyA9PSBudWxsID8gMTAwIDogbWF4Q2FjaGVkU2Vzc2lvbnMpXG4gIHRpbWVvdXQgPSB0aW1lb3V0ID09IG51bGwgPyAxMGUzIDogdGltZW91dFxuICBhbGxvd0gyID0gYWxsb3dIMiAhPSBudWxsID8gYWxsb3dIMiA6IGZhbHNlXG4gIHJldHVybiBmdW5jdGlvbiBjb25uZWN0ICh7IGhvc3RuYW1lLCBob3N0LCBwcm90b2NvbCwgcG9ydCwgc2VydmVybmFtZSwgbG9jYWxBZGRyZXNzLCBodHRwU29ja2V0IH0sIGNhbGxiYWNrKSB7XG4gICAgbGV0IHNvY2tldFxuICAgIGlmIChwcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICAgIGlmICghdGxzKSB7XG4gICAgICAgIHRscyA9IHJlcXVpcmUoJ3RscycpXG4gICAgICB9XG4gICAgICBzZXJ2ZXJuYW1lID0gc2VydmVybmFtZSB8fCBvcHRpb25zLnNlcnZlcm5hbWUgfHwgdXRpbC5nZXRTZXJ2ZXJOYW1lKGhvc3QpIHx8IG51bGxcblxuICAgICAgY29uc3Qgc2Vzc2lvbktleSA9IHNlcnZlcm5hbWUgfHwgaG9zdG5hbWVcbiAgICAgIGNvbnN0IHNlc3Npb24gPSBzZXNzaW9uQ2FjaGUuZ2V0KHNlc3Npb25LZXkpIHx8IG51bGxcblxuICAgICAgYXNzZXJ0KHNlc3Npb25LZXkpXG5cbiAgICAgIHNvY2tldCA9IHRscy5jb25uZWN0KHtcbiAgICAgICAgaGlnaFdhdGVyTWFyazogMTYzODQsIC8vIFRMUyBpbiBub2RlIGNhbid0IGhhdmUgYmlnZ2VyIEhXTSBhbnl3YXkuLi5cbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgc2VydmVybmFtZSxcbiAgICAgICAgc2Vzc2lvbixcbiAgICAgICAgbG9jYWxBZGRyZXNzLFxuICAgICAgICAvLyBUT0RPKEhUVFAvMik6IEFkZCBzdXBwb3J0IGZvciBoMmNcbiAgICAgICAgQUxQTlByb3RvY29sczogYWxsb3dIMiA/IFsnaHR0cC8xLjEnLCAnaDInXSA6IFsnaHR0cC8xLjEnXSxcbiAgICAgICAgc29ja2V0OiBodHRwU29ja2V0LCAvLyB1cGdyYWRlIHNvY2tldCBjb25uZWN0aW9uXG4gICAgICAgIHBvcnQ6IHBvcnQgfHwgNDQzLFxuICAgICAgICBob3N0OiBob3N0bmFtZVxuICAgICAgfSlcblxuICAgICAgc29ja2V0XG4gICAgICAgIC5vbignc2Vzc2lvbicsIGZ1bmN0aW9uIChzZXNzaW9uKSB7XG4gICAgICAgICAgLy8gVE9ETyAoZml4KTogQ2FuIGEgc2Vzc2lvbiBiZWNvbWUgaW52YWxpZCBvbmNlIGVzdGFibGlzaGVkPyBEb24ndCB0aGluayBzbz9cbiAgICAgICAgICBzZXNzaW9uQ2FjaGUuc2V0KHNlc3Npb25LZXksIHNlc3Npb24pXG4gICAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydCghaHR0cFNvY2tldCwgJ2h0dHBTb2NrZXQgY2FuIG9ubHkgYmUgc2VudCBvbiBUTFMgdXBkYXRlJylcbiAgICAgIHNvY2tldCA9IG5ldC5jb25uZWN0KHtcbiAgICAgICAgaGlnaFdhdGVyTWFyazogNjQgKiAxMDI0LCAvLyBTYW1lIGFzIG5vZGVqcyBmcyBzdHJlYW1zLlxuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBsb2NhbEFkZHJlc3MsXG4gICAgICAgIHBvcnQ6IHBvcnQgfHwgODAsXG4gICAgICAgIGhvc3Q6IGhvc3RuYW1lXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIFNldCBUQ1Aga2VlcCBhbGl2ZSBvcHRpb25zIG9uIHRoZSBzb2NrZXQgaGVyZSBpbnN0ZWFkIG9mIGluIGNvbm5lY3QoKSBmb3IgdGhlIGNhc2Ugb2YgYXNzaWduaW5nIHRoZSBzb2NrZXRcbiAgICBpZiAob3B0aW9ucy5rZWVwQWxpdmUgPT0gbnVsbCB8fCBvcHRpb25zLmtlZXBBbGl2ZSkge1xuICAgICAgY29uc3Qga2VlcEFsaXZlSW5pdGlhbERlbGF5ID0gb3B0aW9ucy5rZWVwQWxpdmVJbml0aWFsRGVsYXkgPT09IHVuZGVmaW5lZCA/IDYwZTMgOiBvcHRpb25zLmtlZXBBbGl2ZUluaXRpYWxEZWxheVxuICAgICAgc29ja2V0LnNldEtlZXBBbGl2ZSh0cnVlLCBrZWVwQWxpdmVJbml0aWFsRGVsYXkpXG4gICAgfVxuXG4gICAgY29uc3QgY2FuY2VsVGltZW91dCA9IHNldHVwVGltZW91dCgoKSA9PiBvbkNvbm5lY3RUaW1lb3V0KHNvY2tldCksIHRpbWVvdXQpXG5cbiAgICBzb2NrZXRcbiAgICAgIC5zZXROb0RlbGF5KHRydWUpXG4gICAgICAub25jZShwcm90b2NvbCA9PT0gJ2h0dHBzOicgPyAnc2VjdXJlQ29ubmVjdCcgOiAnY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FuY2VsVGltZW91dCgpXG5cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY29uc3QgY2IgPSBjYWxsYmFja1xuICAgICAgICAgIGNhbGxiYWNrID0gbnVsbFxuICAgICAgICAgIGNiKG51bGwsIHRoaXMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBjYW5jZWxUaW1lb3V0KClcblxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjb25zdCBjYiA9IGNhbGxiYWNrXG4gICAgICAgICAgY2FsbGJhY2sgPSBudWxsXG4gICAgICAgICAgY2IoZXJyKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgcmV0dXJuIHNvY2tldFxuICB9XG59XG5cbmZ1bmN0aW9uIHNldHVwVGltZW91dCAob25Db25uZWN0VGltZW91dCwgdGltZW91dCkge1xuICBpZiAoIXRpbWVvdXQpIHtcbiAgICByZXR1cm4gKCkgPT4ge31cbiAgfVxuXG4gIGxldCBzMSA9IG51bGxcbiAgbGV0IHMyID0gbnVsbFxuICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAvLyBzZXRJbW1lZGlhdGUgaXMgYWRkZWQgdG8gbWFrZSBzdXJlIHRoYXQgd2UgcHJpb3RvcmlzZSBzb2NrZXQgZXJyb3IgZXZlbnRzIG92ZXIgdGltZW91dHNcbiAgICBzMSA9IHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgICAgICAvLyBXaW5kb3dzIG5lZWRzIGFuIGV4dHJhIHNldEltbWVkaWF0ZSBwcm9iYWJseSBkdWUgdG8gaW1wbGVtZW50YXRpb24gZGlmZmVyZW5jZXMgaW4gdGhlIHNvY2tldCBsb2dpY1xuICAgICAgICBzMiA9IHNldEltbWVkaWF0ZSgoKSA9PiBvbkNvbm5lY3RUaW1lb3V0KCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbkNvbm5lY3RUaW1lb3V0KClcbiAgICAgIH1cbiAgICB9KVxuICB9LCB0aW1lb3V0KVxuICByZXR1cm4gKCkgPT4ge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpXG4gICAgY2xlYXJJbW1lZGlhdGUoczEpXG4gICAgY2xlYXJJbW1lZGlhdGUoczIpXG4gIH1cbn1cblxuZnVuY3Rpb24gb25Db25uZWN0VGltZW91dCAoc29ja2V0KSB7XG4gIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBDb25uZWN0VGltZW91dEVycm9yKCkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnVpbGRDb25uZWN0b3JcbiJdLCJuYW1lcyI6WyJuZXQiLCJyZXF1aXJlIiwiYXNzZXJ0IiwidXRpbCIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiQ29ubmVjdFRpbWVvdXRFcnJvciIsInRscyIsIlNlc3Npb25DYWNoZSIsImdsb2JhbCIsIkZpbmFsaXphdGlvblJlZ2lzdHJ5IiwicHJvY2VzcyIsImVudiIsIk5PREVfVjhfQ09WRVJBR0UiLCJXZWFrU2Vzc2lvbkNhY2hlIiwiY29uc3RydWN0b3IiLCJtYXhDYWNoZWRTZXNzaW9ucyIsIl9tYXhDYWNoZWRTZXNzaW9ucyIsIl9zZXNzaW9uQ2FjaGUiLCJNYXAiLCJfc2Vzc2lvblJlZ2lzdHJ5Iiwia2V5Iiwic2l6ZSIsInJlZiIsImdldCIsInVuZGVmaW5lZCIsImRlcmVmIiwiZGVsZXRlIiwic2Vzc2lvbktleSIsInNldCIsInNlc3Npb24iLCJXZWFrUmVmIiwicmVnaXN0ZXIiLCJTaW1wbGVTZXNzaW9uQ2FjaGUiLCJ2YWx1ZSIsIm9sZGVzdEtleSIsImtleXMiLCJuZXh0IiwiYnVpbGRDb25uZWN0b3IiLCJhbGxvd0gyIiwic29ja2V0UGF0aCIsInRpbWVvdXQiLCJvcHRzIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwib3B0aW9ucyIsInBhdGgiLCJzZXNzaW9uQ2FjaGUiLCJjb25uZWN0IiwiaG9zdG5hbWUiLCJob3N0IiwicHJvdG9jb2wiLCJwb3J0Iiwic2VydmVybmFtZSIsImxvY2FsQWRkcmVzcyIsImh0dHBTb2NrZXQiLCJjYWxsYmFjayIsInNvY2tldCIsImdldFNlcnZlck5hbWUiLCJoaWdoV2F0ZXJNYXJrIiwiQUxQTlByb3RvY29scyIsIm9uIiwia2VlcEFsaXZlIiwia2VlcEFsaXZlSW5pdGlhbERlbGF5Iiwic2V0S2VlcEFsaXZlIiwiY2FuY2VsVGltZW91dCIsInNldHVwVGltZW91dCIsIm9uQ29ubmVjdFRpbWVvdXQiLCJzZXROb0RlbGF5Iiwib25jZSIsImNiIiwiZXJyIiwiczEiLCJzMiIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJzZXRJbW1lZGlhdGUiLCJwbGF0Zm9ybSIsImNsZWFyVGltZW91dCIsImNsZWFySW1tZWRpYXRlIiwiZGVzdHJveSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/core/connect.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js":
/*!**********************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/core/errors.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\nclass UndiciError extends Error {\n    constructor(message){\n        super(message);\n        this.name = \"UndiciError\";\n        this.code = \"UND_ERR\";\n    }\n}\nclass ConnectTimeoutError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, ConnectTimeoutError);\n        this.name = \"ConnectTimeoutError\";\n        this.message = message || \"Connect Timeout Error\";\n        this.code = \"UND_ERR_CONNECT_TIMEOUT\";\n    }\n}\nclass HeadersTimeoutError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, HeadersTimeoutError);\n        this.name = \"HeadersTimeoutError\";\n        this.message = message || \"Headers Timeout Error\";\n        this.code = \"UND_ERR_HEADERS_TIMEOUT\";\n    }\n}\nclass HeadersOverflowError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, HeadersOverflowError);\n        this.name = \"HeadersOverflowError\";\n        this.message = message || \"Headers Overflow Error\";\n        this.code = \"UND_ERR_HEADERS_OVERFLOW\";\n    }\n}\nclass BodyTimeoutError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, BodyTimeoutError);\n        this.name = \"BodyTimeoutError\";\n        this.message = message || \"Body Timeout Error\";\n        this.code = \"UND_ERR_BODY_TIMEOUT\";\n    }\n}\nclass ResponseStatusCodeError extends UndiciError {\n    constructor(message, statusCode, headers, body){\n        super(message);\n        Error.captureStackTrace(this, ResponseStatusCodeError);\n        this.name = \"ResponseStatusCodeError\";\n        this.message = message || \"Response Status Code Error\";\n        this.code = \"UND_ERR_RESPONSE_STATUS_CODE\";\n        this.body = body;\n        this.status = statusCode;\n        this.statusCode = statusCode;\n        this.headers = headers;\n    }\n}\nclass InvalidArgumentError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, InvalidArgumentError);\n        this.name = \"InvalidArgumentError\";\n        this.message = message || \"Invalid Argument Error\";\n        this.code = \"UND_ERR_INVALID_ARG\";\n    }\n}\nclass InvalidReturnValueError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, InvalidReturnValueError);\n        this.name = \"InvalidReturnValueError\";\n        this.message = message || \"Invalid Return Value Error\";\n        this.code = \"UND_ERR_INVALID_RETURN_VALUE\";\n    }\n}\nclass RequestAbortedError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, RequestAbortedError);\n        this.name = \"AbortError\";\n        this.message = message || \"Request aborted\";\n        this.code = \"UND_ERR_ABORTED\";\n    }\n}\nclass InformationalError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, InformationalError);\n        this.name = \"InformationalError\";\n        this.message = message || \"Request information\";\n        this.code = \"UND_ERR_INFO\";\n    }\n}\nclass RequestContentLengthMismatchError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, RequestContentLengthMismatchError);\n        this.name = \"RequestContentLengthMismatchError\";\n        this.message = message || \"Request body length does not match content-length header\";\n        this.code = \"UND_ERR_REQ_CONTENT_LENGTH_MISMATCH\";\n    }\n}\nclass ResponseContentLengthMismatchError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, ResponseContentLengthMismatchError);\n        this.name = \"ResponseContentLengthMismatchError\";\n        this.message = message || \"Response body length does not match content-length header\";\n        this.code = \"UND_ERR_RES_CONTENT_LENGTH_MISMATCH\";\n    }\n}\nclass ClientDestroyedError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, ClientDestroyedError);\n        this.name = \"ClientDestroyedError\";\n        this.message = message || \"The client is destroyed\";\n        this.code = \"UND_ERR_DESTROYED\";\n    }\n}\nclass ClientClosedError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, ClientClosedError);\n        this.name = \"ClientClosedError\";\n        this.message = message || \"The client is closed\";\n        this.code = \"UND_ERR_CLOSED\";\n    }\n}\nclass SocketError extends UndiciError {\n    constructor(message, socket){\n        super(message);\n        Error.captureStackTrace(this, SocketError);\n        this.name = \"SocketError\";\n        this.message = message || \"Socket error\";\n        this.code = \"UND_ERR_SOCKET\";\n        this.socket = socket;\n    }\n}\nclass NotSupportedError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, NotSupportedError);\n        this.name = \"NotSupportedError\";\n        this.message = message || \"Not supported error\";\n        this.code = \"UND_ERR_NOT_SUPPORTED\";\n    }\n}\nclass BalancedPoolMissingUpstreamError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, NotSupportedError);\n        this.name = \"MissingUpstreamError\";\n        this.message = message || \"No upstream has been added to the BalancedPool\";\n        this.code = \"UND_ERR_BPL_MISSING_UPSTREAM\";\n    }\n}\nclass HTTPParserError extends Error {\n    constructor(message, code, data){\n        super(message);\n        Error.captureStackTrace(this, HTTPParserError);\n        this.name = \"HTTPParserError\";\n        this.code = code ? `HPE_${code}` : undefined;\n        this.data = data ? data.toString() : undefined;\n    }\n}\nclass ResponseExceededMaxSizeError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, ResponseExceededMaxSizeError);\n        this.name = \"ResponseExceededMaxSizeError\";\n        this.message = message || \"Response content exceeded max size\";\n        this.code = \"UND_ERR_RES_EXCEEDED_MAX_SIZE\";\n    }\n}\nclass RequestRetryError extends UndiciError {\n    constructor(message, code, { headers, data }){\n        super(message);\n        Error.captureStackTrace(this, RequestRetryError);\n        this.name = \"RequestRetryError\";\n        this.message = message || \"Request retry error\";\n        this.code = \"UND_ERR_REQ_RETRY\";\n        this.statusCode = code;\n        this.data = data;\n        this.headers = headers;\n    }\n}\nmodule.exports = {\n    HTTPParserError,\n    UndiciError,\n    HeadersTimeoutError,\n    HeadersOverflowError,\n    BodyTimeoutError,\n    RequestContentLengthMismatchError,\n    ConnectTimeoutError,\n    ResponseStatusCodeError,\n    InvalidArgumentError,\n    InvalidReturnValueError,\n    RequestAbortedError,\n    ClientDestroyedError,\n    ClientClosedError,\n    InformationalError,\n    SocketError,\n    NotSupportedError,\n    ResponseContentLengthMismatchError,\n    BalancedPoolMissingUpstreamError,\n    ResponseExceededMaxSizeError,\n    RequestRetryError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxvQkFBb0JDO0lBQ3hCQyxZQUFhQyxPQUFPLENBQUU7UUFDcEIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDZDtBQUNGO0FBRUEsTUFBTUMsNEJBQTRCTjtJQUNoQ0UsWUFBYUMsT0FBTyxDQUFFO1FBQ3BCLEtBQUssQ0FBQ0E7UUFDTkYsTUFBTU0saUJBQWlCLENBQUMsSUFBSSxFQUFFRDtRQUM5QixJQUFJLENBQUNGLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0QsT0FBTyxHQUFHQSxXQUFXO1FBQzFCLElBQUksQ0FBQ0UsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVBLE1BQU1HLDRCQUE0QlI7SUFDaENFLFlBQWFDLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBO1FBQ05GLE1BQU1NLGlCQUFpQixDQUFDLElBQUksRUFBRUM7UUFDOUIsSUFBSSxDQUFDSixJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNELE9BQU8sR0FBR0EsV0FBVztRQUMxQixJQUFJLENBQUNFLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFFQSxNQUFNSSw2QkFBNkJUO0lBQ2pDRSxZQUFhQyxPQUFPLENBQUU7UUFDcEIsS0FBSyxDQUFDQTtRQUNORixNQUFNTSxpQkFBaUIsQ0FBQyxJQUFJLEVBQUVFO1FBQzlCLElBQUksQ0FBQ0wsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDRCxPQUFPLEdBQUdBLFdBQVc7UUFDMUIsSUFBSSxDQUFDRSxJQUFJLEdBQUc7SUFDZDtBQUNGO0FBRUEsTUFBTUsseUJBQXlCVjtJQUM3QkUsWUFBYUMsT0FBTyxDQUFFO1FBQ3BCLEtBQUssQ0FBQ0E7UUFDTkYsTUFBTU0saUJBQWlCLENBQUMsSUFBSSxFQUFFRztRQUM5QixJ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QjtRQUM5QixJQUFJLENBQUN4QixJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLElBQUksR0FBR0EsT0FBTyxDQUFDLElBQUksRUFBRUEsS0FBSyxDQUFDLEdBQUd5QjtRQUNuQyxJQUFJLENBQUNELElBQUksR0FBR0EsT0FBT0EsS0FBS0UsUUFBUSxLQUFLRDtJQUN2QztBQUNGO0FBRUEsTUFBTUUscUNBQXFDaEM7SUFDekNFLFlBQWFDLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBO1FBQ05GLE1BQU1NLGlCQUFpQixDQUFDLElBQUksRUFBRXlCO1FBQzlCLElBQUksQ0FBQzVCLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0QsT0FBTyxHQUFHQSxXQUFXO1FBQzFCLElBQUksQ0FBQ0UsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVBLE1BQU00QiwwQkFBMEJqQztJQUM5QkUsWUFBYUMsT0FBTyxFQUFFRSxJQUFJLEVBQUUsRUFBRVEsT0FBTyxFQUFFZ0IsSUFBSSxFQUFFLENBQUU7UUFDN0MsS0FBSyxDQUFDMUI7UUFDTkYsTUFBTU0saUJBQWlCLENBQUMsSUFBSSxFQUFFMEI7UUFDOUIsSUFBSSxDQUFDN0IsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDRCxPQUFPLEdBQUdBLFdBQVc7UUFDMUIsSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNPLFVBQVUsR0FBR1A7UUFDbEIsSUFBSSxDQUFDd0IsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ2hCLE9BQU8sR0FBR0E7SUFDakI7QUFDRjtBQUVBcUIsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZQO0lBQ0E1QjtJQUNBUTtJQUNBQztJQUNBQztJQUNBVTtJQUNBZDtJQUNBSztJQUNBSztJQUNBQztJQUNBQztJQUNBSTtJQUNBQztJQUNBSjtJQUNBSztJQUNBRTtJQUNBTDtJQUNBTTtJQUNBSztJQUNBQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1maWdodGVyLWFjYWRlbXkvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS9lcnJvcnMuanM/NWYwMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY2xhc3MgVW5kaWNpRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnVW5kaWNpRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlInXG4gIH1cbn1cblxuY2xhc3MgQ29ubmVjdFRpbWVvdXRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIENvbm5lY3RUaW1lb3V0RXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ0Nvbm5lY3RUaW1lb3V0RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnQ29ubmVjdCBUaW1lb3V0IEVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0NPTk5FQ1RfVElNRU9VVCdcbiAgfVxufVxuXG5jbGFzcyBIZWFkZXJzVGltZW91dEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSGVhZGVyc1RpbWVvdXRFcnJvcilcbiAgICB0aGlzLm5hbWUgPSAnSGVhZGVyc1RpbWVvdXRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdIZWFkZXJzIFRpbWVvdXQgRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfSEVBREVSU19USU1FT1VUJ1xuICB9XG59XG5cbmNsYXNzIEhlYWRlcnNPdmVyZmxvd0Vycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSGVhZGVyc092ZXJmbG93RXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ0hlYWRlcnNPdmVyZmxvd0Vycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0hlYWRlcnMgT3ZlcmZsb3cgRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfSEVBREVSU19PVkVSRkxPVydcbiAgfVxufVxuXG5jbGFzcyBCb2R5VGltZW91dEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQm9keVRpbWVvdXRFcnJvcilcbiAgICB0aGlzLm5hbWUgPSAnQm9keVRpbWVvdXRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdCb2R5IFRpbWVvdXQgRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfQk9EWV9USU1FT1VUJ1xuICB9XG59XG5cbmNsYXNzIFJlc3BvbnNlU3RhdHVzQ29kZUVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgc3RhdHVzQ29kZSwgaGVhZGVycywgYm9keSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ1Jlc3BvbnNlU3RhdHVzQ29kZUVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1Jlc3BvbnNlIFN0YXR1cyBDb2RlIEVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX1JFU1BPTlNFX1NUQVRVU19DT0RFJ1xuICAgIHRoaXMuYm9keSA9IGJvZHlcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1c0NvZGVcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlXG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVyc1xuICB9XG59XG5cbmNsYXNzIEludmFsaWRBcmd1bWVudEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSW52YWxpZEFyZ3VtZW50RXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ0ludmFsaWRBcmd1bWVudEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0ludmFsaWQgQXJndW1lbnQgRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfSU5WQUxJRF9BUkcnXG4gIH1cbn1cblxuY2xhc3MgSW52YWxpZFJldHVyblZhbHVlRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcilcbiAgICB0aGlzLm5hbWUgPSAnSW52YWxpZFJldHVyblZhbHVlRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnSW52YWxpZCBSZXR1cm4gVmFsdWUgRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUnXG4gIH1cbn1cblxuY2xhc3MgUmVxdWVzdEFib3J0ZWRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFJlcXVlc3RBYm9ydGVkRXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ0Fib3J0RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnUmVxdWVzdCBhYm9ydGVkJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0FCT1JURUQnXG4gIH1cbn1cblxuY2xhc3MgSW5mb3JtYXRpb25hbEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSW5mb3JtYXRpb25hbEVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdJbmZvcm1hdGlvbmFsRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnUmVxdWVzdCBpbmZvcm1hdGlvbidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9JTkZPJ1xuICB9XG59XG5cbmNsYXNzIFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcilcbiAgICB0aGlzLm5hbWUgPSAnUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1JlcXVlc3QgYm9keSBsZW5ndGggZG9lcyBub3QgbWF0Y2ggY29udGVudC1sZW5ndGggaGVhZGVyJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX1JFUV9DT05URU5UX0xFTkdUSF9NSVNNQVRDSCdcbiAgfVxufVxuXG5jbGFzcyBSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcilcbiAgICB0aGlzLm5hbWUgPSAnUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdSZXNwb25zZSBib2R5IGxlbmd0aCBkb2VzIG5vdCBtYXRjaCBjb250ZW50LWxlbmd0aCBoZWFkZXInXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfUkVTX0NPTlRFTlRfTEVOR1RIX01JU01BVENIJ1xuICB9XG59XG5cbmNsYXNzIENsaWVudERlc3Ryb3llZEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ2xpZW50RGVzdHJveWVkRXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ0NsaWVudERlc3Ryb3llZEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1RoZSBjbGllbnQgaXMgZGVzdHJveWVkJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0RFU1RST1lFRCdcbiAgfVxufVxuXG5jbGFzcyBDbGllbnRDbG9zZWRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIENsaWVudENsb3NlZEVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdDbGllbnRDbG9zZWRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdUaGUgY2xpZW50IGlzIGNsb3NlZCdcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9DTE9TRUQnXG4gIH1cbn1cblxuY2xhc3MgU29ja2V0RXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlLCBzb2NrZXQpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFNvY2tldEVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdTb2NrZXRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdTb2NrZXQgZXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfU09DS0VUJ1xuICAgIHRoaXMuc29ja2V0ID0gc29ja2V0XG4gIH1cbn1cblxuY2xhc3MgTm90U3VwcG9ydGVkRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBOb3RTdXBwb3J0ZWRFcnJvcilcbiAgICB0aGlzLm5hbWUgPSAnTm90U3VwcG9ydGVkRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnTm90IHN1cHBvcnRlZCBlcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9OT1RfU1VQUE9SVEVEJ1xuICB9XG59XG5cbmNsYXNzIEJhbGFuY2VkUG9vbE1pc3NpbmdVcHN0cmVhbUVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgTm90U3VwcG9ydGVkRXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ01pc3NpbmdVcHN0cmVhbUVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ05vIHVwc3RyZWFtIGhhcyBiZWVuIGFkZGVkIHRvIHRoZSBCYWxhbmNlZFBvb2wnXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfQlBMX01JU1NJTkdfVVBTVFJFQU0nXG4gIH1cbn1cblxuY2xhc3MgSFRUUFBhcnNlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgY29kZSwgZGF0YSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSFRUUFBhcnNlckVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdIVFRQUGFyc2VyRXJyb3InXG4gICAgdGhpcy5jb2RlID0gY29kZSA/IGBIUEVfJHtjb2RlfWAgOiB1bmRlZmluZWRcbiAgICB0aGlzLmRhdGEgPSBkYXRhID8gZGF0YS50b1N0cmluZygpIDogdW5kZWZpbmVkXG4gIH1cbn1cblxuY2xhc3MgUmVzcG9uc2VFeGNlZWRlZE1heFNpemVFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ1Jlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnUmVzcG9uc2UgY29udGVudCBleGNlZWRlZCBtYXggc2l6ZSdcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9SRVNfRVhDRUVERURfTUFYX1NJWkUnXG4gIH1cbn1cblxuY2xhc3MgUmVxdWVzdFJldHJ5RXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlLCBjb2RlLCB7IGhlYWRlcnMsIGRhdGEgfSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUmVxdWVzdFJldHJ5RXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ1JlcXVlc3RSZXRyeUVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1JlcXVlc3QgcmV0cnkgZXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfUkVRX1JFVFJZJ1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IGNvZGVcbiAgICB0aGlzLmRhdGEgPSBkYXRhXG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVyc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBIVFRQUGFyc2VyRXJyb3IsXG4gIFVuZGljaUVycm9yLFxuICBIZWFkZXJzVGltZW91dEVycm9yLFxuICBIZWFkZXJzT3ZlcmZsb3dFcnJvcixcbiAgQm9keVRpbWVvdXRFcnJvcixcbiAgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yLFxuICBDb25uZWN0VGltZW91dEVycm9yLFxuICBSZXNwb25zZVN0YXR1c0NvZGVFcnJvcixcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIEludmFsaWRSZXR1cm5WYWx1ZUVycm9yLFxuICBSZXF1ZXN0QWJvcnRlZEVycm9yLFxuICBDbGllbnREZXN0cm95ZWRFcnJvcixcbiAgQ2xpZW50Q2xvc2VkRXJyb3IsXG4gIEluZm9ybWF0aW9uYWxFcnJvcixcbiAgU29ja2V0RXJyb3IsXG4gIE5vdFN1cHBvcnRlZEVycm9yLFxuICBSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yLFxuICBCYWxhbmNlZFBvb2xNaXNzaW5nVXBzdHJlYW1FcnJvcixcbiAgUmVzcG9uc2VFeGNlZWRlZE1heFNpemVFcnJvcixcbiAgUmVxdWVzdFJldHJ5RXJyb3Jcbn1cbiJdLCJuYW1lcyI6WyJVbmRpY2lFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwibmFtZSIsImNvZGUiLCJDb25uZWN0VGltZW91dEVycm9yIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJIZWFkZXJzVGltZW91dEVycm9yIiwiSGVhZGVyc092ZXJmbG93RXJyb3IiLCJCb2R5VGltZW91dEVycm9yIiwiUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IiLCJzdGF0dXNDb2RlIiwiaGVhZGVycyIsImJvZHkiLCJzdGF0dXMiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIkludmFsaWRSZXR1cm5WYWx1ZUVycm9yIiwiUmVxdWVzdEFib3J0ZWRFcnJvciIsIkluZm9ybWF0aW9uYWxFcnJvciIsIlJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvciIsIlJlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3IiLCJDbGllbnREZXN0cm95ZWRFcnJvciIsIkNsaWVudENsb3NlZEVycm9yIiwiU29ja2V0RXJyb3IiLCJzb2NrZXQiLCJOb3RTdXBwb3J0ZWRFcnJvciIsIkJhbGFuY2VkUG9vbE1pc3NpbmdVcHN0cmVhbUVycm9yIiwiSFRUUFBhcnNlckVycm9yIiwiZGF0YSIsInVuZGVmaW5lZCIsInRvU3RyaW5nIiwiUmVzcG9uc2VFeGNlZWRlZE1heFNpemVFcnJvciIsIlJlcXVlc3RSZXRyeUVycm9yIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/core/request.js":
/*!***********************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/core/request.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { InvalidArgumentError, NotSupportedError } = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\");\nconst util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\n// tokenRegExp and headerCharRegex have been lifted from\n// https://github.com/nodejs/node/blob/main/lib/_http_common.js\n/**\n * Verifies that the given val is a valid HTTP token\n * per the rules defined in RFC 7230\n * See https://tools.ietf.org/html/rfc7230#section-3.2.6\n */ const tokenRegExp = /^[\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]+$/;\n/**\n * Matches if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n */ const headerCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n// Verifies that a given path is valid does not contain control chars \\x00 to \\x20\nconst invalidPathRegex = /[^\\u0021-\\u00ff]/;\nconst kHandler = Symbol(\"handler\");\nconst channels = {};\nlet extractBody;\ntry {\n    const diagnosticsChannel = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\");\n    channels.create = diagnosticsChannel.channel(\"undici:request:create\");\n    channels.bodySent = diagnosticsChannel.channel(\"undici:request:bodySent\");\n    channels.headers = diagnosticsChannel.channel(\"undici:request:headers\");\n    channels.trailers = diagnosticsChannel.channel(\"undici:request:trailers\");\n    channels.error = diagnosticsChannel.channel(\"undici:request:error\");\n} catch  {\n    channels.create = {\n        hasSubscribers: false\n    };\n    channels.bodySent = {\n        hasSubscribers: false\n    };\n    channels.headers = {\n        hasSubscribers: false\n    };\n    channels.trailers = {\n        hasSubscribers: false\n    };\n    channels.error = {\n        hasSubscribers: false\n    };\n}\nclass Request {\n    constructor(origin, { path, method, body, headers, query, idempotent, blocking, upgrade, headersTimeout, bodyTimeout, reset, throwOnError, expectContinue }, handler){\n        if (typeof path !== \"string\") {\n            throw new InvalidArgumentError(\"path must be a string\");\n        } else if (path[0] !== \"/\" && !(path.startsWith(\"http://\") || path.startsWith(\"https://\")) && method !== \"CONNECT\") {\n            throw new InvalidArgumentError(\"path must be an absolute URL or start with a slash\");\n        } else if (invalidPathRegex.exec(path) !== null) {\n            throw new InvalidArgumentError(\"invalid request path\");\n        }\n        if (typeof method !== \"string\") {\n            throw new InvalidArgumentError(\"method must be a string\");\n        } else if (tokenRegExp.exec(method) === null) {\n            throw new InvalidArgumentError(\"invalid request method\");\n        }\n        if (upgrade && typeof upgrade !== \"string\") {\n            throw new InvalidArgumentError(\"upgrade must be a string\");\n        }\n        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {\n            throw new InvalidArgumentError(\"invalid headersTimeout\");\n        }\n        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {\n            throw new InvalidArgumentError(\"invalid bodyTimeout\");\n        }\n        if (reset != null && typeof reset !== \"boolean\") {\n            throw new InvalidArgumentError(\"invalid reset\");\n        }\n        if (expectContinue != null && typeof expectContinue !== \"boolean\") {\n            throw new InvalidArgumentError(\"invalid expectContinue\");\n        }\n        this.headersTimeout = headersTimeout;\n        this.bodyTimeout = bodyTimeout;\n        this.throwOnError = throwOnError === true;\n        this.method = method;\n        this.abort = null;\n        if (body == null) {\n            this.body = null;\n        } else if (util.isStream(body)) {\n            this.body = body;\n            const rState = this.body._readableState;\n            if (!rState || !rState.autoDestroy) {\n                this.endHandler = function autoDestroy() {\n                    util.destroy(this);\n                };\n                this.body.on(\"end\", this.endHandler);\n            }\n            this.errorHandler = (err)=>{\n                if (this.abort) {\n                    this.abort(err);\n                } else {\n                    this.error = err;\n                }\n            };\n            this.body.on(\"error\", this.errorHandler);\n        } else if (util.isBuffer(body)) {\n            this.body = body.byteLength ? body : null;\n        } else if (ArrayBuffer.isView(body)) {\n            this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;\n        } else if (body instanceof ArrayBuffer) {\n            this.body = body.byteLength ? Buffer.from(body) : null;\n        } else if (typeof body === \"string\") {\n            this.body = body.length ? Buffer.from(body) : null;\n        } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {\n            this.body = body;\n        } else {\n            throw new InvalidArgumentError(\"body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable\");\n        }\n        this.completed = false;\n        this.aborted = false;\n        this.upgrade = upgrade || null;\n        this.path = query ? util.buildURL(path, query) : path;\n        this.origin = origin;\n        this.idempotent = idempotent == null ? method === \"HEAD\" || method === \"GET\" : idempotent;\n        this.blocking = blocking == null ? false : blocking;\n        this.reset = reset == null ? null : reset;\n        this.host = null;\n        this.contentLength = null;\n        this.contentType = null;\n        this.headers = \"\";\n        // Only for H2\n        this.expectContinue = expectContinue != null ? expectContinue : false;\n        if (Array.isArray(headers)) {\n            if (headers.length % 2 !== 0) {\n                throw new InvalidArgumentError(\"headers array must be even\");\n            }\n            for(let i = 0; i < headers.length; i += 2){\n                processHeader(this, headers[i], headers[i + 1]);\n            }\n        } else if (headers && typeof headers === \"object\") {\n            const keys = Object.keys(headers);\n            for(let i = 0; i < keys.length; i++){\n                const key = keys[i];\n                processHeader(this, key, headers[key]);\n            }\n        } else if (headers != null) {\n            throw new InvalidArgumentError(\"headers must be an object or an array\");\n        }\n        if (util.isFormDataLike(this.body)) {\n            if (util.nodeMajor < 16 || util.nodeMajor === 16 && util.nodeMinor < 8) {\n                throw new InvalidArgumentError(\"Form-Data bodies are only supported in node v16.8 and newer.\");\n            }\n            if (!extractBody) {\n                extractBody = (__webpack_require__(/*! ../fetch/body.js */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/body.js\").extractBody);\n            }\n            const [bodyStream, contentType] = extractBody(body);\n            if (this.contentType == null) {\n                this.contentType = contentType;\n                this.headers += `content-type: ${contentType}\\r\\n`;\n            }\n            this.body = bodyStream.stream;\n            this.contentLength = bodyStream.length;\n        } else if (util.isBlobLike(body) && this.contentType == null && body.type) {\n            this.contentType = body.type;\n            this.headers += `content-type: ${body.type}\\r\\n`;\n        }\n        util.validateHandler(handler, method, upgrade);\n        this.servername = util.getServerName(this.host);\n        this[kHandler] = handler;\n        if (channels.create.hasSubscribers) {\n            channels.create.publish({\n                request: this\n            });\n        }\n    }\n    onBodySent(chunk) {\n        if (this[kHandler].onBodySent) {\n            try {\n                return this[kHandler].onBodySent(chunk);\n            } catch (err) {\n                this.abort(err);\n            }\n        }\n    }\n    onRequestSent() {\n        if (channels.bodySent.hasSubscribers) {\n            channels.bodySent.publish({\n                request: this\n            });\n        }\n        if (this[kHandler].onRequestSent) {\n            try {\n                return this[kHandler].onRequestSent();\n            } catch (err) {\n                this.abort(err);\n            }\n        }\n    }\n    onConnect(abort) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        if (this.error) {\n            abort(this.error);\n        } else {\n            this.abort = abort;\n            return this[kHandler].onConnect(abort);\n        }\n    }\n    onHeaders(statusCode, headers, resume, statusText) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        if (channels.headers.hasSubscribers) {\n            channels.headers.publish({\n                request: this,\n                response: {\n                    statusCode,\n                    headers,\n                    statusText\n                }\n            });\n        }\n        try {\n            return this[kHandler].onHeaders(statusCode, headers, resume, statusText);\n        } catch (err) {\n            this.abort(err);\n        }\n    }\n    onData(chunk) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        try {\n            return this[kHandler].onData(chunk);\n        } catch (err) {\n            this.abort(err);\n            return false;\n        }\n    }\n    onUpgrade(statusCode, headers, socket) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        return this[kHandler].onUpgrade(statusCode, headers, socket);\n    }\n    onComplete(trailers) {\n        this.onFinally();\n        assert(!this.aborted);\n        this.completed = true;\n        if (channels.trailers.hasSubscribers) {\n            channels.trailers.publish({\n                request: this,\n                trailers\n            });\n        }\n        try {\n            return this[kHandler].onComplete(trailers);\n        } catch (err) {\n            // TODO (fix): This might be a bad idea?\n            this.onError(err);\n        }\n    }\n    onError(error) {\n        this.onFinally();\n        if (channels.error.hasSubscribers) {\n            channels.error.publish({\n                request: this,\n                error\n            });\n        }\n        if (this.aborted) {\n            return;\n        }\n        this.aborted = true;\n        return this[kHandler].onError(error);\n    }\n    onFinally() {\n        if (this.errorHandler) {\n            this.body.off(\"error\", this.errorHandler);\n            this.errorHandler = null;\n        }\n        if (this.endHandler) {\n            this.body.off(\"end\", this.endHandler);\n            this.endHandler = null;\n        }\n    }\n    // TODO: adjust to support H2\n    addHeader(key, value) {\n        processHeader(this, key, value);\n        return this;\n    }\n    static [kHTTP1BuildRequest](origin, opts, handler) {\n        // TODO: Migrate header parsing here, to make Requests\n        // HTTP agnostic\n        return new Request(origin, opts, handler);\n    }\n    static [kHTTP2BuildRequest](origin, opts, handler) {\n        const headers = opts.headers;\n        opts = {\n            ...opts,\n            headers: null\n        };\n        const request = new Request(origin, opts, handler);\n        request.headers = {};\n        if (Array.isArray(headers)) {\n            if (headers.length % 2 !== 0) {\n                throw new InvalidArgumentError(\"headers array must be even\");\n            }\n            for(let i = 0; i < headers.length; i += 2){\n                processHeader(request, headers[i], headers[i + 1], true);\n            }\n        } else if (headers && typeof headers === \"object\") {\n            const keys = Object.keys(headers);\n            for(let i = 0; i < keys.length; i++){\n                const key = keys[i];\n                processHeader(request, key, headers[key], true);\n            }\n        } else if (headers != null) {\n            throw new InvalidArgumentError(\"headers must be an object or an array\");\n        }\n        return request;\n    }\n    static [kHTTP2CopyHeaders](raw) {\n        const rawHeaders = raw.split(\"\\r\\n\");\n        const headers = {};\n        for (const header of rawHeaders){\n            const [key, value] = header.split(\": \");\n            if (value == null || value.length === 0) continue;\n            if (headers[key]) headers[key] += `,${value}`;\n            else headers[key] = value;\n        }\n        return headers;\n    }\n}\nfunction processHeaderValue(key, val, skipAppend) {\n    if (val && typeof val === \"object\") {\n        throw new InvalidArgumentError(`invalid ${key} header`);\n    }\n    val = val != null ? `${val}` : \"\";\n    if (headerCharRegex.exec(val) !== null) {\n        throw new InvalidArgumentError(`invalid ${key} header`);\n    }\n    return skipAppend ? val : `${key}: ${val}\\r\\n`;\n}\nfunction processHeader(request, key, val, skipAppend = false) {\n    if (val && typeof val === \"object\" && !Array.isArray(val)) {\n        throw new InvalidArgumentError(`invalid ${key} header`);\n    } else if (val === undefined) {\n        return;\n    }\n    if (request.host === null && key.length === 4 && key.toLowerCase() === \"host\") {\n        if (headerCharRegex.exec(val) !== null) {\n            throw new InvalidArgumentError(`invalid ${key} header`);\n        }\n        // Consumed by Client\n        request.host = val;\n    } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === \"content-length\") {\n        request.contentLength = parseInt(val, 10);\n        if (!Number.isFinite(request.contentLength)) {\n            throw new InvalidArgumentError(\"invalid content-length header\");\n        }\n    } else if (request.contentType === null && key.length === 12 && key.toLowerCase() === \"content-type\") {\n        request.contentType = val;\n        if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);\n        else request.headers += processHeaderValue(key, val);\n    } else if (key.length === 17 && key.toLowerCase() === \"transfer-encoding\") {\n        throw new InvalidArgumentError(\"invalid transfer-encoding header\");\n    } else if (key.length === 10 && key.toLowerCase() === \"connection\") {\n        const value = typeof val === \"string\" ? val.toLowerCase() : null;\n        if (value !== \"close\" && value !== \"keep-alive\") {\n            throw new InvalidArgumentError(\"invalid connection header\");\n        } else if (value === \"close\") {\n            request.reset = true;\n        }\n    } else if (key.length === 10 && key.toLowerCase() === \"keep-alive\") {\n        throw new InvalidArgumentError(\"invalid keep-alive header\");\n    } else if (key.length === 7 && key.toLowerCase() === \"upgrade\") {\n        throw new InvalidArgumentError(\"invalid upgrade header\");\n    } else if (key.length === 6 && key.toLowerCase() === \"expect\") {\n        throw new NotSupportedError(\"expect header not supported\");\n    } else if (tokenRegExp.exec(key) === null) {\n        throw new InvalidArgumentError(\"invalid header key\");\n    } else {\n        if (Array.isArray(val)) {\n            for(let i = 0; i < val.length; i++){\n                if (skipAppend) {\n                    if (request.headers[key]) request.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`;\n                    else request.headers[key] = processHeaderValue(key, val[i], skipAppend);\n                } else {\n                    request.headers += processHeaderValue(key, val[i]);\n                }\n            }\n        } else {\n            if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);\n            else request.headers += processHeaderValue(key, val);\n        }\n    }\n}\nmodule.exports = Request;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS9yZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUNKQSxvQkFBb0IsRUFDcEJDLGlCQUFpQixFQUNsQixHQUFHQyxtQkFBT0EsQ0FBQztBQUNaLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRUUsa0JBQWtCLEVBQUVDLGlCQUFpQixFQUFFQyxrQkFBa0IsRUFBRSxHQUFHSixtQkFBT0EsQ0FBQztBQUM5RSxNQUFNSyxPQUFPTCxtQkFBT0EsQ0FBQztBQUVyQix3REFBd0Q7QUFDeEQsK0RBQStEO0FBRS9EOzs7O0NBSUMsR0FDRCxNQUFNTSxjQUFjO0FBRXBCOzs7OztDQUtDLEdBQ0QsTUFBTUMsa0JBQWtCO0FBRXhCLGtGQUFrRjtBQUNsRixNQUFNQyxtQkFBbUI7QUFFekIsTUFBTUMsV0FBV0MsT0FBTztBQUV4QixNQUFNQyxXQUFXLENBQUM7QUFFbEIsSUFBSUM7QUFFSixJQUFJO0lBQ0YsTUFBTUMscUJBQXFCYixtQkFBT0EsQ0FBQztJQUNuQ1csU0FBU0csTUFBTSxHQUFHRCxtQkFBbUJFLE9BQU8sQ0FBQztJQUM3Q0osU0FBU0ssUUFBUSxHQUFHSCxtQkFBbUJFLE9BQU8sQ0FBQztJQUMvQ0osU0FBU00sT0FBTyxHQUFHSixtQkFBbUJFLE9BQU8sQ0FBQztJQUM5Q0osU0FBU08sUUFBUSxHQUFHTCxtQkFBbUJFLE9BQU8sQ0FBQztJQUMvQ0osU0FBU1EsS0FBSyxHQUFHTixtQkFBbUJFLE9BQU8sQ0FBQztBQUM5QyxFQUFFLE9BQU07SUFDTkosU0FBU0csTUFBTSxHQUFHO1FBQUVNLGdCQUFnQjtJQUFNO0lBQzFDVCxTQUFTSyxRQUFRLEdBQUc7UUFBRUksZ0JBQWdCO0lBQU07SUFDNUNULFNBQVNNLE9BQU8sR0FBRztRQUFFRyxnQkFBZ0I7SUFBTTtJQUMzQ1QsU0FBU08sUUFBUSxHQUFHO1FBQUVFLGdC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SyxLQUNmZ0IsSUFBSXNDLFdBQVcsT0FBTyxVQUN0QjtRQUNBLE1BQU0sSUFBSWxILGtCQUFrQjtJQUM5QixPQUFPLElBQUlPLFlBQVlnQyxJQUFJLENBQUNxQyxTQUFTLE1BQU07UUFDekMsTUFBTSxJQUFJN0UscUJBQXFCO0lBQ2pDLE9BQU87UUFDTCxJQUFJdUUsTUFBTUMsT0FBTyxDQUFDd0MsTUFBTTtZQUN0QixJQUFLLElBQUl2QyxJQUFJLEdBQUdBLElBQUl1QyxJQUFJbkQsTUFBTSxFQUFFWSxJQUFLO2dCQUNuQyxJQUFJd0MsWUFBWTtvQkFDZCxJQUFJMUIsUUFBUXBFLE9BQU8sQ0FBQzBELElBQUksRUFBRVUsUUFBUXBFLE9BQU8sQ0FBQzBELElBQUksSUFBSSxDQUFDLENBQUMsRUFBRWtDLG1CQUFtQmxDLEtBQUttQyxHQUFHLENBQUN2QyxFQUFFLEVBQUV3QyxZQUFZLENBQUM7eUJBQzlGMUIsUUFBUXBFLE9BQU8sQ0FBQzBELElBQUksR0FBR2tDLG1CQUFtQmxDLEtBQUttQyxHQUFHLENBQUN2QyxFQUFFLEVBQUV3QztnQkFDOUQsT0FBTztvQkFDTDFCLFFBQVFwRSxPQUFPLElBQUk0RixtQkFBbUJsQyxLQUFLbUMsR0FBRyxDQUFDdkMsRUFBRTtnQkFDbkQ7WUFDRjtRQUNGLE9BQU87WUFDTCxJQUFJd0MsWUFBWTFCLFFBQVFwRSxPQUFPLENBQUMwRCxJQUFJLEdBQUdrQyxtQkFBbUJsQyxLQUFLbUMsS0FBS0M7aUJBQy9EMUIsUUFBUXBFLE9BQU8sSUFBSTRGLG1CQUFtQmxDLEtBQUttQztRQUNsRDtJQUNGO0FBQ0Y7QUFFQUssT0FBT0MsT0FBTyxHQUFHL0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3JlcXVlc3QuanM/NDNjZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgTm90U3VwcG9ydGVkRXJyb3Jcbn0gPSByZXF1aXJlKCcuL2Vycm9ycycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgeyBrSFRUUDJCdWlsZFJlcXVlc3QsIGtIVFRQMkNvcHlIZWFkZXJzLCBrSFRUUDFCdWlsZFJlcXVlc3QgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJylcblxuLy8gdG9rZW5SZWdFeHAgYW5kIGhlYWRlckNoYXJSZWdleCBoYXZlIGJlZW4gbGlmdGVkIGZyb21cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21haW4vbGliL19odHRwX2NvbW1vbi5qc1xuXG4vKipcbiAqIFZlcmlmaWVzIHRoYXQgdGhlIGdpdmVuIHZhbCBpcyBhIHZhbGlkIEhUVFAgdG9rZW5cbiAqIHBlciB0aGUgcnVsZXMgZGVmaW5lZCBpbiBSRkMgNzIzMFxuICogU2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4yLjZcbiAqL1xuY29uc3QgdG9rZW5SZWdFeHAgPSAvXltcXF5fYGEtekEtWlxcLTAtOSEjJCUmJyorLnx+XSskL1xuXG4vKipcbiAqIE1hdGNoZXMgaWYgdmFsIGNvbnRhaW5zIGFuIGludmFsaWQgZmllbGQtdmNoYXJcbiAqICBmaWVsZC12YWx1ZSAgICA9ICooIGZpZWxkLWNvbnRlbnQgLyBvYnMtZm9sZCApXG4gKiAgZmllbGQtY29udGVudCAgPSBmaWVsZC12Y2hhciBbIDEqKCBTUCAvIEhUQUIgKSBmaWVsZC12Y2hhciBdXG4gKiAgZmllbGQtdmNoYXIgICAgPSBWQ0hBUiAvIG9icy10ZXh0XG4gKi9cbmNvbnN0IGhlYWRlckNoYXJSZWdleCA9IC9bXlxcdFxceDIwLVxceDdlXFx4ODAtXFx4ZmZdL1xuXG4vLyBWZXJpZmllcyB0aGF0IGEgZ2l2ZW4gcGF0aCBpcyB2YWxpZCBkb2VzIG5vdCBjb250YWluIGNvbnRyb2wgY2hhcnMgXFx4MDAgdG8gXFx4MjBcbmNvbnN0IGludmFsaWRQYXRoUmVnZXggPSAvW15cXHUwMDIxLVxcdTAwZmZdL1xuXG5jb25zdCBrSGFuZGxlciA9IFN5bWJvbCgnaGFuZGxlcicpXG5cbmNvbnN0IGNoYW5uZWxzID0ge31cblxubGV0IGV4dHJhY3RCb2R5XG5cbnRyeSB7XG4gIGNvbnN0IGRpYWdub3N0aWNzQ2hhbm5lbCA9IHJlcXVpcmUoJ2RpYWdub3N0aWNzX2NoYW5uZWwnKVxuICBjaGFubmVscy5jcmVhdGUgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6Y3JlYXRlJylcbiAgY2hhbm5lbHMuYm9keVNlbnQgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6Ym9keVNlbnQnKVxuICBjaGFubmVscy5oZWFkZXJzID0gZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmhlYWRlcnMnKVxuICBjaGFubmVscy50cmFpbGVycyA9IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6cmVxdWVzdDp0cmFpbGVycycpXG4gIGNoYW5uZWxzLmVycm9yID0gZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmVycm9yJylcbn0gY2F0Y2gge1xuICBjaGFubmVscy5jcmVhdGUgPSB7IGhhc1N1YnNjcmliZXJzOiBmYWxzZSB9XG4gIGNoYW5uZWxzLmJvZHlTZW50ID0geyBoYXNTdWJzY3JpYmVyczogZmFsc2UgfVxuICBjaGFubmVscy5oZWFkZXJzID0geyBoYXNTdWJzY3JpYmVyczogZmFsc2UgfVxuICBjaGFubmVscy50cmFpbGVycyA9IHsgaGFzU3Vic2NyaWJlcnM6IGZhbHNlIH1cbiAgY2hhbm5lbHMuZXJyb3IgPSB7IGhhc1N1YnNjcmliZXJzOiBmYWxzZSB9XG59XG5cbmNsYXNzIFJlcXVlc3Qge1xuICBjb25zdHJ1Y3RvciAob3JpZ2luLCB7XG4gICAgcGF0aCxcbiAgICBtZXRob2QsXG4gICAgYm9keSxcbiAgICBoZWFkZXJzLFxuICAgIHF1ZXJ5LFxuICAgIGlkZW1wb3RlbnQsXG4gICAgYmxvY2tpbmcsXG4gICAgdXBncmFkZSxcbiAgICBoZWFkZXJzVGltZW91dCxcbiAgICBib2R5VGltZW91dCxcbiAgICByZXNldCxcbiAgICB0aHJvd09uRXJyb3IsXG4gICAgZXhwZWN0Q29udGludWVcbiAgfSwgaGFuZGxlcikge1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigncGF0aCBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgcGF0aFswXSAhPT0gJy8nICYmXG4gICAgICAhKHBhdGguc3RhcnRzV2l0aCgnaHR0cDovLycpIHx8IHBhdGguc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkgJiZcbiAgICAgIG1ldGhvZCAhPT0gJ0NPTk5FQ1QnXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3BhdGggbXVzdCBiZSBhbiBhYnNvbHV0ZSBVUkwgb3Igc3RhcnQgd2l0aCBhIHNsYXNoJylcbiAgICB9IGVsc2UgaWYgKGludmFsaWRQYXRoUmVnZXguZXhlYyhwYXRoKSAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHJlcXVlc3QgcGF0aCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21ldGhvZCBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9IGVsc2UgaWYgKHRva2VuUmVnRXhwLmV4ZWMobWV0aG9kKSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHJlcXVlc3QgbWV0aG9kJylcbiAgICB9XG5cbiAgICBpZiAodXBncmFkZSAmJiB0eXBlb2YgdXBncmFkZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndXBncmFkZSBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG5cbiAgICBpZiAoaGVhZGVyc1RpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShoZWFkZXJzVGltZW91dCkgfHwgaGVhZGVyc1RpbWVvdXQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGhlYWRlcnNUaW1lb3V0JylcbiAgICB9XG5cbiAgICBpZiAoYm9keVRpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShib2R5VGltZW91dCkgfHwgYm9keVRpbWVvdXQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGJvZHlUaW1lb3V0JylcbiAgICB9XG5cbiAgICBpZiAocmVzZXQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzZXQgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHJlc2V0JylcbiAgICB9XG5cbiAgICBpZiAoZXhwZWN0Q29udGludWUgIT0gbnVsbCAmJiB0eXBlb2YgZXhwZWN0Q29udGludWUgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGV4cGVjdENvbnRpbnVlJylcbiAgICB9XG5cbiAgICB0aGlzLmhlYWRlcnNUaW1lb3V0ID0gaGVhZGVyc1RpbWVvdXRcblxuICAgIHRoaXMuYm9keVRpbWVvdXQgPSBib2R5VGltZW91dFxuXG4gICAgdGhpcy50aHJvd09uRXJyb3IgPSB0aHJvd09uRXJyb3IgPT09IHRydWVcblxuICAgIHRoaXMubWV0aG9kID0gbWV0aG9kXG5cbiAgICB0aGlzLmFib3J0ID0gbnVsbFxuXG4gICAgaWYgKGJvZHkgPT0gbnVsbCkge1xuICAgICAgdGhpcy5ib2R5ID0gbnVsbFxuICAgIH0gZWxzZSBpZiAodXRpbC5pc1N0cmVhbShib2R5KSkge1xuICAgICAgdGhpcy5ib2R5ID0gYm9keVxuXG4gICAgICBjb25zdCByU3RhdGUgPSB0aGlzLmJvZHkuX3JlYWRhYmxlU3RhdGVcbiAgICAgIGlmICghclN0YXRlIHx8ICFyU3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgICAgdGhpcy5lbmRIYW5kbGVyID0gZnVuY3Rpb24gYXV0b0Rlc3Ryb3kgKCkge1xuICAgICAgICAgIHV0aWwuZGVzdHJveSh0aGlzKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm9keS5vbignZW5kJywgdGhpcy5lbmRIYW5kbGVyKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmVycm9ySGFuZGxlciA9IGVyciA9PiB7XG4gICAgICAgIGlmICh0aGlzLmFib3J0KSB7XG4gICAgICAgICAgdGhpcy5hYm9ydChlcnIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lcnJvciA9IGVyclxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmJvZHkub24oJ2Vycm9yJywgdGhpcy5lcnJvckhhbmRsZXIpXG4gICAgfSBlbHNlIGlmICh1dGlsLmlzQnVmZmVyKGJvZHkpKSB7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5LmJ5dGVMZW5ndGggPyBib2R5IDogbnVsbFxuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGJvZHkpKSB7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5LmJ1ZmZlci5ieXRlTGVuZ3RoID8gQnVmZmVyLmZyb20oYm9keS5idWZmZXIsIGJvZHkuYnl0ZU9mZnNldCwgYm9keS5ieXRlTGVuZ3RoKSA6IG51bGxcbiAgICB9IGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgdGhpcy5ib2R5ID0gYm9keS5ieXRlTGVuZ3RoID8gQnVmZmVyLmZyb20oYm9keSkgOiBudWxsXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHkubGVuZ3RoID8gQnVmZmVyLmZyb20oYm9keSkgOiBudWxsXG4gICAgfSBlbHNlIGlmICh1dGlsLmlzRm9ybURhdGFMaWtlKGJvZHkpIHx8IHV0aWwuaXNJdGVyYWJsZShib2R5KSB8fCB1dGlsLmlzQmxvYkxpa2UoYm9keSkpIHtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdib2R5IG11c3QgYmUgYSBzdHJpbmcsIGEgQnVmZmVyLCBhIFJlYWRhYmxlIHN0cmVhbSwgYW4gaXRlcmFibGUsIG9yIGFuIGFzeW5jIGl0ZXJhYmxlJylcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBsZXRlZCA9IGZhbHNlXG5cbiAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZVxuXG4gICAgdGhpcy51cGdyYWRlID0gdXBncmFkZSB8fCBudWxsXG5cbiAgICB0aGlzLnBhdGggPSBxdWVyeSA/IHV0aWwuYnVpbGRVUkwocGF0aCwgcXVlcnkpIDogcGF0aFxuXG4gICAgdGhpcy5vcmlnaW4gPSBvcmlnaW5cblxuICAgIHRoaXMuaWRlbXBvdGVudCA9IGlkZW1wb3RlbnQgPT0gbnVsbFxuICAgICAgPyBtZXRob2QgPT09ICdIRUFEJyB8fCBtZXRob2QgPT09ICdHRVQnXG4gICAgICA6IGlkZW1wb3RlbnRcblxuICAgIHRoaXMuYmxvY2tpbmcgPSBibG9ja2luZyA9PSBudWxsID8gZmFsc2UgOiBibG9ja2luZ1xuXG4gICAgdGhpcy5yZXNldCA9IHJlc2V0ID09IG51bGwgPyBudWxsIDogcmVzZXRcblxuICAgIHRoaXMuaG9zdCA9IG51bGxcblxuICAgIHRoaXMuY29udGVudExlbmd0aCA9IG51bGxcblxuICAgIHRoaXMuY29udGVudFR5cGUgPSBudWxsXG5cbiAgICB0aGlzLmhlYWRlcnMgPSAnJ1xuXG4gICAgLy8gT25seSBmb3IgSDJcbiAgICB0aGlzLmV4cGVjdENvbnRpbnVlID0gZXhwZWN0Q29udGludWUgIT0gbnVsbCA/IGV4cGVjdENvbnRpbnVlIDogZmFsc2VcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBpZiAoaGVhZGVycy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGVhZGVycyBhcnJheSBtdXN0IGJlIGV2ZW4nKVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHByb2Nlc3NIZWFkZXIodGhpcywgaGVhZGVyc1tpXSwgaGVhZGVyc1tpICsgMV0pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoZWFkZXJzICYmIHR5cGVvZiBoZWFkZXJzID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgICAgICBwcm9jZXNzSGVhZGVyKHRoaXMsIGtleSwgaGVhZGVyc1trZXldKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGVhZGVycyAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2hlYWRlcnMgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYW4gYXJyYXknKVxuICAgIH1cblxuICAgIGlmICh1dGlsLmlzRm9ybURhdGFMaWtlKHRoaXMuYm9keSkpIHtcbiAgICAgIGlmICh1dGlsLm5vZGVNYWpvciA8IDE2IHx8ICh1dGlsLm5vZGVNYWpvciA9PT0gMTYgJiYgdXRpbC5ub2RlTWlub3IgPCA4KSkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0Zvcm0tRGF0YSBib2RpZXMgYXJlIG9ubHkgc3VwcG9ydGVkIGluIG5vZGUgdjE2LjggYW5kIG5ld2VyLicpXG4gICAgICB9XG5cbiAgICAgIGlmICghZXh0cmFjdEJvZHkpIHtcbiAgICAgICAgZXh0cmFjdEJvZHkgPSByZXF1aXJlKCcuLi9mZXRjaC9ib2R5LmpzJykuZXh0cmFjdEJvZHlcbiAgICAgIH1cblxuICAgICAgY29uc3QgW2JvZHlTdHJlYW0sIGNvbnRlbnRUeXBlXSA9IGV4dHJhY3RCb2R5KGJvZHkpXG4gICAgICBpZiAodGhpcy5jb250ZW50VHlwZSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY29udGVudFR5cGUgPSBjb250ZW50VHlwZVxuICAgICAgICB0aGlzLmhlYWRlcnMgKz0gYGNvbnRlbnQtdHlwZTogJHtjb250ZW50VHlwZX1cXHJcXG5gXG4gICAgICB9XG4gICAgICB0aGlzLmJvZHkgPSBib2R5U3RyZWFtLnN0cmVhbVxuICAgICAgdGhpcy5jb250ZW50TGVuZ3RoID0gYm9keVN0cmVhbS5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNCbG9iTGlrZShib2R5KSAmJiB0aGlzLmNvbnRlbnRUeXBlID09IG51bGwgJiYgYm9keS50eXBlKSB7XG4gICAgICB0aGlzLmNvbnRlbnRUeXBlID0gYm9keS50eXBlXG4gICAgICB0aGlzLmhlYWRlcnMgKz0gYGNvbnRlbnQtdHlwZTogJHtib2R5LnR5cGV9XFxyXFxuYFxuICAgIH1cblxuICAgIHV0aWwudmFsaWRhdGVIYW5kbGVyKGhhbmRsZXIsIG1ldGhvZCwgdXBncmFkZSlcblxuICAgIHRoaXMuc2VydmVybmFtZSA9IHV0aWwuZ2V0U2VydmVyTmFtZSh0aGlzLmhvc3QpXG5cbiAgICB0aGlzW2tIYW5kbGVyXSA9IGhhbmRsZXJcblxuICAgIGlmIChjaGFubmVscy5jcmVhdGUuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLmNyZWF0ZS5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcyB9KVxuICAgIH1cbiAgfVxuXG4gIG9uQm9keVNlbnQgKGNodW5rKSB7XG4gICAgaWYgKHRoaXNba0hhbmRsZXJdLm9uQm9keVNlbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tIYW5kbGVyXS5vbkJvZHlTZW50KGNodW5rKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuYWJvcnQoZXJyKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uUmVxdWVzdFNlbnQgKCkge1xuICAgIGlmIChjaGFubmVscy5ib2R5U2VudC5oYXNTdWJzY3JpYmVycykge1xuICAgICAgY2hhbm5lbHMuYm9keVNlbnQucHVibGlzaCh7IHJlcXVlc3Q6IHRoaXMgfSlcbiAgICB9XG5cbiAgICBpZiAodGhpc1trSGFuZGxlcl0ub25SZXF1ZXN0U2VudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uUmVxdWVzdFNlbnQoKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuYWJvcnQoZXJyKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQpIHtcbiAgICBhc3NlcnQoIXRoaXMuYWJvcnRlZClcbiAgICBhc3NlcnQoIXRoaXMuY29tcGxldGVkKVxuXG4gICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgIGFib3J0KHRoaXMuZXJyb3IpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuICAgICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uQ29ubmVjdChhYm9ydClcbiAgICB9XG4gIH1cblxuICBvbkhlYWRlcnMgKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHJlc3VtZSwgc3RhdHVzVGV4dCkge1xuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuICAgIGFzc2VydCghdGhpcy5jb21wbGV0ZWQpXG5cbiAgICBpZiAoY2hhbm5lbHMuaGVhZGVycy5oYXNTdWJzY3JpYmVycykge1xuICAgICAgY2hhbm5lbHMuaGVhZGVycy5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcywgcmVzcG9uc2U6IHsgc3RhdHVzQ29kZSwgaGVhZGVycywgc3RhdHVzVGV4dCB9IH0pXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzW2tIYW5kbGVyXS5vbkhlYWRlcnMoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzdW1lLCBzdGF0dXNUZXh0KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5hYm9ydChlcnIpXG4gICAgfVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuICAgIGFzc2VydCghdGhpcy5jb21wbGV0ZWQpXG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uRGF0YShjaHVuaylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuYWJvcnQoZXJyKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgb25VcGdyYWRlIChzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpIHtcbiAgICBhc3NlcnQoIXRoaXMuYWJvcnRlZClcbiAgICBhc3NlcnQoIXRoaXMuY29tcGxldGVkKVxuXG4gICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uVXBncmFkZShzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpXG4gIH1cblxuICBvbkNvbXBsZXRlICh0cmFpbGVycykge1xuICAgIHRoaXMub25GaW5hbGx5KClcblxuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuXG4gICAgdGhpcy5jb21wbGV0ZWQgPSB0cnVlXG4gICAgaWYgKGNoYW5uZWxzLnRyYWlsZXJzLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy50cmFpbGVycy5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcywgdHJhaWxlcnMgfSlcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uQ29tcGxldGUodHJhaWxlcnMpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBUT0RPIChmaXgpOiBUaGlzIG1pZ2h0IGJlIGEgYmFkIGlkZWE/XG4gICAgICB0aGlzLm9uRXJyb3IoZXJyKVxuICAgIH1cbiAgfVxuXG4gIG9uRXJyb3IgKGVycm9yKSB7XG4gICAgdGhpcy5vbkZpbmFsbHkoKVxuXG4gICAgaWYgKGNoYW5uZWxzLmVycm9yLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy5lcnJvci5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcywgZXJyb3IgfSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hYm9ydGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5hYm9ydGVkID0gdHJ1ZVxuXG4gICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uRXJyb3IoZXJyb3IpXG4gIH1cblxuICBvbkZpbmFsbHkgKCkge1xuICAgIGlmICh0aGlzLmVycm9ySGFuZGxlcikge1xuICAgICAgdGhpcy5ib2R5Lm9mZignZXJyb3InLCB0aGlzLmVycm9ySGFuZGxlcilcbiAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gbnVsbFxuICAgIH1cblxuICAgIGlmICh0aGlzLmVuZEhhbmRsZXIpIHtcbiAgICAgIHRoaXMuYm9keS5vZmYoJ2VuZCcsIHRoaXMuZW5kSGFuZGxlcilcbiAgICAgIHRoaXMuZW5kSGFuZGxlciA9IG51bGxcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBhZGp1c3QgdG8gc3VwcG9ydCBIMlxuICBhZGRIZWFkZXIgKGtleSwgdmFsdWUpIHtcbiAgICBwcm9jZXNzSGVhZGVyKHRoaXMsIGtleSwgdmFsdWUpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXRpYyBba0hUVFAxQnVpbGRSZXF1ZXN0XSAob3JpZ2luLCBvcHRzLCBoYW5kbGVyKSB7XG4gICAgLy8gVE9ETzogTWlncmF0ZSBoZWFkZXIgcGFyc2luZyBoZXJlLCB0byBtYWtlIFJlcXVlc3RzXG4gICAgLy8gSFRUUCBhZ25vc3RpY1xuICAgIHJldHVybiBuZXcgUmVxdWVzdChvcmlnaW4sIG9wdHMsIGhhbmRsZXIpXG4gIH1cblxuICBzdGF0aWMgW2tIVFRQMkJ1aWxkUmVxdWVzdF0gKG9yaWdpbiwgb3B0cywgaGFuZGxlcikge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRzLmhlYWRlcnNcbiAgICBvcHRzID0geyAuLi5vcHRzLCBoZWFkZXJzOiBudWxsIH1cblxuICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdChvcmlnaW4sIG9wdHMsIGhhbmRsZXIpXG5cbiAgICByZXF1ZXN0LmhlYWRlcnMgPSB7fVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICAgIGlmIChoZWFkZXJzLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdoZWFkZXJzIGFycmF5IG11c3QgYmUgZXZlbicpXG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgcHJvY2Vzc0hlYWRlcihyZXF1ZXN0LCBoZWFkZXJzW2ldLCBoZWFkZXJzW2kgKyAxXSwgdHJ1ZSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMgJiYgdHlwZW9mIGhlYWRlcnMgPT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaGVhZGVycylcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldXG4gICAgICAgIHByb2Nlc3NIZWFkZXIocmVxdWVzdCwga2V5LCBoZWFkZXJzW2tleV0sIHRydWUpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoZWFkZXJzICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGVhZGVycyBtdXN0IGJlIGFuIG9iamVjdCBvciBhbiBhcnJheScpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcXVlc3RcbiAgfVxuXG4gIHN0YXRpYyBba0hUVFAyQ29weUhlYWRlcnNdIChyYXcpIHtcbiAgICBjb25zdCByYXdIZWFkZXJzID0gcmF3LnNwbGl0KCdcXHJcXG4nKVxuICAgIGNvbnN0IGhlYWRlcnMgPSB7fVxuXG4gICAgZm9yIChjb25zdCBoZWFkZXIgb2YgcmF3SGVhZGVycykge1xuICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gaGVhZGVyLnNwbGl0KCc6ICcpXG5cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCkgY29udGludWVcblxuICAgICAgaWYgKGhlYWRlcnNba2V5XSkgaGVhZGVyc1trZXldICs9IGAsJHt2YWx1ZX1gXG4gICAgICBlbHNlIGhlYWRlcnNba2V5XSA9IHZhbHVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSGVhZGVyVmFsdWUgKGtleSwgdmFsLCBza2lwQXBwZW5kKSB7XG4gIGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYGludmFsaWQgJHtrZXl9IGhlYWRlcmApXG4gIH1cblxuICB2YWwgPSB2YWwgIT0gbnVsbCA/IGAke3ZhbH1gIDogJydcblxuICBpZiAoaGVhZGVyQ2hhclJlZ2V4LmV4ZWModmFsKSAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgaW52YWxpZCAke2tleX0gaGVhZGVyYClcbiAgfVxuXG4gIHJldHVybiBza2lwQXBwZW5kID8gdmFsIDogYCR7a2V5fTogJHt2YWx9XFxyXFxuYFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSGVhZGVyIChyZXF1ZXN0LCBrZXksIHZhbCwgc2tpcEFwcGVuZCA9IGZhbHNlKSB7XG4gIGlmICh2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbCkpKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGBpbnZhbGlkICR7a2V5fSBoZWFkZXJgKVxuICB9IGVsc2UgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoXG4gICAgcmVxdWVzdC5ob3N0ID09PSBudWxsICYmXG4gICAga2V5Lmxlbmd0aCA9PT0gNCAmJlxuICAgIGtleS50b0xvd2VyQ2FzZSgpID09PSAnaG9zdCdcbiAgKSB7XG4gICAgaWYgKGhlYWRlckNoYXJSZWdleC5leGVjKHZhbCkgIT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgaW52YWxpZCAke2tleX0gaGVhZGVyYClcbiAgICB9XG4gICAgLy8gQ29uc3VtZWQgYnkgQ2xpZW50XG4gICAgcmVxdWVzdC5ob3N0ID0gdmFsXG4gIH0gZWxzZSBpZiAoXG4gICAgcmVxdWVzdC5jb250ZW50TGVuZ3RoID09PSBudWxsICYmXG4gICAga2V5Lmxlbmd0aCA9PT0gMTQgJiZcbiAgICBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtbGVuZ3RoJ1xuICApIHtcbiAgICByZXF1ZXN0LmNvbnRlbnRMZW5ndGggPSBwYXJzZUludCh2YWwsIDEwKVxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHJlcXVlc3QuY29udGVudExlbmd0aCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjb250ZW50LWxlbmd0aCBoZWFkZXInKVxuICAgIH1cbiAgfSBlbHNlIGlmIChcbiAgICByZXF1ZXN0LmNvbnRlbnRUeXBlID09PSBudWxsICYmXG4gICAga2V5Lmxlbmd0aCA9PT0gMTIgJiZcbiAgICBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZSdcbiAgKSB7XG4gICAgcmVxdWVzdC5jb250ZW50VHlwZSA9IHZhbFxuICAgIGlmIChza2lwQXBwZW5kKSByZXF1ZXN0LmhlYWRlcnNba2V5XSA9IHByb2Nlc3NIZWFkZXJWYWx1ZShrZXksIHZhbCwgc2tpcEFwcGVuZClcbiAgICBlbHNlIHJlcXVlc3QuaGVhZGVycyArPSBwcm9jZXNzSGVhZGVyVmFsdWUoa2V5LCB2YWwpXG4gIH0gZWxzZSBpZiAoXG4gICAga2V5Lmxlbmd0aCA9PT0gMTcgJiZcbiAgICBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ3RyYW5zZmVyLWVuY29kaW5nJ1xuICApIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgdHJhbnNmZXItZW5jb2RpbmcgaGVhZGVyJylcbiAgfSBlbHNlIGlmIChcbiAgICBrZXkubGVuZ3RoID09PSAxMCAmJlxuICAgIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29ubmVjdGlvbidcbiAgKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/IHZhbC50b0xvd2VyQ2FzZSgpIDogbnVsbFxuICAgIGlmICh2YWx1ZSAhPT0gJ2Nsb3NlJyAmJiB2YWx1ZSAhPT0gJ2tlZXAtYWxpdmUnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY29ubmVjdGlvbiBoZWFkZXInKVxuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICdjbG9zZScpIHtcbiAgICAgIHJlcXVlc3QucmVzZXQgPSB0cnVlXG4gICAgfVxuICB9IGVsc2UgaWYgKFxuICAgIGtleS5sZW5ndGggPT09IDEwICYmXG4gICAga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdrZWVwLWFsaXZlJ1xuICApIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQga2VlcC1hbGl2ZSBoZWFkZXInKVxuICB9IGVsc2UgaWYgKFxuICAgIGtleS5sZW5ndGggPT09IDcgJiZcbiAgICBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ3VwZ3JhZGUnXG4gICkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCB1cGdyYWRlIGhlYWRlcicpXG4gIH0gZWxzZSBpZiAoXG4gICAga2V5Lmxlbmd0aCA9PT0gNiAmJlxuICAgIGtleS50b0xvd2VyQ2FzZSgpID09PSAnZXhwZWN0J1xuICApIHtcbiAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXJyb3IoJ2V4cGVjdCBoZWFkZXIgbm90IHN1cHBvcnRlZCcpXG4gIH0gZWxzZSBpZiAodG9rZW5SZWdFeHAuZXhlYyhrZXkpID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGhlYWRlciBrZXknKVxuICB9IGVsc2Uge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChza2lwQXBwZW5kKSB7XG4gICAgICAgICAgaWYgKHJlcXVlc3QuaGVhZGVyc1trZXldKSByZXF1ZXN0LmhlYWRlcnNba2V5XSArPSBgLCR7cHJvY2Vzc0hlYWRlclZhbHVlKGtleSwgdmFsW2ldLCBza2lwQXBwZW5kKX1gXG4gICAgICAgICAgZWxzZSByZXF1ZXN0LmhlYWRlcnNba2V5XSA9IHByb2Nlc3NIZWFkZXJWYWx1ZShrZXksIHZhbFtpXSwgc2tpcEFwcGVuZClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMgKz0gcHJvY2Vzc0hlYWRlclZhbHVlKGtleSwgdmFsW2ldKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChza2lwQXBwZW5kKSByZXF1ZXN0LmhlYWRlcnNba2V5XSA9IHByb2Nlc3NIZWFkZXJWYWx1ZShrZXksIHZhbCwgc2tpcEFwcGVuZClcbiAgICAgIGVsc2UgcmVxdWVzdC5oZWFkZXJzICs9IHByb2Nlc3NIZWFkZXJWYWx1ZShrZXksIHZhbClcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZXF1ZXN0XG4iXSwibmFtZXMiOlsiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJOb3RTdXBwb3J0ZWRFcnJvciIsInJlcXVpcmUiLCJhc3NlcnQiLCJrSFRUUDJCdWlsZFJlcXVlc3QiLCJrSFRUUDJDb3B5SGVhZGVycyIsImtIVFRQMUJ1aWxkUmVxdWVzdCIsInV0aWwiLCJ0b2tlblJlZ0V4cCIsImhlYWRlckNoYXJSZWdleCIsImludmFsaWRQYXRoUmVnZXgiLCJrSGFuZGxlciIsIlN5bWJvbCIsImNoYW5uZWxzIiwiZXh0cmFjdEJvZHkiLCJkaWFnbm9zdGljc0NoYW5uZWwiLCJjcmVhdGUiLCJjaGFubmVsIiwiYm9keVNlbnQiLCJoZWFkZXJzIiwidHJhaWxlcnMiLCJlcnJvciIsImhhc1N1YnNjcmliZXJzIiwiUmVxdWVzdCIsImNvbnN0cnVjdG9yIiwib3JpZ2luIiwicGF0aCIsIm1ldGhvZCIsImJvZHkiLCJxdWVyeSIsImlkZW1wb3RlbnQiLCJibG9ja2luZyIsInVwZ3JhZGUiLCJoZWFkZXJzVGltZW91dCIsImJvZHlUaW1lb3V0IiwicmVzZXQiLCJ0aHJvd09uRXJyb3IiLCJleHBlY3RDb250aW51ZSIsImhhbmRsZXIiLCJzdGFydHNXaXRoIiwiZXhlYyIsIk51bWJlciIsImlzRmluaXRlIiwiYWJvcnQiLCJpc1N0cmVhbSIsInJTdGF0ZSIsIl9yZWFkYWJsZVN0YXRlIiwiYXV0b0Rlc3Ryb3kiLCJlbmRIYW5kbGVyIiwiZGVzdHJveSIsIm9uIiwiZXJyb3JIYW5kbGVyIiwiZXJyIiwiaXNCdWZmZXIiLCJieXRlTGVuZ3RoIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJidWZmZXIiLCJCdWZmZXIiLCJmcm9tIiwiYnl0ZU9mZnNldCIsImxlbmd0aCIsImlzRm9ybURhdGFMaWtlIiwiaXNJdGVyYWJsZSIsImlzQmxvYkxpa2UiLCJjb21wbGV0ZWQiLCJhYm9ydGVkIiwiYnVpbGRVUkwiLCJob3N0IiwiY29udGVudExlbmd0aCIsImNvbnRlbnRUeXBlIiwiQXJyYXkiLCJpc0FycmF5IiwiaSIsInByb2Nlc3NIZWFkZXIiLCJrZXlzIiwiT2JqZWN0Iiwia2V5Iiwibm9kZU1ham9yIiwibm9kZU1pbm9yIiwiYm9keVN0cmVhbSIsInN0cmVhbSIsInR5cGUiLCJ2YWxpZGF0ZUhhbmRsZXIiLCJzZXJ2ZXJuYW1lIiwiZ2V0U2VydmVyTmFtZSIsInB1Ymxpc2giLCJyZXF1ZXN0Iiwib25Cb2R5U2VudCIsImNodW5rIiwib25SZXF1ZXN0U2VudCIsIm9uQ29ubmVjdCIsIm9uSGVhZGVycyIsInN0YXR1c0NvZGUiLCJyZXN1bWUiLCJzdGF0dXNUZXh0IiwicmVzcG9uc2UiLCJvbkRhdGEiLCJvblVwZ3JhZGUiLCJzb2NrZXQiLCJvbkNvbXBsZXRlIiwib25GaW5hbGx5Iiwib25FcnJvciIsIm9mZiIsImFkZEhlYWRlciIsInZhbHVlIiwib3B0cyIsInJhdyIsInJhd0hlYWRlcnMiLCJzcGxpdCIsImhlYWRlciIsInByb2Nlc3NIZWFkZXJWYWx1ZSIsInZhbCIsInNraXBBcHBlbmQiLCJ1bmRlZmluZWQiLCJ0b0xvd2VyQ2FzZSIsInBhcnNlSW50IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/core/request.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js":
/*!***********************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/core/symbols.js ***!
  \***********************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    kClose: Symbol(\"close\"),\n    kDestroy: Symbol(\"destroy\"),\n    kDispatch: Symbol(\"dispatch\"),\n    kUrl: Symbol(\"url\"),\n    kWriting: Symbol(\"writing\"),\n    kResuming: Symbol(\"resuming\"),\n    kQueue: Symbol(\"queue\"),\n    kConnect: Symbol(\"connect\"),\n    kConnecting: Symbol(\"connecting\"),\n    kHeadersList: Symbol(\"headers list\"),\n    kKeepAliveDefaultTimeout: Symbol(\"default keep alive timeout\"),\n    kKeepAliveMaxTimeout: Symbol(\"max keep alive timeout\"),\n    kKeepAliveTimeoutThreshold: Symbol(\"keep alive timeout threshold\"),\n    kKeepAliveTimeoutValue: Symbol(\"keep alive timeout\"),\n    kKeepAlive: Symbol(\"keep alive\"),\n    kHeadersTimeout: Symbol(\"headers timeout\"),\n    kBodyTimeout: Symbol(\"body timeout\"),\n    kServerName: Symbol(\"server name\"),\n    kLocalAddress: Symbol(\"local address\"),\n    kHost: Symbol(\"host\"),\n    kNoRef: Symbol(\"no ref\"),\n    kBodyUsed: Symbol(\"used\"),\n    kRunning: Symbol(\"running\"),\n    kBlocking: Symbol(\"blocking\"),\n    kPending: Symbol(\"pending\"),\n    kSize: Symbol(\"size\"),\n    kBusy: Symbol(\"busy\"),\n    kQueued: Symbol(\"queued\"),\n    kFree: Symbol(\"free\"),\n    kConnected: Symbol(\"connected\"),\n    kClosed: Symbol(\"closed\"),\n    kNeedDrain: Symbol(\"need drain\"),\n    kReset: Symbol(\"reset\"),\n    kDestroyed: Symbol.for(\"nodejs.stream.destroyed\"),\n    kMaxHeadersSize: Symbol(\"max headers size\"),\n    kRunningIdx: Symbol(\"running index\"),\n    kPendingIdx: Symbol(\"pending index\"),\n    kError: Symbol(\"error\"),\n    kClients: Symbol(\"clients\"),\n    kClient: Symbol(\"client\"),\n    kParser: Symbol(\"parser\"),\n    kOnDestroyed: Symbol(\"destroy callbacks\"),\n    kPipelining: Symbol(\"pipelining\"),\n    kSocket: Symbol(\"socket\"),\n    kHostHeader: Symbol(\"host header\"),\n    kConnector: Symbol(\"connector\"),\n    kStrictContentLength: Symbol(\"strict content length\"),\n    kMaxRedirections: Symbol(\"maxRedirections\"),\n    kMaxRequests: Symbol(\"maxRequestsPerClient\"),\n    kProxy: Symbol(\"proxy agent options\"),\n    kCounter: Symbol(\"socket request counter\"),\n    kInterceptors: Symbol(\"dispatch interceptors\"),\n    kMaxResponseSize: Symbol(\"max response size\"),\n    kHTTP2Session: Symbol(\"http2Session\"),\n    kHTTP2SessionState: Symbol(\"http2Session state\"),\n    kHTTP2BuildRequest: Symbol(\"http2 build request\"),\n    kHTTP1BuildRequest: Symbol(\"http1 build request\"),\n    kHTTP2CopyHeaders: Symbol(\"http2 copy headers\"),\n    kHTTPConnVersion: Symbol(\"http connection version\"),\n    kRetryHandlerDefaultRetry: Symbol(\"retry agent default retry\"),\n    kConstruct: Symbol(\"constructable\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS9zeW1ib2xzLmpzIiwibWFwcGluZ3MiOiI7QUFBQUEsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZDLFFBQVFDLE9BQU87SUFDZkMsVUFBVUQsT0FBTztJQUNqQkUsV0FBV0YsT0FBTztJQUNsQkcsTUFBTUgsT0FBTztJQUNiSSxVQUFVSixPQUFPO0lBQ2pCSyxXQUFXTCxPQUFPO0lBQ2xCTSxRQUFRTixPQUFPO0lBQ2ZPLFVBQVVQLE9BQU87SUFDakJRLGFBQWFSLE9BQU87SUFDcEJTLGNBQWNULE9BQU87SUFDckJVLDBCQUEwQlYsT0FBTztJQUNqQ1csc0JBQXNCWCxPQUFPO0lBQzdCWSw0QkFBNEJaLE9BQU87SUFDbkNhLHdCQUF3QmIsT0FBTztJQUMvQmMsWUFBWWQsT0FBTztJQUNuQmUsaUJBQWlCZixPQUFPO0lBQ3hCZ0IsY0FBY2hCLE9BQU87SUFDckJpQixhQUFhakIsT0FBTztJQUNwQmtCLGVBQWVsQixPQUFPO0lBQ3RCbUIsT0FBT25CLE9BQU87SUFDZG9CLFFBQVFwQixPQUFPO0lBQ2ZxQixXQUFXckIsT0FBTztJQUNsQnNCLFVBQVV0QixPQUFPO0lBQ2pCdUIsV0FBV3ZCLE9BQU87SUFDbEJ3QixVQUFVeEIsT0FBTztJQUNqQnlCLE9BQU96QixPQUFPO0lBQ2QwQixPQUFPMUIsT0FBTztJQUNkMkIsU0FBUzNCLE9BQU87SUFDaEI0QixPQUFPNUIsT0FBTztJQUNkNkIsWUFBWTdCLE9BQU87SUFDbkI4QixTQUFTOUIsT0FBTztJQUNoQitCLFlBQVkvQixPQUFPO0lBQ25CZ0MsUUFBUWhDLE9BQU87SUFDZmlDLFlBQVlqQyxPQUFPa0MsR0FBRyxDQUFDO0lBQ3ZCQyxpQkFBaUJuQyxPQUFPO0lBQ3hCb0MsYUFBYXBDLE9BQU87SUFDcEJxQyxhQUFhckMsT0FBTztJQUNwQnNDLFFBQVF0QyxPQUFPO0lBQ2Z1QyxVQUFVdkMsT0FBTztJQUNqQndDLFNBQVN4QyxPQUFPO0lBQ2hCeUMsU0FBU3pDLE9BQU87SUFDaEIwQyxjQUFjMUMsT0FBTztJQUNyQjJDLGFBQWEzQyxPQUFPO0lBQ3BCNEMsU0FBUzVDLE9BQU87SUFDaEI2QyxhQUFhN0MsT0FBTztJQUNwQjhDLFlBQVk5QyxPQUFPO0lBQ25CK0Msc0JBQXNCL0MsT0FBTztJQUM3QmdELGtCQUFrQmhELE9BQU87SUFDekJpRCxjQUFjakQsT0FBTztJQUNyQmtELFFBQVFsRCxPQUFPO0lBQ2ZtRCxVQUFVbkQsT0FBTztJQUNqQm9ELGVBQWVwRCxPQUFPO0lBQ3RCcUQsa0JBQWtCckQsT0FBTztJQUN6QnNELGVBQWV0RCxPQUFPO0lBQ3RCdUQsb0JBQW9CdkQsT0FBTztJQUMzQndELG9CQUFvQnhELE9BQU87SUFDM0J5RCxvQkFBb0J6RCxPQUFPO0lBQzNCMEQsbUJBQW1CMUQsT0FBTztJQUMxQjJELGtCQUFrQjNELE9BQU87SUFDekI0RCwyQkFBMkI1RCxPQUFPO0lBQ2xDNkQsWUFBWTdELE9BQU87QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3N5bWJvbHMuanM/MDA2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcbiAga0Nsb3NlOiBTeW1ib2woJ2Nsb3NlJyksXG4gIGtEZXN0cm95OiBTeW1ib2woJ2Rlc3Ryb3knKSxcbiAga0Rpc3BhdGNoOiBTeW1ib2woJ2Rpc3BhdGNoJyksXG4gIGtVcmw6IFN5bWJvbCgndXJsJyksXG4gIGtXcml0aW5nOiBTeW1ib2woJ3dyaXRpbmcnKSxcbiAga1Jlc3VtaW5nOiBTeW1ib2woJ3Jlc3VtaW5nJyksXG4gIGtRdWV1ZTogU3ltYm9sKCdxdWV1ZScpLFxuICBrQ29ubmVjdDogU3ltYm9sKCdjb25uZWN0JyksXG4gIGtDb25uZWN0aW5nOiBTeW1ib2woJ2Nvbm5lY3RpbmcnKSxcbiAga0hlYWRlcnNMaXN0OiBTeW1ib2woJ2hlYWRlcnMgbGlzdCcpLFxuICBrS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXQ6IFN5bWJvbCgnZGVmYXVsdCBrZWVwIGFsaXZlIHRpbWVvdXQnKSxcbiAga0tlZXBBbGl2ZU1heFRpbWVvdXQ6IFN5bWJvbCgnbWF4IGtlZXAgYWxpdmUgdGltZW91dCcpLFxuICBrS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZDogU3ltYm9sKCdrZWVwIGFsaXZlIHRpbWVvdXQgdGhyZXNob2xkJyksXG4gIGtLZWVwQWxpdmVUaW1lb3V0VmFsdWU6IFN5bWJvbCgna2VlcCBhbGl2ZSB0aW1lb3V0JyksXG4gIGtLZWVwQWxpdmU6IFN5bWJvbCgna2VlcCBhbGl2ZScpLFxuICBrSGVhZGVyc1RpbWVvdXQ6IFN5bWJvbCgnaGVhZGVycyB0aW1lb3V0JyksXG4gIGtCb2R5VGltZW91dDogU3ltYm9sKCdib2R5IHRpbWVvdXQnKSxcbiAga1NlcnZlck5hbWU6IFN5bWJvbCgnc2VydmVyIG5hbWUnKSxcbiAga0xvY2FsQWRkcmVzczogU3ltYm9sKCdsb2NhbCBhZGRyZXNzJyksXG4gIGtIb3N0OiBTeW1ib2woJ2hvc3QnKSxcbiAga05vUmVmOiBTeW1ib2woJ25vIHJlZicpLFxuICBrQm9keVVzZWQ6IFN5bWJvbCgndXNlZCcpLFxuICBrUnVubmluZzogU3ltYm9sKCdydW5uaW5nJyksXG4gIGtCbG9ja2luZzogU3ltYm9sKCdibG9ja2luZycpLFxuICBrUGVuZGluZzogU3ltYm9sKCdwZW5kaW5nJyksXG4gIGtTaXplOiBTeW1ib2woJ3NpemUnKSxcbiAga0J1c3k6IFN5bWJvbCgnYnVzeScpLFxuICBrUXVldWVkOiBTeW1ib2woJ3F1ZXVlZCcpLFxuICBrRnJlZTogU3ltYm9sKCdmcmVlJyksXG4gIGtDb25uZWN0ZWQ6IFN5bWJvbCgnY29ubmVjdGVkJyksXG4gIGtDbG9zZWQ6IFN5bWJvbCgnY2xvc2VkJyksXG4gIGtOZWVkRHJhaW46IFN5bWJvbCgnbmVlZCBkcmFpbicpLFxuICBrUmVzZXQ6IFN5bWJvbCgncmVzZXQnKSxcbiAga0Rlc3Ryb3llZDogU3ltYm9sLmZvcignbm9kZWpzLnN0cmVhbS5kZXN0cm95ZWQnKSxcbiAga01heEhlYWRlcnNTaXplOiBTeW1ib2woJ21heCBoZWFkZXJzIHNpemUnKSxcbiAga1J1bm5pbmdJZHg6IFN5bWJvbCgncnVubmluZyBpbmRleCcpLFxuICBrUGVuZGluZ0lkeDogU3ltYm9sKCdwZW5kaW5nIGluZGV4JyksXG4gIGtFcnJvcjogU3ltYm9sKCdlcnJvcicpLFxuICBrQ2xpZW50czogU3ltYm9sKCdjbGllbnRzJyksXG4gIGtDbGllbnQ6IFN5bWJvbCgnY2xpZW50JyksXG4gIGtQYXJzZXI6IFN5bWJvbCgncGFyc2VyJyksXG4gIGtPbkRlc3Ryb3llZDogU3ltYm9sKCdkZXN0cm95IGNhbGxiYWNrcycpLFxuICBrUGlwZWxpbmluZzogU3ltYm9sKCdwaXBlbGluaW5nJyksXG4gIGtTb2NrZXQ6IFN5bWJvbCgnc29ja2V0JyksXG4gIGtIb3N0SGVhZGVyOiBTeW1ib2woJ2hvc3QgaGVhZGVyJyksXG4gIGtDb25uZWN0b3I6IFN5bWJvbCgnY29ubmVjdG9yJyksXG4gIGtTdHJpY3RDb250ZW50TGVuZ3RoOiBTeW1ib2woJ3N0cmljdCBjb250ZW50IGxlbmd0aCcpLFxuICBrTWF4UmVkaXJlY3Rpb25zOiBTeW1ib2woJ21heFJlZGlyZWN0aW9ucycpLFxuICBrTWF4UmVxdWVzdHM6IFN5bWJvbCgnbWF4UmVxdWVzdHNQZXJDbGllbnQnKSxcbiAga1Byb3h5OiBTeW1ib2woJ3Byb3h5IGFnZW50IG9wdGlvbnMnKSxcbiAga0NvdW50ZXI6IFN5bWJvbCgnc29ja2V0IHJlcXVlc3QgY291bnRlcicpLFxuICBrSW50ZXJjZXB0b3JzOiBTeW1ib2woJ2Rpc3BhdGNoIGludGVyY2VwdG9ycycpLFxuICBrTWF4UmVzcG9uc2VTaXplOiBTeW1ib2woJ21heCByZXNwb25zZSBzaXplJyksXG4gIGtIVFRQMlNlc3Npb246IFN5bWJvbCgnaHR0cDJTZXNzaW9uJyksXG4gIGtIVFRQMlNlc3Npb25TdGF0ZTogU3ltYm9sKCdodHRwMlNlc3Npb24gc3RhdGUnKSxcbiAga0hUVFAyQnVpbGRSZXF1ZXN0OiBTeW1ib2woJ2h0dHAyIGJ1aWxkIHJlcXVlc3QnKSxcbiAga0hUVFAxQnVpbGRSZXF1ZXN0OiBTeW1ib2woJ2h0dHAxIGJ1aWxkIHJlcXVlc3QnKSxcbiAga0hUVFAyQ29weUhlYWRlcnM6IFN5bWJvbCgnaHR0cDIgY29weSBoZWFkZXJzJyksXG4gIGtIVFRQQ29ublZlcnNpb246IFN5bWJvbCgnaHR0cCBjb25uZWN0aW9uIHZlcnNpb24nKSxcbiAga1JldHJ5SGFuZGxlckRlZmF1bHRSZXRyeTogU3ltYm9sKCdyZXRyeSBhZ2VudCBkZWZhdWx0IHJldHJ5JyksXG4gIGtDb25zdHJ1Y3Q6IFN5bWJvbCgnY29uc3RydWN0YWJsZScpXG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImtDbG9zZSIsIlN5bWJvbCIsImtEZXN0cm95Iiwia0Rpc3BhdGNoIiwia1VybCIsImtXcml0aW5nIiwia1Jlc3VtaW5nIiwia1F1ZXVlIiwia0Nvbm5lY3QiLCJrQ29ubmVjdGluZyIsImtIZWFkZXJzTGlzdCIsImtLZWVwQWxpdmVEZWZhdWx0VGltZW91dCIsImtLZWVwQWxpdmVNYXhUaW1lb3V0Iiwia0tlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQiLCJrS2VlcEFsaXZlVGltZW91dFZhbHVlIiwia0tlZXBBbGl2ZSIsImtIZWFkZXJzVGltZW91dCIsImtCb2R5VGltZW91dCIsImtTZXJ2ZXJOYW1lIiwia0xvY2FsQWRkcmVzcyIsImtIb3N0Iiwia05vUmVmIiwia0JvZHlVc2VkIiwia1J1bm5pbmciLCJrQmxvY2tpbmciLCJrUGVuZGluZyIsImtTaXplIiwia0J1c3kiLCJrUXVldWVkIiwia0ZyZWUiLCJrQ29ubmVjdGVkIiwia0Nsb3NlZCIsImtOZWVkRHJhaW4iLCJrUmVzZXQiLCJrRGVzdHJveWVkIiwiZm9yIiwia01heEhlYWRlcnNTaXplIiwia1J1bm5pbmdJZHgiLCJrUGVuZGluZ0lkeCIsImtFcnJvciIsImtDbGllbnRzIiwia0NsaWVudCIsImtQYXJzZXIiLCJrT25EZXN0cm95ZWQiLCJrUGlwZWxpbmluZyIsImtTb2NrZXQiLCJrSG9zdEhlYWRlciIsImtDb25uZWN0b3IiLCJrU3RyaWN0Q29udGVudExlbmd0aCIsImtNYXhSZWRpcmVjdGlvbnMiLCJrTWF4UmVxdWVzdHMiLCJrUHJveHkiLCJrQ291bnRlciIsImtJbnRlcmNlcHRvcnMiLCJrTWF4UmVzcG9uc2VTaXplIiwia0hUVFAyU2Vzc2lvbiIsImtIVFRQMlNlc3Npb25TdGF0ZSIsImtIVFRQMkJ1aWxkUmVxdWVzdCIsImtIVFRQMUJ1aWxkUmVxdWVzdCIsImtIVFRQMkNvcHlIZWFkZXJzIiwia0hUVFBDb25uVmVyc2lvbiIsImtSZXRyeUhhbmRsZXJEZWZhdWx0UmV0cnkiLCJrQ29uc3RydWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js":
/*!********************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/core/util.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { kDestroyed, kBodyUsed } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\");\nconst { IncomingMessage } = __webpack_require__(/*! http */ \"http\");\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\nconst { Blob } = __webpack_require__(/*! buffer */ \"buffer\");\nconst nodeUtil = __webpack_require__(/*! util */ \"util\");\nconst { stringify } = __webpack_require__(/*! querystring */ \"querystring\");\nconst [nodeMajor, nodeMinor] = process.versions.node.split(\".\").map((v)=>Number(v));\nfunction nop() {}\nfunction isStream(obj) {\n    return obj && typeof obj === \"object\" && typeof obj.pipe === \"function\" && typeof obj.on === \"function\";\n}\n// based on https://github.com/node-fetch/fetch-blob/blob/8ab587d34080de94140b54f07168451e7d0b655e/index.js#L229-L241 (MIT License)\nfunction isBlobLike(object) {\n    return Blob && object instanceof Blob || object && typeof object === \"object\" && (typeof object.stream === \"function\" || typeof object.arrayBuffer === \"function\") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);\n}\nfunction buildURL(url, queryParams) {\n    if (url.includes(\"?\") || url.includes(\"#\")) {\n        throw new Error('Query params cannot be passed when url already contains \"?\" or \"#\".');\n    }\n    const stringified = stringify(queryParams);\n    if (stringified) {\n        url += \"?\" + stringified;\n    }\n    return url;\n}\nfunction parseURL(url) {\n    if (typeof url === \"string\") {\n        url = new URL(url);\n        if (!/^https?:/.test(url.origin || url.protocol)) {\n            throw new InvalidArgumentError(\"Invalid URL protocol: the URL must start with `http:` or `https:`.\");\n        }\n        return url;\n    }\n    if (!url || typeof url !== \"object\") {\n        throw new InvalidArgumentError(\"Invalid URL: The URL argument must be a non-null object.\");\n    }\n    if (!/^https?:/.test(url.origin || url.protocol)) {\n        throw new InvalidArgumentError(\"Invalid URL protocol: the URL must start with `http:` or `https:`.\");\n    }\n    if (!(url instanceof URL)) {\n        if (url.port != null && url.port !== \"\" && !Number.isFinite(parseInt(url.port))) {\n            throw new InvalidArgumentError(\"Invalid URL: port must be a valid integer or a string representation of an integer.\");\n        }\n        if (url.path != null && typeof url.path !== \"string\") {\n            throw new InvalidArgumentError(\"Invalid URL path: the path must be a string or null/undefined.\");\n        }\n        if (url.pathname != null && typeof url.pathname !== \"string\") {\n            throw new InvalidArgumentError(\"Invalid URL pathname: the pathname must be a string or null/undefined.\");\n        }\n        if (url.hostname != null && typeof url.hostname !== \"string\") {\n            throw new InvalidArgumentError(\"Invalid URL hostname: the hostname must be a string or null/undefined.\");\n        }\n        if (url.origin != null && typeof url.origin !== \"string\") {\n            throw new InvalidArgumentError(\"Invalid URL origin: the origin must be a string or null/undefined.\");\n        }\n        const port = url.port != null ? url.port : url.protocol === \"https:\" ? 443 : 80;\n        let origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;\n        let path = url.path != null ? url.path : `${url.pathname || \"\"}${url.search || \"\"}`;\n        if (origin.endsWith(\"/\")) {\n            origin = origin.substring(0, origin.length - 1);\n        }\n        if (path && !path.startsWith(\"/\")) {\n            path = `/${path}`;\n        }\n        // new URL(path, origin) is unsafe when `path` contains an absolute URL\n        // From https://developer.mozilla.org/en-US/docs/Web/API/URL/URL:\n        // If first parameter is a relative URL, second param is required, and will be used as the base URL.\n        // If first parameter is an absolute URL, a given second param will be ignored.\n        url = new URL(origin + path);\n    }\n    return url;\n}\nfunction parseOrigin(url) {\n    url = parseURL(url);\n    if (url.pathname !== \"/\" || url.search || url.hash) {\n        throw new InvalidArgumentError(\"invalid url\");\n    }\n    return url;\n}\nfunction getHostname(host) {\n    if (host[0] === \"[\") {\n        const idx = host.indexOf(\"]\");\n        assert(idx !== -1);\n        return host.substring(1, idx);\n    }\n    const idx = host.indexOf(\":\");\n    if (idx === -1) return host;\n    return host.substring(0, idx);\n}\n// IP addresses are not valid server names per RFC6066\n// > Currently, the only server names supported are DNS hostnames\nfunction getServerName(host) {\n    if (!host) {\n        return null;\n    }\n    assert.strictEqual(typeof host, \"string\");\n    const servername = getHostname(host);\n    if (net.isIP(servername)) {\n        return \"\";\n    }\n    return servername;\n}\nfunction deepClone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\nfunction isAsyncIterable(obj) {\n    return !!(obj != null && typeof obj[Symbol.asyncIterator] === \"function\");\n}\nfunction isIterable(obj) {\n    return !!(obj != null && (typeof obj[Symbol.iterator] === \"function\" || typeof obj[Symbol.asyncIterator] === \"function\"));\n}\nfunction bodyLength(body) {\n    if (body == null) {\n        return 0;\n    } else if (isStream(body)) {\n        const state = body._readableState;\n        return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;\n    } else if (isBlobLike(body)) {\n        return body.size != null ? body.size : null;\n    } else if (isBuffer(body)) {\n        return body.byteLength;\n    }\n    return null;\n}\nfunction isDestroyed(stream) {\n    return !stream || !!(stream.destroyed || stream[kDestroyed]);\n}\nfunction isReadableAborted(stream) {\n    const state = stream && stream._readableState;\n    return isDestroyed(stream) && state && !state.endEmitted;\n}\nfunction destroy(stream, err) {\n    if (stream == null || !isStream(stream) || isDestroyed(stream)) {\n        return;\n    }\n    if (typeof stream.destroy === \"function\") {\n        if (Object.getPrototypeOf(stream).constructor === IncomingMessage) {\n            // See: https://github.com/nodejs/node/pull/38505/files\n            stream.socket = null;\n        }\n        stream.destroy(err);\n    } else if (err) {\n        process.nextTick((stream, err)=>{\n            stream.emit(\"error\", err);\n        }, stream, err);\n    }\n    if (stream.destroyed !== true) {\n        stream[kDestroyed] = true;\n    }\n}\nconst KEEPALIVE_TIMEOUT_EXPR = /timeout=(\\d+)/;\nfunction parseKeepAliveTimeout(val) {\n    const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);\n    return m ? parseInt(m[1], 10) * 1000 : null;\n}\nfunction parseHeaders(headers, obj = {}) {\n    // For H2 support\n    if (!Array.isArray(headers)) return headers;\n    for(let i = 0; i < headers.length; i += 2){\n        const key = headers[i].toString().toLowerCase();\n        let val = obj[key];\n        if (!val) {\n            if (Array.isArray(headers[i + 1])) {\n                obj[key] = headers[i + 1].map((x)=>x.toString(\"utf8\"));\n            } else {\n                obj[key] = headers[i + 1].toString(\"utf8\");\n            }\n        } else {\n            if (!Array.isArray(val)) {\n                val = [\n                    val\n                ];\n                obj[key] = val;\n            }\n            val.push(headers[i + 1].toString(\"utf8\"));\n        }\n    }\n    // See https://github.com/nodejs/node/pull/46528\n    if (\"content-length\" in obj && \"content-disposition\" in obj) {\n        obj[\"content-disposition\"] = Buffer.from(obj[\"content-disposition\"]).toString(\"latin1\");\n    }\n    return obj;\n}\nfunction parseRawHeaders(headers) {\n    const ret = [];\n    let hasContentLength = false;\n    let contentDispositionIdx = -1;\n    for(let n = 0; n < headers.length; n += 2){\n        const key = headers[n + 0].toString();\n        const val = headers[n + 1].toString(\"utf8\");\n        if (key.length === 14 && (key === \"content-length\" || key.toLowerCase() === \"content-length\")) {\n            ret.push(key, val);\n            hasContentLength = true;\n        } else if (key.length === 19 && (key === \"content-disposition\" || key.toLowerCase() === \"content-disposition\")) {\n            contentDispositionIdx = ret.push(key, val) - 1;\n        } else {\n            ret.push(key, val);\n        }\n    }\n    // See https://github.com/nodejs/node/pull/46528\n    if (hasContentLength && contentDispositionIdx !== -1) {\n        ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString(\"latin1\");\n    }\n    return ret;\n}\nfunction isBuffer(buffer) {\n    // See, https://github.com/mcollina/undici/pull/319\n    return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);\n}\nfunction validateHandler(handler, method, upgrade) {\n    if (!handler || typeof handler !== \"object\") {\n        throw new InvalidArgumentError(\"handler must be an object\");\n    }\n    if (typeof handler.onConnect !== \"function\") {\n        throw new InvalidArgumentError(\"invalid onConnect method\");\n    }\n    if (typeof handler.onError !== \"function\") {\n        throw new InvalidArgumentError(\"invalid onError method\");\n    }\n    if (typeof handler.onBodySent !== \"function\" && handler.onBodySent !== undefined) {\n        throw new InvalidArgumentError(\"invalid onBodySent method\");\n    }\n    if (upgrade || method === \"CONNECT\") {\n        if (typeof handler.onUpgrade !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onUpgrade method\");\n        }\n    } else {\n        if (typeof handler.onHeaders !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onHeaders method\");\n        }\n        if (typeof handler.onData !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onData method\");\n        }\n        if (typeof handler.onComplete !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onComplete method\");\n        }\n    }\n}\n// A body is disturbed if it has been read from and it cannot\n// be re-used without losing state or data.\nfunction isDisturbed(body) {\n    return !!(body && (stream.isDisturbed ? stream.isDisturbed(body) || body[kBodyUsed] // TODO (fix): Why is body[kBodyUsed] needed?\n     : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));\n}\nfunction isErrored(body) {\n    return !!(body && (stream.isErrored ? stream.isErrored(body) : /state: 'errored'/.test(nodeUtil.inspect(body))));\n}\nfunction isReadable(body) {\n    return !!(body && (stream.isReadable ? stream.isReadable(body) : /state: 'readable'/.test(nodeUtil.inspect(body))));\n}\nfunction getSocketInfo(socket) {\n    return {\n        localAddress: socket.localAddress,\n        localPort: socket.localPort,\n        remoteAddress: socket.remoteAddress,\n        remotePort: socket.remotePort,\n        remoteFamily: socket.remoteFamily,\n        timeout: socket.timeout,\n        bytesWritten: socket.bytesWritten,\n        bytesRead: socket.bytesRead\n    };\n}\nasync function* convertIterableToBuffer(iterable) {\n    for await (const chunk of iterable){\n        yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);\n    }\n}\nlet ReadableStream;\nfunction ReadableStreamFrom(iterable) {\n    if (!ReadableStream) {\n        ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n    }\n    if (ReadableStream.from) {\n        return ReadableStream.from(convertIterableToBuffer(iterable));\n    }\n    let iterator;\n    return new ReadableStream({\n        async start () {\n            iterator = iterable[Symbol.asyncIterator]();\n        },\n        async pull (controller) {\n            const { done, value } = await iterator.next();\n            if (done) {\n                queueMicrotask(()=>{\n                    controller.close();\n                });\n            } else {\n                const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);\n                controller.enqueue(new Uint8Array(buf));\n            }\n            return controller.desiredSize > 0;\n        },\n        async cancel (reason) {\n            await iterator.return();\n        }\n    }, 0);\n}\n// The chunk should be a FormData instance and contains\n// all the required methods.\nfunction isFormDataLike(object) {\n    return object && typeof object === \"object\" && typeof object.append === \"function\" && typeof object.delete === \"function\" && typeof object.get === \"function\" && typeof object.getAll === \"function\" && typeof object.has === \"function\" && typeof object.set === \"function\" && object[Symbol.toStringTag] === \"FormData\";\n}\nfunction throwIfAborted(signal) {\n    if (!signal) {\n        return;\n    }\n    if (typeof signal.throwIfAborted === \"function\") {\n        signal.throwIfAborted();\n    } else {\n        if (signal.aborted) {\n            // DOMException not available < v17.0.0\n            const err = new Error(\"The operation was aborted\");\n            err.name = \"AbortError\";\n            throw err;\n        }\n    }\n}\nfunction addAbortListener(signal, listener) {\n    if (\"addEventListener\" in signal) {\n        signal.addEventListener(\"abort\", listener, {\n            once: true\n        });\n        return ()=>signal.removeEventListener(\"abort\", listener);\n    }\n    signal.addListener(\"abort\", listener);\n    return ()=>signal.removeListener(\"abort\", listener);\n}\nconst hasToWellFormed = !!String.prototype.toWellFormed;\n/**\n * @param {string} val\n */ function toUSVString(val) {\n    if (hasToWellFormed) {\n        return `${val}`.toWellFormed();\n    } else if (nodeUtil.toUSVString) {\n        return nodeUtil.toUSVString(val);\n    }\n    return `${val}`;\n}\n// Parsed accordingly to RFC 9110\n// https://www.rfc-editor.org/rfc/rfc9110#field.content-range\nfunction parseRangeHeader(range) {\n    if (range == null || range === \"\") return {\n        start: 0,\n        end: null,\n        size: null\n    };\n    const m = range ? range.match(/^bytes (\\d+)-(\\d+)\\/(\\d+)?$/) : null;\n    return m ? {\n        start: parseInt(m[1]),\n        end: m[2] ? parseInt(m[2]) : null,\n        size: m[3] ? parseInt(m[3]) : null\n    } : null;\n}\nconst kEnumerableProperty = Object.create(null);\nkEnumerableProperty.enumerable = true;\nmodule.exports = {\n    kEnumerableProperty,\n    nop,\n    isDisturbed,\n    isErrored,\n    isReadable,\n    toUSVString,\n    isReadableAborted,\n    isBlobLike,\n    parseOrigin,\n    parseURL,\n    getServerName,\n    isStream,\n    isIterable,\n    isAsyncIterable,\n    isDestroyed,\n    parseRawHeaders,\n    parseHeaders,\n    parseKeepAliveTimeout,\n    destroy,\n    bodyLength,\n    deepClone,\n    ReadableStreamFrom,\n    isBuffer,\n    validateHandler,\n    getSocketInfo,\n    isFormDataLike,\n    buildURL,\n    throwIfAborted,\n    addAbortListener,\n    parseRangeHeader,\n    nodeMajor,\n    nodeMinor,\n    nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13,\n    safeHTTPMethods: [\n        \"GET\",\n        \"HEAD\",\n        \"OPTIONS\",\n        \"TRACE\"\n    ]\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLFNBQVMsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUMxQyxNQUFNLEVBQUVHLGVBQWUsRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQztBQUNwQyxNQUFNSSxTQUFTSixtQkFBT0EsQ0FBQztBQUN2QixNQUFNSyxNQUFNTCxtQkFBT0EsQ0FBQztBQUNwQixNQUFNLEVBQUVNLG9CQUFvQixFQUFFLEdBQUdOLG1CQUFPQSxDQUFDO0FBQ3pDLE1BQU0sRUFBRU8sSUFBSSxFQUFFLEdBQUdQLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU1RLFdBQVdSLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU0sRUFBRVMsU0FBUyxFQUFFLEdBQUdULG1CQUFPQSxDQUFDO0FBRTlCLE1BQU0sQ0FBQ1UsV0FBV0MsVUFBVSxHQUFHQyxRQUFRQyxRQUFRLENBQUNDLElBQUksQ0FBQ0MsS0FBSyxDQUFDLEtBQUtDLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0MsT0FBT0Q7QUFFaEYsU0FBU0UsT0FBUTtBQUVqQixTQUFTQyxTQUFVQyxHQUFHO0lBQ3BCLE9BQU9BLE9BQU8sT0FBT0EsUUFBUSxZQUFZLE9BQU9BLElBQUlDLElBQUksS0FBSyxjQUFjLE9BQU9ELElBQUlFLEVBQUUsS0FBSztBQUMvRjtBQUVBLG1JQUFtSTtBQUNuSSxTQUFTQyxXQUFZQyxNQUFNO0lBQ3pCLE9BQU8sUUFBU0Esa0JBQWtCbEIsUUFDaENrQixVQUNBLE9BQU9BLFdBQVcsWUFDakIsUUFBT0EsT0FBT3JCLE1BQU0sS0FBSyxjQUN4QixPQUFPcUIsT0FBT0MsV0FBVyxLQUFLLFVBQVMsS0FDekMsZ0JBQWdCQyxJQUFJLENBQUNGLE1BQU0sQ0FBQ0csT0FBT0MsV0FBVyxDQUFDO0FBRW5EO0FBRUEsU0FBU0MsU0FBVUMsR0FBRyxFQUFFQyxXQUFXO0lBQ2pDLElBQUlELElBQUlFLFFBQVEsQ0FBQyxRQUFRRixJQUFJRSxRQUFRLENBQUMsTUFBTTtRQUMxQyxNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFFQSxNQUFNQyxjQUFjMUIsVUFBVXVCO0lBRTlCLElBQUlHLGFBQWE7UUFDZkosT0FBTyxNQUFNSTtJQUNmO0lBRUEsT0FBT0o7QUFDVDtBQUVBLFNBQVNLLFNBQVVMLEdBQUc7SUFDcEIsSUFBSSxPQUFPQSxRQUFRLFVBQVU7UUFDM0JBLE1BQU0sSUFBSU0sSUFBSU47UUFFZCxJQUFJLENBQUMsV0FBV0osSUFBSSxDQUFDSSxJQUFJTyxNQUFNLElBQUlQLElBQUlRLFFBQVEsR0FBRztZQUNoRCxNQUFNLElBQUlqQyxxQkFBcUI7UUFDakM7UUFFQSxPQUFPeUI7SUFDVDtJQUVBLElBQUksQ0FBQ0EsT0FBTyxPQUFPQSxRQUFRLFVBQVU7UUFDbkMsTUFBTSxJQUFJekIscUJBQXFCO0lBQ2pDO0lBRUEsSUFBSSxDQUFDLFdBQVdxQixJQUFJLENBQUNJLElBQUlPLE1BQU0sSUFBSVAsSUFBSVEsUUFBUSxHQUFHO1FBQ2hELE1BQU0sSUFBSWpDLHFCQUFxQjtJQUNqQztJQUVBLElBQUksQ0FBRXlCLENBQUFBLGVBQWVNLEdBQUUsR0FBSTtRQUN6QixJQUFJTixJQUFJUyxJQUFJLElBQUksUUFBUVQsSUFBSVMsSUFBSSxLQUFLLE1BQU0sQ0FBQ3RCLE9BQU91QixRQUFRLENBQUNDLFNBQVNYLElBQUlTLElBQUksSUFBSTtZQUMvRSxNQUFNLElBQUlsQyxxQkFBcUI7UUFDakM7UUFFQSxJQUFJeUIsSUFBSVksSUFBSSxJQUFJLFFBQVEsT0FBT1osSUFBSVksSUFBSSxLQUFLLFVBQVU7WUFDcEQsTUFBTSxJQUFJckMscUJBQXFCO1FBQ2pDO1FBRUEsSUFBSXlCLElBQUlhLFFBQVEsSUFBSSxRQUFRLE9BQU9iLElBQUlhLFFBQVEsS0FBSyxVQUFVO1lBQzVELE1BQU0sSUFBSXRDLHFCQUFxQjtRQUNqQztRQUVBLElBQUl5QixJQUFJYyxRQUFRLElBQUksUUFBUSxPQUFPZCxJQUFJYyxRQUFRLEtBQUssVUFBVTtZQUM1RCxNQUFNLElBQUl2QyxxQkFBcUI7UUFDakM7UUFFQSxJQUFJeUIsSUFBSU8sTUFBTSxJQUFJLFFBQVEsT0FBT1AsSUFBSU8sTUFBTSxLQUFLLFVBQVU7WUFDeEQsTUFBTSxJQUFJaEMscUJBQXFCO1FBQ2pDO1FBRUEsTUFBTWtDLE9BQU9ULElBQUlTLElBQUksSUFBSSxPQUNyQlQsSUFBSVMsSUFBSSxHQUNQVCxJQUFJUSxRQUFRLEtBQUssV0FBVyxNQUFNO1FBQ3ZDLElBQUlELFNBQVNQLElBQUlPLE1BQU0sSUFBSSxPQUN2QlAsSUFBSU8sTUFBTSxHQUNWLENBQUMsRUFBRVAsSUFBSVEsUUFBUSxDQUFDLEVBQUUsRUFBRVIsSUFBSWMsUUFBUSxDQUFDLENBQUMsRUFBRUwsS0FBSyxDQUFDO1FBQzlDLElBQUlHLE9BQU9aLElBQUlZLElBQUksSUFBSSxPQUNuQlosSUFBSVksSUFBSSxHQUNSLENBQUMsRUFBRVosSUFBSWEsUUFBUSxJQUFJLEdBQUcsRUFBRWIsSUFBSWUsTUFBTSxJQUFJLEdBQUcsQ0FBQztRQUU5QyxJQUFJUixPQUFPUyxRQUFRLENBQUMsTUFBTTtZQUN4QlQsU0FBU0EsT0FBT1UsU0FBUyxDQUFDLEdBQUdWLE9BQU9XLE1BQU0sR0FBRztRQUMvQztRQUVBLElBQUlOLFFBQVEsQ0FBQ0EsS0FBS08sVUFBVSxDQUFDLE1BQU07WUFDakNQLE9BQU8sQ0FBQyxDQUFDLEVBQUVBLEtBQUssQ0FBQztRQUNuQjtRQUNBLHVFQUF1RTtRQUN2RSxpRUFBaUU7UUFDakUsb0dBQW9HO1FBQ3BHLCtFQUErRTtRQUMvRVosTUFBTSxJQUFJTSxJQUFJQyxTQUFTSztJQUN6QjtJQUVBLE9BQU9aO0FBQ1Q7QUFFQSxTQUFTb0IsWUFBYXBCLEdBQUc7SUFDdkJBLE1BQU1LLFNBQVNMO0lBRWYsSUFBSUEsSUFBSWEsUUFBUSxLQUFLLE9BQU9iLElBQUllLE1BQU0sSUFBSWYsSUFBSXFCLElBQUksRUFBRTtRQUNsRCxNQUFNLElBQUk5QyxxQkFBcUI7SUFDakM7SUFFQSxPQUFPeUI7QUFDVDtBQUVBLFNBQVNzQixZQUFhQyxJQUFJO0lBQ3hCLElBQUlBLElBQUksQ0FBQyxFQUFFLEtBQUssS0FBSztRQUNuQixNQUFNQyxNQUFNRCxLQUFLRSxPQUFPLENBQUM7UUFFekJ6RCxPQUFPd0QsUUFBUSxDQUFDO1FBQ2hCLE9BQU9ELEtBQUtOLFNBQVMsQ0FBQyxHQUFHTztJQUMzQjtJQUVBLE1BQU1BLE1BQU1ELEtBQUtFLE9BQU8sQ0FBQztJQUN6QixJQUFJRCxRQUFRLENBQUMsR0FBRyxPQUFPRDtJQUV2QixPQUFPQSxLQUFLTixTQUFTLENBQUMsR0FBR087QUFDM0I7QUFFQSxzREFBc0Q7QUFDdEQsaUVBQWlFO0FBQ2pFLFNBQVNFLGNBQWVILElBQUk7SUFDMUIsSUFBSSxDQUFDQSxNQUFNO1FBQ1QsT0FBTztJQUNUO0lBRUF2RCxPQUFPMkQsV0FBVyxDQUFDLE9BQU9KLE1BQU07SUFFaEMsTUFBTUssYUFBYU4sWUFBWUM7SUFDL0IsSUFBSWpELElBQUl1RCxJQUFJLENBQUNELGFBQWE7UUFDeEIsT0FBTztJQUNUO0lBRUEsT0FBT0E7QUFDVDtBQUVBLFNBQVNFLFVBQVd4QyxHQUFHO0lBQ3JCLE9BQU95QyxLQUFLQyxLQUFLLENBQUNELEtBQUtyRCxTQUFTLENBQUNZO0FBQ25DO0FBRUEsU0FBUzJDLGdCQUFpQjNDLEdBQUc7SUFDM0IsT0FBTyxDQUFDLENBQUVBLENBQUFBLE9BQU8sUUFBUSxPQUFPQSxHQUFHLENBQUNPLE9BQU9xQyxhQUFhLENBQUMsS0FBSyxVQUFTO0FBQ3pFO0FBRUEsU0FBU0MsV0FBWTdDLEdBQUc7SUFDdEIsT0FBTyxDQUFDLENBQUVBLENBQUFBLE9BQU8sUUFBUyxRQUFPQSxHQUFHLENBQUNPLE9BQU91QyxRQUFRLENBQUMsS0FBSyxjQUFjLE9BQU85QyxHQUFHLENBQUNPLE9BQU9xQyxhQUFhLENBQUMsS0FBSyxVQUFTLENBQUM7QUFDekg7QUFFQSxTQUFTRyxXQUFZQyxJQUFJO0lBQ3ZCLElBQUlBLFFBQVEsTUFBTTtRQUNoQixPQUFPO0lBQ1QsT0FBTyxJQUFJakQsU0FBU2lELE9BQU87UUFDekIsTUFBTUMsUUFBUUQsS0FBS0UsY0FBYztRQUNqQyxPQUFPRCxTQUFTQSxNQUFNRSxVQUFVLEtBQUssU0FBU0YsTUFBTUcsS0FBSyxLQUFLLFFBQVF2RCxPQUFPdUIsUUFBUSxDQUFDNkIsTUFBTXJCLE1BQU0sSUFDOUZxQixNQUFNckIsTUFBTSxHQUNaO0lBQ04sT0FBTyxJQUFJekIsV0FBVzZDLE9BQU87UUFDM0IsT0FBT0EsS0FBS0ssSUFBSSxJQUFJLE9BQU9MLEtBQUtLLElBQUksR0FBRztJQUN6QyxPQUFPLElBQUlDLFNBQVNOLE9BQU87UUFDekIsT0FBT0EsS0FBS08sVUFBVTtJQUN4QjtJQUVBLE9BQU87QUFDVDtBQUVBLFNBQVNDLFlBQWF6RSxNQUFNO0lBQzFCLE9BQU8sQ0FBQ0EsVUFBVSxDQUFDLENBQUVBLENBQUFBLE9BQU8wRSxTQUFTLElBQUkxRSxNQUFNLENBQUNILFdBQVc7QUFDN0Q7QUFFQSxTQUFTOEUsa0JBQW1CM0UsTUFBTTtJQUNoQyxNQUFNa0UsUUFBUWxFLFVBQVVBLE9BQU9tRSxjQUFjO0lBQzdDLE9BQU9NLFlBQVl6RSxXQUFXa0UsU0FBUyxDQUFDQSxNQUFNVSxVQUFVO0FBQzFEO0FBRUEsU0FBU0MsUUFBUzdFLE1BQU0sRUFBRThFLEdBQUc7SUFDM0IsSUFBSTlFLFVBQVUsUUFBUSxDQUFDZ0IsU0FBU2hCLFdBQVd5RSxZQUFZekUsU0FBUztRQUM5RDtJQUNGO0lBRUEsSUFBSSxPQUFPQSxPQUFPNkUsT0FBTyxLQUFLLFlBQVk7UUFDeEMsSUFBSUUsT0FBT0MsY0FBYyxDQUFDaEYsUUFBUWlGLFdBQVcsS0FBS2xGLGlCQUFpQjtZQUNqRSx1REFBdUQ7WUFDdkRDLE9BQU9rRixNQUFNLEdBQUc7UUFDbEI7UUFFQWxGLE9BQU82RSxPQUFPLENBQUNDO0lBQ2pCLE9BQU8sSUFBSUEsS0FBSztRQUNkdEUsUUFBUTJFLFFBQVEsQ0FBQyxDQUFDbkYsUUFBUThFO1lBQ3hCOUUsT0FBT29GLElBQUksQ0FBQyxTQUFTTjtRQUN2QixHQUFHOUUsUUFBUThFO0lBQ2I7SUFFQSxJQUFJOUUsT0FBTzBFLFNBQVMsS0FBSyxNQUFNO1FBQzdCMUUsTUFBTSxDQUFDSCxXQUFXLEdBQUc7SUFDdkI7QUFDRjtBQUVBLE1BQU13Rix5QkFBeUI7QUFDL0IsU0FBU0Msc0JBQXVCQyxHQUFHO0lBQ2pDLE1BQU1DLElBQUlELElBQUlFLFFBQVEsR0FBR0MsS0FBSyxDQUFDTDtJQUMvQixPQUFPRyxJQUFJbEQsU0FBU2tELENBQUMsQ0FBQyxFQUFFLEVBQUUsTUFBTSxPQUFPO0FBQ3pDO0FBRUEsU0FBU0csYUFBY0MsT0FBTyxFQUFFM0UsTUFBTSxDQUFDLENBQUM7SUFDdEMsaUJBQWlCO0lBQ2pCLElBQUksQ0FBQzRFLE1BQU1DLE9BQU8sQ0FBQ0YsVUFBVSxPQUFPQTtJQUVwQyxJQUFLLElBQUlHLElBQUksR0FBR0EsSUFBSUgsUUFBUS9DLE1BQU0sRUFBRWtELEtBQUssRUFBRztRQUMxQyxNQUFNQyxNQUFNSixPQUFPLENBQUNHLEVBQUUsQ0FBQ04sUUFBUSxHQUFHUSxXQUFXO1FBQzdDLElBQUlWLE1BQU10RSxHQUFHLENBQUMrRSxJQUFJO1FBRWxCLElBQUksQ0FBQ1QsS0FBSztZQUNSLElBQUlNLE1BQU1DLE9BQU8sQ0FBQ0YsT0FBTyxDQUFDRyxJQUFJLEVBQUUsR0FBRztnQkFDakM5RSxHQUFHLENBQUMrRSxJQUFJLEdBQUdKLE9BQU8sQ0FBQ0csSUFBSSxFQUFFLENBQUNuRixHQUFHLENBQUNzRixDQUFBQSxJQUFLQSxFQUFFVCxRQUFRLENBQUM7WUFDaEQsT0FBTztnQkFDTHhFLEdBQUcsQ0FBQytFLElBQUksR0FBR0osT0FBTyxDQUFDRyxJQUFJLEVBQUUsQ0FBQ04sUUFBUSxDQUFDO1lBQ3JDO1FBQ0YsT0FBTztZQUNMLElBQUksQ0FBQ0ksTUFBTUMsT0FBTyxDQUFDUCxNQUFNO2dCQUN2QkEsTUFBTTtvQkFBQ0E7aUJBQUk7Z0JBQ1h0RSxHQUFHLENBQUMrRSxJQUFJLEdBQUdUO1lBQ2I7WUFDQUEsSUFBSVksSUFBSSxDQUFDUCxPQUFPLENBQUNHLElBQUksRUFBRSxDQUFDTixRQUFRLENBQUM7UUFDbkM7SUFDRjtJQUVBLGdEQUFnRDtJQUNoRCxJQUFJLG9CQUFvQnhFLE9BQU8seUJBQXlCQSxLQUFLO1FBQzNEQSxHQUFHLENBQUMsc0JBQXNCLEdBQUdtRixPQUFPQyxJQUFJLENBQUNwRixHQUFHLENBQUMsc0JBQXNCLEVBQUV3RSxRQUFRLENBQUM7SUFDaEY7SUFFQSxPQUFPeEU7QUFDVDtBQUVBLFNBQVNxRixnQkFBaUJWLE9BQU87SUFDL0IsTUFBTVcsTUFBTSxFQUFFO0lBQ2QsSUFBSUMsbUJBQW1CO0lBQ3ZCLElBQUlDLHdCQUF3QixDQUFDO0lBRTdCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJZCxRQUFRL0MsTUFBTSxFQUFFNkQsS0FBSyxFQUFHO1FBQzFDLE1BQU1WLE1BQU1KLE9BQU8sQ0FBQ2MsSUFBSSxFQUFFLENBQUNqQixRQUFRO1FBQ25DLE1BQU1GLE1BQU1LLE9BQU8sQ0FBQ2MsSUFBSSxFQUFFLENBQUNqQixRQUFRLENBQUM7UUFFcEMsSUFBSU8sSUFBSW5ELE1BQU0sS0FBSyxNQUFPbUQsQ0FBQUEsUUFBUSxvQkFBb0JBLElBQUlDLFdBQVcsT0FBTyxnQkFBZSxHQUFJO1lBQzdGTSxJQUFJSixJQUFJLENBQUNILEtBQUtUO1lBQ2RpQixtQkFBbUI7UUFDckIsT0FBTyxJQUFJUixJQUFJbkQsTUFBTSxLQUFLLE1BQU9tRCxDQUFBQSxRQUFRLHlCQUF5QkEsSUFBSUMsV0FBVyxPQUFPLHFCQUFvQixHQUFJO1lBQzlHUSx3QkFBd0JGLElBQUlKLElBQUksQ0FBQ0gsS0FBS1QsT0FBTztRQUMvQyxPQUFPO1lBQ0xnQixJQUFJSixJQUFJLENBQUNILEtBQUtUO1FBQ2hCO0lBQ0Y7SUFFQSxnREFBZ0Q7SUFDaEQsSUFBSWlCLG9CQUFvQkMsMEJBQTBCLENBQUMsR0FBRztRQUNwREYsR0FBRyxDQUFDRSxzQkFBc0IsR0FBR0wsT0FBT0MsSUFBSSxDQUFDRSxHQUFHLENBQUNFLHNCQUFzQixFQUFFaEIsUUFBUSxDQUFDO0lBQ2hGO0lBRUEsT0FBT2M7QUFDVDtBQUVBLFNBQVNoQyxTQUFVb0MsTUFBTTtJQUN2QixtREFBbUQ7SUFDbkQsT0FBT0Esa0JBQWtCQyxjQUFjUixPQUFPN0IsUUFBUSxDQUFDb0M7QUFDekQ7QUFFQSxTQUFTRSxnQkFBaUJDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxPQUFPO0lBQ2hELElBQUksQ0FBQ0YsV0FBVyxPQUFPQSxZQUFZLFVBQVU7UUFDM0MsTUFBTSxJQUFJNUcscUJBQXFCO0lBQ2pDO0lBRUEsSUFBSSxPQUFPNEcsUUFBUUcsU0FBUyxLQUFLLFlBQVk7UUFDM0MsTUFBTSxJQUFJL0cscUJBQXFCO0lBQ2pDO0lBRUEsSUFBSSxPQUFPNEcsUUFBUUksT0FBTyxLQUFLLFlBQVk7UUFDekMsTUFBTSxJQUFJaEgscUJBQXFCO0lBQ2pDO0lBRUEsSUFBSSxPQUFPNEcsUUFBUUssVUFBVSxLQUFLLGNBQWNMLFFBQVFLLFVBQVUsS0FBS0MsV0FBVztRQUNoRixNQUFNLElBQUlsSCxxQkFBcUI7SUFDakM7SUFFQSxJQUFJOEcsV0FBV0QsV0FBVyxXQUFXO1FBQ25DLElBQUksT0FBT0QsUUFBUU8sU0FBUyxLQUFLLFlBQVk7WUFDM0MsTUFBTSxJQUFJbkgscUJBQXFCO1FBQ2pDO0lBQ0YsT0FBTztRQUNMLElBQUksT0FBTzRHLFFBQVFRLFNBQVMsS0FBSyxZQUFZO1lBQzNDLE1BQU0sSUFBSXBILHFCQUFxQjtRQUNqQztRQUVBLElBQUksT0FBTzRHLFFBQVFTLE1BQU0sS0FBSyxZQUFZO1lBQ3hDLE1BQU0sSUFBSXJILHFCQUFxQjtRQUNqQztRQUVBLElBQUksT0FBTzRHLFFBQVFVLFVBQVUsS0FBSyxZQUFZO1lBQzVDLE1BQU0sSUFBSXRILHFCQUFxQjtRQUNqQztJQUNGO0FBQ0Y7QUFFQSw2REFBNkQ7QUFDN0QsMkNBQTJDO0FBQzNDLFNBQVN1SCxZQUFheEQsSUFBSTtJQUN4QixPQUFPLENBQUMsQ0FBRUEsQ0FBQUEsUUFDUmpFLENBQUFBLE9BQU95SCxXQUFXLEdBQ2R6SCxPQUFPeUgsV0FBVyxDQUFDeEQsU0FBU0EsSUFBSSxDQUFDbkUsVUFBVSxDQUFDLDZDQUE2QztPQUN6Rm1FLElBQUksQ0FBQ25FLFVBQVUsSUFDZm1FLEtBQUt5RCxlQUFlLElBQ25CekQsS0FBS0UsY0FBYyxJQUFJRixLQUFLRSxjQUFjLENBQUN3RCxXQUFXLElBQ3ZEaEQsa0JBQWtCVixLQUFJLENBQzVCO0FBQ0Y7QUFFQSxTQUFTMkQsVUFBVzNELElBQUk7SUFDdEIsT0FBTyxDQUFDLENBQUVBLENBQUFBLFFBQ1JqRSxDQUFBQSxPQUFPNEgsU0FBUyxHQUNaNUgsT0FBTzRILFNBQVMsQ0FBQzNELFFBQ2pCLG1CQUFtQjFDLElBQUksQ0FBQ25CLFNBQVN5SCxPQUFPLENBQUM1RCxNQUMzQyxDQUFDO0FBQ1A7QUFFQSxTQUFTNkQsV0FBWTdELElBQUk7SUFDdkIsT0FBTyxDQUFDLENBQUVBLENBQUFBLFFBQ1JqRSxDQUFBQSxPQUFPOEgsVUFBVSxHQUNiOUgsT0FBTzhILFVBQVUsQ0FBQzdELFFBQ2xCLG9CQUFvQjFDLElBQUksQ0FBQ25CLFNBQVN5SCxPQUFPLENBQUM1RCxNQUM1QyxDQUFDO0FBQ1A7QUFFQSxTQUFTOEQsY0FBZTdDLE1BQU07SUFDNUIsT0FBTztRQUNMOEMsY0FBYzlDLE9BQU84QyxZQUFZO1FBQ2pDQyxXQUFXL0MsT0FBTytDLFNBQVM7UUFDM0JDLGVBQWVoRCxPQUFPZ0QsYUFBYTtRQUNuQ0MsWUFBWWpELE9BQU9pRCxVQUFVO1FBQzdCQyxjQUFjbEQsT0FBT2tELFlBQVk7UUFDakNDLFNBQVNuRCxPQUFPbUQsT0FBTztRQUN2QkMsY0FBY3BELE9BQU9vRCxZQUFZO1FBQ2pDQyxXQUFXckQsT0FBT3FELFNBQVM7SUFDN0I7QUFDRjtBQUVBLGdCQUFpQkMsd0JBQXlCQyxRQUFRO0lBQ2hELFdBQVcsTUFBTUMsU0FBU0QsU0FBVTtRQUNsQyxNQUFNckMsT0FBTzdCLFFBQVEsQ0FBQ21FLFNBQVNBLFFBQVF0QyxPQUFPQyxJQUFJLENBQUNxQztJQUNyRDtBQUNGO0FBRUEsSUFBSUM7QUFDSixTQUFTQyxtQkFBb0JILFFBQVE7SUFDbkMsSUFBSSxDQUFDRSxnQkFBZ0I7UUFDbkJBLGlCQUFpQi9JLG9FQUFvQztJQUN2RDtJQUVBLElBQUkrSSxlQUFldEMsSUFBSSxFQUFFO1FBQ3ZCLE9BQU9zQyxlQUFldEMsSUFBSSxDQUFDbUMsd0JBQXdCQztJQUNyRDtJQUVBLElBQUkxRTtJQUNKLE9BQU8sSUFBSTRFLGVBQ1Q7UUFDRSxNQUFNRTtZQUNKOUUsV0FBVzBFLFFBQVEsQ0FBQ2pILE9BQU9xQyxhQUFhLENBQUM7UUFDM0M7UUFDQSxNQUFNaUYsTUFBTUMsVUFBVTtZQUNwQixNQUFNLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTWxGLFNBQVNtRixJQUFJO1lBQzNDLElBQUlGLE1BQU07Z0JBQ1JHLGVBQWU7b0JBQ2JKLFdBQVdLLEtBQUs7Z0JBQ2xCO1lBQ0YsT0FBTztnQkFDTCxNQUFNQyxNQUFNakQsT0FBTzdCLFFBQVEsQ0FBQzBFLFNBQVNBLFFBQVE3QyxPQUFPQyxJQUFJLENBQUM0QztnQkFDekRGLFdBQVdPLE9BQU8sQ0FBQyxJQUFJMUMsV0FBV3lDO1lBQ3BDO1lBQ0EsT0FBT04sV0FBV1EsV0FBVyxHQUFHO1FBQ2xDO1FBQ0EsTUFBTUMsUUFBUUMsTUFBTTtZQUNsQixNQUFNMUYsU0FBUzJGLE1BQU07UUFDdkI7SUFDRixHQUNBO0FBRUo7QUFFQSx1REFBdUQ7QUFDdkQsNEJBQTRCO0FBQzVCLFNBQVNDLGVBQWdCdEksTUFBTTtJQUM3QixPQUNFQSxVQUNBLE9BQU9BLFdBQVcsWUFDbEIsT0FBT0EsT0FBT3VJLE1BQU0sS0FBSyxjQUN6QixPQUFPdkksT0FBT3dJLE1BQU0sS0FBSyxjQUN6QixPQUFPeEksT0FBT3lJLEdBQUcsS0FBSyxjQUN0QixPQUFPekksT0FBTzBJLE1BQU0sS0FBSyxjQUN6QixPQUFPMUksT0FBTzJJLEdBQUcsS0FBSyxjQUN0QixPQUFPM0ksT0FBTzRJLEdBQUcsS0FBSyxjQUN0QjVJLE1BQU0sQ0FBQ0csT0FBT0MsV0FBVyxDQUFDLEtBQUs7QUFFbkM7QUFFQSxTQUFTeUksZUFBZ0JDLE1BQU07SUFDN0IsSUFBSSxDQUFDQSxRQUFRO1FBQUU7SUFBTztJQUN0QixJQUFJLE9BQU9BLE9BQU9ELGNBQWMsS0FBSyxZQUFZO1FBQy9DQyxPQUFPRCxjQUFjO0lBQ3ZCLE9BQU87UUFDTCxJQUFJQyxPQUFPQyxPQUFPLEVBQUU7WUFDbEIsdUNBQXVDO1lBQ3ZDLE1BQU10RixNQUFNLElBQUloRCxNQUFNO1lBQ3RCZ0QsSUFBSXVGLElBQUksR0FBRztZQUNYLE1BQU12RjtRQUNSO0lBQ0Y7QUFDRjtBQUVBLFNBQVN3RixpQkFBa0JILE1BQU0sRUFBRUksUUFBUTtJQUN6QyxJQUFJLHNCQUFzQkosUUFBUTtRQUNoQ0EsT0FBT0ssZ0JBQWdCLENBQUMsU0FBU0QsVUFBVTtZQUFFRSxNQUFNO1FBQUs7UUFDeEQsT0FBTyxJQUFNTixPQUFPTyxtQkFBbUIsQ0FBQyxTQUFTSDtJQUNuRDtJQUNBSixPQUFPUSxXQUFXLENBQUMsU0FBU0o7SUFDNUIsT0FBTyxJQUFNSixPQUFPUyxjQUFjLENBQUMsU0FBU0w7QUFDOUM7QUFFQSxNQUFNTSxrQkFBa0IsQ0FBQyxDQUFDQyxPQUFPQyxTQUFTLENBQUNDLFlBQVk7QUFFdkQ7O0NBRUMsR0FDRCxTQUFTQyxZQUFhMUYsR0FBRztJQUN2QixJQUFJc0YsaUJBQWlCO1FBQ25CLE9BQU8sQ0FBQyxFQUFFdEYsSUFBSSxDQUFDLENBQUN5RixZQUFZO0lBQzlCLE9BQU8sSUFBSTVLLFNBQVM2SyxXQUFXLEVBQUU7UUFDL0IsT0FBTzdLLFNBQVM2SyxXQUFXLENBQUMxRjtJQUM5QjtJQUVBLE9BQU8sQ0FBQyxFQUFFQSxJQUFJLENBQUM7QUFDakI7QUFFQSxpQ0FBaUM7QUFDakMsNkRBQTZEO0FBQzdELFNBQVMyRixpQkFBa0JDLEtBQUs7SUFDOUIsSUFBSUEsU0FBUyxRQUFRQSxVQUFVLElBQUksT0FBTztRQUFFdEMsT0FBTztRQUFHdUMsS0FBSztRQUFNOUcsTUFBTTtJQUFLO0lBRTVFLE1BQU1rQixJQUFJMkYsUUFBUUEsTUFBTXpGLEtBQUssQ0FBQyxpQ0FBaUM7SUFDL0QsT0FBT0YsSUFDSDtRQUNFcUQsT0FBT3ZHLFNBQVNrRCxDQUFDLENBQUMsRUFBRTtRQUNwQjRGLEtBQUs1RixDQUFDLENBQUMsRUFBRSxHQUFHbEQsU0FBU2tELENBQUMsQ0FBQyxFQUFFLElBQUk7UUFDN0JsQixNQUFNa0IsQ0FBQyxDQUFDLEVBQUUsR0FBR2xELFNBQVNrRCxDQUFDLENBQUMsRUFBRSxJQUFJO0lBQ2hDLElBQ0E7QUFDTjtBQUVBLE1BQU02RixzQkFBc0J0RyxPQUFPdUcsTUFBTSxDQUFDO0FBQzFDRCxvQkFBb0JFLFVBQVUsR0FBRztBQUVqQ0MsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZKO0lBQ0F0SztJQUNBMEc7SUFDQUc7SUFDQUU7SUFDQW1EO0lBQ0F0RztJQUNBdkQ7SUFDQTJCO0lBQ0FmO0lBQ0FxQjtJQUNBckM7SUFDQThDO0lBQ0FGO0lBQ0FhO0lBQ0E2QjtJQUNBWDtJQUNBTDtJQUNBVDtJQUNBYjtJQUNBUDtJQUNBbUY7SUFDQXJFO0lBQ0FzQztJQUNBa0I7SUFDQTRCO0lBQ0FqSTtJQUNBd0k7SUFDQUk7SUFDQVk7SUFDQTVLO0lBQ0FDO0lBQ0FtTCx5QkFBeUJwTCxZQUFZLE1BQU9BLGNBQWMsTUFBTUMsYUFBYTtJQUM3RW9MLGlCQUFpQjtRQUFDO1FBQU87UUFBUTtRQUFXO0tBQVE7QUFDdEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3V0aWwuanM/N2M4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IHsga0Rlc3Ryb3llZCwga0JvZHlVc2VkIH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBJbmNvbWluZ01lc3NhZ2UgfSA9IHJlcXVpcmUoJ2h0dHAnKVxuY29uc3Qgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJylcbmNvbnN0IG5ldCA9IHJlcXVpcmUoJ25ldCcpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuL2Vycm9ycycpXG5jb25zdCB7IEJsb2IgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCBub2RlVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuY29uc3QgeyBzdHJpbmdpZnkgfSA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJylcblxuY29uc3QgW25vZGVNYWpvciwgbm9kZU1pbm9yXSA9IHByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdCgnLicpLm1hcCh2ID0+IE51bWJlcih2KSlcblxuZnVuY3Rpb24gbm9wICgpIHt9XG5cbmZ1bmN0aW9uIGlzU3RyZWFtIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqLnBpcGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5vbiA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9mZXRjaC1ibG9iL2Jsb2IvOGFiNTg3ZDM0MDgwZGU5NDE0MGI1NGYwNzE2ODQ1MWU3ZDBiNjU1ZS9pbmRleC5qcyNMMjI5LUwyNDEgKE1JVCBMaWNlbnNlKVxuZnVuY3Rpb24gaXNCbG9iTGlrZSAob2JqZWN0KSB7XG4gIHJldHVybiAoQmxvYiAmJiBvYmplY3QgaW5zdGFuY2VvZiBCbG9iKSB8fCAoXG4gICAgb2JqZWN0ICYmXG4gICAgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAodHlwZW9mIG9iamVjdC5zdHJlYW0gPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBvYmplY3QuYXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicpICYmXG4gICAgL14oQmxvYnxGaWxlKSQvLnRlc3Qob2JqZWN0W1N5bWJvbC50b1N0cmluZ1RhZ10pXG4gIClcbn1cblxuZnVuY3Rpb24gYnVpbGRVUkwgKHVybCwgcXVlcnlQYXJhbXMpIHtcbiAgaWYgKHVybC5pbmNsdWRlcygnPycpIHx8IHVybC5pbmNsdWRlcygnIycpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeSBwYXJhbXMgY2Fubm90IGJlIHBhc3NlZCB3aGVuIHVybCBhbHJlYWR5IGNvbnRhaW5zIFwiP1wiIG9yIFwiI1wiLicpXG4gIH1cblxuICBjb25zdCBzdHJpbmdpZmllZCA9IHN0cmluZ2lmeShxdWVyeVBhcmFtcylcblxuICBpZiAoc3RyaW5naWZpZWQpIHtcbiAgICB1cmwgKz0gJz8nICsgc3RyaW5naWZpZWRcbiAgfVxuXG4gIHJldHVybiB1cmxcbn1cblxuZnVuY3Rpb24gcGFyc2VVUkwgKHVybCkge1xuICBpZiAodHlwZW9mIHVybCA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmwgPSBuZXcgVVJMKHVybClcblxuICAgIGlmICghL15odHRwcz86Ly50ZXN0KHVybC5vcmlnaW4gfHwgdXJsLnByb3RvY29sKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBwcm90b2NvbDogdGhlIFVSTCBtdXN0IHN0YXJ0IHdpdGggYGh0dHA6YCBvciBgaHR0cHM6YC4nKVxuICAgIH1cblxuICAgIHJldHVybiB1cmxcbiAgfVxuXG4gIGlmICghdXJsIHx8IHR5cGVvZiB1cmwgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTDogVGhlIFVSTCBhcmd1bWVudCBtdXN0IGJlIGEgbm9uLW51bGwgb2JqZWN0LicpXG4gIH1cblxuICBpZiAoIS9eaHR0cHM/Oi8udGVzdCh1cmwub3JpZ2luIHx8IHVybC5wcm90b2NvbCkpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0ludmFsaWQgVVJMIHByb3RvY29sOiB0aGUgVVJMIG11c3Qgc3RhcnQgd2l0aCBgaHR0cDpgIG9yIGBodHRwczpgLicpXG4gIH1cblxuICBpZiAoISh1cmwgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgaWYgKHVybC5wb3J0ICE9IG51bGwgJiYgdXJsLnBvcnQgIT09ICcnICYmICFOdW1iZXIuaXNGaW5pdGUocGFyc2VJbnQodXJsLnBvcnQpKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTDogcG9ydCBtdXN0IGJlIGEgdmFsaWQgaW50ZWdlciBvciBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLicpXG4gICAgfVxuXG4gICAgaWYgKHVybC5wYXRoICE9IG51bGwgJiYgdHlwZW9mIHVybC5wYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBwYXRoOiB0aGUgcGF0aCBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bGwvdW5kZWZpbmVkLicpXG4gICAgfVxuXG4gICAgaWYgKHVybC5wYXRobmFtZSAhPSBudWxsICYmIHR5cGVvZiB1cmwucGF0aG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0ludmFsaWQgVVJMIHBhdGhuYW1lOiB0aGUgcGF0aG5hbWUgbXVzdCBiZSBhIHN0cmluZyBvciBudWxsL3VuZGVmaW5lZC4nKVxuICAgIH1cblxuICAgIGlmICh1cmwuaG9zdG5hbWUgIT0gbnVsbCAmJiB0eXBlb2YgdXJsLmhvc3RuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBob3N0bmFtZTogdGhlIGhvc3RuYW1lIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVsbC91bmRlZmluZWQuJylcbiAgICB9XG5cbiAgICBpZiAodXJsLm9yaWdpbiAhPSBudWxsICYmIHR5cGVvZiB1cmwub3JpZ2luICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBvcmlnaW46IHRoZSBvcmlnaW4gbXVzdCBiZSBhIHN0cmluZyBvciBudWxsL3VuZGVmaW5lZC4nKVxuICAgIH1cblxuICAgIGNvbnN0IHBvcnQgPSB1cmwucG9ydCAhPSBudWxsXG4gICAgICA/IHVybC5wb3J0XG4gICAgICA6ICh1cmwucHJvdG9jb2wgPT09ICdodHRwczonID8gNDQzIDogODApXG4gICAgbGV0IG9yaWdpbiA9IHVybC5vcmlnaW4gIT0gbnVsbFxuICAgICAgPyB1cmwub3JpZ2luXG4gICAgICA6IGAke3VybC5wcm90b2NvbH0vLyR7dXJsLmhvc3RuYW1lfToke3BvcnR9YFxuICAgIGxldCBwYXRoID0gdXJsLnBhdGggIT0gbnVsbFxuICAgICAgPyB1cmwucGF0aFxuICAgICAgOiBgJHt1cmwucGF0aG5hbWUgfHwgJyd9JHt1cmwuc2VhcmNoIHx8ICcnfWBcblxuICAgIGlmIChvcmlnaW4uZW5kc1dpdGgoJy8nKSkge1xuICAgICAgb3JpZ2luID0gb3JpZ2luLnN1YnN0cmluZygwLCBvcmlnaW4ubGVuZ3RoIC0gMSlcbiAgICB9XG5cbiAgICBpZiAocGF0aCAmJiAhcGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgIHBhdGggPSBgLyR7cGF0aH1gXG4gICAgfVxuICAgIC8vIG5ldyBVUkwocGF0aCwgb3JpZ2luKSBpcyB1bnNhZmUgd2hlbiBgcGF0aGAgY29udGFpbnMgYW4gYWJzb2x1dGUgVVJMXG4gICAgLy8gRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVVJML1VSTDpcbiAgICAvLyBJZiBmaXJzdCBwYXJhbWV0ZXIgaXMgYSByZWxhdGl2ZSBVUkwsIHNlY29uZCBwYXJhbSBpcyByZXF1aXJlZCwgYW5kIHdpbGwgYmUgdXNlZCBhcyB0aGUgYmFzZSBVUkwuXG4gICAgLy8gSWYgZmlyc3QgcGFyYW1ldGVyIGlzIGFuIGFic29sdXRlIFVSTCwgYSBnaXZlbiBzZWNvbmQgcGFyYW0gd2lsbCBiZSBpZ25vcmVkLlxuICAgIHVybCA9IG5ldyBVUkwob3JpZ2luICsgcGF0aClcbiAgfVxuXG4gIHJldHVybiB1cmxcbn1cblxuZnVuY3Rpb24gcGFyc2VPcmlnaW4gKHVybCkge1xuICB1cmwgPSBwYXJzZVVSTCh1cmwpXG5cbiAgaWYgKHVybC5wYXRobmFtZSAhPT0gJy8nIHx8IHVybC5zZWFyY2ggfHwgdXJsLmhhc2gpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgdXJsJylcbiAgfVxuXG4gIHJldHVybiB1cmxcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdG5hbWUgKGhvc3QpIHtcbiAgaWYgKGhvc3RbMF0gPT09ICdbJykge1xuICAgIGNvbnN0IGlkeCA9IGhvc3QuaW5kZXhPZignXScpXG5cbiAgICBhc3NlcnQoaWR4ICE9PSAtMSlcbiAgICByZXR1cm4gaG9zdC5zdWJzdHJpbmcoMSwgaWR4KVxuICB9XG5cbiAgY29uc3QgaWR4ID0gaG9zdC5pbmRleE9mKCc6JylcbiAgaWYgKGlkeCA9PT0gLTEpIHJldHVybiBob3N0XG5cbiAgcmV0dXJuIGhvc3Quc3Vic3RyaW5nKDAsIGlkeClcbn1cblxuLy8gSVAgYWRkcmVzc2VzIGFyZSBub3QgdmFsaWQgc2VydmVyIG5hbWVzIHBlciBSRkM2MDY2XG4vLyA+IEN1cnJlbnRseSwgdGhlIG9ubHkgc2VydmVyIG5hbWVzIHN1cHBvcnRlZCBhcmUgRE5TIGhvc3RuYW1lc1xuZnVuY3Rpb24gZ2V0U2VydmVyTmFtZSAoaG9zdCkge1xuICBpZiAoIWhvc3QpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBob3N0LCAnc3RyaW5nJylcblxuICBjb25zdCBzZXJ2ZXJuYW1lID0gZ2V0SG9zdG5hbWUoaG9zdClcbiAgaWYgKG5ldC5pc0lQKHNlcnZlcm5hbWUpKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICByZXR1cm4gc2VydmVybmFtZVxufVxuXG5mdW5jdGlvbiBkZWVwQ2xvbmUgKG9iaikge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKVxufVxuXG5mdW5jdGlvbiBpc0FzeW5jSXRlcmFibGUgKG9iaikge1xuICByZXR1cm4gISEob2JqICE9IG51bGwgJiYgdHlwZW9mIG9ialtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpXG59XG5cbmZ1bmN0aW9uIGlzSXRlcmFibGUgKG9iaikge1xuICByZXR1cm4gISEob2JqICE9IG51bGwgJiYgKHR5cGVvZiBvYmpbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykpXG59XG5cbmZ1bmN0aW9uIGJvZHlMZW5ndGggKGJvZHkpIHtcbiAgaWYgKGJvZHkgPT0gbnVsbCkge1xuICAgIHJldHVybiAwXG4gIH0gZWxzZSBpZiAoaXNTdHJlYW0oYm9keSkpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGJvZHkuX3JlYWRhYmxlU3RhdGVcbiAgICByZXR1cm4gc3RhdGUgJiYgc3RhdGUub2JqZWN0TW9kZSA9PT0gZmFsc2UgJiYgc3RhdGUuZW5kZWQgPT09IHRydWUgJiYgTnVtYmVyLmlzRmluaXRlKHN0YXRlLmxlbmd0aClcbiAgICAgID8gc3RhdGUubGVuZ3RoXG4gICAgICA6IG51bGxcbiAgfSBlbHNlIGlmIChpc0Jsb2JMaWtlKGJvZHkpKSB7XG4gICAgcmV0dXJuIGJvZHkuc2l6ZSAhPSBudWxsID8gYm9keS5zaXplIDogbnVsbFxuICB9IGVsc2UgaWYgKGlzQnVmZmVyKGJvZHkpKSB7XG4gICAgcmV0dXJuIGJvZHkuYnl0ZUxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZXN0cm95ZWQgKHN0cmVhbSkge1xuICByZXR1cm4gIXN0cmVhbSB8fCAhIShzdHJlYW0uZGVzdHJveWVkIHx8IHN0cmVhbVtrRGVzdHJveWVkXSlcbn1cblxuZnVuY3Rpb24gaXNSZWFkYWJsZUFib3J0ZWQgKHN0cmVhbSkge1xuICBjb25zdCBzdGF0ZSA9IHN0cmVhbSAmJiBzdHJlYW0uX3JlYWRhYmxlU3RhdGVcbiAgcmV0dXJuIGlzRGVzdHJveWVkKHN0cmVhbSkgJiYgc3RhdGUgJiYgIXN0YXRlLmVuZEVtaXR0ZWRcbn1cblxuZnVuY3Rpb24gZGVzdHJveSAoc3RyZWFtLCBlcnIpIHtcbiAgaWYgKHN0cmVhbSA9PSBudWxsIHx8ICFpc1N0cmVhbShzdHJlYW0pIHx8IGlzRGVzdHJveWVkKHN0cmVhbSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICh0eXBlb2Ygc3RyZWFtLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHN0cmVhbSkuY29uc3RydWN0b3IgPT09IEluY29taW5nTWVzc2FnZSkge1xuICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zODUwNS9maWxlc1xuICAgICAgc3RyZWFtLnNvY2tldCA9IG51bGxcbiAgICB9XG5cbiAgICBzdHJlYW0uZGVzdHJveShlcnIpXG4gIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoc3RyZWFtLCBlcnIpID0+IHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycilcbiAgICB9LCBzdHJlYW0sIGVycilcbiAgfVxuXG4gIGlmIChzdHJlYW0uZGVzdHJveWVkICE9PSB0cnVlKSB7XG4gICAgc3RyZWFtW2tEZXN0cm95ZWRdID0gdHJ1ZVxuICB9XG59XG5cbmNvbnN0IEtFRVBBTElWRV9USU1FT1VUX0VYUFIgPSAvdGltZW91dD0oXFxkKykvXG5mdW5jdGlvbiBwYXJzZUtlZXBBbGl2ZVRpbWVvdXQgKHZhbCkge1xuICBjb25zdCBtID0gdmFsLnRvU3RyaW5nKCkubWF0Y2goS0VFUEFMSVZFX1RJTUVPVVRfRVhQUilcbiAgcmV0dXJuIG0gPyBwYXJzZUludChtWzFdLCAxMCkgKiAxMDAwIDogbnVsbFxufVxuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMgKGhlYWRlcnMsIG9iaiA9IHt9KSB7XG4gIC8vIEZvciBIMiBzdXBwb3J0XG4gIGlmICghQXJyYXkuaXNBcnJheShoZWFkZXJzKSkgcmV0dXJuIGhlYWRlcnNcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBjb25zdCBrZXkgPSBoZWFkZXJzW2ldLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKVxuICAgIGxldCB2YWwgPSBvYmpba2V5XVxuXG4gICAgaWYgKCF2YWwpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnNbaSArIDFdKSkge1xuICAgICAgICBvYmpba2V5XSA9IGhlYWRlcnNbaSArIDFdLm1hcCh4ID0+IHgudG9TdHJpbmcoJ3V0ZjgnKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gaGVhZGVyc1tpICsgMV0udG9TdHJpbmcoJ3V0ZjgnKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICB2YWwgPSBbdmFsXVxuICAgICAgICBvYmpba2V5XSA9IHZhbFxuICAgICAgfVxuICAgICAgdmFsLnB1c2goaGVhZGVyc1tpICsgMV0udG9TdHJpbmcoJ3V0ZjgnKSlcbiAgICB9XG4gIH1cblxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvNDY1MjhcbiAgaWYgKCdjb250ZW50LWxlbmd0aCcgaW4gb2JqICYmICdjb250ZW50LWRpc3Bvc2l0aW9uJyBpbiBvYmopIHtcbiAgICBvYmpbJ2NvbnRlbnQtZGlzcG9zaXRpb24nXSA9IEJ1ZmZlci5mcm9tKG9ialsnY29udGVudC1kaXNwb3NpdGlvbiddKS50b1N0cmluZygnbGF0aW4xJylcbiAgfVxuXG4gIHJldHVybiBvYmpcbn1cblxuZnVuY3Rpb24gcGFyc2VSYXdIZWFkZXJzIChoZWFkZXJzKSB7XG4gIGNvbnN0IHJldCA9IFtdXG4gIGxldCBoYXNDb250ZW50TGVuZ3RoID0gZmFsc2VcbiAgbGV0IGNvbnRlbnREaXNwb3NpdGlvbklkeCA9IC0xXG5cbiAgZm9yIChsZXQgbiA9IDA7IG4gPCBoZWFkZXJzLmxlbmd0aDsgbiArPSAyKSB7XG4gICAgY29uc3Qga2V5ID0gaGVhZGVyc1tuICsgMF0udG9TdHJpbmcoKVxuICAgIGNvbnN0IHZhbCA9IGhlYWRlcnNbbiArIDFdLnRvU3RyaW5nKCd1dGY4JylcblxuICAgIGlmIChrZXkubGVuZ3RoID09PSAxNCAmJiAoa2V5ID09PSAnY29udGVudC1sZW5ndGgnIHx8IGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC1sZW5ndGgnKSkge1xuICAgICAgcmV0LnB1c2goa2V5LCB2YWwpXG4gICAgICBoYXNDb250ZW50TGVuZ3RoID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA9PT0gMTkgJiYgKGtleSA9PT0gJ2NvbnRlbnQtZGlzcG9zaXRpb24nIHx8IGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC1kaXNwb3NpdGlvbicpKSB7XG4gICAgICBjb250ZW50RGlzcG9zaXRpb25JZHggPSByZXQucHVzaChrZXksIHZhbCkgLSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldC5wdXNoKGtleSwgdmFsKVxuICAgIH1cbiAgfVxuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC80NjUyOFxuICBpZiAoaGFzQ29udGVudExlbmd0aCAmJiBjb250ZW50RGlzcG9zaXRpb25JZHggIT09IC0xKSB7XG4gICAgcmV0W2NvbnRlbnREaXNwb3NpdGlvbklkeF0gPSBCdWZmZXIuZnJvbShyZXRbY29udGVudERpc3Bvc2l0aW9uSWR4XSkudG9TdHJpbmcoJ2xhdGluMScpXG4gIH1cblxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChidWZmZXIpIHtcbiAgLy8gU2VlLCBodHRwczovL2dpdGh1Yi5jb20vbWNvbGxpbmEvdW5kaWNpL3B1bGwvMzE5XG4gIHJldHVybiBidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IEJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlSGFuZGxlciAoaGFuZGxlciwgbWV0aG9kLCB1cGdyYWRlKSB7XG4gIGlmICghaGFuZGxlciB8fCB0eXBlb2YgaGFuZGxlciAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2hhbmRsZXIgbXVzdCBiZSBhbiBvYmplY3QnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uQ29ubmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkNvbm5lY3QgbWV0aG9kJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgaGFuZGxlci5vbkVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uRXJyb3IgbWV0aG9kJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgaGFuZGxlci5vbkJvZHlTZW50ICE9PSAnZnVuY3Rpb24nICYmIGhhbmRsZXIub25Cb2R5U2VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uQm9keVNlbnQgbWV0aG9kJylcbiAgfVxuXG4gIGlmICh1cGdyYWRlIHx8IG1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uVXBncmFkZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uVXBncmFkZSBtZXRob2QnKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIub25IZWFkZXJzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25IZWFkZXJzIG1ldGhvZCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uRGF0YSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uRGF0YSBtZXRob2QnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkNvbXBsZXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25Db21wbGV0ZSBtZXRob2QnKVxuICAgIH1cbiAgfVxufVxuXG4vLyBBIGJvZHkgaXMgZGlzdHVyYmVkIGlmIGl0IGhhcyBiZWVuIHJlYWQgZnJvbSBhbmQgaXQgY2Fubm90XG4vLyBiZSByZS11c2VkIHdpdGhvdXQgbG9zaW5nIHN0YXRlIG9yIGRhdGEuXG5mdW5jdGlvbiBpc0Rpc3R1cmJlZCAoYm9keSkge1xuICByZXR1cm4gISEoYm9keSAmJiAoXG4gICAgc3RyZWFtLmlzRGlzdHVyYmVkXG4gICAgICA/IHN0cmVhbS5pc0Rpc3R1cmJlZChib2R5KSB8fCBib2R5W2tCb2R5VXNlZF0gLy8gVE9ETyAoZml4KTogV2h5IGlzIGJvZHlba0JvZHlVc2VkXSBuZWVkZWQ/XG4gICAgICA6IGJvZHlba0JvZHlVc2VkXSB8fFxuICAgICAgICBib2R5LnJlYWRhYmxlRGlkUmVhZCB8fFxuICAgICAgICAoYm9keS5fcmVhZGFibGVTdGF0ZSAmJiBib2R5Ll9yZWFkYWJsZVN0YXRlLmRhdGFFbWl0dGVkKSB8fFxuICAgICAgICBpc1JlYWRhYmxlQWJvcnRlZChib2R5KVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0Vycm9yZWQgKGJvZHkpIHtcbiAgcmV0dXJuICEhKGJvZHkgJiYgKFxuICAgIHN0cmVhbS5pc0Vycm9yZWRcbiAgICAgID8gc3RyZWFtLmlzRXJyb3JlZChib2R5KVxuICAgICAgOiAvc3RhdGU6ICdlcnJvcmVkJy8udGVzdChub2RlVXRpbC5pbnNwZWN0KGJvZHkpXG4gICAgICApKSlcbn1cblxuZnVuY3Rpb24gaXNSZWFkYWJsZSAoYm9keSkge1xuICByZXR1cm4gISEoYm9keSAmJiAoXG4gICAgc3RyZWFtLmlzUmVhZGFibGVcbiAgICAgID8gc3RyZWFtLmlzUmVhZGFibGUoYm9keSlcbiAgICAgIDogL3N0YXRlOiAncmVhZGFibGUnLy50ZXN0KG5vZGVVdGlsLmluc3BlY3QoYm9keSlcbiAgICAgICkpKVxufVxuXG5mdW5jdGlvbiBnZXRTb2NrZXRJbmZvIChzb2NrZXQpIHtcbiAgcmV0dXJuIHtcbiAgICBsb2NhbEFkZHJlc3M6IHNvY2tldC5sb2NhbEFkZHJlc3MsXG4gICAgbG9jYWxQb3J0OiBzb2NrZXQubG9jYWxQb3J0LFxuICAgIHJlbW90ZUFkZHJlc3M6IHNvY2tldC5yZW1vdGVBZGRyZXNzLFxuICAgIHJlbW90ZVBvcnQ6IHNvY2tldC5yZW1vdGVQb3J0LFxuICAgIHJlbW90ZUZhbWlseTogc29ja2V0LnJlbW90ZUZhbWlseSxcbiAgICB0aW1lb3V0OiBzb2NrZXQudGltZW91dCxcbiAgICBieXRlc1dyaXR0ZW46IHNvY2tldC5ieXRlc1dyaXR0ZW4sXG4gICAgYnl0ZXNSZWFkOiBzb2NrZXQuYnl0ZXNSZWFkXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gKiBjb252ZXJ0SXRlcmFibGVUb0J1ZmZlciAoaXRlcmFibGUpIHtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBpdGVyYWJsZSkge1xuICAgIHlpZWxkIEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgPyBjaHVuayA6IEJ1ZmZlci5mcm9tKGNodW5rKVxuICB9XG59XG5cbmxldCBSZWFkYWJsZVN0cmVhbVxuZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1Gcm9tIChpdGVyYWJsZSkge1xuICBpZiAoIVJlYWRhYmxlU3RyZWFtKSB7XG4gICAgUmVhZGFibGVTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0vd2ViJykuUmVhZGFibGVTdHJlYW1cbiAgfVxuXG4gIGlmIChSZWFkYWJsZVN0cmVhbS5mcm9tKSB7XG4gICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtLmZyb20oY29udmVydEl0ZXJhYmxlVG9CdWZmZXIoaXRlcmFibGUpKVxuICB9XG5cbiAgbGV0IGl0ZXJhdG9yXG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oXG4gICAge1xuICAgICAgYXN5bmMgc3RhcnQgKCkge1xuICAgICAgICBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpXG4gICAgICB9LFxuICAgICAgYXN5bmMgcHVsbCAoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdGVyYXRvci5uZXh0KClcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKClcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkgPyB2YWx1ZSA6IEJ1ZmZlci5mcm9tKHZhbHVlKVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShuZXcgVWludDhBcnJheShidWYpKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLmRlc2lyZWRTaXplID4gMFxuICAgICAgfSxcbiAgICAgIGFzeW5jIGNhbmNlbCAocmVhc29uKSB7XG4gICAgICAgIGF3YWl0IGl0ZXJhdG9yLnJldHVybigpXG4gICAgICB9XG4gICAgfSxcbiAgICAwXG4gIClcbn1cblxuLy8gVGhlIGNodW5rIHNob3VsZCBiZSBhIEZvcm1EYXRhIGluc3RhbmNlIGFuZCBjb250YWluc1xuLy8gYWxsIHRoZSByZXF1aXJlZCBtZXRob2RzLlxuZnVuY3Rpb24gaXNGb3JtRGF0YUxpa2UgKG9iamVjdCkge1xuICByZXR1cm4gKFxuICAgIG9iamVjdCAmJlxuICAgIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIG9iamVjdC5hcHBlbmQgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygb2JqZWN0LmRlbGV0ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmplY3QuZ2V0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIG9iamVjdC5nZXRBbGwgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygb2JqZWN0LmhhcyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmplY3Quc2V0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgb2JqZWN0W1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdGb3JtRGF0YSdcbiAgKVxufVxuXG5mdW5jdGlvbiB0aHJvd0lmQWJvcnRlZCAoc2lnbmFsKSB7XG4gIGlmICghc2lnbmFsKSB7IHJldHVybiB9XG4gIGlmICh0eXBlb2Ygc2lnbmFsLnRocm93SWZBYm9ydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2lnbmFsLnRocm93SWZBYm9ydGVkKClcbiAgfSBlbHNlIHtcbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIC8vIERPTUV4Y2VwdGlvbiBub3QgYXZhaWxhYmxlIDwgdjE3LjAuMFxuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkJylcbiAgICAgIGVyci5uYW1lID0gJ0Fib3J0RXJyb3InXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkQWJvcnRMaXN0ZW5lciAoc2lnbmFsLCBsaXN0ZW5lcikge1xuICBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIHNpZ25hbCkge1xuICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSlcbiAgICByZXR1cm4gKCkgPT4gc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgbGlzdGVuZXIpXG4gIH1cbiAgc2lnbmFsLmFkZExpc3RlbmVyKCdhYm9ydCcsIGxpc3RlbmVyKVxuICByZXR1cm4gKCkgPT4gc2lnbmFsLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIGxpc3RlbmVyKVxufVxuXG5jb25zdCBoYXNUb1dlbGxGb3JtZWQgPSAhIVN0cmluZy5wcm90b3R5cGUudG9XZWxsRm9ybWVkXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbFxuICovXG5mdW5jdGlvbiB0b1VTVlN0cmluZyAodmFsKSB7XG4gIGlmIChoYXNUb1dlbGxGb3JtZWQpIHtcbiAgICByZXR1cm4gYCR7dmFsfWAudG9XZWxsRm9ybWVkKClcbiAgfSBlbHNlIGlmIChub2RlVXRpbC50b1VTVlN0cmluZykge1xuICAgIHJldHVybiBub2RlVXRpbC50b1VTVlN0cmluZyh2YWwpXG4gIH1cblxuICByZXR1cm4gYCR7dmFsfWBcbn1cblxuLy8gUGFyc2VkIGFjY29yZGluZ2x5IHRvIFJGQyA5MTEwXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMCNmaWVsZC5jb250ZW50LXJhbmdlXG5mdW5jdGlvbiBwYXJzZVJhbmdlSGVhZGVyIChyYW5nZSkge1xuICBpZiAocmFuZ2UgPT0gbnVsbCB8fCByYW5nZSA9PT0gJycpIHJldHVybiB7IHN0YXJ0OiAwLCBlbmQ6IG51bGwsIHNpemU6IG51bGwgfVxuXG4gIGNvbnN0IG0gPSByYW5nZSA/IHJhbmdlLm1hdGNoKC9eYnl0ZXMgKFxcZCspLShcXGQrKVxcLyhcXGQrKT8kLykgOiBudWxsXG4gIHJldHVybiBtXG4gICAgPyB7XG4gICAgICAgIHN0YXJ0OiBwYXJzZUludChtWzFdKSxcbiAgICAgICAgZW5kOiBtWzJdID8gcGFyc2VJbnQobVsyXSkgOiBudWxsLFxuICAgICAgICBzaXplOiBtWzNdID8gcGFyc2VJbnQobVszXSkgOiBudWxsXG4gICAgICB9XG4gICAgOiBudWxsXG59XG5cbmNvbnN0IGtFbnVtZXJhYmxlUHJvcGVydHkgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5rRW51bWVyYWJsZVByb3BlcnR5LmVudW1lcmFibGUgPSB0cnVlXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBub3AsXG4gIGlzRGlzdHVyYmVkLFxuICBpc0Vycm9yZWQsXG4gIGlzUmVhZGFibGUsXG4gIHRvVVNWU3RyaW5nLFxuICBpc1JlYWRhYmxlQWJvcnRlZCxcbiAgaXNCbG9iTGlrZSxcbiAgcGFyc2VPcmlnaW4sXG4gIHBhcnNlVVJMLFxuICBnZXRTZXJ2ZXJOYW1lLFxuICBpc1N0cmVhbSxcbiAgaXNJdGVyYWJsZSxcbiAgaXNBc3luY0l0ZXJhYmxlLFxuICBpc0Rlc3Ryb3llZCxcbiAgcGFyc2VSYXdIZWFkZXJzLFxuICBwYXJzZUhlYWRlcnMsXG4gIHBhcnNlS2VlcEFsaXZlVGltZW91dCxcbiAgZGVzdHJveSxcbiAgYm9keUxlbmd0aCxcbiAgZGVlcENsb25lLFxuICBSZWFkYWJsZVN0cmVhbUZyb20sXG4gIGlzQnVmZmVyLFxuICB2YWxpZGF0ZUhhbmRsZXIsXG4gIGdldFNvY2tldEluZm8sXG4gIGlzRm9ybURhdGFMaWtlLFxuICBidWlsZFVSTCxcbiAgdGhyb3dJZkFib3J0ZWQsXG4gIGFkZEFib3J0TGlzdGVuZXIsXG4gIHBhcnNlUmFuZ2VIZWFkZXIsXG4gIG5vZGVNYWpvcixcbiAgbm9kZU1pbm9yLFxuICBub2RlSGFzQXV0b1NlbGVjdEZhbWlseTogbm9kZU1ham9yID4gMTggfHwgKG5vZGVNYWpvciA9PT0gMTggJiYgbm9kZU1pbm9yID49IDEzKSxcbiAgc2FmZUhUVFBNZXRob2RzOiBbJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnVFJBQ0UnXVxufVxuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJrRGVzdHJveWVkIiwia0JvZHlVc2VkIiwiSW5jb21pbmdNZXNzYWdlIiwic3RyZWFtIiwibmV0IiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJCbG9iIiwibm9kZVV0aWwiLCJzdHJpbmdpZnkiLCJub2RlTWFqb3IiLCJub2RlTWlub3IiLCJwcm9jZXNzIiwidmVyc2lvbnMiLCJub2RlIiwic3BsaXQiLCJtYXAiLCJ2IiwiTnVtYmVyIiwibm9wIiwiaXNTdHJlYW0iLCJvYmoiLCJwaXBlIiwib24iLCJpc0Jsb2JMaWtlIiwib2JqZWN0IiwiYXJyYXlCdWZmZXIiLCJ0ZXN0IiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJidWlsZFVSTCIsInVybCIsInF1ZXJ5UGFyYW1zIiwiaW5jbHVkZXMiLCJFcnJvciIsInN0cmluZ2lmaWVkIiwicGFyc2VVUkwiLCJVUkwiLCJvcmlnaW4iLCJwcm90b2NvbCIsInBvcnQiLCJpc0Zpbml0ZSIsInBhcnNlSW50IiwicGF0aCIsInBhdGhuYW1lIiwiaG9zdG5hbWUiLCJzZWFyY2giLCJlbmRzV2l0aCIsInN1YnN0cmluZyIsImxlbmd0aCIsInN0YXJ0c1dpdGgiLCJwYXJzZU9yaWdpbiIsImhhc2giLCJnZXRIb3N0bmFtZSIsImhvc3QiLCJpZHgiLCJpbmRleE9mIiwiZ2V0U2VydmVyTmFtZSIsInN0cmljdEVxdWFsIiwic2VydmVybmFtZSIsImlzSVAiLCJkZWVwQ2xvbmUiLCJKU09OIiwicGFyc2UiLCJpc0FzeW5jSXRlcmFibGUiLCJhc3luY0l0ZXJhdG9yIiwiaXNJdGVyYWJsZSIsIml0ZXJhdG9yIiwiYm9keUxlbmd0aCIsImJvZHkiLCJzdGF0ZSIsIl9yZWFkYWJsZVN0YXRlIiwib2JqZWN0TW9kZSIsImVuZGVkIiwic2l6ZSIsImlzQnVmZmVyIiwiYnl0ZUxlbmd0aCIsImlzRGVzdHJveWVkIiwiZGVzdHJveWVkIiwiaXNSZWFkYWJsZUFib3J0ZWQiLCJlbmRFbWl0dGVkIiwiZGVzdHJveSIsImVyciIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwiY29uc3RydWN0b3IiLCJzb2NrZXQiLCJuZXh0VGljayIsImVtaXQiLCJLRUVQQUxJVkVfVElNRU9VVF9FWFBSIiwicGFyc2VLZWVwQWxpdmVUaW1lb3V0IiwidmFsIiwibSIsInRvU3RyaW5nIiwibWF0Y2giLCJwYXJzZUhlYWRlcnMiLCJoZWFkZXJzIiwiQXJyYXkiLCJpc0FycmF5IiwiaSIsImtleSIsInRvTG93ZXJDYXNlIiwieCIsInB1c2giLCJCdWZmZXIiLCJmcm9tIiwicGFyc2VSYXdIZWFkZXJzIiwicmV0IiwiaGFzQ29udGVudExlbmd0aCIsImNvbnRlbnREaXNwb3NpdGlvbklkeCIsIm4iLCJidWZmZXIiLCJVaW50OEFycmF5IiwidmFsaWRhdGVIYW5kbGVyIiwiaGFuZGxlciIsIm1ldGhvZCIsInVwZ3JhZGUiLCJvbkNvbm5lY3QiLCJvbkVycm9yIiwib25Cb2R5U2VudCIsInVuZGVmaW5lZCIsIm9uVXBncmFkZSIsIm9uSGVhZGVycyIsIm9uRGF0YSIsIm9uQ29tcGxldGUiLCJpc0Rpc3R1cmJlZCIsInJlYWRhYmxlRGlkUmVhZCIsImRhdGFFbWl0dGVkIiwiaXNFcnJvcmVkIiwiaW5zcGVjdCIsImlzUmVhZGFibGUiLCJnZXRTb2NrZXRJbmZvIiwibG9jYWxBZGRyZXNzIiwibG9jYWxQb3J0IiwicmVtb3RlQWRkcmVzcyIsInJlbW90ZVBvcnQiLCJyZW1vdGVGYW1pbHkiLCJ0aW1lb3V0IiwiYnl0ZXNXcml0dGVuIiwiYnl0ZXNSZWFkIiwiY29udmVydEl0ZXJhYmxlVG9CdWZmZXIiLCJpdGVyYWJsZSIsImNodW5rIiwiUmVhZGFibGVTdHJlYW0iLCJSZWFkYWJsZVN0cmVhbUZyb20iLCJzdGFydCIsInB1bGwiLCJjb250cm9sbGVyIiwiZG9uZSIsInZhbHVlIiwibmV4dCIsInF1ZXVlTWljcm90YXNrIiwiY2xvc2UiLCJidWYiLCJlbnF1ZXVlIiwiZGVzaXJlZFNpemUiLCJjYW5jZWwiLCJyZWFzb24iLCJyZXR1cm4iLCJpc0Zvcm1EYXRhTGlrZSIsImFwcGVuZCIsImRlbGV0ZSIsImdldCIsImdldEFsbCIsImhhcyIsInNldCIsInRocm93SWZBYm9ydGVkIiwic2lnbmFsIiwiYWJvcnRlZCIsIm5hbWUiLCJhZGRBYm9ydExpc3RlbmVyIiwibGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwib25jZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwiaGFzVG9XZWxsRm9ybWVkIiwiU3RyaW5nIiwicHJvdG90eXBlIiwidG9XZWxsRm9ybWVkIiwidG9VU1ZTdHJpbmciLCJwYXJzZVJhbmdlSGVhZGVyIiwicmFuZ2UiLCJlbmQiLCJrRW51bWVyYWJsZVByb3BlcnR5IiwiY3JlYXRlIiwiZW51bWVyYWJsZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJub2RlSGFzQXV0b1NlbGVjdEZhbWlseSIsInNhZmVIVFRQTWV0aG9kcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/dispatcher-base.js":
/*!**************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/dispatcher-base.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Dispatcher = __webpack_require__(/*! ./dispatcher */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/dispatcher.js\");\nconst { ClientDestroyedError, ClientClosedError, InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\nconst { kDestroy, kClose, kDispatch, kInterceptors } = __webpack_require__(/*! ./core/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\");\nconst kDestroyed = Symbol(\"destroyed\");\nconst kClosed = Symbol(\"closed\");\nconst kOnDestroyed = Symbol(\"onDestroyed\");\nconst kOnClosed = Symbol(\"onClosed\");\nconst kInterceptedDispatch = Symbol(\"Intercepted Dispatch\");\nclass DispatcherBase extends Dispatcher {\n    constructor(){\n        super();\n        this[kDestroyed] = false;\n        this[kOnDestroyed] = null;\n        this[kClosed] = false;\n        this[kOnClosed] = [];\n    }\n    get destroyed() {\n        return this[kDestroyed];\n    }\n    get closed() {\n        return this[kClosed];\n    }\n    get interceptors() {\n        return this[kInterceptors];\n    }\n    set interceptors(newInterceptors) {\n        if (newInterceptors) {\n            for(let i = newInterceptors.length - 1; i >= 0; i--){\n                const interceptor = this[kInterceptors][i];\n                if (typeof interceptor !== \"function\") {\n                    throw new InvalidArgumentError(\"interceptor must be an function\");\n                }\n            }\n        }\n        this[kInterceptors] = newInterceptors;\n    }\n    close(callback) {\n        if (callback === undefined) {\n            return new Promise((resolve, reject)=>{\n                this.close((err, data)=>{\n                    return err ? reject(err) : resolve(data);\n                });\n            });\n        }\n        if (typeof callback !== \"function\") {\n            throw new InvalidArgumentError(\"invalid callback\");\n        }\n        if (this[kDestroyed]) {\n            queueMicrotask(()=>callback(new ClientDestroyedError(), null));\n            return;\n        }\n        if (this[kClosed]) {\n            if (this[kOnClosed]) {\n                this[kOnClosed].push(callback);\n            } else {\n                queueMicrotask(()=>callback(null, null));\n            }\n            return;\n        }\n        this[kClosed] = true;\n        this[kOnClosed].push(callback);\n        const onClosed = ()=>{\n            const callbacks = this[kOnClosed];\n            this[kOnClosed] = null;\n            for(let i = 0; i < callbacks.length; i++){\n                callbacks[i](null, null);\n            }\n        };\n        // Should not error.\n        this[kClose]().then(()=>this.destroy()).then(()=>{\n            queueMicrotask(onClosed);\n        });\n    }\n    destroy(err, callback) {\n        if (typeof err === \"function\") {\n            callback = err;\n            err = null;\n        }\n        if (callback === undefined) {\n            return new Promise((resolve, reject)=>{\n                this.destroy(err, (err, data)=>{\n                    return err ? /* istanbul ignore next: should never error */ reject(err) : resolve(data);\n                });\n            });\n        }\n        if (typeof callback !== \"function\") {\n            throw new InvalidArgumentError(\"invalid callback\");\n        }\n        if (this[kDestroyed]) {\n            if (this[kOnDestroyed]) {\n                this[kOnDestroyed].push(callback);\n            } else {\n                queueMicrotask(()=>callback(null, null));\n            }\n            return;\n        }\n        if (!err) {\n            err = new ClientDestroyedError();\n        }\n        this[kDestroyed] = true;\n        this[kOnDestroyed] = this[kOnDestroyed] || [];\n        this[kOnDestroyed].push(callback);\n        const onDestroyed = ()=>{\n            const callbacks = this[kOnDestroyed];\n            this[kOnDestroyed] = null;\n            for(let i = 0; i < callbacks.length; i++){\n                callbacks[i](null, null);\n            }\n        };\n        // Should not error.\n        this[kDestroy](err).then(()=>{\n            queueMicrotask(onDestroyed);\n        });\n    }\n    [kInterceptedDispatch](opts, handler) {\n        if (!this[kInterceptors] || this[kInterceptors].length === 0) {\n            this[kInterceptedDispatch] = this[kDispatch];\n            return this[kDispatch](opts, handler);\n        }\n        let dispatch = this[kDispatch].bind(this);\n        for(let i = this[kInterceptors].length - 1; i >= 0; i--){\n            dispatch = this[kInterceptors][i](dispatch);\n        }\n        this[kInterceptedDispatch] = dispatch;\n        return dispatch(opts, handler);\n    }\n    dispatch(opts, handler) {\n        if (!handler || typeof handler !== \"object\") {\n            throw new InvalidArgumentError(\"handler must be an object\");\n        }\n        try {\n            if (!opts || typeof opts !== \"object\") {\n                throw new InvalidArgumentError(\"opts must be an object.\");\n            }\n            if (this[kDestroyed] || this[kOnDestroyed]) {\n                throw new ClientDestroyedError();\n            }\n            if (this[kClosed]) {\n                throw new ClientClosedError();\n            }\n            return this[kInterceptedDispatch](opts, handler);\n        } catch (err) {\n            if (typeof handler.onError !== \"function\") {\n                throw new InvalidArgumentError(\"invalid onError method\");\n            }\n            handler.onError(err);\n            return false;\n        }\n    }\n}\nmodule.exports = DispatcherBase;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZGlzcGF0Y2hlci1iYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsYUFBYUMsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUNKQyxvQkFBb0IsRUFDcEJDLGlCQUFpQixFQUNqQkMsb0JBQW9CLEVBQ3JCLEdBQUdILG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFSSxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxhQUFhLEVBQUUsR0FBR1AsbUJBQU9BLENBQUM7QUFFL0QsTUFBTVEsYUFBYUMsT0FBTztBQUMxQixNQUFNQyxVQUFVRCxPQUFPO0FBQ3ZCLE1BQU1FLGVBQWVGLE9BQU87QUFDNUIsTUFBTUcsWUFBWUgsT0FBTztBQUN6QixNQUFNSSx1QkFBdUJKLE9BQU87QUFFcEMsTUFBTUssdUJBQXVCZjtJQUMzQmdCLGFBQWU7UUFDYixLQUFLO1FBRUwsSUFBSSxDQUFDUCxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDRyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDRCxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDRSxVQUFVLEdBQUcsRUFBRTtJQUN0QjtJQUVBLElBQUlJLFlBQWE7UUFDZixPQUFPLElBQUksQ0FBQ1IsV0FBVztJQUN6QjtJQUVBLElBQUlTLFNBQVU7UUFDWixPQUFPLElBQUksQ0FBQ1AsUUFBUTtJQUN0QjtJQUVBLElBQUlRLGVBQWdCO1FBQ2xCLE9BQU8sSUFBSSxDQUFDWCxjQUFjO0lBQzVCO0lBRUEsSUFBSVcsYUFBY0MsZUFBZSxFQUFFO1FBQ2pDLElBQUlBLGlCQUFpQjtZQUNuQixJQUFLLElBQUlDLElBQUlELGdCQUFnQkUsTUFBTSxHQUFHLEdBQUdELEtBQUssR0FBR0EsSUFBSztnQkFDcEQsTUFBTUUsY0FBYyxJQUFJLENBQUNmLGNBQWMsQ0FBQ2EsRUFBRTtnQkFDMUMsSUFBSSxPQUFPRSxnQkFBZ0IsWUFB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O1lBRUFvQyxRQUFRRyxPQUFPLENBQUNiO1lBRWhCLE9BQU87UUFDVDtJQUNGO0FBQ0Y7QUFFQWMsT0FBT0MsT0FBTyxHQUFHOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyLWJhc2UuanM/NTZlNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hlcicpXG5jb25zdCB7XG4gIENsaWVudERlc3Ryb3llZEVycm9yLFxuICBDbGllbnRDbG9zZWRFcnJvcixcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3Jcbn0gPSByZXF1aXJlKCcuL2NvcmUvZXJyb3JzJylcbmNvbnN0IHsga0Rlc3Ryb3ksIGtDbG9zZSwga0Rpc3BhdGNoLCBrSW50ZXJjZXB0b3JzIH0gPSByZXF1aXJlKCcuL2NvcmUvc3ltYm9scycpXG5cbmNvbnN0IGtEZXN0cm95ZWQgPSBTeW1ib2woJ2Rlc3Ryb3llZCcpXG5jb25zdCBrQ2xvc2VkID0gU3ltYm9sKCdjbG9zZWQnKVxuY29uc3Qga09uRGVzdHJveWVkID0gU3ltYm9sKCdvbkRlc3Ryb3llZCcpXG5jb25zdCBrT25DbG9zZWQgPSBTeW1ib2woJ29uQ2xvc2VkJylcbmNvbnN0IGtJbnRlcmNlcHRlZERpc3BhdGNoID0gU3ltYm9sKCdJbnRlcmNlcHRlZCBEaXNwYXRjaCcpXG5cbmNsYXNzIERpc3BhdGNoZXJCYXNlIGV4dGVuZHMgRGlzcGF0Y2hlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzW2tEZXN0cm95ZWRdID0gZmFsc2VcbiAgICB0aGlzW2tPbkRlc3Ryb3llZF0gPSBudWxsXG4gICAgdGhpc1trQ2xvc2VkXSA9IGZhbHNlXG4gICAgdGhpc1trT25DbG9zZWRdID0gW11cbiAgfVxuXG4gIGdldCBkZXN0cm95ZWQgKCkge1xuICAgIHJldHVybiB0aGlzW2tEZXN0cm95ZWRdXG4gIH1cblxuICBnZXQgY2xvc2VkICgpIHtcbiAgICByZXR1cm4gdGhpc1trQ2xvc2VkXVxuICB9XG5cbiAgZ2V0IGludGVyY2VwdG9ycyAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0ludGVyY2VwdG9yc11cbiAgfVxuXG4gIHNldCBpbnRlcmNlcHRvcnMgKG5ld0ludGVyY2VwdG9ycykge1xuICAgIGlmIChuZXdJbnRlcmNlcHRvcnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSBuZXdJbnRlcmNlcHRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgaW50ZXJjZXB0b3IgPSB0aGlzW2tJbnRlcmNlcHRvcnNdW2ldXG4gICAgICAgIGlmICh0eXBlb2YgaW50ZXJjZXB0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludGVyY2VwdG9yIG11c3QgYmUgYW4gZnVuY3Rpb24nKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpc1trSW50ZXJjZXB0b3JzXSA9IG5ld0ludGVyY2VwdG9yc1xuICB9XG5cbiAgY2xvc2UgKGNhbGxiYWNrKSB7XG4gICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuY2xvc2UoKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgIHJldHVybiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoZGF0YSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNhbGxiYWNrJylcbiAgICB9XG5cbiAgICBpZiAodGhpc1trRGVzdHJveWVkXSkge1xuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2sobmV3IENsaWVudERlc3Ryb3llZEVycm9yKCksIG51bGwpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXNba0Nsb3NlZF0pIHtcbiAgICAgIGlmICh0aGlzW2tPbkNsb3NlZF0pIHtcbiAgICAgICAgdGhpc1trT25DbG9zZWRdLnB1c2goY2FsbGJhY2spXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhudWxsLCBudWxsKSlcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXNba0Nsb3NlZF0gPSB0cnVlXG4gICAgdGhpc1trT25DbG9zZWRdLnB1c2goY2FsbGJhY2spXG5cbiAgICBjb25zdCBvbkNsb3NlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXNba09uQ2xvc2VkXVxuICAgICAgdGhpc1trT25DbG9zZWRdID0gbnVsbFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbGJhY2tzW2ldKG51bGwsIG51bGwpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2hvdWxkIG5vdCBlcnJvci5cbiAgICB0aGlzW2tDbG9zZV0oKVxuICAgICAgLnRoZW4oKCkgPT4gdGhpcy5kZXN0cm95KCkpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKG9uQ2xvc2VkKVxuICAgICAgfSlcbiAgfVxuXG4gIGRlc3Ryb3kgKGVyciwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGVyciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBlcnJcbiAgICAgIGVyciA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdGhpcy5kZXN0cm95KGVyciwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgIHJldHVybiBlcnIgPyAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2hvdWxkIG5ldmVyIGVycm9yICovIHJlamVjdChlcnIpIDogcmVzb2x2ZShkYXRhKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY2FsbGJhY2snKVxuICAgIH1cblxuICAgIGlmICh0aGlzW2tEZXN0cm95ZWRdKSB7XG4gICAgICBpZiAodGhpc1trT25EZXN0cm95ZWRdKSB7XG4gICAgICAgIHRoaXNba09uRGVzdHJveWVkXS5wdXNoKGNhbGxiYWNrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2sobnVsbCwgbnVsbCkpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIWVycikge1xuICAgICAgZXJyID0gbmV3IENsaWVudERlc3Ryb3llZEVycm9yKClcbiAgICB9XG5cbiAgICB0aGlzW2tEZXN0cm95ZWRdID0gdHJ1ZVxuICAgIHRoaXNba09uRGVzdHJveWVkXSA9IHRoaXNba09uRGVzdHJveWVkXSB8fCBbXVxuICAgIHRoaXNba09uRGVzdHJveWVkXS5wdXNoKGNhbGxiYWNrKVxuXG4gICAgY29uc3Qgb25EZXN0cm95ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzW2tPbkRlc3Ryb3llZF1cbiAgICAgIHRoaXNba09uRGVzdHJveWVkXSA9IG51bGxcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxiYWNrc1tpXShudWxsLCBudWxsKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNob3VsZCBub3QgZXJyb3IuXG4gICAgdGhpc1trRGVzdHJveV0oZXJyKS50aGVuKCgpID0+IHtcbiAgICAgIHF1ZXVlTWljcm90YXNrKG9uRGVzdHJveWVkKVxuICAgIH0pXG4gIH1cblxuICBba0ludGVyY2VwdGVkRGlzcGF0Y2hdIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgaWYgKCF0aGlzW2tJbnRlcmNlcHRvcnNdIHx8IHRoaXNba0ludGVyY2VwdG9yc10ubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzW2tJbnRlcmNlcHRlZERpc3BhdGNoXSA9IHRoaXNba0Rpc3BhdGNoXVxuICAgICAgcmV0dXJuIHRoaXNba0Rpc3BhdGNoXShvcHRzLCBoYW5kbGVyKVxuICAgIH1cblxuICAgIGxldCBkaXNwYXRjaCA9IHRoaXNba0Rpc3BhdGNoXS5iaW5kKHRoaXMpXG4gICAgZm9yIChsZXQgaSA9IHRoaXNba0ludGVyY2VwdG9yc10ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGRpc3BhdGNoID0gdGhpc1trSW50ZXJjZXB0b3JzXVtpXShkaXNwYXRjaClcbiAgICB9XG4gICAgdGhpc1trSW50ZXJjZXB0ZWREaXNwYXRjaF0gPSBkaXNwYXRjaFxuICAgIHJldHVybiBkaXNwYXRjaChvcHRzLCBoYW5kbGVyKVxuICB9XG5cbiAgZGlzcGF0Y2ggKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBpZiAoIWhhbmRsZXIgfHwgdHlwZW9mIGhhbmRsZXIgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2hhbmRsZXIgbXVzdCBiZSBhbiBvYmplY3QnKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignb3B0cyBtdXN0IGJlIGFuIG9iamVjdC4nKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1trRGVzdHJveWVkXSB8fCB0aGlzW2tPbkRlc3Ryb3llZF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IENsaWVudERlc3Ryb3llZEVycm9yKClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNba0Nsb3NlZF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IENsaWVudENsb3NlZEVycm9yKClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXNba0ludGVyY2VwdGVkRGlzcGF0Y2hdKG9wdHMsIGhhbmRsZXIpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIub25FcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25FcnJvciBtZXRob2QnKVxuICAgICAgfVxuXG4gICAgICBoYW5kbGVyLm9uRXJyb3IoZXJyKVxuXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEaXNwYXRjaGVyQmFzZVxuIl0sIm5hbWVzIjpbIkRpc3BhdGNoZXIiLCJyZXF1aXJlIiwiQ2xpZW50RGVzdHJveWVkRXJyb3IiLCJDbGllbnRDbG9zZWRFcnJvciIsIkludmFsaWRBcmd1bWVudEVycm9yIiwia0Rlc3Ryb3kiLCJrQ2xvc2UiLCJrRGlzcGF0Y2giLCJrSW50ZXJjZXB0b3JzIiwia0Rlc3Ryb3llZCIsIlN5bWJvbCIsImtDbG9zZWQiLCJrT25EZXN0cm95ZWQiLCJrT25DbG9zZWQiLCJrSW50ZXJjZXB0ZWREaXNwYXRjaCIsIkRpc3BhdGNoZXJCYXNlIiwiY29uc3RydWN0b3IiLCJkZXN0cm95ZWQiLCJjbG9zZWQiLCJpbnRlcmNlcHRvcnMiLCJuZXdJbnRlcmNlcHRvcnMiLCJpIiwibGVuZ3RoIiwiaW50ZXJjZXB0b3IiLCJjbG9zZSIsImNhbGxiYWNrIiwidW5kZWZpbmVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJlcnIiLCJkYXRhIiwicXVldWVNaWNyb3Rhc2siLCJwdXNoIiwib25DbG9zZWQiLCJjYWxsYmFja3MiLCJ0aGVuIiwiZGVzdHJveSIsIm9uRGVzdHJveWVkIiwib3B0cyIsImhhbmRsZXIiLCJkaXNwYXRjaCIsImJpbmQiLCJvbkVycm9yIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/dispatcher-base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/dispatcher.js":
/*!*********************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/dispatcher.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nclass Dispatcher extends EventEmitter {\n    dispatch() {\n        throw new Error(\"not implemented\");\n    }\n    close() {\n        throw new Error(\"not implemented\");\n    }\n    destroy() {\n        throw new Error(\"not implemented\");\n    }\n}\nmodule.exports = Dispatcher;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZGlzcGF0Y2hlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLGVBQWVDLG1CQUFPQSxDQUFDO0FBRTdCLE1BQU1DLG1CQUFtQkY7SUFDdkJHLFdBQVk7UUFDVixNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFFQUMsUUFBUztRQUNQLE1BQU0sSUFBSUQsTUFBTTtJQUNsQjtJQUVBRSxVQUFXO1FBQ1QsTUFBTSxJQUFJRixNQUFNO0lBQ2xCO0FBQ0Y7QUFFQUcsT0FBT0MsT0FBTyxHQUFHTiIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Rpc3BhdGNoZXIuanM/M2NjZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJylcblxuY2xhc3MgRGlzcGF0Y2hlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGRpc3BhdGNoICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpXG4gIH1cblxuICBjbG9zZSAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzcGF0Y2hlclxuIl0sIm5hbWVzIjpbIkV2ZW50RW1pdHRlciIsInJlcXVpcmUiLCJEaXNwYXRjaGVyIiwiZGlzcGF0Y2giLCJFcnJvciIsImNsb3NlIiwiZGVzdHJveSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/dispatcher.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/body.js":
/*!*********************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/fetch/body.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Busboy = __webpack_require__(/*! @fastify/busboy */ \"(ssr)/./node_modules/@fastify/busboy/lib/main.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst { ReadableStreamFrom, isBlobLike, isReadableStreamLike, readableStreamClose, createDeferredPromise, fullyReadBody } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/util.js\");\nconst { FormData } = __webpack_require__(/*! ./formdata */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/formdata.js\");\nconst { kState } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/webidl.js\");\nconst { DOMException, structuredClone } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/constants.js\");\nconst { Blob, File: NativeFile } = __webpack_require__(/*! buffer */ \"buffer\");\nconst { kBodyUsed } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { isErrored } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst { isUint8Array, isArrayBuffer } = __webpack_require__(/*! util/types */ \"util/types\");\nconst { File: UndiciFile } = __webpack_require__(/*! ./file */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/file.js\");\nconst { parseMIMEType, serializeAMimeType } = __webpack_require__(/*! ./dataURL */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/dataURL.js\");\nlet ReadableStream = globalThis.ReadableStream;\n/** @type {globalThis['File']} */ const File = NativeFile ?? UndiciFile;\nconst textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction extractBody(object, keepalive = false) {\n    if (!ReadableStream) {\n        ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n    }\n    // 1. Let stream be null.\n    let stream = null;\n    // 2. If object is a ReadableStream object, then set stream to object.\n    if (object instanceof ReadableStream) {\n        stream = object;\n    } else if (isBlobLike(object)) {\n        // 3. Otherwise, if object is a Blob object, set stream to the\n        //    result of running objects get stream.\n        stream = object.stream();\n    } else {\n        // 4. Otherwise, set stream to a new ReadableStream object, and set\n        //    up stream.\n        stream = new ReadableStream({\n            async pull (controller) {\n                controller.enqueue(typeof source === \"string\" ? textEncoder.encode(source) : source);\n                queueMicrotask(()=>readableStreamClose(controller));\n            },\n            start () {},\n            type: undefined\n        });\n    }\n    // 5. Assert: stream is a ReadableStream object.\n    assert(isReadableStreamLike(stream));\n    // 6. Let action be null.\n    let action = null;\n    // 7. Let source be null.\n    let source = null;\n    // 8. Let length be null.\n    let length = null;\n    // 9. Let type be null.\n    let type = null;\n    // 10. Switch on object:\n    if (typeof object === \"string\") {\n        // Set source to the UTF-8 encoding of object.\n        // Note: setting source to a Uint8Array here breaks some mocking assumptions.\n        source = object;\n        // Set type to `text/plain;charset=UTF-8`.\n        type = \"text/plain;charset=UTF-8\";\n    } else if (object instanceof URLSearchParams) {\n        // URLSearchParams\n        // spec says to run application/x-www-form-urlencoded on body.list\n        // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n        // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n        // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n        // Set source to the result of running the application/x-www-form-urlencoded serializer with objects list.\n        source = object.toString();\n        // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.\n        type = \"application/x-www-form-urlencoded;charset=UTF-8\";\n    } else if (isArrayBuffer(object)) {\n        // BufferSource/ArrayBuffer\n        // Set source to a copy of the bytes held by object.\n        source = new Uint8Array(object.slice());\n    } else if (ArrayBuffer.isView(object)) {\n        // BufferSource/ArrayBufferView\n        // Set source to a copy of the bytes held by object.\n        source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));\n    } else if (util.isFormDataLike(object)) {\n        const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, \"0\")}`;\n        const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`;\n        /*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */ const escape = (str)=>str.replace(/\\n/g, \"%0A\").replace(/\\r/g, \"%0D\").replace(/\"/g, \"%22\");\n        const normalizeLinefeeds = (value)=>value.replace(/\\r?\\n|\\r/g, \"\\r\\n\");\n        // Set action to this step: run the multipart/form-data\n        // encoding algorithm, with objects entry list and UTF-8.\n        // - This ensures that the body is immutable and can't be changed afterwords\n        // - That the content-length is calculated in advance.\n        // - And that all parts are pre-encoded and ready to be sent.\n        const blobParts = [];\n        const rn = new Uint8Array([\n            13,\n            10\n        ]) // '\\r\\n'\n        ;\n        length = 0;\n        let hasUnknownSizeValue = false;\n        for (const [name, value] of object){\n            if (typeof value === \"string\") {\n                const chunk = textEncoder.encode(prefix + `; name=\"${escape(normalizeLinefeeds(name))}\"` + `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`);\n                blobParts.push(chunk);\n                length += chunk.byteLength;\n            } else {\n                const chunk = textEncoder.encode(`${prefix}; name=\"${escape(normalizeLinefeeds(name))}\"` + (value.name ? `; filename=\"${escape(value.name)}\"` : \"\") + \"\\r\\n\" + `Content-Type: ${value.type || \"application/octet-stream\"}\\r\\n\\r\\n`);\n                blobParts.push(chunk, value, rn);\n                if (typeof value.size === \"number\") {\n                    length += chunk.byteLength + value.size + rn.byteLength;\n                } else {\n                    hasUnknownSizeValue = true;\n                }\n            }\n        }\n        const chunk = textEncoder.encode(`--${boundary}--`);\n        blobParts.push(chunk);\n        length += chunk.byteLength;\n        if (hasUnknownSizeValue) {\n            length = null;\n        }\n        // Set source to object.\n        source = object;\n        action = async function*() {\n            for (const part of blobParts){\n                if (part.stream) {\n                    yield* part.stream();\n                } else {\n                    yield part;\n                }\n            }\n        };\n        // Set type to `multipart/form-data; boundary=`,\n        // followed by the multipart/form-data boundary string generated\n        // by the multipart/form-data encoding algorithm.\n        type = \"multipart/form-data; boundary=\" + boundary;\n    } else if (isBlobLike(object)) {\n        // Blob\n        // Set source to object.\n        source = object;\n        // Set length to objects size.\n        length = object.size;\n        // If objects type attribute is not the empty byte sequence, set\n        // type to its value.\n        if (object.type) {\n            type = object.type;\n        }\n    } else if (typeof object[Symbol.asyncIterator] === \"function\") {\n        // If keepalive is true, then throw a TypeError.\n        if (keepalive) {\n            throw new TypeError(\"keepalive\");\n        }\n        // If object is disturbed or locked, then throw a TypeError.\n        if (util.isDisturbed(object) || object.locked) {\n            throw new TypeError(\"Response body object should not be disturbed or locked\");\n        }\n        stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);\n    }\n    // 11. If source is a byte sequence, then set action to a\n    // step that returns source and length to sources length.\n    if (typeof source === \"string\" || util.isBuffer(source)) {\n        length = Buffer.byteLength(source);\n    }\n    // 12. If action is non-null, then run these steps in in parallel:\n    if (action != null) {\n        // Run action.\n        let iterator;\n        stream = new ReadableStream({\n            async start () {\n                iterator = action(object)[Symbol.asyncIterator]();\n            },\n            async pull (controller) {\n                const { value, done } = await iterator.next();\n                if (done) {\n                    // When running action is done, close stream.\n                    queueMicrotask(()=>{\n                        controller.close();\n                    });\n                } else {\n                    // Whenever one or more bytes are available and stream is not errored,\n                    // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n                    // bytes into stream.\n                    if (!isErrored(stream)) {\n                        controller.enqueue(new Uint8Array(value));\n                    }\n                }\n                return controller.desiredSize > 0;\n            },\n            async cancel (reason) {\n                await iterator.return();\n            },\n            type: undefined\n        });\n    }\n    // 13. Let body be a body whose stream is stream, source is source,\n    // and length is length.\n    const body = {\n        stream,\n        source,\n        length\n    };\n    // 14. Return (body, type).\n    return [\n        body,\n        type\n    ];\n}\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction safelyExtractBody(object, keepalive = false) {\n    if (!ReadableStream) {\n        // istanbul ignore next\n        ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n    }\n    // To safely extract a body and a `Content-Type` value from\n    // a byte sequence or BodyInit object object, run these steps:\n    // 1. If object is a ReadableStream object, then:\n    if (object instanceof ReadableStream) {\n        // Assert: object is neither disturbed nor locked.\n        // istanbul ignore next\n        assert(!util.isDisturbed(object), \"The body has already been consumed.\");\n        // istanbul ignore next\n        assert(!object.locked, \"The stream is locked.\");\n    }\n    // 2. Return the results of extracting object.\n    return extractBody(object, keepalive);\n}\nfunction cloneBody(body) {\n    // To clone a body body, run these steps:\n    // https://fetch.spec.whatwg.org/#concept-body-clone\n    // 1. Let  out1, out2  be the result of teeing bodys stream.\n    const [out1, out2] = body.stream.tee();\n    const out2Clone = structuredClone(out2, {\n        transfer: [\n            out2\n        ]\n    });\n    // This, for whatever reasons, unrefs out2Clone which allows\n    // the process to exit by itself.\n    const [, finalClone] = out2Clone.tee();\n    // 2. Set bodys stream to out1.\n    body.stream = out1;\n    // 3. Return a body whose stream is out2 and other members are copied from body.\n    return {\n        stream: finalClone,\n        length: body.length,\n        source: body.source\n    };\n}\nasync function* consumeBody(body) {\n    if (body) {\n        if (isUint8Array(body)) {\n            yield body;\n        } else {\n            const stream = body.stream;\n            if (util.isDisturbed(stream)) {\n                throw new TypeError(\"The body has already been consumed.\");\n            }\n            if (stream.locked) {\n                throw new TypeError(\"The stream is locked.\");\n            }\n            // Compat.\n            stream[kBodyUsed] = true;\n            yield* stream;\n        }\n    }\n}\nfunction throwIfAborted(state) {\n    if (state.aborted) {\n        throw new DOMException(\"The operation was aborted.\", \"AbortError\");\n    }\n}\nfunction bodyMixinMethods(instance) {\n    const methods = {\n        blob () {\n            // The blob() method steps are to return the result of\n            // running consume body with this and the following step\n            // given a byte sequence bytes: return a Blob whose\n            // contents are bytes and whose type attribute is thiss\n            // MIME type.\n            return specConsumeBody(this, (bytes)=>{\n                let mimeType = bodyMimeType(this);\n                if (mimeType === \"failure\") {\n                    mimeType = \"\";\n                } else if (mimeType) {\n                    mimeType = serializeAMimeType(mimeType);\n                }\n                // Return a Blob whose contents are bytes and type attribute\n                // is mimeType.\n                return new Blob([\n                    bytes\n                ], {\n                    type: mimeType\n                });\n            }, instance);\n        },\n        arrayBuffer () {\n            // The arrayBuffer() method steps are to return the result\n            // of running consume body with this and the following step\n            // given a byte sequence bytes: return a new ArrayBuffer\n            // whose contents are bytes.\n            return specConsumeBody(this, (bytes)=>{\n                return new Uint8Array(bytes).buffer;\n            }, instance);\n        },\n        text () {\n            // The text() method steps are to return the result of running\n            // consume body with this and UTF-8 decode.\n            return specConsumeBody(this, utf8DecodeBytes, instance);\n        },\n        json () {\n            // The json() method steps are to return the result of running\n            // consume body with this and parse JSON from bytes.\n            return specConsumeBody(this, parseJSONFromBytes, instance);\n        },\n        async formData () {\n            webidl.brandCheck(this, instance);\n            throwIfAborted(this[kState]);\n            const contentType = this.headers.get(\"Content-Type\");\n            // If mimeTypes essence is \"multipart/form-data\", then:\n            if (/multipart\\/form-data/.test(contentType)) {\n                const headers = {};\n                for (const [key, value] of this.headers)headers[key.toLowerCase()] = value;\n                const responseFormData = new FormData();\n                let busboy;\n                try {\n                    busboy = new Busboy({\n                        headers,\n                        preservePath: true\n                    });\n                } catch (err) {\n                    throw new DOMException(`${err}`, \"AbortError\");\n                }\n                busboy.on(\"field\", (name, value)=>{\n                    responseFormData.append(name, value);\n                });\n                busboy.on(\"file\", (name, value, filename, encoding, mimeType)=>{\n                    const chunks = [];\n                    if (encoding === \"base64\" || encoding.toLowerCase() === \"base64\") {\n                        let base64chunk = \"\";\n                        value.on(\"data\", (chunk)=>{\n                            base64chunk += chunk.toString().replace(/[\\r\\n]/gm, \"\");\n                            const end = base64chunk.length - base64chunk.length % 4;\n                            chunks.push(Buffer.from(base64chunk.slice(0, end), \"base64\"));\n                            base64chunk = base64chunk.slice(end);\n                        });\n                        value.on(\"end\", ()=>{\n                            chunks.push(Buffer.from(base64chunk, \"base64\"));\n                            responseFormData.append(name, new File(chunks, filename, {\n                                type: mimeType\n                            }));\n                        });\n                    } else {\n                        value.on(\"data\", (chunk)=>{\n                            chunks.push(chunk);\n                        });\n                        value.on(\"end\", ()=>{\n                            responseFormData.append(name, new File(chunks, filename, {\n                                type: mimeType\n                            }));\n                        });\n                    }\n                });\n                const busboyResolve = new Promise((resolve, reject)=>{\n                    busboy.on(\"finish\", resolve);\n                    busboy.on(\"error\", (err)=>reject(new TypeError(err)));\n                });\n                if (this.body !== null) for await (const chunk of consumeBody(this[kState].body))busboy.write(chunk);\n                busboy.end();\n                await busboyResolve;\n                return responseFormData;\n            } else if (/application\\/x-www-form-urlencoded/.test(contentType)) {\n                // Otherwise, if mimeTypes essence is \"application/x-www-form-urlencoded\", then:\n                // 1. Let entries be the result of parsing bytes.\n                let entries;\n                try {\n                    let text = \"\";\n                    // application/x-www-form-urlencoded parser will keep the BOM.\n                    // https://url.spec.whatwg.org/#concept-urlencoded-parser\n                    // Note that streaming decoder is stateful and cannot be reused\n                    const streamingDecoder = new TextDecoder(\"utf-8\", {\n                        ignoreBOM: true\n                    });\n                    for await (const chunk of consumeBody(this[kState].body)){\n                        if (!isUint8Array(chunk)) {\n                            throw new TypeError(\"Expected Uint8Array chunk\");\n                        }\n                        text += streamingDecoder.decode(chunk, {\n                            stream: true\n                        });\n                    }\n                    text += streamingDecoder.decode();\n                    entries = new URLSearchParams(text);\n                } catch (err) {\n                    // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.\n                    // 2. If entries is failure, then throw a TypeError.\n                    throw Object.assign(new TypeError(), {\n                        cause: err\n                    });\n                }\n                // 3. Return a new FormData object whose entries are entries.\n                const formData = new FormData();\n                for (const [name, value] of entries){\n                    formData.append(name, value);\n                }\n                return formData;\n            } else {\n                // Wait a tick before checking if the request has been aborted.\n                // Otherwise, a TypeError can be thrown when an AbortError should.\n                await Promise.resolve();\n                throwIfAborted(this[kState]);\n                // Otherwise, throw a TypeError.\n                throw webidl.errors.exception({\n                    header: `${instance.name}.formData`,\n                    message: \"Could not parse content as FormData.\"\n                });\n            }\n        }\n    };\n    return methods;\n}\nfunction mixinBody(prototype) {\n    Object.assign(prototype.prototype, bodyMixinMethods(prototype));\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-consume-body\n * @param {Response|Request} object\n * @param {(value: unknown) => unknown} convertBytesToJSValue\n * @param {Response|Request} instance\n */ async function specConsumeBody(object, convertBytesToJSValue, instance) {\n    webidl.brandCheck(object, instance);\n    throwIfAborted(object[kState]);\n    // 1. If object is unusable, then return a promise rejected\n    //    with a TypeError.\n    if (bodyUnusable(object[kState].body)) {\n        throw new TypeError(\"Body is unusable\");\n    }\n    // 2. Let promise be a new promise.\n    const promise = createDeferredPromise();\n    // 3. Let errorSteps given error be to reject promise with error.\n    const errorSteps = (error)=>promise.reject(error);\n    // 4. Let successSteps given a byte sequence data be to resolve\n    //    promise with the result of running convertBytesToJSValue\n    //    with data. If that threw an exception, then run errorSteps\n    //    with that exception.\n    const successSteps = (data)=>{\n        try {\n            promise.resolve(convertBytesToJSValue(data));\n        } catch (e) {\n            errorSteps(e);\n        }\n    };\n    // 5. If objects body is null, then run successSteps with an\n    //    empty byte sequence.\n    if (object[kState].body == null) {\n        successSteps(new Uint8Array());\n        return promise.promise;\n    }\n    // 6. Otherwise, fully read objects body given successSteps,\n    //    errorSteps, and objects relevant global object.\n    await fullyReadBody(object[kState].body, successSteps, errorSteps);\n    // 7. Return promise.\n    return promise.promise;\n}\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction bodyUnusable(body) {\n    // An object including the Body interface mixin is\n    // said to be unusable if its body is non-null and\n    // its bodys stream is disturbed or locked.\n    return body != null && (body.stream.locked || util.isDisturbed(body.stream));\n}\n/**\n * @see https://encoding.spec.whatwg.org/#utf-8-decode\n * @param {Buffer} buffer\n */ function utf8DecodeBytes(buffer) {\n    if (buffer.length === 0) {\n        return \"\";\n    }\n    // 1. Let buffer be the result of peeking three bytes from\n    //    ioQueue, converted to a byte sequence.\n    // 2. If buffer is 0xEF 0xBB 0xBF, then read three\n    //    bytes from ioQueue. (Do nothing with those bytes.)\n    if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {\n        buffer = buffer.subarray(3);\n    }\n    // 3. Process a queue with an instance of UTF-8s\n    //    decoder, ioQueue, output, and \"replacement\".\n    const output = textDecoder.decode(buffer);\n    // 4. Return output.\n    return output;\n}\n/**\n * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value\n * @param {Uint8Array} bytes\n */ function parseJSONFromBytes(bytes) {\n    return JSON.parse(utf8DecodeBytes(bytes));\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-mime-type\n * @param {import('./response').Response|import('./request').Request} object\n */ function bodyMimeType(object) {\n    const { headersList } = object[kState];\n    const contentType = headersList.get(\"content-type\");\n    if (contentType === null) {\n        return \"failure\";\n    }\n    return parseMIMEType(contentType);\n}\nmodule.exports = {\n    extractBody,\n    safelyExtractBody,\n    cloneBody,\n    mixinBody\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvYm9keS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFDSkUsa0JBQWtCLEVBQ2xCQyxVQUFVLEVBQ1ZDLG9CQUFvQixFQUNwQkMsbUJBQW1CLEVBQ25CQyxxQkFBcUIsRUFDckJDLGFBQWEsRUFDZCxHQUFHUCxtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRVEsUUFBUSxFQUFFLEdBQUdSLG1CQUFPQSxDQUFDO0FBQzdCLE1BQU0sRUFBRVMsTUFBTSxFQUFFLEdBQUdULG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRVUsTUFBTSxFQUFFLEdBQUdWLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRVcsWUFBWSxFQUFFQyxlQUFlLEVBQUUsR0FBR1osbUJBQU9BLENBQUM7QUFDbEQsTUFBTSxFQUFFYSxJQUFJLEVBQUVDLE1BQU1DLFVBQVUsRUFBRSxHQUFHZixtQkFBT0EsQ0FBQztBQUMzQyxNQUFNLEVBQUVnQixTQUFTLEVBQUUsR0FBR2hCLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU1pQixTQUFTakIsbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFa0IsU0FBUyxFQUFFLEdBQUdsQixtQkFBT0EsQ0FBQztBQUM5QixNQUFNLEVBQUVtQixZQUFZLEVBQUVDLGFBQWEsRUFBRSxHQUFHcEIsbUJBQU9BLENBQUM7QUFDaEQsTUFBTSxFQUFFYyxNQUFNTyxVQUFVLEVBQUUsR0FBR3JCLG1CQUFPQSxDQUFDO0FBQ3JDLE1BQU0sRUFBRXNCLGFBQWEsRUFBRUMsa0JBQWtCLEVBQUUsR0FBR3ZCLG1CQUFPQSxDQUFDO0FBRXRELElBQUl3QixpQkFBaUJDLFdBQVdELGNBQWM7QUFFOUMsK0JBQStCLEdBQy9CLE1BQU1WLE9BQU9DLGNBQWNNO0FBQzNC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RCxTQUFTRSxhQUFjOUUsTUFBTTtJQUMzQixNQUFNLEVBQUVzSSxXQUFXLEVBQUUsR0FBR3RJLE1BQU0sQ0FBQ3RCLE9BQU87SUFDdEMsTUFBTTRHLGNBQWNnRCxZQUFZOUMsR0FBRyxDQUFDO0lBRXBDLElBQUlGLGdCQUFnQixNQUFNO1FBQ3hCLE9BQU87SUFDVDtJQUVBLE9BQU8vRixjQUFjK0Y7QUFDdkI7QUFFQWlELE9BQU9DLE9BQU8sR0FBRztJQUNmekk7SUFDQTREO0lBQ0FDO0lBQ0E0RDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1maWdodGVyLWFjYWRlbXkvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvYm9keS5qcz83ZjE2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBCdXNib3kgPSByZXF1aXJlKCdAZmFzdGlmeS9idXNib3knKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7XG4gIFJlYWRhYmxlU3RyZWFtRnJvbSxcbiAgaXNCbG9iTGlrZSxcbiAgaXNSZWFkYWJsZVN0cmVhbUxpa2UsXG4gIHJlYWRhYmxlU3RyZWFtQ2xvc2UsXG4gIGNyZWF0ZURlZmVycmVkUHJvbWlzZSxcbiAgZnVsbHlSZWFkQm9keVxufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IEZvcm1EYXRhIH0gPSByZXF1aXJlKCcuL2Zvcm1kYXRhJylcbmNvbnN0IHsga1N0YXRlIH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4vd2ViaWRsJylcbmNvbnN0IHsgRE9NRXhjZXB0aW9uLCBzdHJ1Y3R1cmVkQ2xvbmUgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsgQmxvYiwgRmlsZTogTmF0aXZlRmlsZSB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IHsga0JvZHlVc2VkIH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IHsgaXNFcnJvcmVkIH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBpc1VpbnQ4QXJyYXksIGlzQXJyYXlCdWZmZXIgfSA9IHJlcXVpcmUoJ3V0aWwvdHlwZXMnKVxuY29uc3QgeyBGaWxlOiBVbmRpY2lGaWxlIH0gPSByZXF1aXJlKCcuL2ZpbGUnKVxuY29uc3QgeyBwYXJzZU1JTUVUeXBlLCBzZXJpYWxpemVBTWltZVR5cGUgfSA9IHJlcXVpcmUoJy4vZGF0YVVSTCcpXG5cbmxldCBSZWFkYWJsZVN0cmVhbSA9IGdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW1cblxuLyoqIEB0eXBlIHtnbG9iYWxUaGlzWydGaWxlJ119ICovXG5jb25zdCBGaWxlID0gTmF0aXZlRmlsZSA/PyBVbmRpY2lGaWxlXG5jb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG5jb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHlpbml0LWV4dHJhY3RcbmZ1bmN0aW9uIGV4dHJhY3RCb2R5IChvYmplY3QsIGtlZXBhbGl2ZSA9IGZhbHNlKSB7XG4gIGlmICghUmVhZGFibGVTdHJlYW0pIHtcbiAgICBSZWFkYWJsZVN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbS93ZWInKS5SZWFkYWJsZVN0cmVhbVxuICB9XG5cbiAgLy8gMS4gTGV0IHN0cmVhbSBiZSBudWxsLlxuICBsZXQgc3RyZWFtID0gbnVsbFxuXG4gIC8vIDIuIElmIG9iamVjdCBpcyBhIFJlYWRhYmxlU3RyZWFtIG9iamVjdCwgdGhlbiBzZXQgc3RyZWFtIHRvIG9iamVjdC5cbiAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKSB7XG4gICAgc3RyZWFtID0gb2JqZWN0XG4gIH0gZWxzZSBpZiAoaXNCbG9iTGlrZShvYmplY3QpKSB7XG4gICAgLy8gMy4gT3RoZXJ3aXNlLCBpZiBvYmplY3QgaXMgYSBCbG9iIG9iamVjdCwgc2V0IHN0cmVhbSB0byB0aGVcbiAgICAvLyAgICByZXN1bHQgb2YgcnVubmluZyBvYmplY3TigJlzIGdldCBzdHJlYW0uXG4gICAgc3RyZWFtID0gb2JqZWN0LnN0cmVhbSgpXG4gIH0gZWxzZSB7XG4gICAgLy8gNC4gT3RoZXJ3aXNlLCBzZXQgc3RyZWFtIHRvIGEgbmV3IFJlYWRhYmxlU3RyZWFtIG9iamVjdCwgYW5kIHNldFxuICAgIC8vICAgIHVwIHN0cmVhbS5cbiAgICBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgYXN5bmMgcHVsbCAoY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyB0ZXh0RW5jb2Rlci5lbmNvZGUoc291cmNlKSA6IHNvdXJjZVxuICAgICAgICApXG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHJlYWRhYmxlU3RyZWFtQ2xvc2UoY29udHJvbGxlcikpXG4gICAgICB9LFxuICAgICAgc3RhcnQgKCkge30sXG4gICAgICB0eXBlOiB1bmRlZmluZWRcbiAgICB9KVxuICB9XG5cbiAgLy8gNS4gQXNzZXJ0OiBzdHJlYW0gaXMgYSBSZWFkYWJsZVN0cmVhbSBvYmplY3QuXG4gIGFzc2VydChpc1JlYWRhYmxlU3RyZWFtTGlrZShzdHJlYW0pKVxuXG4gIC8vIDYuIExldCBhY3Rpb24gYmUgbnVsbC5cbiAgbGV0IGFjdGlvbiA9IG51bGxcblxuICAvLyA3LiBMZXQgc291cmNlIGJlIG51bGwuXG4gIGxldCBzb3VyY2UgPSBudWxsXG5cbiAgLy8gOC4gTGV0IGxlbmd0aCBiZSBudWxsLlxuICBsZXQgbGVuZ3RoID0gbnVsbFxuXG4gIC8vIDkuIExldCB0eXBlIGJlIG51bGwuXG4gIGxldCB0eXBlID0gbnVsbFxuXG4gIC8vIDEwLiBTd2l0Y2ggb24gb2JqZWN0OlxuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBTZXQgc291cmNlIHRvIHRoZSBVVEYtOCBlbmNvZGluZyBvZiBvYmplY3QuXG4gICAgLy8gTm90ZTogc2V0dGluZyBzb3VyY2UgdG8gYSBVaW50OEFycmF5IGhlcmUgYnJlYWtzIHNvbWUgbW9ja2luZyBhc3N1bXB0aW9ucy5cbiAgICBzb3VyY2UgPSBvYmplY3RcblxuICAgIC8vIFNldCB0eXBlIHRvIGB0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThgLlxuICAgIHR5cGUgPSAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04J1xuICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykge1xuICAgIC8vIFVSTFNlYXJjaFBhcmFtc1xuXG4gICAgLy8gc3BlYyBzYXlzIHRvIHJ1biBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQgb24gYm9keS5saXN0XG4gICAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBpbiBOb2RlLmpzIGFzIGFwYXJ0IG9mIGFuIFVSTFNlYXJjaFBhcmFtcyBpbnN0YW5jZSB0b1N0cmluZyBtZXRob2RcbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2U0NmM2ODBiZjJiMjExYmJkNTJjZjk1OWNhMTdlZTk4YzdmNjU3ZjUvbGliL2ludGVybmFsL3VybC5qcyNMNDkwXG4gICAgLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2U0NmM2ODBiZjJiMjExYmJkNTJjZjk1OWNhMTdlZTk4YzdmNjU3ZjUvbGliL2ludGVybmFsL3VybC5qcyNMMTEwMFxuXG4gICAgLy8gU2V0IHNvdXJjZSB0byB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgdGhlIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCBzZXJpYWxpemVyIHdpdGggb2JqZWN04oCZcyBsaXN0LlxuICAgIHNvdXJjZSA9IG9iamVjdC50b1N0cmluZygpXG5cbiAgICAvLyBTZXQgdHlwZSB0byBgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLThgLlxuICAgIHR5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnXG4gIH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcihvYmplY3QpKSB7XG4gICAgLy8gQnVmZmVyU291cmNlL0FycmF5QnVmZmVyXG5cbiAgICAvLyBTZXQgc291cmNlIHRvIGEgY29weSBvZiB0aGUgYnl0ZXMgaGVsZCBieSBvYmplY3QuXG4gICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkob2JqZWN0LnNsaWNlKCkpXG4gIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KG9iamVjdCkpIHtcbiAgICAvLyBCdWZmZXJTb3VyY2UvQXJyYXlCdWZmZXJWaWV3XG5cbiAgICAvLyBTZXQgc291cmNlIHRvIGEgY29weSBvZiB0aGUgYnl0ZXMgaGVsZCBieSBvYmplY3QuXG4gICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkob2JqZWN0LmJ1ZmZlci5zbGljZShvYmplY3QuYnl0ZU9mZnNldCwgb2JqZWN0LmJ5dGVPZmZzZXQgKyBvYmplY3QuYnl0ZUxlbmd0aCkpXG4gIH0gZWxzZSBpZiAodXRpbC5pc0Zvcm1EYXRhTGlrZShvYmplY3QpKSB7XG4gICAgY29uc3QgYm91bmRhcnkgPSBgLS0tLWZvcm1kYXRhLXVuZGljaS0wJHtgJHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTExKX1gLnBhZFN0YXJ0KDExLCAnMCcpfWBcbiAgICBjb25zdCBwcmVmaXggPSBgLS0ke2JvdW5kYXJ5fVxcclxcbkNvbnRlbnQtRGlzcG9zaXRpb246IGZvcm0tZGF0YWBcblxuICAgIC8qISBmb3JtZGF0YS1wb2x5ZmlsbC4gTUlUIExpY2Vuc2UuIEppbW15IFfDpHJ0aW5nIDxodHRwczovL2ppbW15LndhcnRpbmcuc2Uvb3BlbnNvdXJjZT4gKi9cbiAgICBjb25zdCBlc2NhcGUgPSAoc3RyKSA9PlxuICAgICAgc3RyLnJlcGxhY2UoL1xcbi9nLCAnJTBBJykucmVwbGFjZSgvXFxyL2csICclMEQnKS5yZXBsYWNlKC9cIi9nLCAnJTIyJylcbiAgICBjb25zdCBub3JtYWxpemVMaW5lZmVlZHMgPSAodmFsdWUpID0+IHZhbHVlLnJlcGxhY2UoL1xccj9cXG58XFxyL2csICdcXHJcXG4nKVxuXG4gICAgLy8gU2V0IGFjdGlvbiB0byB0aGlzIHN0ZXA6IHJ1biB0aGUgbXVsdGlwYXJ0L2Zvcm0tZGF0YVxuICAgIC8vIGVuY29kaW5nIGFsZ29yaXRobSwgd2l0aCBvYmplY3TigJlzIGVudHJ5IGxpc3QgYW5kIFVURi04LlxuICAgIC8vIC0gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIGJvZHkgaXMgaW1tdXRhYmxlIGFuZCBjYW4ndCBiZSBjaGFuZ2VkIGFmdGVyd29yZHNcbiAgICAvLyAtIFRoYXQgdGhlIGNvbnRlbnQtbGVuZ3RoIGlzIGNhbGN1bGF0ZWQgaW4gYWR2YW5jZS5cbiAgICAvLyAtIEFuZCB0aGF0IGFsbCBwYXJ0cyBhcmUgcHJlLWVuY29kZWQgYW5kIHJlYWR5IHRvIGJlIHNlbnQuXG5cbiAgICBjb25zdCBibG9iUGFydHMgPSBbXVxuICAgIGNvbnN0IHJuID0gbmV3IFVpbnQ4QXJyYXkoWzEzLCAxMF0pIC8vICdcXHJcXG4nXG4gICAgbGVuZ3RoID0gMFxuICAgIGxldCBoYXNVbmtub3duU2l6ZVZhbHVlID0gZmFsc2VcblxuICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBvYmplY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IGNodW5rID0gdGV4dEVuY29kZXIuZW5jb2RlKHByZWZpeCArXG4gICAgICAgICAgYDsgbmFtZT1cIiR7ZXNjYXBlKG5vcm1hbGl6ZUxpbmVmZWVkcyhuYW1lKSl9XCJgICtcbiAgICAgICAgICBgXFxyXFxuXFxyXFxuJHtub3JtYWxpemVMaW5lZmVlZHModmFsdWUpfVxcclxcbmApXG4gICAgICAgIGJsb2JQYXJ0cy5wdXNoKGNodW5rKVxuICAgICAgICBsZW5ndGggKz0gY2h1bmsuYnl0ZUxlbmd0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoYCR7cHJlZml4fTsgbmFtZT1cIiR7ZXNjYXBlKG5vcm1hbGl6ZUxpbmVmZWVkcyhuYW1lKSl9XCJgICtcbiAgICAgICAgICAodmFsdWUubmFtZSA/IGA7IGZpbGVuYW1lPVwiJHtlc2NhcGUodmFsdWUubmFtZSl9XCJgIDogJycpICsgJ1xcclxcbicgK1xuICAgICAgICAgIGBDb250ZW50LVR5cGU6ICR7XG4gICAgICAgICAgICB2YWx1ZS50eXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXG4gICAgICAgICAgfVxcclxcblxcclxcbmApXG4gICAgICAgIGJsb2JQYXJ0cy5wdXNoKGNodW5rLCB2YWx1ZSwgcm4pXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUuc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBsZW5ndGggKz0gY2h1bmsuYnl0ZUxlbmd0aCArIHZhbHVlLnNpemUgKyBybi5ieXRlTGVuZ3RoXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFzVW5rbm93blNpemVWYWx1ZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNodW5rID0gdGV4dEVuY29kZXIuZW5jb2RlKGAtLSR7Ym91bmRhcnl9LS1gKVxuICAgIGJsb2JQYXJ0cy5wdXNoKGNodW5rKVxuICAgIGxlbmd0aCArPSBjaHVuay5ieXRlTGVuZ3RoXG4gICAgaWYgKGhhc1Vua25vd25TaXplVmFsdWUpIHtcbiAgICAgIGxlbmd0aCA9IG51bGxcbiAgICB9XG5cbiAgICAvLyBTZXQgc291cmNlIHRvIG9iamVjdC5cbiAgICBzb3VyY2UgPSBvYmplY3RcblxuICAgIGFjdGlvbiA9IGFzeW5jIGZ1bmN0aW9uICogKCkge1xuICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIGJsb2JQYXJ0cykge1xuICAgICAgICBpZiAocGFydC5zdHJlYW0pIHtcbiAgICAgICAgICB5aWVsZCAqIHBhcnQuc3RyZWFtKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5aWVsZCBwYXJ0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgdHlwZSB0byBgbXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9YCxcbiAgICAvLyBmb2xsb3dlZCBieSB0aGUgbXVsdGlwYXJ0L2Zvcm0tZGF0YSBib3VuZGFyeSBzdHJpbmcgZ2VuZXJhdGVkXG4gICAgLy8gYnkgdGhlIG11bHRpcGFydC9mb3JtLWRhdGEgZW5jb2RpbmcgYWxnb3JpdGhtLlxuICAgIHR5cGUgPSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9JyArIGJvdW5kYXJ5XG4gIH0gZWxzZSBpZiAoaXNCbG9iTGlrZShvYmplY3QpKSB7XG4gICAgLy8gQmxvYlxuXG4gICAgLy8gU2V0IHNvdXJjZSB0byBvYmplY3QuXG4gICAgc291cmNlID0gb2JqZWN0XG5cbiAgICAvLyBTZXQgbGVuZ3RoIHRvIG9iamVjdOKAmXMgc2l6ZS5cbiAgICBsZW5ndGggPSBvYmplY3Quc2l6ZVxuXG4gICAgLy8gSWYgb2JqZWN04oCZcyB0eXBlIGF0dHJpYnV0ZSBpcyBub3QgdGhlIGVtcHR5IGJ5dGUgc2VxdWVuY2UsIHNldFxuICAgIC8vIHR5cGUgdG8gaXRzIHZhbHVlLlxuICAgIGlmIChvYmplY3QudHlwZSkge1xuICAgICAgdHlwZSA9IG9iamVjdC50eXBlXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3RbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gSWYga2VlcGFsaXZlIGlzIHRydWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKGtlZXBhbGl2ZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigna2VlcGFsaXZlJylcbiAgICB9XG5cbiAgICAvLyBJZiBvYmplY3QgaXMgZGlzdHVyYmVkIG9yIGxvY2tlZCwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAodXRpbC5pc0Rpc3R1cmJlZChvYmplY3QpIHx8IG9iamVjdC5sb2NrZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdSZXNwb25zZSBib2R5IG9iamVjdCBzaG91bGQgbm90IGJlIGRpc3R1cmJlZCBvciBsb2NrZWQnXG4gICAgICApXG4gICAgfVxuXG4gICAgc3RyZWFtID1cbiAgICAgIG9iamVjdCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtID8gb2JqZWN0IDogUmVhZGFibGVTdHJlYW1Gcm9tKG9iamVjdClcbiAgfVxuXG4gIC8vIDExLiBJZiBzb3VyY2UgaXMgYSBieXRlIHNlcXVlbmNlLCB0aGVuIHNldCBhY3Rpb24gdG8gYVxuICAvLyBzdGVwIHRoYXQgcmV0dXJucyBzb3VyY2UgYW5kIGxlbmd0aCB0byBzb3VyY2XigJlzIGxlbmd0aC5cbiAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnIHx8IHV0aWwuaXNCdWZmZXIoc291cmNlKSkge1xuICAgIGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHNvdXJjZSlcbiAgfVxuXG4gIC8vIDEyLiBJZiBhY3Rpb24gaXMgbm9uLW51bGwsIHRoZW4gcnVuIHRoZXNlIHN0ZXBzIGluIGluIHBhcmFsbGVsOlxuICBpZiAoYWN0aW9uICE9IG51bGwpIHtcbiAgICAvLyBSdW4gYWN0aW9uLlxuICAgIGxldCBpdGVyYXRvclxuICAgIHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBhc3luYyBzdGFydCAoKSB7XG4gICAgICAgIGl0ZXJhdG9yID0gYWN0aW9uKG9iamVjdClbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKClcbiAgICAgIH0sXG4gICAgICBhc3luYyBwdWxsIChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGl0ZXJhdG9yLm5leHQoKVxuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIC8vIFdoZW4gcnVubmluZyBhY3Rpb24gaXMgZG9uZSwgY2xvc2Ugc3RyZWFtLlxuICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gV2hlbmV2ZXIgb25lIG9yIG1vcmUgYnl0ZXMgYXJlIGF2YWlsYWJsZSBhbmQgc3RyZWFtIGlzIG5vdCBlcnJvcmVkLFxuICAgICAgICAgIC8vIGVucXVldWUgYSBVaW50OEFycmF5IHdyYXBwaW5nIGFuIEFycmF5QnVmZmVyIGNvbnRhaW5pbmcgdGhlIGF2YWlsYWJsZVxuICAgICAgICAgIC8vIGJ5dGVzIGludG8gc3RyZWFtLlxuICAgICAgICAgIGlmICghaXNFcnJvcmVkKHN0cmVhbSkpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShuZXcgVWludDhBcnJheSh2YWx1ZSkpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLmRlc2lyZWRTaXplID4gMFxuICAgICAgfSxcbiAgICAgIGFzeW5jIGNhbmNlbCAocmVhc29uKSB7XG4gICAgICAgIGF3YWl0IGl0ZXJhdG9yLnJldHVybigpXG4gICAgICB9LFxuICAgICAgdHlwZTogdW5kZWZpbmVkXG4gICAgfSlcbiAgfVxuXG4gIC8vIDEzLiBMZXQgYm9keSBiZSBhIGJvZHkgd2hvc2Ugc3RyZWFtIGlzIHN0cmVhbSwgc291cmNlIGlzIHNvdXJjZSxcbiAgLy8gYW5kIGxlbmd0aCBpcyBsZW5ndGguXG4gIGNvbnN0IGJvZHkgPSB7IHN0cmVhbSwgc291cmNlLCBsZW5ndGggfVxuXG4gIC8vIDE0LiBSZXR1cm4gKGJvZHksIHR5cGUpLlxuICByZXR1cm4gW2JvZHksIHR5cGVdXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5aW5pdC1zYWZlbHktZXh0cmFjdFxuZnVuY3Rpb24gc2FmZWx5RXh0cmFjdEJvZHkgKG9iamVjdCwga2VlcGFsaXZlID0gZmFsc2UpIHtcbiAgaWYgKCFSZWFkYWJsZVN0cmVhbSkge1xuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgUmVhZGFibGVTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0vd2ViJykuUmVhZGFibGVTdHJlYW1cbiAgfVxuXG4gIC8vIFRvIHNhZmVseSBleHRyYWN0IGEgYm9keSBhbmQgYSBgQ29udGVudC1UeXBlYCB2YWx1ZSBmcm9tXG4gIC8vIGEgYnl0ZSBzZXF1ZW5jZSBvciBCb2R5SW5pdCBvYmplY3Qgb2JqZWN0LCBydW4gdGhlc2Ugc3RlcHM6XG5cbiAgLy8gMS4gSWYgb2JqZWN0IGlzIGEgUmVhZGFibGVTdHJlYW0gb2JqZWN0LCB0aGVuOlxuICBpZiAob2JqZWN0IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICAvLyBBc3NlcnQ6IG9iamVjdCBpcyBuZWl0aGVyIGRpc3R1cmJlZCBub3IgbG9ja2VkLlxuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgYXNzZXJ0KCF1dGlsLmlzRGlzdHVyYmVkKG9iamVjdCksICdUaGUgYm9keSBoYXMgYWxyZWFkeSBiZWVuIGNvbnN1bWVkLicpXG4gICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICBhc3NlcnQoIW9iamVjdC5sb2NrZWQsICdUaGUgc3RyZWFtIGlzIGxvY2tlZC4nKVxuICB9XG5cbiAgLy8gMi4gUmV0dXJuIHRoZSByZXN1bHRzIG9mIGV4dHJhY3Rpbmcgb2JqZWN0LlxuICByZXR1cm4gZXh0cmFjdEJvZHkob2JqZWN0LCBrZWVwYWxpdmUpXG59XG5cbmZ1bmN0aW9uIGNsb25lQm9keSAoYm9keSkge1xuICAvLyBUbyBjbG9uZSBhIGJvZHkgYm9keSwgcnVuIHRoZXNlIHN0ZXBzOlxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHktY2xvbmVcblxuICAvLyAxLiBMZXQgwqsgb3V0MSwgb3V0MiDCuyBiZSB0aGUgcmVzdWx0IG9mIHRlZWluZyBib2R54oCZcyBzdHJlYW0uXG4gIGNvbnN0IFtvdXQxLCBvdXQyXSA9IGJvZHkuc3RyZWFtLnRlZSgpXG4gIGNvbnN0IG91dDJDbG9uZSA9IHN0cnVjdHVyZWRDbG9uZShvdXQyLCB7IHRyYW5zZmVyOiBbb3V0Ml0gfSlcbiAgLy8gVGhpcywgZm9yIHdoYXRldmVyIHJlYXNvbnMsIHVucmVmcyBvdXQyQ2xvbmUgd2hpY2ggYWxsb3dzXG4gIC8vIHRoZSBwcm9jZXNzIHRvIGV4aXQgYnkgaXRzZWxmLlxuICBjb25zdCBbLCBmaW5hbENsb25lXSA9IG91dDJDbG9uZS50ZWUoKVxuXG4gIC8vIDIuIFNldCBib2R54oCZcyBzdHJlYW0gdG8gb3V0MS5cbiAgYm9keS5zdHJlYW0gPSBvdXQxXG5cbiAgLy8gMy4gUmV0dXJuIGEgYm9keSB3aG9zZSBzdHJlYW0gaXMgb3V0MiBhbmQgb3RoZXIgbWVtYmVycyBhcmUgY29waWVkIGZyb20gYm9keS5cbiAgcmV0dXJuIHtcbiAgICBzdHJlYW06IGZpbmFsQ2xvbmUsXG4gICAgbGVuZ3RoOiBib2R5Lmxlbmd0aCxcbiAgICBzb3VyY2U6IGJvZHkuc291cmNlXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gKiBjb25zdW1lQm9keSAoYm9keSkge1xuICBpZiAoYm9keSkge1xuICAgIGlmIChpc1VpbnQ4QXJyYXkoYm9keSkpIHtcbiAgICAgIHlpZWxkIGJvZHlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RyZWFtID0gYm9keS5zdHJlYW1cblxuICAgICAgaWYgKHV0aWwuaXNEaXN0dXJiZWQoc3RyZWFtKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgYm9keSBoYXMgYWxyZWFkeSBiZWVuIGNvbnN1bWVkLicpXG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJlYW0ubG9ja2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBzdHJlYW0gaXMgbG9ja2VkLicpXG4gICAgICB9XG5cbiAgICAgIC8vIENvbXBhdC5cbiAgICAgIHN0cmVhbVtrQm9keVVzZWRdID0gdHJ1ZVxuXG4gICAgICB5aWVsZCAqIHN0cmVhbVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0aHJvd0lmQWJvcnRlZCAoc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLicsICdBYm9ydEVycm9yJylcbiAgfVxufVxuXG5mdW5jdGlvbiBib2R5TWl4aW5NZXRob2RzIChpbnN0YW5jZSkge1xuICBjb25zdCBtZXRob2RzID0ge1xuICAgIGJsb2IgKCkge1xuICAgICAgLy8gVGhlIGJsb2IoKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgcmVzdWx0IG9mXG4gICAgICAvLyBydW5uaW5nIGNvbnN1bWUgYm9keSB3aXRoIHRoaXMgYW5kIHRoZSBmb2xsb3dpbmcgc3RlcFxuICAgICAgLy8gZ2l2ZW4gYSBieXRlIHNlcXVlbmNlIGJ5dGVzOiByZXR1cm4gYSBCbG9iIHdob3NlXG4gICAgICAvLyBjb250ZW50cyBhcmUgYnl0ZXMgYW5kIHdob3NlIHR5cGUgYXR0cmlidXRlIGlzIHRoaXPigJlzXG4gICAgICAvLyBNSU1FIHR5cGUuXG4gICAgICByZXR1cm4gc3BlY0NvbnN1bWVCb2R5KHRoaXMsIChieXRlcykgPT4ge1xuICAgICAgICBsZXQgbWltZVR5cGUgPSBib2R5TWltZVR5cGUodGhpcylcblxuICAgICAgICBpZiAobWltZVR5cGUgPT09ICdmYWlsdXJlJykge1xuICAgICAgICAgIG1pbWVUeXBlID0gJydcbiAgICAgICAgfSBlbHNlIGlmIChtaW1lVHlwZSkge1xuICAgICAgICAgIG1pbWVUeXBlID0gc2VyaWFsaXplQU1pbWVUeXBlKG1pbWVUeXBlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0dXJuIGEgQmxvYiB3aG9zZSBjb250ZW50cyBhcmUgYnl0ZXMgYW5kIHR5cGUgYXR0cmlidXRlXG4gICAgICAgIC8vIGlzIG1pbWVUeXBlLlxuICAgICAgICByZXR1cm4gbmV3IEJsb2IoW2J5dGVzXSwgeyB0eXBlOiBtaW1lVHlwZSB9KVxuICAgICAgfSwgaW5zdGFuY2UpXG4gICAgfSxcblxuICAgIGFycmF5QnVmZmVyICgpIHtcbiAgICAgIC8vIFRoZSBhcnJheUJ1ZmZlcigpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoZSByZXN1bHRcbiAgICAgIC8vIG9mIHJ1bm5pbmcgY29uc3VtZSBib2R5IHdpdGggdGhpcyBhbmQgdGhlIGZvbGxvd2luZyBzdGVwXG4gICAgICAvLyBnaXZlbiBhIGJ5dGUgc2VxdWVuY2UgYnl0ZXM6IHJldHVybiBhIG5ldyBBcnJheUJ1ZmZlclxuICAgICAgLy8gd2hvc2UgY29udGVudHMgYXJlIGJ5dGVzLlxuICAgICAgcmV0dXJuIHNwZWNDb25zdW1lQm9keSh0aGlzLCAoYnl0ZXMpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzKS5idWZmZXJcbiAgICAgIH0sIGluc3RhbmNlKVxuICAgIH0sXG5cbiAgICB0ZXh0ICgpIHtcbiAgICAgIC8vIFRoZSB0ZXh0KCkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgICAvLyBjb25zdW1lIGJvZHkgd2l0aCB0aGlzIGFuZCBVVEYtOCBkZWNvZGUuXG4gICAgICByZXR1cm4gc3BlY0NvbnN1bWVCb2R5KHRoaXMsIHV0ZjhEZWNvZGVCeXRlcywgaW5zdGFuY2UpXG4gICAgfSxcblxuICAgIGpzb24gKCkge1xuICAgICAgLy8gVGhlIGpzb24oKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgIC8vIGNvbnN1bWUgYm9keSB3aXRoIHRoaXMgYW5kIHBhcnNlIEpTT04gZnJvbSBieXRlcy5cbiAgICAgIHJldHVybiBzcGVjQ29uc3VtZUJvZHkodGhpcywgcGFyc2VKU09ORnJvbUJ5dGVzLCBpbnN0YW5jZSlcbiAgICB9LFxuXG4gICAgYXN5bmMgZm9ybURhdGEgKCkge1xuICAgICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgaW5zdGFuY2UpXG5cbiAgICAgIHRocm93SWZBYm9ydGVkKHRoaXNba1N0YXRlXSlcblxuICAgICAgY29uc3QgY29udGVudFR5cGUgPSB0aGlzLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKVxuXG4gICAgICAvLyBJZiBtaW1lVHlwZeKAmXMgZXNzZW5jZSBpcyBcIm11bHRpcGFydC9mb3JtLWRhdGFcIiwgdGhlbjpcbiAgICAgIGlmICgvbXVsdGlwYXJ0XFwvZm9ybS1kYXRhLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge31cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5oZWFkZXJzKSBoZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlXG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2VGb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpXG5cbiAgICAgICAgbGV0IGJ1c2JveVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYnVzYm95ID0gbmV3IEJ1c2JveSh7XG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgcHJlc2VydmVQYXRoOiB0cnVlXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihgJHtlcnJ9YCwgJ0Fib3J0RXJyb3InKVxuICAgICAgICB9XG5cbiAgICAgICAgYnVzYm95Lm9uKCdmaWVsZCcsIChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIHJlc3BvbnNlRm9ybURhdGEuYXBwZW5kKG5hbWUsIHZhbHVlKVxuICAgICAgICB9KVxuICAgICAgICBidXNib3kub24oJ2ZpbGUnLCAobmFtZSwgdmFsdWUsIGZpbGVuYW1lLCBlbmNvZGluZywgbWltZVR5cGUpID0+IHtcbiAgICAgICAgICBjb25zdCBjaHVua3MgPSBbXVxuXG4gICAgICAgICAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0JyB8fCBlbmNvZGluZy50b0xvd2VyQ2FzZSgpID09PSAnYmFzZTY0Jykge1xuICAgICAgICAgICAgbGV0IGJhc2U2NGNodW5rID0gJydcblxuICAgICAgICAgICAgdmFsdWUub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgYmFzZTY0Y2h1bmsgKz0gY2h1bmsudG9TdHJpbmcoKS5yZXBsYWNlKC9bXFxyXFxuXS9nbSwgJycpXG5cbiAgICAgICAgICAgICAgY29uc3QgZW5kID0gYmFzZTY0Y2h1bmsubGVuZ3RoIC0gYmFzZTY0Y2h1bmsubGVuZ3RoICUgNFxuICAgICAgICAgICAgICBjaHVua3MucHVzaChCdWZmZXIuZnJvbShiYXNlNjRjaHVuay5zbGljZSgwLCBlbmQpLCAnYmFzZTY0JykpXG5cbiAgICAgICAgICAgICAgYmFzZTY0Y2h1bmsgPSBiYXNlNjRjaHVuay5zbGljZShlbmQpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgdmFsdWUub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgY2h1bmtzLnB1c2goQnVmZmVyLmZyb20oYmFzZTY0Y2h1bmssICdiYXNlNjQnKSlcbiAgICAgICAgICAgICAgcmVzcG9uc2VGb3JtRGF0YS5hcHBlbmQobmFtZSwgbmV3IEZpbGUoY2h1bmtzLCBmaWxlbmFtZSwgeyB0eXBlOiBtaW1lVHlwZSB9KSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHZhbHVlLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHJlc3BvbnNlRm9ybURhdGEuYXBwZW5kKG5hbWUsIG5ldyBGaWxlKGNodW5rcywgZmlsZW5hbWUsIHsgdHlwZTogbWltZVR5cGUgfSkpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBidXNib3lSZXNvbHZlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGJ1c2JveS5vbignZmluaXNoJywgcmVzb2x2ZSlcbiAgICAgICAgICBidXNib3kub24oJ2Vycm9yJywgKGVycikgPT4gcmVqZWN0KG5ldyBUeXBlRXJyb3IoZXJyKSkpXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKHRoaXMuYm9keSAhPT0gbnVsbCkgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBjb25zdW1lQm9keSh0aGlzW2tTdGF0ZV0uYm9keSkpIGJ1c2JveS53cml0ZShjaHVuaylcbiAgICAgICAgYnVzYm95LmVuZCgpXG4gICAgICAgIGF3YWl0IGJ1c2JveVJlc29sdmVcblxuICAgICAgICByZXR1cm4gcmVzcG9uc2VGb3JtRGF0YVxuICAgICAgfSBlbHNlIGlmICgvYXBwbGljYXRpb25cXC94LXd3dy1mb3JtLXVybGVuY29kZWQvLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgaWYgbWltZVR5cGXigJlzIGVzc2VuY2UgaXMgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiwgdGhlbjpcblxuICAgICAgICAvLyAxLiBMZXQgZW50cmllcyBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgYnl0ZXMuXG4gICAgICAgIGxldCBlbnRyaWVzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IHRleHQgPSAnJ1xuICAgICAgICAgIC8vIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCBwYXJzZXIgd2lsbCBrZWVwIHRoZSBCT00uXG4gICAgICAgICAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXVybGVuY29kZWQtcGFyc2VyXG4gICAgICAgICAgLy8gTm90ZSB0aGF0IHN0cmVhbWluZyBkZWNvZGVyIGlzIHN0YXRlZnVsIGFuZCBjYW5ub3QgYmUgcmV1c2VkXG4gICAgICAgICAgY29uc3Qgc3RyZWFtaW5nRGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnLCB7IGlnbm9yZUJPTTogdHJ1ZSB9KVxuXG4gICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBjb25zdW1lQm9keSh0aGlzW2tTdGF0ZV0uYm9keSkpIHtcbiAgICAgICAgICAgIGlmICghaXNVaW50OEFycmF5KGNodW5rKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5IGNodW5rJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHQgKz0gc3RyZWFtaW5nRGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pXG4gICAgICAgICAgfVxuICAgICAgICAgIHRleHQgKz0gc3RyZWFtaW5nRGVjb2Rlci5kZWNvZGUoKVxuICAgICAgICAgIGVudHJpZXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHRleHQpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBVbmNsZWFyIHdoZW4gbmV3IFVSTFNlYXJjaFBhcmFtcyBjYW4gZmFpbCBvbiBhIHN0cmluZy5cbiAgICAgICAgICAvLyAyLiBJZiBlbnRyaWVzIGlzIGZhaWx1cmUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgVHlwZUVycm9yKCksIHsgY2F1c2U6IGVyciB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gUmV0dXJuIGEgbmV3IEZvcm1EYXRhIG9iamVjdCB3aG9zZSBlbnRyaWVzIGFyZSBlbnRyaWVzLlxuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpXG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgZm9ybURhdGEuYXBwZW5kKG5hbWUsIHZhbHVlKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtRGF0YVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2FpdCBhIHRpY2sgYmVmb3JlIGNoZWNraW5nIGlmIHRoZSByZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWQuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgYSBUeXBlRXJyb3IgY2FuIGJlIHRocm93biB3aGVuIGFuIEFib3J0RXJyb3Igc2hvdWxkLlxuICAgICAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKVxuXG4gICAgICAgIHRocm93SWZBYm9ydGVkKHRoaXNba1N0YXRlXSlcblxuICAgICAgICAvLyBPdGhlcndpc2UsIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgaGVhZGVyOiBgJHtpbnN0YW5jZS5uYW1lfS5mb3JtRGF0YWAsXG4gICAgICAgICAgbWVzc2FnZTogJ0NvdWxkIG5vdCBwYXJzZSBjb250ZW50IGFzIEZvcm1EYXRhLidcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWV0aG9kc1xufVxuXG5mdW5jdGlvbiBtaXhpbkJvZHkgKHByb3RvdHlwZSkge1xuICBPYmplY3QuYXNzaWduKHByb3RvdHlwZS5wcm90b3R5cGUsIGJvZHlNaXhpbk1ldGhvZHMocHJvdG90eXBlKSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHktY29uc3VtZS1ib2R5XG4gKiBAcGFyYW0ge1Jlc3BvbnNlfFJlcXVlc3R9IG9iamVjdFxuICogQHBhcmFtIHsodmFsdWU6IHVua25vd24pID0+IHVua25vd259IGNvbnZlcnRCeXRlc1RvSlNWYWx1ZVxuICogQHBhcmFtIHtSZXNwb25zZXxSZXF1ZXN0fSBpbnN0YW5jZVxuICovXG5hc3luYyBmdW5jdGlvbiBzcGVjQ29uc3VtZUJvZHkgKG9iamVjdCwgY29udmVydEJ5dGVzVG9KU1ZhbHVlLCBpbnN0YW5jZSkge1xuICB3ZWJpZGwuYnJhbmRDaGVjayhvYmplY3QsIGluc3RhbmNlKVxuXG4gIHRocm93SWZBYm9ydGVkKG9iamVjdFtrU3RhdGVdKVxuXG4gIC8vIDEuIElmIG9iamVjdCBpcyB1bnVzYWJsZSwgdGhlbiByZXR1cm4gYSBwcm9taXNlIHJlamVjdGVkXG4gIC8vICAgIHdpdGggYSBUeXBlRXJyb3IuXG4gIGlmIChib2R5VW51c2FibGUob2JqZWN0W2tTdGF0ZV0uYm9keSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IGlzIHVudXNhYmxlJylcbiAgfVxuXG4gIC8vIDIuIExldCBwcm9taXNlIGJlIGEgbmV3IHByb21pc2UuXG4gIGNvbnN0IHByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gIC8vIDMuIExldCBlcnJvclN0ZXBzIGdpdmVuIGVycm9yIGJlIHRvIHJlamVjdCBwcm9taXNlIHdpdGggZXJyb3IuXG4gIGNvbnN0IGVycm9yU3RlcHMgPSAoZXJyb3IpID0+IHByb21pc2UucmVqZWN0KGVycm9yKVxuXG4gIC8vIDQuIExldCBzdWNjZXNzU3RlcHMgZ2l2ZW4gYSBieXRlIHNlcXVlbmNlIGRhdGEgYmUgdG8gcmVzb2x2ZVxuICAvLyAgICBwcm9taXNlIHdpdGggdGhlIHJlc3VsdCBvZiBydW5uaW5nIGNvbnZlcnRCeXRlc1RvSlNWYWx1ZVxuICAvLyAgICB3aXRoIGRhdGEuIElmIHRoYXQgdGhyZXcgYW4gZXhjZXB0aW9uLCB0aGVuIHJ1biBlcnJvclN0ZXBzXG4gIC8vICAgIHdpdGggdGhhdCBleGNlcHRpb24uXG4gIGNvbnN0IHN1Y2Nlc3NTdGVwcyA9IChkYXRhKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHByb21pc2UucmVzb2x2ZShjb252ZXJ0Qnl0ZXNUb0pTVmFsdWUoZGF0YSkpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3JTdGVwcyhlKVxuICAgIH1cbiAgfVxuXG4gIC8vIDUuIElmIG9iamVjdOKAmXMgYm9keSBpcyBudWxsLCB0aGVuIHJ1biBzdWNjZXNzU3RlcHMgd2l0aCBhblxuICAvLyAgICBlbXB0eSBieXRlIHNlcXVlbmNlLlxuICBpZiAob2JqZWN0W2tTdGF0ZV0uYm9keSA9PSBudWxsKSB7XG4gICAgc3VjY2Vzc1N0ZXBzKG5ldyBVaW50OEFycmF5KCkpXG4gICAgcmV0dXJuIHByb21pc2UucHJvbWlzZVxuICB9XG5cbiAgLy8gNi4gT3RoZXJ3aXNlLCBmdWxseSByZWFkIG9iamVjdOKAmXMgYm9keSBnaXZlbiBzdWNjZXNzU3RlcHMsXG4gIC8vICAgIGVycm9yU3RlcHMsIGFuZCBvYmplY3TigJlzIHJlbGV2YW50IGdsb2JhbCBvYmplY3QuXG4gIGF3YWl0IGZ1bGx5UmVhZEJvZHkob2JqZWN0W2tTdGF0ZV0uYm9keSwgc3VjY2Vzc1N0ZXBzLCBlcnJvclN0ZXBzKVxuXG4gIC8vIDcuIFJldHVybiBwcm9taXNlLlxuICByZXR1cm4gcHJvbWlzZS5wcm9taXNlXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5LXVudXNhYmxlXG5mdW5jdGlvbiBib2R5VW51c2FibGUgKGJvZHkpIHtcbiAgLy8gQW4gb2JqZWN0IGluY2x1ZGluZyB0aGUgQm9keSBpbnRlcmZhY2UgbWl4aW4gaXNcbiAgLy8gc2FpZCB0byBiZSB1bnVzYWJsZSBpZiBpdHMgYm9keSBpcyBub24tbnVsbCBhbmRcbiAgLy8gaXRzIGJvZHnigJlzIHN0cmVhbSBpcyBkaXN0dXJiZWQgb3IgbG9ja2VkLlxuICByZXR1cm4gYm9keSAhPSBudWxsICYmIChib2R5LnN0cmVhbS5sb2NrZWQgfHwgdXRpbC5pc0Rpc3R1cmJlZChib2R5LnN0cmVhbSkpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2VuY29kaW5nLnNwZWMud2hhdHdnLm9yZy8jdXRmLTgtZGVjb2RlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyXG4gKi9cbmZ1bmN0aW9uIHV0ZjhEZWNvZGVCeXRlcyAoYnVmZmVyKSB7XG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyAxLiBMZXQgYnVmZmVyIGJlIHRoZSByZXN1bHQgb2YgcGVla2luZyB0aHJlZSBieXRlcyBmcm9tXG4gIC8vICAgIGlvUXVldWUsIGNvbnZlcnRlZCB0byBhIGJ5dGUgc2VxdWVuY2UuXG5cbiAgLy8gMi4gSWYgYnVmZmVyIGlzIDB4RUYgMHhCQiAweEJGLCB0aGVuIHJlYWQgdGhyZWVcbiAgLy8gICAgYnl0ZXMgZnJvbSBpb1F1ZXVlLiAoRG8gbm90aGluZyB3aXRoIHRob3NlIGJ5dGVzLilcbiAgaWYgKGJ1ZmZlclswXSA9PT0gMHhFRiAmJiBidWZmZXJbMV0gPT09IDB4QkIgJiYgYnVmZmVyWzJdID09PSAweEJGKSB7XG4gICAgYnVmZmVyID0gYnVmZmVyLnN1YmFycmF5KDMpXG4gIH1cblxuICAvLyAzLiBQcm9jZXNzIGEgcXVldWUgd2l0aCBhbiBpbnN0YW5jZSBvZiBVVEYtOOKAmXNcbiAgLy8gICAgZGVjb2RlciwgaW9RdWV1ZSwgb3V0cHV0LCBhbmQgXCJyZXBsYWNlbWVudFwiLlxuICBjb25zdCBvdXRwdXQgPSB0ZXh0RGVjb2Rlci5kZWNvZGUoYnVmZmVyKVxuXG4gIC8vIDQuIFJldHVybiBvdXRwdXQuXG4gIHJldHVybiBvdXRwdXRcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNwYXJzZS1qc29uLWJ5dGVzLXRvLWEtamF2YXNjcmlwdC12YWx1ZVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICovXG5mdW5jdGlvbiBwYXJzZUpTT05Gcm9tQnl0ZXMgKGJ5dGVzKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKHV0ZjhEZWNvZGVCeXRlcyhieXRlcykpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ib2R5LW1pbWUtdHlwZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vcmVzcG9uc2UnKS5SZXNwb25zZXxpbXBvcnQoJy4vcmVxdWVzdCcpLlJlcXVlc3R9IG9iamVjdFxuICovXG5mdW5jdGlvbiBib2R5TWltZVR5cGUgKG9iamVjdCkge1xuICBjb25zdCB7IGhlYWRlcnNMaXN0IH0gPSBvYmplY3Rba1N0YXRlXVxuICBjb25zdCBjb250ZW50VHlwZSA9IGhlYWRlcnNMaXN0LmdldCgnY29udGVudC10eXBlJylcblxuICBpZiAoY29udGVudFR5cGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICByZXR1cm4gcGFyc2VNSU1FVHlwZShjb250ZW50VHlwZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGV4dHJhY3RCb2R5LFxuICBzYWZlbHlFeHRyYWN0Qm9keSxcbiAgY2xvbmVCb2R5LFxuICBtaXhpbkJvZHlcbn1cbiJdLCJuYW1lcyI6WyJCdXNib3kiLCJyZXF1aXJlIiwidXRpbCIsIlJlYWRhYmxlU3RyZWFtRnJvbSIsImlzQmxvYkxpa2UiLCJpc1JlYWRhYmxlU3RyZWFtTGlrZSIsInJlYWRhYmxlU3RyZWFtQ2xvc2UiLCJjcmVhdGVEZWZlcnJlZFByb21pc2UiLCJmdWxseVJlYWRCb2R5IiwiRm9ybURhdGEiLCJrU3RhdGUiLCJ3ZWJpZGwiLCJET01FeGNlcHRpb24iLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJCbG9iIiwiRmlsZSIsIk5hdGl2ZUZpbGUiLCJrQm9keVVzZWQiLCJhc3NlcnQiLCJpc0Vycm9yZWQiLCJpc1VpbnQ4QXJyYXkiLCJpc0FycmF5QnVmZmVyIiwiVW5kaWNpRmlsZSIsInBhcnNlTUlNRVR5cGUiLCJzZXJpYWxpemVBTWltZVR5cGUiLCJSZWFkYWJsZVN0cmVhbSIsImdsb2JhbFRoaXMiLCJ0ZXh0RW5jb2RlciIsIlRleHRFbmNvZGVyIiwidGV4dERlY29kZXIiLCJUZXh0RGVjb2RlciIsImV4dHJhY3RCb2R5Iiwib2JqZWN0Iiwia2VlcGFsaXZlIiwic3RyZWFtIiwicHVsbCIsImNvbnRyb2xsZXIiLCJlbnF1ZXVlIiwic291cmNlIiwiZW5jb2RlIiwicXVldWVNaWNyb3Rhc2siLCJzdGFydCIsInR5cGUiLCJ1bmRlZmluZWQiLCJhY3Rpb24iLCJsZW5ndGgiLCJVUkxTZWFyY2hQYXJhbXMiLCJ0b1N0cmluZyIsIlVpbnQ4QXJyYXkiLCJzbGljZSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJpc0Zvcm1EYXRhTGlrZSIsImJvdW5kYXJ5IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwicGFkU3RhcnQiLCJwcmVmaXgiLCJlc2NhcGUiLCJzdHIiLCJyZXBsYWNlIiwibm9ybWFsaXplTGluZWZlZWRzIiwidmFsdWUiLCJibG9iUGFydHMiLCJybiIsImhhc1Vua25vd25TaXplVmFsdWUiLCJuYW1lIiwiY2h1bmsiLCJwdXNoIiwic2l6ZSIsInBhcnQiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwiVHlwZUVycm9yIiwiaXNEaXN0dXJiZWQiLCJsb2NrZWQiLCJpc0J1ZmZlciIsIkJ1ZmZlciIsIml0ZXJhdG9yIiwiZG9uZSIsIm5leHQiLCJjbG9zZSIsImRlc2lyZWRTaXplIiwiY2FuY2VsIiwicmVhc29uIiwicmV0dXJuIiwiYm9keSIsInNhZmVseUV4dHJhY3RCb2R5IiwiY2xvbmVCb2R5Iiwib3V0MSIsIm91dDIiLCJ0ZWUiLCJvdXQyQ2xvbmUiLCJ0cmFuc2ZlciIsImZpbmFsQ2xvbmUiLCJjb25zdW1lQm9keSIsInRocm93SWZBYm9ydGVkIiwic3RhdGUiLCJhYm9ydGVkIiwiYm9keU1peGluTWV0aG9kcyIsImluc3RhbmNlIiwibWV0aG9kcyIsImJsb2IiLCJzcGVjQ29uc3VtZUJvZHkiLCJieXRlcyIsIm1pbWVUeXBlIiwiYm9keU1pbWVUeXBlIiwiYXJyYXlCdWZmZXIiLCJ0ZXh0IiwidXRmOERlY29kZUJ5dGVzIiwianNvbiIsInBhcnNlSlNPTkZyb21CeXRlcyIsImZvcm1EYXRhIiwiYnJhbmRDaGVjayIsImNvbnRlbnRUeXBlIiwiaGVhZGVycyIsImdldCIsInRlc3QiLCJrZXkiLCJ0b0xvd2VyQ2FzZSIsInJlc3BvbnNlRm9ybURhdGEiLCJidXNib3kiLCJwcmVzZXJ2ZVBhdGgiLCJlcnIiLCJvbiIsImFwcGVuZCIsImZpbGVuYW1lIiwiZW5jb2RpbmciLCJjaHVua3MiLCJiYXNlNjRjaHVuayIsImVuZCIsImZyb20iLCJidXNib3lSZXNvbHZlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ3cml0ZSIsImVudHJpZXMiLCJzdHJlYW1pbmdEZWNvZGVyIiwiaWdub3JlQk9NIiwiZGVjb2RlIiwiT2JqZWN0IiwiYXNzaWduIiwiY2F1c2UiLCJlcnJvcnMiLCJleGNlcHRpb24iLCJoZWFkZXIiLCJtZXNzYWdlIiwibWl4aW5Cb2R5IiwicHJvdG90eXBlIiwiY29udmVydEJ5dGVzVG9KU1ZhbHVlIiwiYm9keVVudXNhYmxlIiwicHJvbWlzZSIsImVycm9yU3RlcHMiLCJlcnJvciIsInN1Y2Nlc3NTdGVwcyIsImRhdGEiLCJlIiwic3ViYXJyYXkiLCJvdXRwdXQiLCJKU09OIiwicGFyc2UiLCJoZWFkZXJzTGlzdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/body.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/constants.js":
/*!**************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/fetch/constants.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { MessageChannel, receiveMessageOnPort } = __webpack_require__(/*! worker_threads */ \"worker_threads\");\nconst corsSafeListedMethods = [\n    \"GET\",\n    \"HEAD\",\n    \"POST\"\n];\nconst corsSafeListedMethodsSet = new Set(corsSafeListedMethods);\nconst nullBodyStatus = [\n    101,\n    204,\n    205,\n    304\n];\nconst redirectStatus = [\n    301,\n    302,\n    303,\n    307,\n    308\n];\nconst redirectStatusSet = new Set(redirectStatus);\n// https://fetch.spec.whatwg.org/#block-bad-port\nconst badPorts = [\n    \"1\",\n    \"7\",\n    \"9\",\n    \"11\",\n    \"13\",\n    \"15\",\n    \"17\",\n    \"19\",\n    \"20\",\n    \"21\",\n    \"22\",\n    \"23\",\n    \"25\",\n    \"37\",\n    \"42\",\n    \"43\",\n    \"53\",\n    \"69\",\n    \"77\",\n    \"79\",\n    \"87\",\n    \"95\",\n    \"101\",\n    \"102\",\n    \"103\",\n    \"104\",\n    \"109\",\n    \"110\",\n    \"111\",\n    \"113\",\n    \"115\",\n    \"117\",\n    \"119\",\n    \"123\",\n    \"135\",\n    \"137\",\n    \"139\",\n    \"143\",\n    \"161\",\n    \"179\",\n    \"389\",\n    \"427\",\n    \"465\",\n    \"512\",\n    \"513\",\n    \"514\",\n    \"515\",\n    \"526\",\n    \"530\",\n    \"531\",\n    \"532\",\n    \"540\",\n    \"548\",\n    \"554\",\n    \"556\",\n    \"563\",\n    \"587\",\n    \"601\",\n    \"636\",\n    \"989\",\n    \"990\",\n    \"993\",\n    \"995\",\n    \"1719\",\n    \"1720\",\n    \"1723\",\n    \"2049\",\n    \"3659\",\n    \"4045\",\n    \"5060\",\n    \"5061\",\n    \"6000\",\n    \"6566\",\n    \"6665\",\n    \"6666\",\n    \"6667\",\n    \"6668\",\n    \"6669\",\n    \"6697\",\n    \"10080\"\n];\nconst badPortsSet = new Set(badPorts);\n// https://w3c.github.io/webappsec-referrer-policy/#referrer-policies\nconst referrerPolicy = [\n    \"\",\n    \"no-referrer\",\n    \"no-referrer-when-downgrade\",\n    \"same-origin\",\n    \"origin\",\n    \"strict-origin\",\n    \"origin-when-cross-origin\",\n    \"strict-origin-when-cross-origin\",\n    \"unsafe-url\"\n];\nconst referrerPolicySet = new Set(referrerPolicy);\nconst requestRedirect = [\n    \"follow\",\n    \"manual\",\n    \"error\"\n];\nconst safeMethods = [\n    \"GET\",\n    \"HEAD\",\n    \"OPTIONS\",\n    \"TRACE\"\n];\nconst safeMethodsSet = new Set(safeMethods);\nconst requestMode = [\n    \"navigate\",\n    \"same-origin\",\n    \"no-cors\",\n    \"cors\"\n];\nconst requestCredentials = [\n    \"omit\",\n    \"same-origin\",\n    \"include\"\n];\nconst requestCache = [\n    \"default\",\n    \"no-store\",\n    \"reload\",\n    \"no-cache\",\n    \"force-cache\",\n    \"only-if-cached\"\n];\n// https://fetch.spec.whatwg.org/#request-body-header-name\nconst requestBodyHeader = [\n    \"content-encoding\",\n    \"content-language\",\n    \"content-location\",\n    \"content-type\",\n    // See https://github.com/nodejs/undici/issues/2021\n    // 'Content-Length' is a forbidden header name, which is typically\n    // removed in the Headers implementation. However, undici doesn't\n    // filter out headers, so we add it here.\n    \"content-length\"\n];\n// https://fetch.spec.whatwg.org/#enumdef-requestduplex\nconst requestDuplex = [\n    \"half\"\n];\n// http://fetch.spec.whatwg.org/#forbidden-method\nconst forbiddenMethods = [\n    \"CONNECT\",\n    \"TRACE\",\n    \"TRACK\"\n];\nconst forbiddenMethodsSet = new Set(forbiddenMethods);\nconst subresource = [\n    \"audio\",\n    \"audioworklet\",\n    \"font\",\n    \"image\",\n    \"manifest\",\n    \"paintworklet\",\n    \"script\",\n    \"style\",\n    \"track\",\n    \"video\",\n    \"xslt\",\n    \"\"\n];\nconst subresourceSet = new Set(subresource);\n/** @type {globalThis['DOMException']} */ const DOMException = globalThis.DOMException ?? (()=>{\n    // DOMException was only made a global in Node v17.0.0,\n    // but fetch supports >= v16.8.\n    try {\n        atob(\"~\");\n    } catch (err) {\n        return Object.getPrototypeOf(err).constructor;\n    }\n})();\nlet channel;\n/** @type {globalThis['structuredClone']} */ const structuredClone = globalThis.structuredClone ?? // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js\n// structuredClone was added in v17.0.0, but fetch supports v16.8\nfunction structuredClone(value, options = undefined) {\n    if (arguments.length === 0) {\n        throw new TypeError(\"missing argument\");\n    }\n    if (!channel) {\n        channel = new MessageChannel();\n    }\n    channel.port1.unref();\n    channel.port2.unref();\n    channel.port1.postMessage(value, options?.transfer);\n    return receiveMessageOnPort(channel.port2).message;\n};\nmodule.exports = {\n    DOMException,\n    structuredClone,\n    subresource,\n    forbiddenMethods,\n    requestBodyHeader,\n    referrerPolicy,\n    requestRedirect,\n    requestMode,\n    requestCredentials,\n    requestCache,\n    redirectStatus,\n    corsSafeListedMethods,\n    nullBodyStatus,\n    safeMethods,\n    badPorts,\n    requestDuplex,\n    subresourceSet,\n    badPortsSet,\n    redirectStatusSet,\n    corsSafeListedMethodsSet,\n    safeMethodsSet,\n    forbiddenMethodsSet,\n    referrerPolicySet\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxjQUFjLEVBQUVDLG9CQUFvQixFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBRXpELE1BQU1DLHdCQUF3QjtJQUFDO0lBQU87SUFBUTtDQUFPO0FBQ3JELE1BQU1DLDJCQUEyQixJQUFJQyxJQUFJRjtBQUV6QyxNQUFNRyxpQkFBaUI7SUFBQztJQUFLO0lBQUs7SUFBSztDQUFJO0FBRTNDLE1BQU1DLGlCQUFpQjtJQUFDO0lBQUs7SUFBSztJQUFLO0lBQUs7Q0FBSTtBQUNoRCxNQUFNQyxvQkFBb0IsSUFBSUgsSUFBSUU7QUFFbEMsZ0RBQWdEO0FBQ2hELE1BQU1FLFdBQVc7SUFDZjtJQUFLO0lBQUs7SUFBSztJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQy9HO0lBQU07SUFBTTtJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQ3ZHO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUNsRztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFRO0lBQVE7SUFDcEc7SUFBUTtJQUFRO0lBQVE7SUFBUTtJQUFRO0lBQVE7SUFBUTtJQUFRO0lBQVE7SUFBUTtJQUFRO0lBQVE7SUFDaEc7Q0FDRDtBQUVELE1BQU1DLGNBQWMsSUFBSUwsSUFBSUk7QUFFNUIscUVBQXFFO0FBQ3JFLE1BQU1FLGlCQUFpQjtJQUNyQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUNELE1BQU1DLG9CQUFvQixJQUFJUCxJQUFJTTtBQUVsQyxNQUFNRSxrQkFBa0I7SUFBQztJQUFVO0lBQVU7Q0FBUTtBQUVyRCxNQUFNQyxjQUFjO0lBQUM7SUFBTztJQUFRO0lBQVc7Q0FBUTtBQUN2RCxNQUFNQyxpQkFBaUIsSUFBSVYsSUFBSVM7QUFFL0IsTUFBTUUsY0FBYztJQUFDO0lBQVk7SUFBZTtJQUFXO0NBQU87QUFFbEUsTUFBTUMscUJBQXFCO0lBQUM7SUFBUTtJQUFlO0NBQVU7QUFFN0QsTUFBTUMsZUFBZTtJQUNuQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUVELDBEQUEwRDtBQUMxRCxNQUFNQyxvQkFBb0I7SUFDeEI7SUFDQTtJQUNBO0lBQ0E7SUFDQSxtREFBbUQ7SUFDbkQsa0VBQWtFO0lBQ2xFLGlFQUFpRTtJQUNqRSx5Q0FBeUM7SUFDekM7Q0FDRDtBQUVELHVEQUF1RDtBQUN2RCxNQUFNQyxnQkFBZ0I7SUFDcEI7Q0FDRDtBQUVELGlEQUFpRDtBQUNqRCxNQUFNQyxtQkFBbUI7SUFBQztJQUFXO0lBQVM7Q0FBUTtBQUN0RCxNQUFNQyxzQkFBc0IsSUFBSWpCLElBQUlnQjtBQUVwQyxNQUFNRSxjQUFjO0lBQ2xCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBQ0QsTUFBTUMsaUJBQWlCLElBQUluQixJQUFJa0I7QUFFL0IsdUNBQXVDLEdBQ3ZDLE1BQU1FLGVBQWVDLFdBQVdELFlBQVksSUFBSSxDQUFDO0lBQy9DLHVEQUF1RDtJQUN2RCwrQkFBK0I7SUFDL0IsSUFBSTtRQUNGRSxLQUFLO0lBQ1AsRUFBRSxPQUFPQyxLQUFLO1FBQ1osT0FBT0MsT0FBT0MsY0FBYyxDQUFDRixLQUFLRyxXQUFXO0lBQy9DO0FBQ0Y7QUFFQSxJQUFJQztBQUVKLDBDQUEwQyxHQUMxQyxNQUFNQyxrQkFDSlAsV0FBV08sZUFBZSxJQUMxQixnSEFBZ0g7QUFDaEgsaUVBQWlFO0FBQ2pFLFNBQVNBLGdCQUFpQkMsS0FBSyxFQUFFQyxVQUFVQyxTQUFTO0lBQ2xELElBQUlDLFVBQVVDLE1BQU0sS0FBSyxHQUFHO1FBQzFCLE1BQU0sSUFBSUMsVUFBVTtJQUN0QjtJQUVBLElBQUksQ0FBQ1AsU0FBUztRQUNaQSxVQUFVLElBQUloQztJQUNoQjtJQUNBZ0MsUUFBUVEsS0FBSyxDQUFDQyxLQUFLO0lBQ25CVCxRQUFRVSxLQUFLLENBQUNELEtBQUs7SUFDbkJULFFBQVFRLEtBQUssQ0FBQ0csV0FBVyxDQUFDVCxPQUFPQyxTQUFTUztJQUMxQyxPQUFPM0MscUJBQXFCK0IsUUFBUVUsS0FBSyxFQUFFRyxPQUFPO0FBQ3BEO0FBRUZDLE9BQU9DLE9BQU8sR0FBRztJQUNmdEI7SUFDQVE7SUFDQVY7SUFDQUY7SUFDQUY7SUFDQVI7SUFDQUU7SUFDQUc7SUFDQUM7SUFDQUM7SUFDQVg7SUFDQUo7SUFDQUc7SUFDQVE7SUFDQUw7SUFDQVc7SUFDQUk7SUFDQWQ7SUFDQUY7SUFDQUo7SUFDQVc7SUFDQU87SUFDQVY7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL2NvbnN0YW50cy5qcz8xODc5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IE1lc3NhZ2VDaGFubmVsLCByZWNlaXZlTWVzc2FnZU9uUG9ydCB9ID0gcmVxdWlyZSgnd29ya2VyX3RocmVhZHMnKVxuXG5jb25zdCBjb3JzU2FmZUxpc3RlZE1ldGhvZHMgPSBbJ0dFVCcsICdIRUFEJywgJ1BPU1QnXVxuY29uc3QgY29yc1NhZmVMaXN0ZWRNZXRob2RzU2V0ID0gbmV3IFNldChjb3JzU2FmZUxpc3RlZE1ldGhvZHMpXG5cbmNvbnN0IG51bGxCb2R5U3RhdHVzID0gWzEwMSwgMjA0LCAyMDUsIDMwNF1cblxuY29uc3QgcmVkaXJlY3RTdGF0dXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5jb25zdCByZWRpcmVjdFN0YXR1c1NldCA9IG5ldyBTZXQocmVkaXJlY3RTdGF0dXMpXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNibG9jay1iYWQtcG9ydFxuY29uc3QgYmFkUG9ydHMgPSBbXG4gICcxJywgJzcnLCAnOScsICcxMScsICcxMycsICcxNScsICcxNycsICcxOScsICcyMCcsICcyMScsICcyMicsICcyMycsICcyNScsICczNycsICc0MicsICc0MycsICc1MycsICc2OScsICc3NycsICc3OScsXG4gICc4NycsICc5NScsICcxMDEnLCAnMTAyJywgJzEwMycsICcxMDQnLCAnMTA5JywgJzExMCcsICcxMTEnLCAnMTEzJywgJzExNScsICcxMTcnLCAnMTE5JywgJzEyMycsICcxMzUnLCAnMTM3JyxcbiAgJzEzOScsICcxNDMnLCAnMTYxJywgJzE3OScsICczODknLCAnNDI3JywgJzQ2NScsICc1MTInLCAnNTEzJywgJzUxNCcsICc1MTUnLCAnNTI2JywgJzUzMCcsICc1MzEnLCAnNTMyJyxcbiAgJzU0MCcsICc1NDgnLCAnNTU0JywgJzU1NicsICc1NjMnLCAnNTg3JywgJzYwMScsICc2MzYnLCAnOTg5JywgJzk5MCcsICc5OTMnLCAnOTk1JywgJzE3MTknLCAnMTcyMCcsICcxNzIzJyxcbiAgJzIwNDknLCAnMzY1OScsICc0MDQ1JywgJzUwNjAnLCAnNTA2MScsICc2MDAwJywgJzY1NjYnLCAnNjY2NScsICc2NjY2JywgJzY2NjcnLCAnNjY2OCcsICc2NjY5JywgJzY2OTcnLFxuICAnMTAwODAnXG5dXG5cbmNvbnN0IGJhZFBvcnRzU2V0ID0gbmV3IFNldChiYWRQb3J0cylcblxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI3JlZmVycmVyLXBvbGljaWVzXG5jb25zdCByZWZlcnJlclBvbGljeSA9IFtcbiAgJycsXG4gICduby1yZWZlcnJlcicsXG4gICduby1yZWZlcnJlci13aGVuLWRvd25ncmFkZScsXG4gICdzYW1lLW9yaWdpbicsXG4gICdvcmlnaW4nLFxuICAnc3RyaWN0LW9yaWdpbicsXG4gICdvcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nLFxuICAnc3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpbicsXG4gICd1bnNhZmUtdXJsJ1xuXVxuY29uc3QgcmVmZXJyZXJQb2xpY3lTZXQgPSBuZXcgU2V0KHJlZmVycmVyUG9saWN5KVxuXG5jb25zdCByZXF1ZXN0UmVkaXJlY3QgPSBbJ2ZvbGxvdycsICdtYW51YWwnLCAnZXJyb3InXVxuXG5jb25zdCBzYWZlTWV0aG9kcyA9IFsnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdUUkFDRSddXG5jb25zdCBzYWZlTWV0aG9kc1NldCA9IG5ldyBTZXQoc2FmZU1ldGhvZHMpXG5cbmNvbnN0IHJlcXVlc3RNb2RlID0gWyduYXZpZ2F0ZScsICdzYW1lLW9yaWdpbicsICduby1jb3JzJywgJ2NvcnMnXVxuXG5jb25zdCByZXF1ZXN0Q3JlZGVudGlhbHMgPSBbJ29taXQnLCAnc2FtZS1vcmlnaW4nLCAnaW5jbHVkZSddXG5cbmNvbnN0IHJlcXVlc3RDYWNoZSA9IFtcbiAgJ2RlZmF1bHQnLFxuICAnbm8tc3RvcmUnLFxuICAncmVsb2FkJyxcbiAgJ25vLWNhY2hlJyxcbiAgJ2ZvcmNlLWNhY2hlJyxcbiAgJ29ubHktaWYtY2FjaGVkJ1xuXVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdC1ib2R5LWhlYWRlci1uYW1lXG5jb25zdCByZXF1ZXN0Qm9keUhlYWRlciA9IFtcbiAgJ2NvbnRlbnQtZW5jb2RpbmcnLFxuICAnY29udGVudC1sYW5ndWFnZScsXG4gICdjb250ZW50LWxvY2F0aW9uJyxcbiAgJ2NvbnRlbnQtdHlwZScsXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMjAyMVxuICAvLyAnQ29udGVudC1MZW5ndGgnIGlzIGEgZm9yYmlkZGVuIGhlYWRlciBuYW1lLCB3aGljaCBpcyB0eXBpY2FsbHlcbiAgLy8gcmVtb3ZlZCBpbiB0aGUgSGVhZGVycyBpbXBsZW1lbnRhdGlvbi4gSG93ZXZlciwgdW5kaWNpIGRvZXNuJ3RcbiAgLy8gZmlsdGVyIG91dCBoZWFkZXJzLCBzbyB3ZSBhZGQgaXQgaGVyZS5cbiAgJ2NvbnRlbnQtbGVuZ3RoJ1xuXVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZW51bWRlZi1yZXF1ZXN0ZHVwbGV4XG5jb25zdCByZXF1ZXN0RHVwbGV4ID0gW1xuICAnaGFsZidcbl1cblxuLy8gaHR0cDovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZm9yYmlkZGVuLW1ldGhvZFxuY29uc3QgZm9yYmlkZGVuTWV0aG9kcyA9IFsnQ09OTkVDVCcsICdUUkFDRScsICdUUkFDSyddXG5jb25zdCBmb3JiaWRkZW5NZXRob2RzU2V0ID0gbmV3IFNldChmb3JiaWRkZW5NZXRob2RzKVxuXG5jb25zdCBzdWJyZXNvdXJjZSA9IFtcbiAgJ2F1ZGlvJyxcbiAgJ2F1ZGlvd29ya2xldCcsXG4gICdmb250JyxcbiAgJ2ltYWdlJyxcbiAgJ21hbmlmZXN0JyxcbiAgJ3BhaW50d29ya2xldCcsXG4gICdzY3JpcHQnLFxuICAnc3R5bGUnLFxuICAndHJhY2snLFxuICAndmlkZW8nLFxuICAneHNsdCcsXG4gICcnXG5dXG5jb25zdCBzdWJyZXNvdXJjZVNldCA9IG5ldyBTZXQoc3VicmVzb3VyY2UpXG5cbi8qKiBAdHlwZSB7Z2xvYmFsVGhpc1snRE9NRXhjZXB0aW9uJ119ICovXG5jb25zdCBET01FeGNlcHRpb24gPSBnbG9iYWxUaGlzLkRPTUV4Y2VwdGlvbiA/PyAoKCkgPT4ge1xuICAvLyBET01FeGNlcHRpb24gd2FzIG9ubHkgbWFkZSBhIGdsb2JhbCBpbiBOb2RlIHYxNy4wLjAsXG4gIC8vIGJ1dCBmZXRjaCBzdXBwb3J0cyA+PSB2MTYuOC5cbiAgdHJ5IHtcbiAgICBhdG9iKCd+JylcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihlcnIpLmNvbnN0cnVjdG9yXG4gIH1cbn0pKClcblxubGV0IGNoYW5uZWxcblxuLyoqIEB0eXBlIHtnbG9iYWxUaGlzWydzdHJ1Y3R1cmVkQ2xvbmUnXX0gKi9cbmNvbnN0IHN0cnVjdHVyZWRDbG9uZSA9XG4gIGdsb2JhbFRoaXMuc3RydWN0dXJlZENsb25lID8/XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2IyN2FlMjRkY2M0MjUxYmFkNzI2ZDlkODRiYWY2NzhkMWY3MDdmZWQvbGliL2ludGVybmFsL3N0cnVjdHVyZWRfY2xvbmUuanNcbiAgLy8gc3RydWN0dXJlZENsb25lIHdhcyBhZGRlZCBpbiB2MTcuMC4wLCBidXQgZmV0Y2ggc3VwcG9ydHMgdjE2LjhcbiAgZnVuY3Rpb24gc3RydWN0dXJlZENsb25lICh2YWx1ZSwgb3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGFyZ3VtZW50JylcbiAgICB9XG5cbiAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKVxuICAgIH1cbiAgICBjaGFubmVsLnBvcnQxLnVucmVmKClcbiAgICBjaGFubmVsLnBvcnQyLnVucmVmKClcbiAgICBjaGFubmVsLnBvcnQxLnBvc3RNZXNzYWdlKHZhbHVlLCBvcHRpb25zPy50cmFuc2ZlcilcbiAgICByZXR1cm4gcmVjZWl2ZU1lc3NhZ2VPblBvcnQoY2hhbm5lbC5wb3J0MikubWVzc2FnZVxuICB9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBET01FeGNlcHRpb24sXG4gIHN0cnVjdHVyZWRDbG9uZSxcbiAgc3VicmVzb3VyY2UsXG4gIGZvcmJpZGRlbk1ldGhvZHMsXG4gIHJlcXVlc3RCb2R5SGVhZGVyLFxuICByZWZlcnJlclBvbGljeSxcbiAgcmVxdWVzdFJlZGlyZWN0LFxuICByZXF1ZXN0TW9kZSxcbiAgcmVxdWVzdENyZWRlbnRpYWxzLFxuICByZXF1ZXN0Q2FjaGUsXG4gIHJlZGlyZWN0U3RhdHVzLFxuICBjb3JzU2FmZUxpc3RlZE1ldGhvZHMsXG4gIG51bGxCb2R5U3RhdHVzLFxuICBzYWZlTWV0aG9kcyxcbiAgYmFkUG9ydHMsXG4gIHJlcXVlc3REdXBsZXgsXG4gIHN1YnJlc291cmNlU2V0LFxuICBiYWRQb3J0c1NldCxcbiAgcmVkaXJlY3RTdGF0dXNTZXQsXG4gIGNvcnNTYWZlTGlzdGVkTWV0aG9kc1NldCxcbiAgc2FmZU1ldGhvZHNTZXQsXG4gIGZvcmJpZGRlbk1ldGhvZHNTZXQsXG4gIHJlZmVycmVyUG9saWN5U2V0XG59XG4iXSwibmFtZXMiOlsiTWVzc2FnZUNoYW5uZWwiLCJyZWNlaXZlTWVzc2FnZU9uUG9ydCIsInJlcXVpcmUiLCJjb3JzU2FmZUxpc3RlZE1ldGhvZHMiLCJjb3JzU2FmZUxpc3RlZE1ldGhvZHNTZXQiLCJTZXQiLCJudWxsQm9keVN0YXR1cyIsInJlZGlyZWN0U3RhdHVzIiwicmVkaXJlY3RTdGF0dXNTZXQiLCJiYWRQb3J0cyIsImJhZFBvcnRzU2V0IiwicmVmZXJyZXJQb2xpY3kiLCJyZWZlcnJlclBvbGljeVNldCIsInJlcXVlc3RSZWRpcmVjdCIsInNhZmVNZXRob2RzIiwic2FmZU1ldGhvZHNTZXQiLCJyZXF1ZXN0TW9kZSIsInJlcXVlc3RDcmVkZW50aWFscyIsInJlcXVlc3RDYWNoZSIsInJlcXVlc3RCb2R5SGVhZGVyIiwicmVxdWVzdER1cGxleCIsImZvcmJpZGRlbk1ldGhvZHMiLCJmb3JiaWRkZW5NZXRob2RzU2V0Iiwic3VicmVzb3VyY2UiLCJzdWJyZXNvdXJjZVNldCIsIkRPTUV4Y2VwdGlvbiIsImdsb2JhbFRoaXMiLCJhdG9iIiwiZXJyIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJjb25zdHJ1Y3RvciIsImNoYW5uZWwiLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJ2YWx1ZSIsIm9wdGlvbnMiLCJ1bmRlZmluZWQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJUeXBlRXJyb3IiLCJwb3J0MSIsInVucmVmIiwicG9ydDIiLCJwb3N0TWVzc2FnZSIsInRyYW5zZmVyIiwibWVzc2FnZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/dataURL.js":
/*!************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/fetch/dataURL.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { atob } = __webpack_require__(/*! buffer */ \"buffer\");\nconst { isomorphicDecode } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/util.js\");\nconst encoder = new TextEncoder();\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-token-code-point\n */ const HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;\nconst HTTP_WHITESPACE_REGEX = /(\\u000A|\\u000D|\\u0009|\\u0020)/ // eslint-disable-line\n;\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n */ const HTTP_QUOTED_STRING_TOKENS = /[\\u0009|\\u0020-\\u007E|\\u0080-\\u00FF]/ // eslint-disable-line\n;\n// https://fetch.spec.whatwg.org/#data-url-processor\n/** @param {URL} dataURL */ function dataURLProcessor(dataURL) {\n    // 1. Assert: dataURLs scheme is \"data\".\n    assert(dataURL.protocol === \"data:\");\n    // 2. Let input be the result of running the URL\n    // serializer on dataURL with exclude fragment\n    // set to true.\n    let input = URLSerializer(dataURL, true);\n    // 3. Remove the leading \"data:\" string from input.\n    input = input.slice(5);\n    // 4. Let position point at the start of input.\n    const position = {\n        position: 0\n    };\n    // 5. Let mimeType be the result of collecting a\n    // sequence of code points that are not equal\n    // to U+002C (,), given position.\n    let mimeType = collectASequenceOfCodePointsFast(\",\", input, position);\n    // 6. Strip leading and trailing ASCII whitespace\n    // from mimeType.\n    // Undici implementation note: we need to store the\n    // length because if the mimetype has spaces removed,\n    // the wrong amount will be sliced from the input in\n    // step #9\n    const mimeTypeLength = mimeType.length;\n    mimeType = removeASCIIWhitespace(mimeType, true, true);\n    // 7. If position is past the end of input, then\n    // return failure\n    if (position.position >= input.length) {\n        return \"failure\";\n    }\n    // 8. Advance position by 1.\n    position.position++;\n    // 9. Let encodedBody be the remainder of input.\n    const encodedBody = input.slice(mimeTypeLength + 1);\n    // 10. Let body be the percent-decoding of encodedBody.\n    let body = stringPercentDecode(encodedBody);\n    // 11. If mimeType ends with U+003B (;), followed by\n    // zero or more U+0020 SPACE, followed by an ASCII\n    // case-insensitive match for \"base64\", then:\n    if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n        // 1. Let stringBody be the isomorphic decode of body.\n        const stringBody = isomorphicDecode(body);\n        // 2. Set body to the forgiving-base64 decode of\n        // stringBody.\n        body = forgivingBase64(stringBody);\n        // 3. If body is failure, then return failure.\n        if (body === \"failure\") {\n            return \"failure\";\n        }\n        // 4. Remove the last 6 code points from mimeType.\n        mimeType = mimeType.slice(0, -6);\n        // 5. Remove trailing U+0020 SPACE code points from mimeType,\n        // if any.\n        mimeType = mimeType.replace(/(\\u0020)+$/, \"\");\n        // 6. Remove the last U+003B (;) code point from mimeType.\n        mimeType = mimeType.slice(0, -1);\n    }\n    // 12. If mimeType starts with U+003B (;), then prepend\n    // \"text/plain\" to mimeType.\n    if (mimeType.startsWith(\";\")) {\n        mimeType = \"text/plain\" + mimeType;\n    }\n    // 13. Let mimeTypeRecord be the result of parsing\n    // mimeType.\n    let mimeTypeRecord = parseMIMEType(mimeType);\n    // 14. If mimeTypeRecord is failure, then set\n    // mimeTypeRecord to text/plain;charset=US-ASCII.\n    if (mimeTypeRecord === \"failure\") {\n        mimeTypeRecord = parseMIMEType(\"text/plain;charset=US-ASCII\");\n    }\n    // 15. Return a new data: URL struct whose MIME\n    // type is mimeTypeRecord and body is body.\n    // https://fetch.spec.whatwg.org/#data-url-struct\n    return {\n        mimeType: mimeTypeRecord,\n        body\n    };\n}\n// https://url.spec.whatwg.org/#concept-url-serializer\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */ function URLSerializer(url, excludeFragment = false) {\n    if (!excludeFragment) {\n        return url.href;\n    }\n    const href = url.href;\n    const hashLength = url.hash.length;\n    return hashLength === 0 ? href : href.substring(0, href.length - hashLength);\n}\n// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n */ function collectASequenceOfCodePoints(condition, input, position) {\n    // 1. Let result be the empty string.\n    let result = \"\";\n    // 2. While position doesnt point past the end of input and the\n    // code point at position within input meets the condition condition:\n    while(position.position < input.length && condition(input[position.position])){\n        // 1. Append that code point to the end of result.\n        result += input[position.position];\n        // 2. Advance position by 1.\n        position.position++;\n    }\n    // 3. Return result.\n    return result;\n}\n/**\n * A faster collectASequenceOfCodePoints that only works when comparing a single character.\n * @param {string} char\n * @param {string} input\n * @param {{ position: number }} position\n */ function collectASequenceOfCodePointsFast(char, input, position) {\n    const idx = input.indexOf(char, position.position);\n    const start = position.position;\n    if (idx === -1) {\n        position.position = input.length;\n        return input.slice(start);\n    }\n    position.position = idx;\n    return input.slice(start, position.position);\n}\n// https://url.spec.whatwg.org/#string-percent-decode\n/** @param {string} input */ function stringPercentDecode(input) {\n    // 1. Let bytes be the UTF-8 encoding of input.\n    const bytes = encoder.encode(input);\n    // 2. Return the percent-decoding of bytes.\n    return percentDecode(bytes);\n}\n// https://url.spec.whatwg.org/#percent-decode\n/** @param {Uint8Array} input */ function percentDecode(input) {\n    // 1. Let output be an empty byte sequence.\n    /** @type {number[]} */ const output = [];\n    // 2. For each byte byte in input:\n    for(let i = 0; i < input.length; i++){\n        const byte = input[i];\n        // 1. If byte is not 0x25 (%), then append byte to output.\n        if (byte !== 0x25) {\n            output.push(byte);\n        // 2. Otherwise, if byte is 0x25 (%) and the next two bytes\n        // after byte in input are not in the ranges\n        // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),\n        // and 0x61 (a) to 0x66 (f), all inclusive, append byte\n        // to output.\n        } else if (byte === 0x25 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {\n            output.push(0x25);\n        // 3. Otherwise:\n        } else {\n            // 1. Let bytePoint be the two bytes after byte in input,\n            // decoded, and then interpreted as hexadecimal number.\n            const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);\n            const bytePoint = Number.parseInt(nextTwoBytes, 16);\n            // 2. Append a byte whose value is bytePoint to output.\n            output.push(bytePoint);\n            // 3. Skip the next two bytes in input.\n            i += 2;\n        }\n    }\n    // 3. Return output.\n    return Uint8Array.from(output);\n}\n// https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n/** @param {string} input */ function parseMIMEType(input) {\n    // 1. Remove any leading and trailing HTTP whitespace\n    // from input.\n    input = removeHTTPWhitespace(input, true, true);\n    // 2. Let position be a position variable for input,\n    // initially pointing at the start of input.\n    const position = {\n        position: 0\n    };\n    // 3. Let type be the result of collecting a sequence\n    // of code points that are not U+002F (/) from\n    // input, given position.\n    const type = collectASequenceOfCodePointsFast(\"/\", input, position);\n    // 4. If type is the empty string or does not solely\n    // contain HTTP token code points, then return failure.\n    // https://mimesniff.spec.whatwg.org/#http-token-code-point\n    if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {\n        return \"failure\";\n    }\n    // 5. If position is past the end of input, then return\n    // failure\n    if (position.position > input.length) {\n        return \"failure\";\n    }\n    // 6. Advance position by 1. (This skips past U+002F (/).)\n    position.position++;\n    // 7. Let subtype be the result of collecting a sequence of\n    // code points that are not U+003B (;) from input, given\n    // position.\n    let subtype = collectASequenceOfCodePointsFast(\";\", input, position);\n    // 8. Remove any trailing HTTP whitespace from subtype.\n    subtype = removeHTTPWhitespace(subtype, false, true);\n    // 9. If subtype is the empty string or does not solely\n    // contain HTTP token code points, then return failure.\n    if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {\n        return \"failure\";\n    }\n    const typeLowercase = type.toLowerCase();\n    const subtypeLowercase = subtype.toLowerCase();\n    // 10. Let mimeType be a new MIME type record whose type\n    // is type, in ASCII lowercase, and subtype is subtype,\n    // in ASCII lowercase.\n    // https://mimesniff.spec.whatwg.org/#mime-type\n    const mimeType = {\n        type: typeLowercase,\n        subtype: subtypeLowercase,\n        /** @type {Map<string, string>} */ parameters: new Map(),\n        // https://mimesniff.spec.whatwg.org/#mime-type-essence\n        essence: `${typeLowercase}/${subtypeLowercase}`\n    };\n    // 11. While position is not past the end of input:\n    while(position.position < input.length){\n        // 1. Advance position by 1. (This skips past U+003B (;).)\n        position.position++;\n        // 2. Collect a sequence of code points that are HTTP\n        // whitespace from input given position.\n        collectASequenceOfCodePoints(// https://fetch.spec.whatwg.org/#http-whitespace\n        (char)=>HTTP_WHITESPACE_REGEX.test(char), input, position);\n        // 3. Let parameterName be the result of collecting a\n        // sequence of code points that are not U+003B (;)\n        // or U+003D (=) from input, given position.\n        let parameterName = collectASequenceOfCodePoints((char)=>char !== \";\" && char !== \"=\", input, position);\n        // 4. Set parameterName to parameterName, in ASCII\n        // lowercase.\n        parameterName = parameterName.toLowerCase();\n        // 5. If position is not past the end of input, then:\n        if (position.position < input.length) {\n            // 1. If the code point at position within input is\n            // U+003B (;), then continue.\n            if (input[position.position] === \";\") {\n                continue;\n            }\n            // 2. Advance position by 1. (This skips past U+003D (=).)\n            position.position++;\n        }\n        // 6. If position is past the end of input, then break.\n        if (position.position > input.length) {\n            break;\n        }\n        // 7. Let parameterValue be null.\n        let parameterValue = null;\n        // 8. If the code point at position within input is\n        // U+0022 (\"), then:\n        if (input[position.position] === '\"') {\n            // 1. Set parameterValue to the result of collecting\n            // an HTTP quoted string from input, given position\n            // and the extract-value flag.\n            parameterValue = collectAnHTTPQuotedString(input, position, true);\n            // 2. Collect a sequence of code points that are not\n            // U+003B (;) from input, given position.\n            collectASequenceOfCodePointsFast(\";\", input, position);\n        // 9. Otherwise:\n        } else {\n            // 1. Set parameterValue to the result of collecting\n            // a sequence of code points that are not U+003B (;)\n            // from input, given position.\n            parameterValue = collectASequenceOfCodePointsFast(\";\", input, position);\n            // 2. Remove any trailing HTTP whitespace from parameterValue.\n            parameterValue = removeHTTPWhitespace(parameterValue, false, true);\n            // 3. If parameterValue is the empty string, then continue.\n            if (parameterValue.length === 0) {\n                continue;\n            }\n        }\n        // 10. If all of the following are true\n        // - parameterName is not the empty string\n        // - parameterName solely contains HTTP token code points\n        // - parameterValue solely contains HTTP quoted-string token code points\n        // - mimeTypes parameters[parameterName] does not exist\n        // then set mimeTypes parameters[parameterName] to parameterValue.\n        if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {\n            mimeType.parameters.set(parameterName, parameterValue);\n        }\n    }\n    // 12. Return mimeType.\n    return mimeType;\n}\n// https://infra.spec.whatwg.org/#forgiving-base64-decode\n/** @param {string} data */ function forgivingBase64(data) {\n    // 1. Remove all ASCII whitespace from data.\n    data = data.replace(/[\\u0009\\u000A\\u000C\\u000D\\u0020]/g, \"\") // eslint-disable-line\n    ;\n    // 2. If datas code point length divides by 4 leaving\n    // no remainder, then:\n    if (data.length % 4 === 0) {\n        // 1. If data ends with one or two U+003D (=) code points,\n        // then remove them from data.\n        data = data.replace(/=?=$/, \"\");\n    }\n    // 3. If datas code point length divides by 4 leaving\n    // a remainder of 1, then return failure.\n    if (data.length % 4 === 1) {\n        return \"failure\";\n    }\n    // 4. If data contains a code point that is not one of\n    //  U+002B (+)\n    //  U+002F (/)\n    //  ASCII alphanumeric\n    // then return failure.\n    if (/[^+/0-9A-Za-z]/.test(data)) {\n        return \"failure\";\n    }\n    const binary = atob(data);\n    const bytes = new Uint8Array(binary.length);\n    for(let byte = 0; byte < binary.length; byte++){\n        bytes[byte] = binary.charCodeAt(byte);\n    }\n    return bytes;\n}\n// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean?} extractValue\n */ function collectAnHTTPQuotedString(input, position, extractValue) {\n    // 1. Let positionStart be position.\n    const positionStart = position.position;\n    // 2. Let value be the empty string.\n    let value = \"\";\n    // 3. Assert: the code point at position within input\n    // is U+0022 (\").\n    assert(input[position.position] === '\"');\n    // 4. Advance position by 1.\n    position.position++;\n    // 5. While true:\n    while(true){\n        // 1. Append the result of collecting a sequence of code points\n        // that are not U+0022 (\") or U+005C (\\) from input, given\n        // position, to value.\n        value += collectASequenceOfCodePoints((char)=>char !== '\"' && char !== \"\\\\\", input, position);\n        // 2. If position is past the end of input, then break.\n        if (position.position >= input.length) {\n            break;\n        }\n        // 3. Let quoteOrBackslash be the code point at position within\n        // input.\n        const quoteOrBackslash = input[position.position];\n        // 4. Advance position by 1.\n        position.position++;\n        // 5. If quoteOrBackslash is U+005C (\\), then:\n        if (quoteOrBackslash === \"\\\\\") {\n            // 1. If position is past the end of input, then append\n            // U+005C (\\) to value and break.\n            if (position.position >= input.length) {\n                value += \"\\\\\";\n                break;\n            }\n            // 2. Append the code point at position within input to value.\n            value += input[position.position];\n            // 3. Advance position by 1.\n            position.position++;\n        // 6. Otherwise:\n        } else {\n            // 1. Assert: quoteOrBackslash is U+0022 (\").\n            assert(quoteOrBackslash === '\"');\n            break;\n        }\n    }\n    // 6. If the extract-value flag is set, then return value.\n    if (extractValue) {\n        return value;\n    }\n    // 7. Return the code points from positionStart to position,\n    // inclusive, within input.\n    return input.slice(positionStart, position.position);\n}\n/**\n * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type\n */ function serializeAMimeType(mimeType) {\n    assert(mimeType !== \"failure\");\n    const { parameters, essence } = mimeType;\n    // 1. Let serialization be the concatenation of mimeTypes\n    //    type, U+002F (/), and mimeTypes subtype.\n    let serialization = essence;\n    // 2. For each name  value of mimeTypes parameters:\n    for (let [name, value] of parameters.entries()){\n        // 1. Append U+003B (;) to serialization.\n        serialization += \";\";\n        // 2. Append name to serialization.\n        serialization += name;\n        // 3. Append U+003D (=) to serialization.\n        serialization += \"=\";\n        // 4. If value does not solely contain HTTP token code\n        //    points or value is the empty string, then:\n        if (!HTTP_TOKEN_CODEPOINTS.test(value)) {\n            // 1. Precede each occurence of U+0022 (\") or\n            //    U+005C (\\) in value with U+005C (\\).\n            value = value.replace(/(\\\\|\")/g, \"\\\\$1\");\n            // 2. Prepend U+0022 (\") to value.\n            value = '\"' + value;\n            // 3. Append U+0022 (\") to value.\n            value += '\"';\n        }\n        // 5. Append value to serialization.\n        serialization += value;\n    }\n    // 3. Return serialization.\n    return serialization;\n}\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {string} char\n */ function isHTTPWhiteSpace(char) {\n    return char === \"\\r\" || char === \"\\n\" || char === \"\t\" || char === \" \";\n}\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {string} str\n */ function removeHTTPWhitespace(str, leading = true, trailing = true) {\n    let lead = 0;\n    let trail = str.length - 1;\n    if (leading) {\n        for(; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++);\n    }\n    if (trailing) {\n        for(; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--);\n    }\n    return str.slice(lead, trail + 1);\n}\n/**\n * @see https://infra.spec.whatwg.org/#ascii-whitespace\n * @param {string} char\n */ function isASCIIWhitespace(char) {\n    return char === \"\\r\" || char === \"\\n\" || char === \"\t\" || char === \"\\f\" || char === \" \";\n}\n/**\n * @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace\n */ function removeASCIIWhitespace(str, leading = true, trailing = true) {\n    let lead = 0;\n    let trail = str.length - 1;\n    if (leading) {\n        for(; lead < str.length && isASCIIWhitespace(str[lead]); lead++);\n    }\n    if (trailing) {\n        for(; trail > 0 && isASCIIWhitespace(str[trail]); trail--);\n    }\n    return str.slice(lead, trail + 1);\n}\nmodule.exports = {\n    dataURLProcessor,\n    URLSerializer,\n    collectASequenceOfCodePoints,\n    collectASequenceOfCodePointsFast,\n    stringPercentDecode,\n    parseMIMEType,\n    collectAnHTTPQuotedString,\n    serializeAMimeType\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvZGF0YVVSTC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFQyxJQUFJLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFDekIsTUFBTSxFQUFFRSxnQkFBZ0IsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUVyQyxNQUFNRyxVQUFVLElBQUlDO0FBRXBCOztDQUVDLEdBQ0QsTUFBTUMsd0JBQXdCO0FBQzlCLE1BQU1DLHdCQUF3QixnQ0FBZ0Msc0JBQXNCOztBQUNwRjs7Q0FFQyxHQUNELE1BQU1DLDRCQUE0Qix1Q0FBdUMsc0JBQXNCOztBQUUvRixvREFBb0Q7QUFDcEQseUJBQXlCLEdBQ3pCLFNBQVNDLGlCQUFrQkMsT0FBTztJQUNoQyx5Q0FBeUM7SUFDekNWLE9BQU9VLFFBQVFDLFFBQVEsS0FBSztJQUU1QixnREFBZ0Q7SUFDaEQsOENBQThDO0lBQzlDLGVBQWU7SUFDZixJQUFJQyxRQUFRQyxjQUFjSCxTQUFTO0lBRW5DLG1EQUFtRDtJQUNuREUsUUFBUUEsTUFBTUUsS0FBSyxDQUFDO0lBRXBCLCtDQUErQztJQUMvQyxNQUFNQyxXQUFXO1FBQUVBLFVBQVU7SUFBRTtJQUUvQixnREFBZ0Q7SUFDaEQsNkNBQTZDO0lBQzdDLGlDQUFpQztJQUNqQyxJQUFJQyxXQUFXQyxpQ0FDYixLQUNBTCxPQUNBRztJQUdGLGlEQUFpRDtJQUNqRCxpQkFBaUI7SUFDakIsbURBQW1EO0lBQ25ELHFEQUFxRDtJQUNyRCxvREFBb0Q7SUFDcEQsVUFBVTtJQUNWLE1BQU1HLGlCQUFpQkYsU0FBU0csTUFBTTtJQUN0Q0gsV0FBV0ksc0JBQXNCSixVQUFVLE1BQU07SUFFakQsZ0RBQWdEO0lBQ2hELGlCQUFpQjtJQUNqQixJQUFJRCxTQUFTQSxRQUFRLElBQUlILE1BQU1PLE1BQU0sRUFBRTtRQUNyQyxPQUFPO0lB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LWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9kYXRhVVJMLmpzP2EzYjciXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IHsgYXRvYiB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IHsgaXNvbW9ycGhpY0RlY29kZSB9ID0gcmVxdWlyZSgnLi91dGlsJylcblxuY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG5cbi8qKlxuICogQHNlZSBodHRwczovL21pbWVzbmlmZi5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtdG9rZW4tY29kZS1wb2ludFxuICovXG5jb25zdCBIVFRQX1RPS0VOX0NPREVQT0lOVFMgPSAvXlshIyQlJicqKy0uXl98fkEtWmEtejAtOV0rJC9cbmNvbnN0IEhUVFBfV0hJVEVTUEFDRV9SRUdFWCA9IC8oXFx1MDAwQXxcXHUwMDBEfFxcdTAwMDl8XFx1MDAyMCkvIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbi8qKlxuICogQHNlZSBodHRwczovL21pbWVzbmlmZi5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtcXVvdGVkLXN0cmluZy10b2tlbi1jb2RlLXBvaW50XG4gKi9cbmNvbnN0IEhUVFBfUVVPVEVEX1NUUklOR19UT0tFTlMgPSAvW1xcdTAwMDl8XFx1MDAyMC1cXHUwMDdFfFxcdTAwODAtXFx1MDBGRl0vIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RhdGEtdXJsLXByb2Nlc3NvclxuLyoqIEBwYXJhbSB7VVJMfSBkYXRhVVJMICovXG5mdW5jdGlvbiBkYXRhVVJMUHJvY2Vzc29yIChkYXRhVVJMKSB7XG4gIC8vIDEuIEFzc2VydDogZGF0YVVSTOKAmXMgc2NoZW1lIGlzIFwiZGF0YVwiLlxuICBhc3NlcnQoZGF0YVVSTC5wcm90b2NvbCA9PT0gJ2RhdGE6JylcblxuICAvLyAyLiBMZXQgaW5wdXQgYmUgdGhlIHJlc3VsdCBvZiBydW5uaW5nIHRoZSBVUkxcbiAgLy8gc2VyaWFsaXplciBvbiBkYXRhVVJMIHdpdGggZXhjbHVkZSBmcmFnbWVudFxuICAvLyBzZXQgdG8gdHJ1ZS5cbiAgbGV0IGlucHV0ID0gVVJMU2VyaWFsaXplcihkYXRhVVJMLCB0cnVlKVxuXG4gIC8vIDMuIFJlbW92ZSB0aGUgbGVhZGluZyBcImRhdGE6XCIgc3RyaW5nIGZyb20gaW5wdXQuXG4gIGlucHV0ID0gaW5wdXQuc2xpY2UoNSlcblxuICAvLyA0LiBMZXQgcG9zaXRpb24gcG9pbnQgYXQgdGhlIHN0YXJ0IG9mIGlucHV0LlxuICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfVxuXG4gIC8vIDUuIExldCBtaW1lVHlwZSBiZSB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYVxuICAvLyBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBub3QgZXF1YWxcbiAgLy8gdG8gVSswMDJDICgsKSwgZ2l2ZW4gcG9zaXRpb24uXG4gIGxldCBtaW1lVHlwZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICcsJyxcbiAgICBpbnB1dCxcbiAgICBwb3NpdGlvblxuICApXG5cbiAgLy8gNi4gU3RyaXAgbGVhZGluZyBhbmQgdHJhaWxpbmcgQVNDSUkgd2hpdGVzcGFjZVxuICAvLyBmcm9tIG1pbWVUeXBlLlxuICAvLyBVbmRpY2kgaW1wbGVtZW50YXRpb24gbm90ZTogd2UgbmVlZCB0byBzdG9yZSB0aGVcbiAgLy8gbGVuZ3RoIGJlY2F1c2UgaWYgdGhlIG1pbWV0eXBlIGhhcyBzcGFjZXMgcmVtb3ZlZCxcbiAgLy8gdGhlIHdyb25nIGFtb3VudCB3aWxsIGJlIHNsaWNlZCBmcm9tIHRoZSBpbnB1dCBpblxuICAvLyBzdGVwICM5XG4gIGNvbnN0IG1pbWVUeXBlTGVuZ3RoID0gbWltZVR5cGUubGVuZ3RoXG4gIG1pbWVUeXBlID0gcmVtb3ZlQVNDSUlXaGl0ZXNwYWNlKG1pbWVUeXBlLCB0cnVlLCB0cnVlKVxuXG4gIC8vIDcuIElmIHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgdGhlblxuICAvLyByZXR1cm4gZmFpbHVyZVxuICBpZiAocG9zaXRpb24ucG9zaXRpb24gPj0gaW5wdXQubGVuZ3RoKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gOC4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgLy8gOS4gTGV0IGVuY29kZWRCb2R5IGJlIHRoZSByZW1haW5kZXIgb2YgaW5wdXQuXG4gIGNvbnN0IGVuY29kZWRCb2R5ID0gaW5wdXQuc2xpY2UobWltZVR5cGVMZW5ndGggKyAxKVxuXG4gIC8vIDEwLiBMZXQgYm9keSBiZSB0aGUgcGVyY2VudC1kZWNvZGluZyBvZiBlbmNvZGVkQm9keS5cbiAgbGV0IGJvZHkgPSBzdHJpbmdQZXJjZW50RGVjb2RlKGVuY29kZWRCb2R5KVxuXG4gIC8vIDExLiBJZiBtaW1lVHlwZSBlbmRzIHdpdGggVSswMDNCICg7KSwgZm9sbG93ZWQgYnlcbiAgLy8gemVybyBvciBtb3JlIFUrMDAyMCBTUEFDRSwgZm9sbG93ZWQgYnkgYW4gQVNDSUlcbiAgLy8gY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3IgXCJiYXNlNjRcIiwgdGhlbjpcbiAgaWYgKC87KFxcdTAwMjApezAsfWJhc2U2NCQvaS50ZXN0KG1pbWVUeXBlKSkge1xuICAgIC8vIDEuIExldCBzdHJpbmdCb2R5IGJlIHRoZSBpc29tb3JwaGljIGRlY29kZSBvZiBib2R5LlxuICAgIGNvbnN0IHN0cmluZ0JvZHkgPSBpc29tb3JwaGljRGVjb2RlKGJvZHkpXG5cbiAgICAvLyAyLiBTZXQgYm9keSB0byB0aGUgZm9yZ2l2aW5nLWJhc2U2NCBkZWNvZGUgb2ZcbiAgICAvLyBzdHJpbmdCb2R5LlxuICAgIGJvZHkgPSBmb3JnaXZpbmdCYXNlNjQoc3RyaW5nQm9keSlcblxuICAgIC8vIDMuIElmIGJvZHkgaXMgZmFpbHVyZSwgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgICBpZiAoYm9keSA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gICAgfVxuXG4gICAgLy8gNC4gUmVtb3ZlIHRoZSBsYXN0IDYgY29kZSBwb2ludHMgZnJvbSBtaW1lVHlwZS5cbiAgICBtaW1lVHlwZSA9IG1pbWVUeXBlLnNsaWNlKDAsIC02KVxuXG4gICAgLy8gNS4gUmVtb3ZlIHRyYWlsaW5nIFUrMDAyMCBTUEFDRSBjb2RlIHBvaW50cyBmcm9tIG1pbWVUeXBlLFxuICAgIC8vIGlmIGFueS5cbiAgICBtaW1lVHlwZSA9IG1pbWVUeXBlLnJlcGxhY2UoLyhcXHUwMDIwKSskLywgJycpXG5cbiAgICAvLyA2LiBSZW1vdmUgdGhlIGxhc3QgVSswMDNCICg7KSBjb2RlIHBvaW50IGZyb20gbWltZVR5cGUuXG4gICAgbWltZVR5cGUgPSBtaW1lVHlwZS5zbGljZSgwLCAtMSlcbiAgfVxuXG4gIC8vIDEyLiBJZiBtaW1lVHlwZSBzdGFydHMgd2l0aCBVKzAwM0IgKDspLCB0aGVuIHByZXBlbmRcbiAgLy8gXCJ0ZXh0L3BsYWluXCIgdG8gbWltZVR5cGUuXG4gIGlmIChtaW1lVHlwZS5zdGFydHNXaXRoKCc7JykpIHtcbiAgICBtaW1lVHlwZSA9ICd0ZXh0L3BsYWluJyArIG1pbWVUeXBlXG4gIH1cblxuICAvLyAxMy4gTGV0IG1pbWVUeXBlUmVjb3JkIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZ1xuICAvLyBtaW1lVHlwZS5cbiAgbGV0IG1pbWVUeXBlUmVjb3JkID0gcGFyc2VNSU1FVHlwZShtaW1lVHlwZSlcblxuICAvLyAxNC4gSWYgbWltZVR5cGVSZWNvcmQgaXMgZmFpbHVyZSwgdGhlbiBzZXRcbiAgLy8gbWltZVR5cGVSZWNvcmQgdG8gdGV4dC9wbGFpbjtjaGFyc2V0PVVTLUFTQ0lJLlxuICBpZiAobWltZVR5cGVSZWNvcmQgPT09ICdmYWlsdXJlJykge1xuICAgIG1pbWVUeXBlUmVjb3JkID0gcGFyc2VNSU1FVHlwZSgndGV4dC9wbGFpbjtjaGFyc2V0PVVTLUFTQ0lJJylcbiAgfVxuXG4gIC8vIDE1LiBSZXR1cm4gYSBuZXcgZGF0YTogVVJMIHN0cnVjdCB3aG9zZSBNSU1FXG4gIC8vIHR5cGUgaXMgbWltZVR5cGVSZWNvcmQgYW5kIGJvZHkgaXMgYm9keS5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RhdGEtdXJsLXN0cnVjdFxuICByZXR1cm4geyBtaW1lVHlwZTogbWltZVR5cGVSZWNvcmQsIGJvZHkgfVxufVxuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtdXJsLXNlcmlhbGl6ZXJcbi8qKlxuICogQHBhcmFtIHtVUkx9IHVybFxuICogQHBhcmFtIHtib29sZWFufSBleGNsdWRlRnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gVVJMU2VyaWFsaXplciAodXJsLCBleGNsdWRlRnJhZ21lbnQgPSBmYWxzZSkge1xuICBpZiAoIWV4Y2x1ZGVGcmFnbWVudCkge1xuICAgIHJldHVybiB1cmwuaHJlZlxuICB9XG5cbiAgY29uc3QgaHJlZiA9IHVybC5ocmVmXG4gIGNvbnN0IGhhc2hMZW5ndGggPSB1cmwuaGFzaC5sZW5ndGhcblxuICByZXR1cm4gaGFzaExlbmd0aCA9PT0gMCA/IGhyZWYgOiBocmVmLnN1YnN0cmluZygwLCBocmVmLmxlbmd0aCAtIGhhc2hMZW5ndGgpXG59XG5cbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNjb2xsZWN0LWEtc2VxdWVuY2Utb2YtY29kZS1wb2ludHNcbi8qKlxuICogQHBhcmFtIHsoY2hhcjogc3RyaW5nKSA9PiBib29sZWFufSBjb25kaXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICogQHBhcmFtIHt7IHBvc2l0aW9uOiBudW1iZXIgfX0gcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyAoY29uZGl0aW9uLCBpbnB1dCwgcG9zaXRpb24pIHtcbiAgLy8gMS4gTGV0IHJlc3VsdCBiZSB0aGUgZW1wdHkgc3RyaW5nLlxuICBsZXQgcmVzdWx0ID0gJydcblxuICAvLyAyLiBXaGlsZSBwb3NpdGlvbiBkb2VzbuKAmXQgcG9pbnQgcGFzdCB0aGUgZW5kIG9mIGlucHV0IGFuZCB0aGVcbiAgLy8gY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW4gaW5wdXQgbWVldHMgdGhlIGNvbmRpdGlvbiBjb25kaXRpb246XG4gIHdoaWxlIChwb3NpdGlvbi5wb3NpdGlvbiA8IGlucHV0Lmxlbmd0aCAmJiBjb25kaXRpb24oaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dKSkge1xuICAgIC8vIDEuIEFwcGVuZCB0aGF0IGNvZGUgcG9pbnQgdG8gdGhlIGVuZCBvZiByZXN1bHQuXG4gICAgcmVzdWx0ICs9IGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXVxuXG4gICAgLy8gMi4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcbiAgfVxuXG4gIC8vIDMuIFJldHVybiByZXN1bHQuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBBIGZhc3RlciBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzIHRoYXQgb25seSB3b3JrcyB3aGVuIGNvbXBhcmluZyBhIHNpbmdsZSBjaGFyYWN0ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhclxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKiBAcGFyYW0ge3sgcG9zaXRpb246IG51bWJlciB9fSBwb3NpdGlvblxuICovXG5mdW5jdGlvbiBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdCAoY2hhciwgaW5wdXQsIHBvc2l0aW9uKSB7XG4gIGNvbnN0IGlkeCA9IGlucHV0LmluZGV4T2YoY2hhciwgcG9zaXRpb24ucG9zaXRpb24pXG4gIGNvbnN0IHN0YXJ0ID0gcG9zaXRpb24ucG9zaXRpb25cblxuICBpZiAoaWR4ID09PSAtMSkge1xuICAgIHBvc2l0aW9uLnBvc2l0aW9uID0gaW5wdXQubGVuZ3RoXG4gICAgcmV0dXJuIGlucHV0LnNsaWNlKHN0YXJ0KVxuICB9XG5cbiAgcG9zaXRpb24ucG9zaXRpb24gPSBpZHhcbiAgcmV0dXJuIGlucHV0LnNsaWNlKHN0YXJ0LCBwb3NpdGlvbi5wb3NpdGlvbilcbn1cblxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNzdHJpbmctcGVyY2VudC1kZWNvZGVcbi8qKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgKi9cbmZ1bmN0aW9uIHN0cmluZ1BlcmNlbnREZWNvZGUgKGlucHV0KSB7XG4gIC8vIDEuIExldCBieXRlcyBiZSB0aGUgVVRGLTggZW5jb2Rpbmcgb2YgaW5wdXQuXG4gIGNvbnN0IGJ5dGVzID0gZW5jb2Rlci5lbmNvZGUoaW5wdXQpXG5cbiAgLy8gMi4gUmV0dXJuIHRoZSBwZXJjZW50LWRlY29kaW5nIG9mIGJ5dGVzLlxuICByZXR1cm4gcGVyY2VudERlY29kZShieXRlcylcbn1cblxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNwZXJjZW50LWRlY29kZVxuLyoqIEBwYXJhbSB7VWludDhBcnJheX0gaW5wdXQgKi9cbmZ1bmN0aW9uIHBlcmNlbnREZWNvZGUgKGlucHV0KSB7XG4gIC8vIDEuIExldCBvdXRwdXQgYmUgYW4gZW1wdHkgYnl0ZSBzZXF1ZW5jZS5cbiAgLyoqIEB0eXBlIHtudW1iZXJbXX0gKi9cbiAgY29uc3Qgb3V0cHV0ID0gW11cblxuICAvLyAyLiBGb3IgZWFjaCBieXRlIGJ5dGUgaW4gaW5wdXQ6XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBieXRlID0gaW5wdXRbaV1cblxuICAgIC8vIDEuIElmIGJ5dGUgaXMgbm90IDB4MjUgKCUpLCB0aGVuIGFwcGVuZCBieXRlIHRvIG91dHB1dC5cbiAgICBpZiAoYnl0ZSAhPT0gMHgyNSkge1xuICAgICAgb3V0cHV0LnB1c2goYnl0ZSlcblxuICAgIC8vIDIuIE90aGVyd2lzZSwgaWYgYnl0ZSBpcyAweDI1ICglKSBhbmQgdGhlIG5leHQgdHdvIGJ5dGVzXG4gICAgLy8gYWZ0ZXIgYnl0ZSBpbiBpbnB1dCBhcmUgbm90IGluIHRoZSByYW5nZXNcbiAgICAvLyAweDMwICgwKSB0byAweDM5ICg5KSwgMHg0MSAoQSkgdG8gMHg0NiAoRiksXG4gICAgLy8gYW5kIDB4NjEgKGEpIHRvIDB4NjYgKGYpLCBhbGwgaW5jbHVzaXZlLCBhcHBlbmQgYnl0ZVxuICAgIC8vIHRvIG91dHB1dC5cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYnl0ZSA9PT0gMHgyNSAmJlxuICAgICAgIS9eWzAtOUEtRmEtZl17Mn0kL2kudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGlucHV0W2kgKyAxXSwgaW5wdXRbaSArIDJdKSlcbiAgICApIHtcbiAgICAgIG91dHB1dC5wdXNoKDB4MjUpXG5cbiAgICAvLyAzLiBPdGhlcndpc2U6XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDEuIExldCBieXRlUG9pbnQgYmUgdGhlIHR3byBieXRlcyBhZnRlciBieXRlIGluIGlucHV0LFxuICAgICAgLy8gZGVjb2RlZCwgYW5kIHRoZW4gaW50ZXJwcmV0ZWQgYXMgaGV4YWRlY2ltYWwgbnVtYmVyLlxuICAgICAgY29uc3QgbmV4dFR3b0J5dGVzID0gU3RyaW5nLmZyb21DaGFyQ29kZShpbnB1dFtpICsgMV0sIGlucHV0W2kgKyAyXSlcbiAgICAgIGNvbnN0IGJ5dGVQb2ludCA9IE51bWJlci5wYXJzZUludChuZXh0VHdvQnl0ZXMsIDE2KVxuXG4gICAgICAvLyAyLiBBcHBlbmQgYSBieXRlIHdob3NlIHZhbHVlIGlzIGJ5dGVQb2ludCB0byBvdXRwdXQuXG4gICAgICBvdXRwdXQucHVzaChieXRlUG9pbnQpXG5cbiAgICAgIC8vIDMuIFNraXAgdGhlIG5leHQgdHdvIGJ5dGVzIGluIGlucHV0LlxuICAgICAgaSArPSAyXG4gICAgfVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIG91dHB1dC5cbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShvdXRwdXQpXG59XG5cbi8vIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jcGFyc2UtYS1taW1lLXR5cGVcbi8qKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgKi9cbmZ1bmN0aW9uIHBhcnNlTUlNRVR5cGUgKGlucHV0KSB7XG4gIC8vIDEuIFJlbW92ZSBhbnkgbGVhZGluZyBhbmQgdHJhaWxpbmcgSFRUUCB3aGl0ZXNwYWNlXG4gIC8vIGZyb20gaW5wdXQuXG4gIGlucHV0ID0gcmVtb3ZlSFRUUFdoaXRlc3BhY2UoaW5wdXQsIHRydWUsIHRydWUpXG5cbiAgLy8gMi4gTGV0IHBvc2l0aW9uIGJlIGEgcG9zaXRpb24gdmFyaWFibGUgZm9yIGlucHV0LFxuICAvLyBpbml0aWFsbHkgcG9pbnRpbmcgYXQgdGhlIHN0YXJ0IG9mIGlucHV0LlxuICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfVxuXG4gIC8vIDMuIExldCB0eXBlIGJlIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhIHNlcXVlbmNlXG4gIC8vIG9mIGNvZGUgcG9pbnRzIHRoYXQgYXJlIG5vdCBVKzAwMkYgKC8pIGZyb21cbiAgLy8gaW5wdXQsIGdpdmVuIHBvc2l0aW9uLlxuICBjb25zdCB0eXBlID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgJy8nLFxuICAgIGlucHV0LFxuICAgIHBvc2l0aW9uXG4gIClcblxuICAvLyA0LiBJZiB0eXBlIGlzIHRoZSBlbXB0eSBzdHJpbmcgb3IgZG9lcyBub3Qgc29sZWx5XG4gIC8vIGNvbnRhaW4gSFRUUCB0b2tlbiBjb2RlIHBvaW50cywgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgLy8gaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNodHRwLXRva2VuLWNvZGUtcG9pbnRcbiAgaWYgKHR5cGUubGVuZ3RoID09PSAwIHx8ICFIVFRQX1RPS0VOX0NPREVQT0lOVFMudGVzdCh0eXBlKSkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDUuIElmIHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgdGhlbiByZXR1cm5cbiAgLy8gZmFpbHVyZVxuICBpZiAocG9zaXRpb24ucG9zaXRpb24gPiBpbnB1dC5sZW5ndGgpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyA2LiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuIChUaGlzIHNraXBzIHBhc3QgVSswMDJGICgvKS4pXG4gIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAvLyA3LiBMZXQgc3VidHlwZSBiZSB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYSBzZXF1ZW5jZSBvZlxuICAvLyBjb2RlIHBvaW50cyB0aGF0IGFyZSBub3QgVSswMDNCICg7KSBmcm9tIGlucHV0LCBnaXZlblxuICAvLyBwb3NpdGlvbi5cbiAgbGV0IHN1YnR5cGUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAnOycsXG4gICAgaW5wdXQsXG4gICAgcG9zaXRpb25cbiAgKVxuXG4gIC8vIDguIFJlbW92ZSBhbnkgdHJhaWxpbmcgSFRUUCB3aGl0ZXNwYWNlIGZyb20gc3VidHlwZS5cbiAgc3VidHlwZSA9IHJlbW92ZUhUVFBXaGl0ZXNwYWNlKHN1YnR5cGUsIGZhbHNlLCB0cnVlKVxuXG4gIC8vIDkuIElmIHN1YnR5cGUgaXMgdGhlIGVtcHR5IHN0cmluZyBvciBkb2VzIG5vdCBzb2xlbHlcbiAgLy8gY29udGFpbiBIVFRQIHRva2VuIGNvZGUgcG9pbnRzLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICBpZiAoc3VidHlwZS5sZW5ndGggPT09IDAgfHwgIUhUVFBfVE9LRU5fQ09ERVBPSU5UUy50ZXN0KHN1YnR5cGUpKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgY29uc3QgdHlwZUxvd2VyY2FzZSA9IHR5cGUudG9Mb3dlckNhc2UoKVxuICBjb25zdCBzdWJ0eXBlTG93ZXJjYXNlID0gc3VidHlwZS50b0xvd2VyQ2FzZSgpXG5cbiAgLy8gMTAuIExldCBtaW1lVHlwZSBiZSBhIG5ldyBNSU1FIHR5cGUgcmVjb3JkIHdob3NlIHR5cGVcbiAgLy8gaXMgdHlwZSwgaW4gQVNDSUkgbG93ZXJjYXNlLCBhbmQgc3VidHlwZSBpcyBzdWJ0eXBlLFxuICAvLyBpbiBBU0NJSSBsb3dlcmNhc2UuXG4gIC8vIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jbWltZS10eXBlXG4gIGNvbnN0IG1pbWVUeXBlID0ge1xuICAgIHR5cGU6IHR5cGVMb3dlcmNhc2UsXG4gICAgc3VidHlwZTogc3VidHlwZUxvd2VyY2FzZSxcbiAgICAvKiogQHR5cGUge01hcDxzdHJpbmcsIHN0cmluZz59ICovXG4gICAgcGFyYW1ldGVyczogbmV3IE1hcCgpLFxuICAgIC8vIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jbWltZS10eXBlLWVzc2VuY2VcbiAgICBlc3NlbmNlOiBgJHt0eXBlTG93ZXJjYXNlfS8ke3N1YnR5cGVMb3dlcmNhc2V9YFxuICB9XG5cbiAgLy8gMTEuIFdoaWxlIHBvc2l0aW9uIGlzIG5vdCBwYXN0IHRoZSBlbmQgb2YgaW5wdXQ6XG4gIHdoaWxlIChwb3NpdGlvbi5wb3NpdGlvbiA8IGlucHV0Lmxlbmd0aCkge1xuICAgIC8vIDEuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS4gKFRoaXMgc2tpcHMgcGFzdCBVKzAwM0IgKDspLilcbiAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgICAvLyAyLiBDb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgSFRUUFxuICAgIC8vIHdoaXRlc3BhY2UgZnJvbSBpbnB1dCBnaXZlbiBwb3NpdGlvbi5cbiAgICBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtd2hpdGVzcGFjZVxuICAgICAgY2hhciA9PiBIVFRQX1dISVRFU1BBQ0VfUkVHRVgudGVzdChjaGFyKSxcbiAgICAgIGlucHV0LFxuICAgICAgcG9zaXRpb25cbiAgICApXG5cbiAgICAvLyAzLiBMZXQgcGFyYW1ldGVyTmFtZSBiZSB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYVxuICAgIC8vIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzIHRoYXQgYXJlIG5vdCBVKzAwM0IgKDspXG4gICAgLy8gb3IgVSswMDNEICg9KSBmcm9tIGlucHV0LCBnaXZlbiBwb3NpdGlvbi5cbiAgICBsZXQgcGFyYW1ldGVyTmFtZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAoY2hhcikgPT4gY2hhciAhPT0gJzsnICYmIGNoYXIgIT09ICc9JyxcbiAgICAgIGlucHV0LFxuICAgICAgcG9zaXRpb25cbiAgICApXG5cbiAgICAvLyA0LiBTZXQgcGFyYW1ldGVyTmFtZSB0byBwYXJhbWV0ZXJOYW1lLCBpbiBBU0NJSVxuICAgIC8vIGxvd2VyY2FzZS5cbiAgICBwYXJhbWV0ZXJOYW1lID0gcGFyYW1ldGVyTmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgICAvLyA1LiBJZiBwb3NpdGlvbiBpcyBub3QgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCB0aGVuOlxuICAgIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgLy8gMS4gSWYgdGhlIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluIGlucHV0IGlzXG4gICAgICAvLyBVKzAwM0IgKDspLCB0aGVuIGNvbnRpbnVlLlxuICAgICAgaWYgKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSA9PT0gJzsnKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS4gKFRoaXMgc2tpcHMgcGFzdCBVKzAwM0QgKD0pLilcbiAgICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcbiAgICB9XG5cbiAgICAvLyA2LiBJZiBwb3NpdGlvbiBpcyBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW4gYnJlYWsuXG4gICAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uID4gaW5wdXQubGVuZ3RoKSB7XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIC8vIDcuIExldCBwYXJhbWV0ZXJWYWx1ZSBiZSBudWxsLlxuICAgIGxldCBwYXJhbWV0ZXJWYWx1ZSA9IG51bGxcblxuICAgIC8vIDguIElmIHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBpbnB1dCBpc1xuICAgIC8vIFUrMDAyMiAoXCIpLCB0aGVuOlxuICAgIGlmIChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gPT09ICdcIicpIHtcbiAgICAgIC8vIDEuIFNldCBwYXJhbWV0ZXJWYWx1ZSB0byB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmdcbiAgICAgIC8vIGFuIEhUVFAgcXVvdGVkIHN0cmluZyBmcm9tIGlucHV0LCBnaXZlbiBwb3NpdGlvblxuICAgICAgLy8gYW5kIHRoZSBleHRyYWN0LXZhbHVlIGZsYWcuXG4gICAgICBwYXJhbWV0ZXJWYWx1ZSA9IGNvbGxlY3RBbkhUVFBRdW90ZWRTdHJpbmcoaW5wdXQsIHBvc2l0aW9uLCB0cnVlKVxuXG4gICAgICAvLyAyLiBDb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgbm90XG4gICAgICAvLyBVKzAwM0IgKDspIGZyb20gaW5wdXQsIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgICAgICc7JyxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIHBvc2l0aW9uXG4gICAgICApXG5cbiAgICAvLyA5LiBPdGhlcndpc2U6XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDEuIFNldCBwYXJhbWV0ZXJWYWx1ZSB0byB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmdcbiAgICAgIC8vIGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgbm90IFUrMDAzQiAoOylcbiAgICAgIC8vIGZyb20gaW5wdXQsIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgcGFyYW1ldGVyVmFsdWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAgICAgJzsnLFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgcG9zaXRpb25cbiAgICAgIClcblxuICAgICAgLy8gMi4gUmVtb3ZlIGFueSB0cmFpbGluZyBIVFRQIHdoaXRlc3BhY2UgZnJvbSBwYXJhbWV0ZXJWYWx1ZS5cbiAgICAgIHBhcmFtZXRlclZhbHVlID0gcmVtb3ZlSFRUUFdoaXRlc3BhY2UocGFyYW1ldGVyVmFsdWUsIGZhbHNlLCB0cnVlKVxuXG4gICAgICAvLyAzLiBJZiBwYXJhbWV0ZXJWYWx1ZSBpcyB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuIGNvbnRpbnVlLlxuICAgICAgaWYgKHBhcmFtZXRlclZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDEwLiBJZiBhbGwgb2YgdGhlIGZvbGxvd2luZyBhcmUgdHJ1ZVxuICAgIC8vIC0gcGFyYW1ldGVyTmFtZSBpcyBub3QgdGhlIGVtcHR5IHN0cmluZ1xuICAgIC8vIC0gcGFyYW1ldGVyTmFtZSBzb2xlbHkgY29udGFpbnMgSFRUUCB0b2tlbiBjb2RlIHBvaW50c1xuICAgIC8vIC0gcGFyYW1ldGVyVmFsdWUgc29sZWx5IGNvbnRhaW5zIEhUVFAgcXVvdGVkLXN0cmluZyB0b2tlbiBjb2RlIHBvaW50c1xuICAgIC8vIC0gbWltZVR5cGXigJlzIHBhcmFtZXRlcnNbcGFyYW1ldGVyTmFtZV0gZG9lcyBub3QgZXhpc3RcbiAgICAvLyB0aGVuIHNldCBtaW1lVHlwZeKAmXMgcGFyYW1ldGVyc1twYXJhbWV0ZXJOYW1lXSB0byBwYXJhbWV0ZXJWYWx1ZS5cbiAgICBpZiAoXG4gICAgICBwYXJhbWV0ZXJOYW1lLmxlbmd0aCAhPT0gMCAmJlxuICAgICAgSFRUUF9UT0tFTl9DT0RFUE9JTlRTLnRlc3QocGFyYW1ldGVyTmFtZSkgJiZcbiAgICAgIChwYXJhbWV0ZXJWYWx1ZS5sZW5ndGggPT09IDAgfHwgSFRUUF9RVU9URURfU1RSSU5HX1RPS0VOUy50ZXN0KHBhcmFtZXRlclZhbHVlKSkgJiZcbiAgICAgICFtaW1lVHlwZS5wYXJhbWV0ZXJzLmhhcyhwYXJhbWV0ZXJOYW1lKVxuICAgICkge1xuICAgICAgbWltZVR5cGUucGFyYW1ldGVycy5zZXQocGFyYW1ldGVyTmFtZSwgcGFyYW1ldGVyVmFsdWUpXG4gICAgfVxuICB9XG5cbiAgLy8gMTIuIFJldHVybiBtaW1lVHlwZS5cbiAgcmV0dXJuIG1pbWVUeXBlXG59XG5cbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNmb3JnaXZpbmctYmFzZTY0LWRlY29kZVxuLyoqIEBwYXJhbSB7c3RyaW5nfSBkYXRhICovXG5mdW5jdGlvbiBmb3JnaXZpbmdCYXNlNjQgKGRhdGEpIHtcbiAgLy8gMS4gUmVtb3ZlIGFsbCBBU0NJSSB3aGl0ZXNwYWNlIGZyb20gZGF0YS5cbiAgZGF0YSA9IGRhdGEucmVwbGFjZSgvW1xcdTAwMDlcXHUwMDBBXFx1MDAwQ1xcdTAwMERcXHUwMDIwXS9nLCAnJykgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAvLyAyLiBJZiBkYXRh4oCZcyBjb2RlIHBvaW50IGxlbmd0aCBkaXZpZGVzIGJ5IDQgbGVhdmluZ1xuICAvLyBubyByZW1haW5kZXIsIHRoZW46XG4gIGlmIChkYXRhLmxlbmd0aCAlIDQgPT09IDApIHtcbiAgICAvLyAxLiBJZiBkYXRhIGVuZHMgd2l0aCBvbmUgb3IgdHdvIFUrMDAzRCAoPSkgY29kZSBwb2ludHMsXG4gICAgLy8gdGhlbiByZW1vdmUgdGhlbSBmcm9tIGRhdGEuXG4gICAgZGF0YSA9IGRhdGEucmVwbGFjZSgvPT89JC8sICcnKVxuICB9XG5cbiAgLy8gMy4gSWYgZGF0YeKAmXMgY29kZSBwb2ludCBsZW5ndGggZGl2aWRlcyBieSA0IGxlYXZpbmdcbiAgLy8gYSByZW1haW5kZXIgb2YgMSwgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgaWYgKGRhdGEubGVuZ3RoICUgNCA9PT0gMSkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDQuIElmIGRhdGEgY29udGFpbnMgYSBjb2RlIHBvaW50IHRoYXQgaXMgbm90IG9uZSBvZlxuICAvLyAgVSswMDJCICgrKVxuICAvLyAgVSswMDJGICgvKVxuICAvLyAgQVNDSUkgYWxwaGFudW1lcmljXG4gIC8vIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmICgvW14rLzAtOUEtWmEtel0vLnRlc3QoZGF0YSkpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICBjb25zdCBiaW5hcnkgPSBhdG9iKGRhdGEpXG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5Lmxlbmd0aClcblxuICBmb3IgKGxldCBieXRlID0gMDsgYnl0ZSA8IGJpbmFyeS5sZW5ndGg7IGJ5dGUrKykge1xuICAgIGJ5dGVzW2J5dGVdID0gYmluYXJ5LmNoYXJDb2RlQXQoYnl0ZSlcbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29sbGVjdC1hbi1odHRwLXF1b3RlZC1zdHJpbmdcbi8vIHRlc3RzOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZXhhbXBsZS1odHRwLXF1b3RlZC1zdHJpbmdcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKiBAcGFyYW0ge3sgcG9zaXRpb246IG51bWJlciB9fSBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFuP30gZXh0cmFjdFZhbHVlXG4gKi9cbmZ1bmN0aW9uIGNvbGxlY3RBbkhUVFBRdW90ZWRTdHJpbmcgKGlucHV0LCBwb3NpdGlvbiwgZXh0cmFjdFZhbHVlKSB7XG4gIC8vIDEuIExldCBwb3NpdGlvblN0YXJ0IGJlIHBvc2l0aW9uLlxuICBjb25zdCBwb3NpdGlvblN0YXJ0ID0gcG9zaXRpb24ucG9zaXRpb25cblxuICAvLyAyLiBMZXQgdmFsdWUgYmUgdGhlIGVtcHR5IHN0cmluZy5cbiAgbGV0IHZhbHVlID0gJydcblxuICAvLyAzLiBBc3NlcnQ6IHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBpbnB1dFxuICAvLyBpcyBVKzAwMjIgKFwiKS5cbiAgYXNzZXJ0KGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSA9PT0gJ1wiJylcblxuICAvLyA0LiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuXG4gIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAvLyA1LiBXaGlsZSB0cnVlOlxuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIDEuIEFwcGVuZCB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50c1xuICAgIC8vIHRoYXQgYXJlIG5vdCBVKzAwMjIgKFwiKSBvciBVKzAwNUMgKFxcKSBmcm9tIGlucHV0LCBnaXZlblxuICAgIC8vIHBvc2l0aW9uLCB0byB2YWx1ZS5cbiAgICB2YWx1ZSArPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgICAgKGNoYXIpID0+IGNoYXIgIT09ICdcIicgJiYgY2hhciAhPT0gJ1xcXFwnLFxuICAgICAgaW5wdXQsXG4gICAgICBwb3NpdGlvblxuICAgIClcblxuICAgIC8vIDIuIElmIHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgdGhlbiBicmVhay5cbiAgICBpZiAocG9zaXRpb24ucG9zaXRpb24gPj0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIC8vIDMuIExldCBxdW90ZU9yQmFja3NsYXNoIGJlIHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpblxuICAgIC8vIGlucHV0LlxuICAgIGNvbnN0IHF1b3RlT3JCYWNrc2xhc2ggPSBpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl1cblxuICAgIC8vIDQuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgICAvLyA1LiBJZiBxdW90ZU9yQmFja3NsYXNoIGlzIFUrMDA1QyAoXFwpLCB0aGVuOlxuICAgIGlmIChxdW90ZU9yQmFja3NsYXNoID09PSAnXFxcXCcpIHtcbiAgICAgIC8vIDEuIElmIHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgdGhlbiBhcHBlbmRcbiAgICAgIC8vIFUrMDA1QyAoXFwpIHRvIHZhbHVlIGFuZCBicmVhay5cbiAgICAgIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA+PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgKz0gJ1xcXFwnXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIEFwcGVuZCB0aGUgY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW4gaW5wdXQgdG8gdmFsdWUuXG4gICAgICB2YWx1ZSArPSBpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl1cblxuICAgICAgLy8gMy4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICAgICAgcG9zaXRpb24ucG9zaXRpb24rK1xuXG4gICAgLy8gNi4gT3RoZXJ3aXNlOlxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAxLiBBc3NlcnQ6IHF1b3RlT3JCYWNrc2xhc2ggaXMgVSswMDIyIChcIikuXG4gICAgICBhc3NlcnQocXVvdGVPckJhY2tzbGFzaCA9PT0gJ1wiJylcblxuICAgICAgLy8gMi4gQnJlYWsuXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIDYuIElmIHRoZSBleHRyYWN0LXZhbHVlIGZsYWcgaXMgc2V0LCB0aGVuIHJldHVybiB2YWx1ZS5cbiAgaWYgKGV4dHJhY3RWYWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLy8gNy4gUmV0dXJuIHRoZSBjb2RlIHBvaW50cyBmcm9tIHBvc2l0aW9uU3RhcnQgdG8gcG9zaXRpb24sXG4gIC8vIGluY2x1c2l2ZSwgd2l0aGluIGlucHV0LlxuICByZXR1cm4gaW5wdXQuc2xpY2UocG9zaXRpb25TdGFydCwgcG9zaXRpb24ucG9zaXRpb24pXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL21pbWVzbmlmZi5zcGVjLndoYXR3Zy5vcmcvI3NlcmlhbGl6ZS1hLW1pbWUtdHlwZVxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVBTWltZVR5cGUgKG1pbWVUeXBlKSB7XG4gIGFzc2VydChtaW1lVHlwZSAhPT0gJ2ZhaWx1cmUnKVxuICBjb25zdCB7IHBhcmFtZXRlcnMsIGVzc2VuY2UgfSA9IG1pbWVUeXBlXG5cbiAgLy8gMS4gTGV0IHNlcmlhbGl6YXRpb24gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgbWltZVR5cGXigJlzXG4gIC8vICAgIHR5cGUsIFUrMDAyRiAoLyksIGFuZCBtaW1lVHlwZeKAmXMgc3VidHlwZS5cbiAgbGV0IHNlcmlhbGl6YXRpb24gPSBlc3NlbmNlXG5cbiAgLy8gMi4gRm9yIGVhY2ggbmFtZSDihpIgdmFsdWUgb2YgbWltZVR5cGXigJlzIHBhcmFtZXRlcnM6XG4gIGZvciAobGV0IFtuYW1lLCB2YWx1ZV0gb2YgcGFyYW1ldGVycy5lbnRyaWVzKCkpIHtcbiAgICAvLyAxLiBBcHBlbmQgVSswMDNCICg7KSB0byBzZXJpYWxpemF0aW9uLlxuICAgIHNlcmlhbGl6YXRpb24gKz0gJzsnXG5cbiAgICAvLyAyLiBBcHBlbmQgbmFtZSB0byBzZXJpYWxpemF0aW9uLlxuICAgIHNlcmlhbGl6YXRpb24gKz0gbmFtZVxuXG4gICAgLy8gMy4gQXBwZW5kIFUrMDAzRCAoPSkgdG8gc2VyaWFsaXphdGlvbi5cbiAgICBzZXJpYWxpemF0aW9uICs9ICc9J1xuXG4gICAgLy8gNC4gSWYgdmFsdWUgZG9lcyBub3Qgc29sZWx5IGNvbnRhaW4gSFRUUCB0b2tlbiBjb2RlXG4gICAgLy8gICAgcG9pbnRzIG9yIHZhbHVlIGlzIHRoZSBlbXB0eSBzdHJpbmcsIHRoZW46XG4gICAgaWYgKCFIVFRQX1RPS0VOX0NPREVQT0lOVFMudGVzdCh2YWx1ZSkpIHtcbiAgICAgIC8vIDEuIFByZWNlZGUgZWFjaCBvY2N1cmVuY2Ugb2YgVSswMDIyIChcIikgb3JcbiAgICAgIC8vICAgIFUrMDA1QyAoXFwpIGluIHZhbHVlIHdpdGggVSswMDVDIChcXCkuXG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLyhcXFxcfFwiKS9nLCAnXFxcXCQxJylcblxuICAgICAgLy8gMi4gUHJlcGVuZCBVKzAwMjIgKFwiKSB0byB2YWx1ZS5cbiAgICAgIHZhbHVlID0gJ1wiJyArIHZhbHVlXG5cbiAgICAgIC8vIDMuIEFwcGVuZCBVKzAwMjIgKFwiKSB0byB2YWx1ZS5cbiAgICAgIHZhbHVlICs9ICdcIidcbiAgICB9XG5cbiAgICAvLyA1LiBBcHBlbmQgdmFsdWUgdG8gc2VyaWFsaXphdGlvbi5cbiAgICBzZXJpYWxpemF0aW9uICs9IHZhbHVlXG4gIH1cblxuICAvLyAzLiBSZXR1cm4gc2VyaWFsaXphdGlvbi5cbiAgcmV0dXJuIHNlcmlhbGl6YXRpb25cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLXdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyXG4gKi9cbmZ1bmN0aW9uIGlzSFRUUFdoaXRlU3BhY2UgKGNoYXIpIHtcbiAgcmV0dXJuIGNoYXIgPT09ICdcXHInIHx8IGNoYXIgPT09ICdcXG4nIHx8IGNoYXIgPT09ICdcXHQnIHx8IGNoYXIgPT09ICcgJ1xufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtd2hpdGVzcGFjZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICovXG5mdW5jdGlvbiByZW1vdmVIVFRQV2hpdGVzcGFjZSAoc3RyLCBsZWFkaW5nID0gdHJ1ZSwgdHJhaWxpbmcgPSB0cnVlKSB7XG4gIGxldCBsZWFkID0gMFxuICBsZXQgdHJhaWwgPSBzdHIubGVuZ3RoIC0gMVxuXG4gIGlmIChsZWFkaW5nKSB7XG4gICAgZm9yICg7IGxlYWQgPCBzdHIubGVuZ3RoICYmIGlzSFRUUFdoaXRlU3BhY2Uoc3RyW2xlYWRdKTsgbGVhZCsrKTtcbiAgfVxuXG4gIGlmICh0cmFpbGluZykge1xuICAgIGZvciAoOyB0cmFpbCA+IDAgJiYgaXNIVFRQV2hpdGVTcGFjZShzdHJbdHJhaWxdKTsgdHJhaWwtLSk7XG4gIH1cblxuICByZXR1cm4gc3RyLnNsaWNlKGxlYWQsIHRyYWlsICsgMSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNhc2NpaS13aGl0ZXNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhclxuICovXG5mdW5jdGlvbiBpc0FTQ0lJV2hpdGVzcGFjZSAoY2hhcikge1xuICByZXR1cm4gY2hhciA9PT0gJ1xccicgfHwgY2hhciA9PT0gJ1xcbicgfHwgY2hhciA9PT0gJ1xcdCcgfHwgY2hhciA9PT0gJ1xcZicgfHwgY2hhciA9PT0gJyAnXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtbGVhZGluZy1hbmQtdHJhaWxpbmctYXNjaWktd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiByZW1vdmVBU0NJSVdoaXRlc3BhY2UgKHN0ciwgbGVhZGluZyA9IHRydWUsIHRyYWlsaW5nID0gdHJ1ZSkge1xuICBsZXQgbGVhZCA9IDBcbiAgbGV0IHRyYWlsID0gc3RyLmxlbmd0aCAtIDFcblxuICBpZiAobGVhZGluZykge1xuICAgIGZvciAoOyBsZWFkIDwgc3RyLmxlbmd0aCAmJiBpc0FTQ0lJV2hpdGVzcGFjZShzdHJbbGVhZF0pOyBsZWFkKyspO1xuICB9XG5cbiAgaWYgKHRyYWlsaW5nKSB7XG4gICAgZm9yICg7IHRyYWlsID4gMCAmJiBpc0FTQ0lJV2hpdGVzcGFjZShzdHJbdHJhaWxdKTsgdHJhaWwtLSk7XG4gIH1cblxuICByZXR1cm4gc3RyLnNsaWNlKGxlYWQsIHRyYWlsICsgMSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRhdGFVUkxQcm9jZXNzb3IsXG4gIFVSTFNlcmlhbGl6ZXIsXG4gIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMsXG4gIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0LFxuICBzdHJpbmdQZXJjZW50RGVjb2RlLFxuICBwYXJzZU1JTUVUeXBlLFxuICBjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nLFxuICBzZXJpYWxpemVBTWltZVR5cGVcbn1cbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwiYXRvYiIsImlzb21vcnBoaWNEZWNvZGUiLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJIVFRQX1RPS0VOX0NPREVQT0lOVFMiLCJIVFRQX1dISVRFU1BBQ0VfUkVHRVgiLCJIVFRQX1FVT1RFRF9TVFJJTkdfVE9LRU5TIiwiZGF0YVVSTFByb2Nlc3NvciIsImRhdGFVUkwiLCJwcm90b2NvbCIsImlucHV0IiwiVVJMU2VyaWFsaXplciIsInNsaWNlIiwicG9zaXRpb24iLCJtaW1lVHlwZSIsImNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0IiwibWltZVR5cGVMZW5ndGgiLCJsZW5ndGgiLCJyZW1vdmVBU0NJSVdoaXRlc3BhY2UiLCJlbmNvZGVkQm9keSIsImJvZHkiLCJzdHJpbmdQZXJjZW50RGVjb2RlIiwidGVzdCIsInN0cmluZ0JvZHkiLCJmb3JnaXZpbmdCYXNlNjQiLCJyZXBsYWNlIiwic3RhcnRzV2l0aCIsIm1pbWVUeXBlUmVjb3JkIiwicGFyc2VNSU1FVHlwZSIsInVybCIsImV4Y2x1ZGVGcmFnbWVudCIsImhyZWYiLCJoYXNoTGVuZ3RoIiwiaGFzaCIsInN1YnN0cmluZyIsImNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMiLCJjb25kaXRpb24iLCJyZXN1bHQiLCJjaGFyIiwiaWR4IiwiaW5kZXhPZiIsInN0YXJ0IiwiYnl0ZXMiLCJlbmNvZGUiLCJwZXJjZW50RGVjb2RlIiwib3V0cHV0IiwiaSIsImJ5dGUiLCJwdXNoIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwibmV4dFR3b0J5dGVzIiwiYnl0ZVBvaW50IiwiTnVtYmVyIiwicGFyc2VJbnQiLCJVaW50OEFycmF5IiwiZnJvbSIsInJlbW92ZUhUVFBXaGl0ZXNwYWNlIiwidHlwZSIsInN1YnR5cGUiLCJ0eXBlTG93ZXJjYXNlIiwidG9Mb3dlckNhc2UiLCJzdWJ0eXBlTG93ZXJjYXNlIiwicGFyYW1ldGVycyIsIk1hcCIsImVzc2VuY2UiLCJwYXJhbWV0ZXJOYW1lIiwicGFyYW1ldGVyVmFsdWUiLCJjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nIiwiaGFzIiwic2V0IiwiZGF0YSIsImJpbmFyeSIsImNoYXJDb2RlQXQiLCJleHRyYWN0VmFsdWUiLCJwb3NpdGlvblN0YXJ0IiwidmFsdWUiLCJxdW90ZU9yQmFja3NsYXNoIiwic2VyaWFsaXplQU1pbWVUeXBlIiwic2VyaWFsaXphdGlvbiIsIm5hbWUiLCJlbnRyaWVzIiwiaXNIVFRQV2hpdGVTcGFjZSIsInN0ciIsImxlYWRpbmciLCJ0cmFpbGluZyIsImxlYWQiLCJ0cmFpbCIsImlzQVNDSUlXaGl0ZXNwYWNlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/dataURL.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/file.js":
/*!*********************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/fetch/file.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Blob, File: NativeFile } = __webpack_require__(/*! buffer */ \"buffer\");\nconst { types } = __webpack_require__(/*! util */ \"util\");\nconst { kState } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/symbols.js\");\nconst { isBlobLike } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/util.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/webidl.js\");\nconst { parseMIMEType, serializeAMimeType } = __webpack_require__(/*! ./dataURL */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/dataURL.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst encoder = new TextEncoder();\nclass File extends Blob {\n    constructor(fileBits, fileName, options = {}){\n        // The File constructor is invoked with two or three parameters, depending\n        // on whether the optional dictionary parameter is used. When the File()\n        // constructor is invoked, user agents must run the following steps:\n        webidl.argumentLengthCheck(arguments, 2, {\n            header: \"File constructor\"\n        });\n        fileBits = webidl.converters[\"sequence<BlobPart>\"](fileBits);\n        fileName = webidl.converters.USVString(fileName);\n        options = webidl.converters.FilePropertyBag(options);\n        // 1. Let bytes be the result of processing blob parts given fileBits and\n        // options.\n        // Note: Blob handles this for us\n        // 2. Let n be the fileName argument to the constructor.\n        const n = fileName;\n        // 3. Process FilePropertyBag dictionary argument by running the following\n        // substeps:\n        //    1. If the type member is provided and is not the empty string, let t\n        //    be set to the type dictionary member. If t contains any characters\n        //    outside the range U+0020 to U+007E, then set t to the empty string\n        //    and return from these substeps.\n        //    2. Convert every character in t to ASCII lowercase.\n        let t = options.type;\n        let d;\n        // eslint-disable-next-line no-labels\n        substep: {\n            if (t) {\n                t = parseMIMEType(t);\n                if (t === \"failure\") {\n                    t = \"\";\n                    break substep;\n                }\n                t = serializeAMimeType(t).toLowerCase();\n            }\n            //    3. If the lastModified member is provided, let d be set to the\n            //    lastModified dictionary member. If it is not provided, set d to the\n            //    current date and time represented as the number of milliseconds since\n            //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).\n            d = options.lastModified;\n        }\n        // 4. Return a new File object F such that:\n        // F refers to the bytes byte sequence.\n        // F.size is set to the number of total bytes in bytes.\n        // F.name is set to n.\n        // F.type is set to t.\n        // F.lastModified is set to d.\n        super(processBlobParts(fileBits, options), {\n            type: t\n        });\n        this[kState] = {\n            name: n,\n            lastModified: d,\n            type: t\n        };\n    }\n    get name() {\n        webidl.brandCheck(this, File);\n        return this[kState].name;\n    }\n    get lastModified() {\n        webidl.brandCheck(this, File);\n        return this[kState].lastModified;\n    }\n    get type() {\n        webidl.brandCheck(this, File);\n        return this[kState].type;\n    }\n}\nclass FileLike {\n    constructor(blobLike, fileName, options = {}){\n        // TODO: argument idl type check\n        // The File constructor is invoked with two or three parameters, depending\n        // on whether the optional dictionary parameter is used. When the File()\n        // constructor is invoked, user agents must run the following steps:\n        // 1. Let bytes be the result of processing blob parts given fileBits and\n        // options.\n        // 2. Let n be the fileName argument to the constructor.\n        const n = fileName;\n        // 3. Process FilePropertyBag dictionary argument by running the following\n        // substeps:\n        //    1. If the type member is provided and is not the empty string, let t\n        //    be set to the type dictionary member. If t contains any characters\n        //    outside the range U+0020 to U+007E, then set t to the empty string\n        //    and return from these substeps.\n        //    TODO\n        const t = options.type;\n        //    2. Convert every character in t to ASCII lowercase.\n        //    TODO\n        //    3. If the lastModified member is provided, let d be set to the\n        //    lastModified dictionary member. If it is not provided, set d to the\n        //    current date and time represented as the number of milliseconds since\n        //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).\n        const d = options.lastModified ?? Date.now();\n        // 4. Return a new File object F such that:\n        // F refers to the bytes byte sequence.\n        // F.size is set to the number of total bytes in bytes.\n        // F.name is set to n.\n        // F.type is set to t.\n        // F.lastModified is set to d.\n        this[kState] = {\n            blobLike,\n            name: n,\n            type: t,\n            lastModified: d\n        };\n    }\n    stream(...args) {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.stream(...args);\n    }\n    arrayBuffer(...args) {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.arrayBuffer(...args);\n    }\n    slice(...args) {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.slice(...args);\n    }\n    text(...args) {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.text(...args);\n    }\n    get size() {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.size;\n    }\n    get type() {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.type;\n    }\n    get name() {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].name;\n    }\n    get lastModified() {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].lastModified;\n    }\n    get [Symbol.toStringTag]() {\n        return \"File\";\n    }\n}\nObject.defineProperties(File.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"File\",\n        configurable: true\n    },\n    name: kEnumerableProperty,\n    lastModified: kEnumerableProperty\n});\nwebidl.converters.Blob = webidl.interfaceConverter(Blob);\nwebidl.converters.BlobPart = function(V, opts) {\n    if (webidl.util.Type(V) === \"Object\") {\n        if (isBlobLike(V)) {\n            return webidl.converters.Blob(V, {\n                strict: false\n            });\n        }\n        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {\n            return webidl.converters.BufferSource(V, opts);\n        }\n    }\n    return webidl.converters.USVString(V, opts);\n};\nwebidl.converters[\"sequence<BlobPart>\"] = webidl.sequenceConverter(webidl.converters.BlobPart);\n// https://www.w3.org/TR/FileAPI/#dfn-FilePropertyBag\nwebidl.converters.FilePropertyBag = webidl.dictionaryConverter([\n    {\n        key: \"lastModified\",\n        converter: webidl.converters[\"long long\"],\n        get defaultValue () {\n            return Date.now();\n        }\n    },\n    {\n        key: \"type\",\n        converter: webidl.converters.DOMString,\n        defaultValue: \"\"\n    },\n    {\n        key: \"endings\",\n        converter: (value)=>{\n            value = webidl.converters.DOMString(value);\n            value = value.toLowerCase();\n            if (value !== \"native\") {\n                value = \"transparent\";\n            }\n            return value;\n        },\n        defaultValue: \"transparent\"\n    }\n]);\n/**\n * @see https://www.w3.org/TR/FileAPI/#process-blob-parts\n * @param {(NodeJS.TypedArray|Blob|string)[]} parts\n * @param {{ type: string, endings: string }} options\n */ function processBlobParts(parts, options) {\n    // 1. Let bytes be an empty sequence of bytes.\n    /** @type {NodeJS.TypedArray[]} */ const bytes = [];\n    // 2. For each element in parts:\n    for (const element of parts){\n        // 1. If element is a USVString, run the following substeps:\n        if (typeof element === \"string\") {\n            // 1. Let s be element.\n            let s = element;\n            // 2. If the endings member of options is \"native\", set s\n            //    to the result of converting line endings to native\n            //    of element.\n            if (options.endings === \"native\") {\n                s = convertLineEndingsNative(s);\n            }\n            // 3. Append the result of UTF-8 encoding s to bytes.\n            bytes.push(encoder.encode(s));\n        } else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element)) {\n            // 2. If element is a BufferSource, get a copy of the\n            //    bytes held by the buffer source, and append those\n            //    bytes to bytes.\n            if (!element.buffer) {\n                bytes.push(new Uint8Array(element));\n            } else {\n                bytes.push(new Uint8Array(element.buffer, element.byteOffset, element.byteLength));\n            }\n        } else if (isBlobLike(element)) {\n            // 3. If element is a Blob, append the bytes it represents\n            //    to bytes.\n            bytes.push(element);\n        }\n    }\n    // 3. Return bytes.\n    return bytes;\n}\n/**\n * @see https://www.w3.org/TR/FileAPI/#convert-line-endings-to-native\n * @param {string} s\n */ function convertLineEndingsNative(s) {\n    // 1. Let native line ending be be the code point U+000A LF.\n    let nativeLineEnding = \"\\n\";\n    // 2. If the underlying platforms conventions are to\n    //    represent newlines as a carriage return and line feed\n    //    sequence, set native line ending to the code point\n    //    U+000D CR followed by the code point U+000A LF.\n    if (process.platform === \"win32\") {\n        nativeLineEnding = \"\\r\\n\";\n    }\n    return s.replace(/\\r?\\n/g, nativeLineEnding);\n}\n// If this function is moved to ./util.js, some tools (such as\n// rollup) will warn about circular dependencies. See:\n// https://github.com/nodejs/undici/issues/1629\nfunction isFileLike(object) {\n    return NativeFile && object instanceof NativeFile || object instanceof File || object && (typeof object.stream === \"function\" || typeof object.arrayBuffer === \"function\") && object[Symbol.toStringTag] === \"File\";\n}\nmodule.exports = {\n    File,\n    FileLike,\n    isFileLike\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvZmlsZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsSUFBSSxFQUFFQyxNQUFNQyxVQUFVLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDM0MsTUFBTSxFQUFFQyxLQUFLLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFDMUIsTUFBTSxFQUFFRSxNQUFNLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFRyxVQUFVLEVBQUUsR0FBR0gsbUJBQU9BLENBQUM7QUFDL0IsTUFBTSxFQUFFSSxNQUFNLEVBQUUsR0FBR0osbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFSyxhQUFhLEVBQUVDLGtCQUFrQixFQUFFLEdBQUdOLG1CQUFPQSxDQUFDO0FBQ3RELE1BQU0sRUFBRU8sbUJBQW1CLEVBQUUsR0FBR1AsbUJBQU9BLENBQUM7QUFDeEMsTUFBTVEsVUFBVSxJQUFJQztBQUVwQixNQUFNWCxhQUFhRDtJQUNqQmEsWUFBYUMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLENBQUU7UUFDN0MsMEVBQTBFO1FBQzFFLHdFQUF3RTtRQUN4RSxvRUFBb0U7UUFDcEVULE9BQU9VLG1CQUFtQixDQUFDQyxXQUFXLEdBQUc7WUFBRUMsUUFBUTtRQUFtQjtRQUV0RUwsV0FBV1AsT0FBT2EsVUFBVSxDQUFDLHFCQUFxQixDQUFDTjtRQUNuREMsV0FBV1IsT0FBT2EsVUFBVSxDQUFDQyxTQUFTLENBQUNOO1FBQ3ZDQyxVQUFVVCxPQUFPYSxVQUFVLENBQUNFLGVBQWUsQ0FBQ047UUFFNUMseUVBQXlFO1FBQ3pFLFdBQVc7UUFDWCxpQ0FBaUM7UUFFakMsd0RBQXdEO1FBQ3hELE1BQU1PLElBQUlSO1FBRVYsMEVBQTBFO1FBQzFFLFlBQVk7UUFFWiwwRUFBMEU7UUFDMUUsd0VBQXdFO1FBQ3hFLHdFQUF3RTtRQUN4RSxx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VUFDQyxRQUFPQSxPQUFPaEQsTUFBTSxLQUFLLGNBQzFCLE9BQU9nRCxPQUFPOUMsV0FBVyxLQUFLLFVBQVMsS0FDdkM4QyxNQUFNLENBQUMxQyxPQUFPQyxXQUFXLENBQUMsS0FBSztBQUdyQztBQUVBMEMsT0FBT0MsT0FBTyxHQUFHO0lBQUV0RjtJQUFNZ0M7SUFBVW1EO0FBQVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9maWxlLmpzPzJjYjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQmxvYiwgRmlsZTogTmF0aXZlRmlsZSB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IHsgdHlwZXMgfSA9IHJlcXVpcmUoJ3V0aWwnKVxuY29uc3QgeyBrU3RhdGUgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IGlzQmxvYkxpa2UgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi93ZWJpZGwnKVxuY29uc3QgeyBwYXJzZU1JTUVUeXBlLCBzZXJpYWxpemVBTWltZVR5cGUgfSA9IHJlcXVpcmUoJy4vZGF0YVVSTCcpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcblxuY2xhc3MgRmlsZSBleHRlbmRzIEJsb2Ige1xuICBjb25zdHJ1Y3RvciAoZmlsZUJpdHMsIGZpbGVOYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICAvLyBUaGUgRmlsZSBjb25zdHJ1Y3RvciBpcyBpbnZva2VkIHdpdGggdHdvIG9yIHRocmVlIHBhcmFtZXRlcnMsIGRlcGVuZGluZ1xuICAgIC8vIG9uIHdoZXRoZXIgdGhlIG9wdGlvbmFsIGRpY3Rpb25hcnkgcGFyYW1ldGVyIGlzIHVzZWQuIFdoZW4gdGhlIEZpbGUoKVxuICAgIC8vIGNvbnN0cnVjdG9yIGlzIGludm9rZWQsIHVzZXIgYWdlbnRzIG11c3QgcnVuIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCB7IGhlYWRlcjogJ0ZpbGUgY29uc3RydWN0b3InIH0pXG5cbiAgICBmaWxlQml0cyA9IHdlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxCbG9iUGFydD4nXShmaWxlQml0cylcbiAgICBmaWxlTmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhmaWxlTmFtZSlcbiAgICBvcHRpb25zID0gd2ViaWRsLmNvbnZlcnRlcnMuRmlsZVByb3BlcnR5QmFnKG9wdGlvbnMpXG5cbiAgICAvLyAxLiBMZXQgYnl0ZXMgYmUgdGhlIHJlc3VsdCBvZiBwcm9jZXNzaW5nIGJsb2IgcGFydHMgZ2l2ZW4gZmlsZUJpdHMgYW5kXG4gICAgLy8gb3B0aW9ucy5cbiAgICAvLyBOb3RlOiBCbG9iIGhhbmRsZXMgdGhpcyBmb3IgdXNcblxuICAgIC8vIDIuIExldCBuIGJlIHRoZSBmaWxlTmFtZSBhcmd1bWVudCB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgY29uc3QgbiA9IGZpbGVOYW1lXG5cbiAgICAvLyAzLiBQcm9jZXNzIEZpbGVQcm9wZXJ0eUJhZyBkaWN0aW9uYXJ5IGFyZ3VtZW50IGJ5IHJ1bm5pbmcgdGhlIGZvbGxvd2luZ1xuICAgIC8vIHN1YnN0ZXBzOlxuXG4gICAgLy8gICAgMS4gSWYgdGhlIHR5cGUgbWVtYmVyIGlzIHByb3ZpZGVkIGFuZCBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IHRcbiAgICAvLyAgICBiZSBzZXQgdG8gdGhlIHR5cGUgZGljdGlvbmFyeSBtZW1iZXIuIElmIHQgY29udGFpbnMgYW55IGNoYXJhY3RlcnNcbiAgICAvLyAgICBvdXRzaWRlIHRoZSByYW5nZSBVKzAwMjAgdG8gVSswMDdFLCB0aGVuIHNldCB0IHRvIHRoZSBlbXB0eSBzdHJpbmdcbiAgICAvLyAgICBhbmQgcmV0dXJuIGZyb20gdGhlc2Ugc3Vic3RlcHMuXG4gICAgLy8gICAgMi4gQ29udmVydCBldmVyeSBjaGFyYWN0ZXIgaW4gdCB0byBBU0NJSSBsb3dlcmNhc2UuXG4gICAgbGV0IHQgPSBvcHRpb25zLnR5cGVcbiAgICBsZXQgZFxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxhYmVsc1xuICAgIHN1YnN0ZXA6IHtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIHQgPSBwYXJzZU1JTUVUeXBlKHQpXG5cbiAgICAgICAgaWYgKHQgPT09ICdmYWlsdXJlJykge1xuICAgICAgICAgIHQgPSAnJ1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sYWJlbHNcbiAgICAgICAgICBicmVhayBzdWJzdGVwXG4gICAgICAgIH1cblxuICAgICAgICB0ID0gc2VyaWFsaXplQU1pbWVUeXBlKHQpLnRvTG93ZXJDYXNlKClcbiAgICAgIH1cblxuICAgICAgLy8gICAgMy4gSWYgdGhlIGxhc3RNb2RpZmllZCBtZW1iZXIgaXMgcHJvdmlkZWQsIGxldCBkIGJlIHNldCB0byB0aGVcbiAgICAgIC8vICAgIGxhc3RNb2RpZmllZCBkaWN0aW9uYXJ5IG1lbWJlci4gSWYgaXQgaXMgbm90IHByb3ZpZGVkLCBzZXQgZCB0byB0aGVcbiAgICAgIC8vICAgIGN1cnJlbnQgZGF0ZSBhbmQgdGltZSByZXByZXNlbnRlZCBhcyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZVxuICAgICAgLy8gICAgdGhlIFVuaXggRXBvY2ggKHdoaWNoIGlzIHRoZSBlcXVpdmFsZW50IG9mIERhdGUubm93KCkgW0VDTUEtMjYyXSkuXG4gICAgICBkID0gb3B0aW9ucy5sYXN0TW9kaWZpZWRcbiAgICB9XG5cbiAgICAvLyA0LiBSZXR1cm4gYSBuZXcgRmlsZSBvYmplY3QgRiBzdWNoIHRoYXQ6XG4gICAgLy8gRiByZWZlcnMgdG8gdGhlIGJ5dGVzIGJ5dGUgc2VxdWVuY2UuXG4gICAgLy8gRi5zaXplIGlzIHNldCB0byB0aGUgbnVtYmVyIG9mIHRvdGFsIGJ5dGVzIGluIGJ5dGVzLlxuICAgIC8vIEYubmFtZSBpcyBzZXQgdG8gbi5cbiAgICAvLyBGLnR5cGUgaXMgc2V0IHRvIHQuXG4gICAgLy8gRi5sYXN0TW9kaWZpZWQgaXMgc2V0IHRvIGQuXG5cbiAgICBzdXBlcihwcm9jZXNzQmxvYlBhcnRzKGZpbGVCaXRzLCBvcHRpb25zKSwgeyB0eXBlOiB0IH0pXG4gICAgdGhpc1trU3RhdGVdID0ge1xuICAgICAgbmFtZTogbixcbiAgICAgIGxhc3RNb2RpZmllZDogZCxcbiAgICAgIHR5cGU6IHRcbiAgICB9XG4gIH1cblxuICBnZXQgbmFtZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubmFtZVxuICB9XG5cbiAgZ2V0IGxhc3RNb2RpZmllZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubGFzdE1vZGlmaWVkXG4gIH1cblxuICBnZXQgdHlwZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0udHlwZVxuICB9XG59XG5cbmNsYXNzIEZpbGVMaWtlIHtcbiAgY29uc3RydWN0b3IgKGJsb2JMaWtlLCBmaWxlTmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gVE9ETzogYXJndW1lbnQgaWRsIHR5cGUgY2hlY2tcblxuICAgIC8vIFRoZSBGaWxlIGNvbnN0cnVjdG9yIGlzIGludm9rZWQgd2l0aCB0d28gb3IgdGhyZWUgcGFyYW1ldGVycywgZGVwZW5kaW5nXG4gICAgLy8gb24gd2hldGhlciB0aGUgb3B0aW9uYWwgZGljdGlvbmFyeSBwYXJhbWV0ZXIgaXMgdXNlZC4gV2hlbiB0aGUgRmlsZSgpXG4gICAgLy8gY29uc3RydWN0b3IgaXMgaW52b2tlZCwgdXNlciBhZ2VudHMgbXVzdCBydW4gdGhlIGZvbGxvd2luZyBzdGVwczpcblxuICAgIC8vIDEuIExldCBieXRlcyBiZSB0aGUgcmVzdWx0IG9mIHByb2Nlc3NpbmcgYmxvYiBwYXJ0cyBnaXZlbiBmaWxlQml0cyBhbmRcbiAgICAvLyBvcHRpb25zLlxuXG4gICAgLy8gMi4gTGV0IG4gYmUgdGhlIGZpbGVOYW1lIGFyZ3VtZW50IHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICBjb25zdCBuID0gZmlsZU5hbWVcblxuICAgIC8vIDMuIFByb2Nlc3MgRmlsZVByb3BlcnR5QmFnIGRpY3Rpb25hcnkgYXJndW1lbnQgYnkgcnVubmluZyB0aGUgZm9sbG93aW5nXG4gICAgLy8gc3Vic3RlcHM6XG5cbiAgICAvLyAgICAxLiBJZiB0aGUgdHlwZSBtZW1iZXIgaXMgcHJvdmlkZWQgYW5kIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgdFxuICAgIC8vICAgIGJlIHNldCB0byB0aGUgdHlwZSBkaWN0aW9uYXJ5IG1lbWJlci4gSWYgdCBjb250YWlucyBhbnkgY2hhcmFjdGVyc1xuICAgIC8vICAgIG91dHNpZGUgdGhlIHJhbmdlIFUrMDAyMCB0byBVKzAwN0UsIHRoZW4gc2V0IHQgdG8gdGhlIGVtcHR5IHN0cmluZ1xuICAgIC8vICAgIGFuZCByZXR1cm4gZnJvbSB0aGVzZSBzdWJzdGVwcy5cbiAgICAvLyAgICBUT0RPXG4gICAgY29uc3QgdCA9IG9wdGlvbnMudHlwZVxuXG4gICAgLy8gICAgMi4gQ29udmVydCBldmVyeSBjaGFyYWN0ZXIgaW4gdCB0byBBU0NJSSBsb3dlcmNhc2UuXG4gICAgLy8gICAgVE9ET1xuXG4gICAgLy8gICAgMy4gSWYgdGhlIGxhc3RNb2RpZmllZCBtZW1iZXIgaXMgcHJvdmlkZWQsIGxldCBkIGJlIHNldCB0byB0aGVcbiAgICAvLyAgICBsYXN0TW9kaWZpZWQgZGljdGlvbmFyeSBtZW1iZXIuIElmIGl0IGlzIG5vdCBwcm92aWRlZCwgc2V0IGQgdG8gdGhlXG4gICAgLy8gICAgY3VycmVudCBkYXRlIGFuZCB0aW1lIHJlcHJlc2VudGVkIGFzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlXG4gICAgLy8gICAgdGhlIFVuaXggRXBvY2ggKHdoaWNoIGlzIHRoZSBlcXVpdmFsZW50IG9mIERhdGUubm93KCkgW0VDTUEtMjYyXSkuXG4gICAgY29uc3QgZCA9IG9wdGlvbnMubGFzdE1vZGlmaWVkID8/IERhdGUubm93KClcblxuICAgIC8vIDQuIFJldHVybiBhIG5ldyBGaWxlIG9iamVjdCBGIHN1Y2ggdGhhdDpcbiAgICAvLyBGIHJlZmVycyB0byB0aGUgYnl0ZXMgYnl0ZSBzZXF1ZW5jZS5cbiAgICAvLyBGLnNpemUgaXMgc2V0IHRvIHRoZSBudW1iZXIgb2YgdG90YWwgYnl0ZXMgaW4gYnl0ZXMuXG4gICAgLy8gRi5uYW1lIGlzIHNldCB0byBuLlxuICAgIC8vIEYudHlwZSBpcyBzZXQgdG8gdC5cbiAgICAvLyBGLmxhc3RNb2RpZmllZCBpcyBzZXQgdG8gZC5cblxuICAgIHRoaXNba1N0YXRlXSA9IHtcbiAgICAgIGJsb2JMaWtlLFxuICAgICAgbmFtZTogbixcbiAgICAgIHR5cGU6IHQsXG4gICAgICBsYXN0TW9kaWZpZWQ6IGRcbiAgICB9XG4gIH1cblxuICBzdHJlYW0gKC4uLmFyZ3MpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlTGlrZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYmxvYkxpa2Uuc3RyZWFtKC4uLmFyZ3MpXG4gIH1cblxuICBhcnJheUJ1ZmZlciAoLi4uYXJncykge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVMaWtlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ibG9iTGlrZS5hcnJheUJ1ZmZlciguLi5hcmdzKVxuICB9XG5cbiAgc2xpY2UgKC4uLmFyZ3MpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlTGlrZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYmxvYkxpa2Uuc2xpY2UoLi4uYXJncylcbiAgfVxuXG4gIHRleHQgKC4uLmFyZ3MpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlTGlrZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYmxvYkxpa2UudGV4dCguLi5hcmdzKVxuICB9XG5cbiAgZ2V0IHNpemUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVMaWtlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ibG9iTGlrZS5zaXplXG4gIH1cblxuICBnZXQgdHlwZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZUxpa2UpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJsb2JMaWtlLnR5cGVcbiAgfVxuXG4gIGdldCBuYW1lICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlTGlrZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubmFtZVxuICB9XG5cbiAgZ2V0IGxhc3RNb2RpZmllZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZUxpa2UpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmxhc3RNb2RpZmllZFxuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddICgpIHtcbiAgICByZXR1cm4gJ0ZpbGUnXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRmlsZS5wcm90b3R5cGUsIHtcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ0ZpbGUnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9LFxuICBuYW1lOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBsYXN0TW9kaWZpZWQ6IGtFbnVtZXJhYmxlUHJvcGVydHlcbn0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkJsb2IgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKEJsb2IpXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkJsb2JQYXJ0ID0gZnVuY3Rpb24gKFYsIG9wdHMpIHtcbiAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgPT09ICdPYmplY3QnKSB7XG4gICAgaWYgKGlzQmxvYkxpa2UoVikpIHtcbiAgICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5CbG9iKFYsIHsgc3RyaWN0OiBmYWxzZSB9KVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIEFycmF5QnVmZmVyLmlzVmlldyhWKSB8fFxuICAgICAgdHlwZXMuaXNBbnlBcnJheUJ1ZmZlcihWKVxuICAgICkge1xuICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkJ1ZmZlclNvdXJjZShWLCBvcHRzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoViwgb3B0cylcbn1cblxud2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPEJsb2JQYXJ0PiddID0gd2ViaWRsLnNlcXVlbmNlQ29udmVydGVyKFxuICB3ZWJpZGwuY29udmVydGVycy5CbG9iUGFydFxuKVxuXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvRmlsZUFQSS8jZGZuLUZpbGVQcm9wZXJ0eUJhZ1xud2ViaWRsLmNvbnZlcnRlcnMuRmlsZVByb3BlcnR5QmFnID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICB7XG4gICAga2V5OiAnbGFzdE1vZGlmaWVkJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWydsb25nIGxvbmcnXSxcbiAgICBnZXQgZGVmYXVsdFZhbHVlICgpIHtcbiAgICAgIHJldHVybiBEYXRlLm5vdygpXG4gICAgfVxuICB9LFxuICB7XG4gICAga2V5OiAndHlwZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgZGVmYXVsdFZhbHVlOiAnJ1xuICB9LFxuICB7XG4gICAga2V5OiAnZW5kaW5ncycsXG4gICAgY29udmVydGVyOiAodmFsdWUpID0+IHtcbiAgICAgIHZhbHVlID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKHZhbHVlKVxuICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpXG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gJ25hdGl2ZScpIHtcbiAgICAgICAgdmFsdWUgPSAndHJhbnNwYXJlbnQnXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0sXG4gICAgZGVmYXVsdFZhbHVlOiAndHJhbnNwYXJlbnQnXG4gIH1cbl0pXG5cbi8qKlxuICogQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvRmlsZUFQSS8jcHJvY2Vzcy1ibG9iLXBhcnRzXG4gKiBAcGFyYW0geyhOb2RlSlMuVHlwZWRBcnJheXxCbG9ifHN0cmluZylbXX0gcGFydHNcbiAqIEBwYXJhbSB7eyB0eXBlOiBzdHJpbmcsIGVuZGluZ3M6IHN0cmluZyB9fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NCbG9iUGFydHMgKHBhcnRzLCBvcHRpb25zKSB7XG4gIC8vIDEuIExldCBieXRlcyBiZSBhbiBlbXB0eSBzZXF1ZW5jZSBvZiBieXRlcy5cbiAgLyoqIEB0eXBlIHtOb2RlSlMuVHlwZWRBcnJheVtdfSAqL1xuICBjb25zdCBieXRlcyA9IFtdXG5cbiAgLy8gMi4gRm9yIGVhY2ggZWxlbWVudCBpbiBwYXJ0czpcbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIHBhcnRzKSB7XG4gICAgLy8gMS4gSWYgZWxlbWVudCBpcyBhIFVTVlN0cmluZywgcnVuIHRoZSBmb2xsb3dpbmcgc3Vic3RlcHM6XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gMS4gTGV0IHMgYmUgZWxlbWVudC5cbiAgICAgIGxldCBzID0gZWxlbWVudFxuXG4gICAgICAvLyAyLiBJZiB0aGUgZW5kaW5ncyBtZW1iZXIgb2Ygb3B0aW9ucyBpcyBcIm5hdGl2ZVwiLCBzZXQgc1xuICAgICAgLy8gICAgdG8gdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIGxpbmUgZW5kaW5ncyB0byBuYXRpdmVcbiAgICAgIC8vICAgIG9mIGVsZW1lbnQuXG4gICAgICBpZiAob3B0aW9ucy5lbmRpbmdzID09PSAnbmF0aXZlJykge1xuICAgICAgICBzID0gY29udmVydExpbmVFbmRpbmdzTmF0aXZlKHMpXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIEFwcGVuZCB0aGUgcmVzdWx0IG9mIFVURi04IGVuY29kaW5nIHMgdG8gYnl0ZXMuXG4gICAgICBieXRlcy5wdXNoKGVuY29kZXIuZW5jb2RlKHMpKVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0eXBlcy5pc0FueUFycmF5QnVmZmVyKGVsZW1lbnQpIHx8XG4gICAgICB0eXBlcy5pc1R5cGVkQXJyYXkoZWxlbWVudClcbiAgICApIHtcbiAgICAgIC8vIDIuIElmIGVsZW1lbnQgaXMgYSBCdWZmZXJTb3VyY2UsIGdldCBhIGNvcHkgb2YgdGhlXG4gICAgICAvLyAgICBieXRlcyBoZWxkIGJ5IHRoZSBidWZmZXIgc291cmNlLCBhbmQgYXBwZW5kIHRob3NlXG4gICAgICAvLyAgICBieXRlcyB0byBieXRlcy5cbiAgICAgIGlmICghZWxlbWVudC5idWZmZXIpIHsgLy8gQXJyYXlCdWZmZXJcbiAgICAgICAgYnl0ZXMucHVzaChuZXcgVWludDhBcnJheShlbGVtZW50KSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZWxlbWVudC5idWZmZXIsIGVsZW1lbnQuYnl0ZU9mZnNldCwgZWxlbWVudC5ieXRlTGVuZ3RoKVxuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0Jsb2JMaWtlKGVsZW1lbnQpKSB7XG4gICAgICAvLyAzLiBJZiBlbGVtZW50IGlzIGEgQmxvYiwgYXBwZW5kIHRoZSBieXRlcyBpdCByZXByZXNlbnRzXG4gICAgICAvLyAgICB0byBieXRlcy5cbiAgICAgIGJ5dGVzLnB1c2goZWxlbWVudClcbiAgICB9XG4gIH1cblxuICAvLyAzLiBSZXR1cm4gYnl0ZXMuXG4gIHJldHVybiBieXRlc1xufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL0ZpbGVBUEkvI2NvbnZlcnQtbGluZS1lbmRpbmdzLXRvLW5hdGl2ZVxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqL1xuZnVuY3Rpb24gY29udmVydExpbmVFbmRpbmdzTmF0aXZlIChzKSB7XG4gIC8vIDEuIExldCBuYXRpdmUgbGluZSBlbmRpbmcgYmUgYmUgdGhlIGNvZGUgcG9pbnQgVSswMDBBIExGLlxuICBsZXQgbmF0aXZlTGluZUVuZGluZyA9ICdcXG4nXG5cbiAgLy8gMi4gSWYgdGhlIHVuZGVybHlpbmcgcGxhdGZvcm3igJlzIGNvbnZlbnRpb25zIGFyZSB0b1xuICAvLyAgICByZXByZXNlbnQgbmV3bGluZXMgYXMgYSBjYXJyaWFnZSByZXR1cm4gYW5kIGxpbmUgZmVlZFxuICAvLyAgICBzZXF1ZW5jZSwgc2V0IG5hdGl2ZSBsaW5lIGVuZGluZyB0byB0aGUgY29kZSBwb2ludFxuICAvLyAgICBVKzAwMEQgQ1IgZm9sbG93ZWQgYnkgdGhlIGNvZGUgcG9pbnQgVSswMDBBIExGLlxuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgIG5hdGl2ZUxpbmVFbmRpbmcgPSAnXFxyXFxuJ1xuICB9XG5cbiAgcmV0dXJuIHMucmVwbGFjZSgvXFxyP1xcbi9nLCBuYXRpdmVMaW5lRW5kaW5nKVxufVxuXG4vLyBJZiB0aGlzIGZ1bmN0aW9uIGlzIG1vdmVkIHRvIC4vdXRpbC5qcywgc29tZSB0b29scyAoc3VjaCBhc1xuLy8gcm9sbHVwKSB3aWxsIHdhcm4gYWJvdXQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLiBTZWU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMTYyOVxuZnVuY3Rpb24gaXNGaWxlTGlrZSAob2JqZWN0KSB7XG4gIHJldHVybiAoXG4gICAgKE5hdGl2ZUZpbGUgJiYgb2JqZWN0IGluc3RhbmNlb2YgTmF0aXZlRmlsZSkgfHxcbiAgICBvYmplY3QgaW5zdGFuY2VvZiBGaWxlIHx8IChcbiAgICAgIG9iamVjdCAmJlxuICAgICAgKHR5cGVvZiBvYmplY3Quc3RyZWFtID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2Ygb2JqZWN0LmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nKSAmJlxuICAgICAgb2JqZWN0W1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdGaWxlJ1xuICAgIClcbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgRmlsZSwgRmlsZUxpa2UsIGlzRmlsZUxpa2UgfVxuIl0sIm5hbWVzIjpbIkJsb2IiLCJGaWxlIiwiTmF0aXZlRmlsZSIsInJlcXVpcmUiLCJ0eXBlcyIsImtTdGF0ZSIsImlzQmxvYkxpa2UiLCJ3ZWJpZGwiLCJwYXJzZU1JTUVUeXBlIiwic2VyaWFsaXplQU1pbWVUeXBlIiwia0VudW1lcmFibGVQcm9wZXJ0eSIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsImNvbnN0cnVjdG9yIiwiZmlsZUJpdHMiLCJmaWxlTmFtZSIsIm9wdGlvbnMiLCJhcmd1bWVudExlbmd0aENoZWNrIiwiYXJndW1lbnRzIiwiaGVhZGVyIiwiY29udmVydGVycyIsIlVTVlN0cmluZyIsIkZpbGVQcm9wZXJ0eUJhZyIsIm4iLCJ0IiwidHlwZSIsImQiLCJzdWJzdGVwIiwidG9Mb3dlckNhc2UiLCJsYXN0TW9kaWZpZWQiLCJwcm9jZXNzQmxvYlBhcnRzIiwibmFtZSIsImJyYW5kQ2hlY2siLCJGaWxlTGlrZSIsImJsb2JMaWtlIiwiRGF0ZSIsIm5vdyIsInN0cmVhbSIsImFyZ3MiLCJhcnJheUJ1ZmZlciIsInNsaWNlIiwidGV4dCIsInNpemUiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJwcm90b3R5cGUiLCJ2YWx1ZSIsImNvbmZpZ3VyYWJsZSIsImludGVyZmFjZUNvbnZlcnRlciIsIkJsb2JQYXJ0IiwiViIsIm9wdHMiLCJ1dGlsIiwiVHlwZSIsInN0cmljdCIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiaXNBbnlBcnJheUJ1ZmZlciIsIkJ1ZmZlclNvdXJjZSIsInNlcXVlbmNlQ29udmVydGVyIiwiZGljdGlvbmFyeUNvbnZlcnRlciIsImtleSIsImNvbnZlcnRlciIsImRlZmF1bHRWYWx1ZSIsIkRPTVN0cmluZyIsInBhcnRzIiwiYnl0ZXMiLCJlbGVtZW50IiwicyIsImVuZGluZ3MiLCJjb252ZXJ0TGluZUVuZGluZ3NOYXRpdmUiLCJwdXNoIiwiZW5jb2RlIiwiaXNUeXBlZEFycmF5IiwiYnVmZmVyIiwiVWludDhBcnJheSIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwibmF0aXZlTGluZUVuZGluZyIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsInJlcGxhY2UiLCJpc0ZpbGVMaWtlIiwib2JqZWN0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/file.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/formdata.js":
/*!*************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/fetch/formdata.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { isBlobLike, toUSVString, makeIterator } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/util.js\");\nconst { kState } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/symbols.js\");\nconst { File: UndiciFile, FileLike, isFileLike } = __webpack_require__(/*! ./file */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/file.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/webidl.js\");\nconst { Blob, File: NativeFile } = __webpack_require__(/*! buffer */ \"buffer\");\n/** @type {globalThis['File']} */ const File = NativeFile ?? UndiciFile;\n// https://xhr.spec.whatwg.org/#formdata\nclass FormData {\n    constructor(form){\n        if (form !== undefined) {\n            throw webidl.errors.conversionFailed({\n                prefix: \"FormData constructor\",\n                argument: \"Argument 1\",\n                types: [\n                    \"undefined\"\n                ]\n            });\n        }\n        this[kState] = [];\n    }\n    append(name, value, filename = undefined) {\n        webidl.brandCheck(this, FormData);\n        webidl.argumentLengthCheck(arguments, 2, {\n            header: \"FormData.append\"\n        });\n        if (arguments.length === 3 && !isBlobLike(value)) {\n            throw new TypeError(\"Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'\");\n        }\n        // 1. Let value be value if given; otherwise blobValue.\n        name = webidl.converters.USVString(name);\n        value = isBlobLike(value) ? webidl.converters.Blob(value, {\n            strict: false\n        }) : webidl.converters.USVString(value);\n        filename = arguments.length === 3 ? webidl.converters.USVString(filename) : undefined;\n        // 2. Let entry be the result of creating an entry with\n        // name, value, and filename if given.\n        const entry = makeEntry(name, value, filename);\n        // 3. Append entry to thiss entry list.\n        this[kState].push(entry);\n    }\n    delete(name) {\n        webidl.brandCheck(this, FormData);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FormData.delete\"\n        });\n        name = webidl.converters.USVString(name);\n        // The delete(name) method steps are to remove all entries whose name\n        // is name from thiss entry list.\n        this[kState] = this[kState].filter((entry)=>entry.name !== name);\n    }\n    get(name) {\n        webidl.brandCheck(this, FormData);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FormData.get\"\n        });\n        name = webidl.converters.USVString(name);\n        // 1. If there is no entry whose name is name in thiss entry list,\n        // then return null.\n        const idx = this[kState].findIndex((entry)=>entry.name === name);\n        if (idx === -1) {\n            return null;\n        }\n        // 2. Return the value of the first entry whose name is name from\n        // thiss entry list.\n        return this[kState][idx].value;\n    }\n    getAll(name) {\n        webidl.brandCheck(this, FormData);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FormData.getAll\"\n        });\n        name = webidl.converters.USVString(name);\n        // 1. If there is no entry whose name is name in thiss entry list,\n        // then return the empty list.\n        // 2. Return the values of all entries whose name is name, in order,\n        // from thiss entry list.\n        return this[kState].filter((entry)=>entry.name === name).map((entry)=>entry.value);\n    }\n    has(name) {\n        webidl.brandCheck(this, FormData);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FormData.has\"\n        });\n        name = webidl.converters.USVString(name);\n        // The has(name) method steps are to return true if there is an entry\n        // whose name is name in thiss entry list; otherwise false.\n        return this[kState].findIndex((entry)=>entry.name === name) !== -1;\n    }\n    set(name, value, filename = undefined) {\n        webidl.brandCheck(this, FormData);\n        webidl.argumentLengthCheck(arguments, 2, {\n            header: \"FormData.set\"\n        });\n        if (arguments.length === 3 && !isBlobLike(value)) {\n            throw new TypeError(\"Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'\");\n        }\n        // The set(name, value) and set(name, blobValue, filename) method steps\n        // are:\n        // 1. Let value be value if given; otherwise blobValue.\n        name = webidl.converters.USVString(name);\n        value = isBlobLike(value) ? webidl.converters.Blob(value, {\n            strict: false\n        }) : webidl.converters.USVString(value);\n        filename = arguments.length === 3 ? toUSVString(filename) : undefined;\n        // 2. Let entry be the result of creating an entry with name, value, and\n        // filename if given.\n        const entry = makeEntry(name, value, filename);\n        // 3. If there are entries in thiss entry list whose name is name, then\n        // replace the first such entry with entry and remove the others.\n        const idx = this[kState].findIndex((entry)=>entry.name === name);\n        if (idx !== -1) {\n            this[kState] = [\n                ...this[kState].slice(0, idx),\n                entry,\n                ...this[kState].slice(idx + 1).filter((entry)=>entry.name !== name)\n            ];\n        } else {\n            // 4. Otherwise, append entry to thiss entry list.\n            this[kState].push(entry);\n        }\n    }\n    entries() {\n        webidl.brandCheck(this, FormData);\n        return makeIterator(()=>this[kState].map((pair)=>[\n                    pair.name,\n                    pair.value\n                ]), \"FormData\", \"key+value\");\n    }\n    keys() {\n        webidl.brandCheck(this, FormData);\n        return makeIterator(()=>this[kState].map((pair)=>[\n                    pair.name,\n                    pair.value\n                ]), \"FormData\", \"key\");\n    }\n    values() {\n        webidl.brandCheck(this, FormData);\n        return makeIterator(()=>this[kState].map((pair)=>[\n                    pair.name,\n                    pair.value\n                ]), \"FormData\", \"value\");\n    }\n    /**\n   * @param {(value: string, key: string, self: FormData) => void} callbackFn\n   * @param {unknown} thisArg\n   */ forEach(callbackFn, thisArg = globalThis) {\n        webidl.brandCheck(this, FormData);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FormData.forEach\"\n        });\n        if (typeof callbackFn !== \"function\") {\n            throw new TypeError(\"Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.\");\n        }\n        for (const [key, value] of this){\n            callbackFn.apply(thisArg, [\n                value,\n                key,\n                this\n            ]);\n        }\n    }\n}\nFormData.prototype[Symbol.iterator] = FormData.prototype.entries;\nObject.defineProperties(FormData.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"FormData\",\n        configurable: true\n    }\n});\n/**\n * @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry\n * @param {string} name\n * @param {string|Blob} value\n * @param {?string} filename\n * @returns\n */ function makeEntry(name, value, filename) {\n    // 1. Set name to the result of converting name into a scalar value string.\n    // \"To convert a string into a scalar value string, replace any surrogates\n    //  with U+FFFD.\"\n    // see: https://nodejs.org/dist/latest-v18.x/docs/api/buffer.html#buftostringencoding-start-end\n    name = Buffer.from(name).toString(\"utf8\");\n    // 2. If value is a string, then set value to the result of converting\n    //    value into a scalar value string.\n    if (typeof value === \"string\") {\n        value = Buffer.from(value).toString(\"utf8\");\n    } else {\n        // 3. Otherwise:\n        // 1. If value is not a File object, then set value to a new File object,\n        //    representing the same bytes, whose name attribute value is \"blob\"\n        if (!isFileLike(value)) {\n            value = value instanceof Blob ? new File([\n                value\n            ], \"blob\", {\n                type: value.type\n            }) : new FileLike(value, \"blob\", {\n                type: value.type\n            });\n        }\n        // 2. If filename is given, then set value to a new File object,\n        //    representing the same bytes, whose name attribute is filename.\n        if (filename !== undefined) {\n            /** @type {FilePropertyBag} */ const options = {\n                type: value.type,\n                lastModified: value.lastModified\n            };\n            value = NativeFile && value instanceof NativeFile || value instanceof UndiciFile ? new File([\n                value\n            ], filename, options) : new FileLike(value, filename, options);\n        }\n    }\n    // 4. Return an entry whose name is name and whose value is value.\n    return {\n        name,\n        value\n    };\n}\nmodule.exports = {\n    FormData\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvZm9ybWRhdGEuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFVBQVUsRUFBRUMsV0FBVyxFQUFFQyxZQUFZLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDMUQsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFRSxNQUFNQyxVQUFVLEVBQUVDLFFBQVEsRUFBRUMsVUFBVSxFQUFFLEdBQUdMLG1CQUFPQSxDQUFDO0FBQzNELE1BQU0sRUFBRU0sTUFBTSxFQUFFLEdBQUdOLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRU8sSUFBSSxFQUFFTCxNQUFNTSxVQUFVLEVBQUUsR0FBR1IsbUJBQU9BLENBQUM7QUFFM0MsK0JBQStCLEdBQy9CLE1BQU1FLE9BQU9NLGNBQWNMO0FBRTNCLHdDQUF3QztBQUN4QyxNQUFNTTtJQUNKQyxZQUFhQyxJQUFJLENBQUU7UUFDakIsSUFBSUEsU0FBU0MsV0FBVztZQUN0QixNQUFNTixPQUFPTyxNQUFNLENBQUNDLGdCQUFnQixDQUFDO2dCQUNuQ0MsUUFBUTtnQkFDUkMsVUFBVTtnQkFDVkMsT0FBTztvQkFBQztpQkFBWTtZQUN0QjtRQUNGO1FBRUEsSUFBSSxDQUFDaEIsT0FBTyxHQUFHLEVBQUU7SUFDbkI7SUFFQWlCLE9BQVFDLElBQUksRUFBRUMsS0FBSyxFQUFFQyxXQUFXVCxTQUFTLEVBQUU7UUFDekNOLE9BQU9nQixVQUFVLENBQUMsSUFBSSxFQUFFYjtRQUV4QkgsT0FBT2lCLG1CQUFtQixDQUFDQyxXQUFXLEdBQUc7WUFBRUMsUUFBUTtRQUFrQjtRQUVyRSxJQUFJRCxVQUFVRSxNQUFNLEtBQUssS0FBSyxDQUFDN0IsV0FBV3VCLFFBQVE7WUFDaEQsTUFBTSxJQUFJTyxVQUNSO1FBRUo7UUFFQSx1REFBdUQ7UUFFdkRSLE9BQU9iLE9BQU9zQixV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QTJFO0lBQzNFLDBFQUEwRTtJQUMxRSxpQkFBaUI7SUFDakIsK0ZBQStGO0lBQy9GRixPQUFPMEMsT0FBT0MsSUFBSSxDQUFDM0MsTUFBTTRDLFFBQVEsQ0FBQztJQUVsQyxzRUFBc0U7SUFDdEUsdUNBQXVDO0lBQ3ZDLElBQUksT0FBTzNDLFVBQVUsVUFBVTtRQUM3QkEsUUFBUXlDLE9BQU9DLElBQUksQ0FBQzFDLE9BQU8yQyxRQUFRLENBQUM7SUFDdEMsT0FBTztRQUNMLGdCQUFnQjtRQUVoQix5RUFBeUU7UUFDekUsdUVBQXVFO1FBQ3ZFLElBQUksQ0FBQzFELFdBQVdlLFFBQVE7WUFDdEJBLFFBQVFBLGlCQUFpQmIsT0FDckIsSUFBSUwsS0FBSztnQkFBQ2tCO2FBQU0sRUFBRSxRQUFRO2dCQUFFNEMsTUFBTTVDLE1BQU00QyxJQUFJO1lBQUMsS0FDN0MsSUFBSTVELFNBQVNnQixPQUFPLFFBQVE7Z0JBQUU0QyxNQUFNNUMsTUFBTTRDLElBQUk7WUFBQztRQUNyRDtRQUVBLGdFQUFnRTtRQUNoRSxvRUFBb0U7UUFDcEUsSUFBSTNDLGFBQWFULFdBQVc7WUFDMUIsNEJBQTRCLEdBQzVCLE1BQU1xRCxVQUFVO2dCQUNkRCxNQUFNNUMsTUFBTTRDLElBQUk7Z0JBQ2hCRSxjQUFjOUMsTUFBTThDLFlBQVk7WUFDbEM7WUFFQTlDLFFBQVEsY0FBZUEsaUJBQWlCWixjQUFlWSxpQkFBaUJqQixhQUNwRSxJQUFJRCxLQUFLO2dCQUFDa0I7YUFBTSxFQUFFQyxVQUFVNEMsV0FDNUIsSUFBSTdELFNBQVNnQixPQUFPQyxVQUFVNEM7UUFDcEM7SUFDRjtJQUVBLGtFQUFrRTtJQUNsRSxPQUFPO1FBQUU5QztRQUFNQztJQUFNO0FBQ3ZCO0FBRUErQyxPQUFPQyxPQUFPLEdBQUc7SUFBRTNEO0FBQVMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9mb3JtZGF0YS5qcz85NTk2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGlzQmxvYkxpa2UsIHRvVVNWU3RyaW5nLCBtYWtlSXRlcmF0b3IgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IGtTdGF0ZSB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgRmlsZTogVW5kaWNpRmlsZSwgRmlsZUxpa2UsIGlzRmlsZUxpa2UgfSA9IHJlcXVpcmUoJy4vZmlsZScpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi93ZWJpZGwnKVxuY29uc3QgeyBCbG9iLCBGaWxlOiBOYXRpdmVGaWxlIH0gPSByZXF1aXJlKCdidWZmZXInKVxuXG4vKiogQHR5cGUge2dsb2JhbFRoaXNbJ0ZpbGUnXX0gKi9cbmNvbnN0IEZpbGUgPSBOYXRpdmVGaWxlID8/IFVuZGljaUZpbGVcblxuLy8gaHR0cHM6Ly94aHIuc3BlYy53aGF0d2cub3JnLyNmb3JtZGF0YVxuY2xhc3MgRm9ybURhdGEge1xuICBjb25zdHJ1Y3RvciAoZm9ybSkge1xuICAgIGlmIChmb3JtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgICAgIHByZWZpeDogJ0Zvcm1EYXRhIGNvbnN0cnVjdG9yJyxcbiAgICAgICAgYXJndW1lbnQ6ICdBcmd1bWVudCAxJyxcbiAgICAgICAgdHlwZXM6IFsndW5kZWZpbmVkJ11cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpc1trU3RhdGVdID0gW11cbiAgfVxuXG4gIGFwcGVuZCAobmFtZSwgdmFsdWUsIGZpbGVuYW1lID0gdW5kZWZpbmVkKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDIsIHsgaGVhZGVyOiAnRm9ybURhdGEuYXBwZW5kJyB9KVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgIWlzQmxvYkxpa2UodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkZhaWxlZCB0byBleGVjdXRlICdhcHBlbmQnIG9uICdGb3JtRGF0YSc6IHBhcmFtZXRlciAyIGlzIG5vdCBvZiB0eXBlICdCbG9iJ1wiXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gMS4gTGV0IHZhbHVlIGJlIHZhbHVlIGlmIGdpdmVuOyBvdGhlcndpc2UgYmxvYlZhbHVlLlxuXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhuYW1lKVxuICAgIHZhbHVlID0gaXNCbG9iTGlrZSh2YWx1ZSlcbiAgICAgID8gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYih2YWx1ZSwgeyBzdHJpY3Q6IGZhbHNlIH0pXG4gICAgICA6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyh2YWx1ZSlcbiAgICBmaWxlbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDNcbiAgICAgID8gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKGZpbGVuYW1lKVxuICAgICAgOiB1bmRlZmluZWRcblxuICAgIC8vIDIuIExldCBlbnRyeSBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGFuIGVudHJ5IHdpdGhcbiAgICAvLyBuYW1lLCB2YWx1ZSwgYW5kIGZpbGVuYW1lIGlmIGdpdmVuLlxuICAgIGNvbnN0IGVudHJ5ID0gbWFrZUVudHJ5KG5hbWUsIHZhbHVlLCBmaWxlbmFtZSlcblxuICAgIC8vIDMuIEFwcGVuZCBlbnRyeSB0byB0aGlz4oCZcyBlbnRyeSBsaXN0LlxuICAgIHRoaXNba1N0YXRlXS5wdXNoKGVudHJ5KVxuICB9XG5cbiAgZGVsZXRlIChuYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnRm9ybURhdGEuZGVsZXRlJyB9KVxuXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhuYW1lKVxuXG4gICAgLy8gVGhlIGRlbGV0ZShuYW1lKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJlbW92ZSBhbGwgZW50cmllcyB3aG9zZSBuYW1lXG4gICAgLy8gaXMgbmFtZSBmcm9tIHRoaXPigJlzIGVudHJ5IGxpc3QuXG4gICAgdGhpc1trU3RhdGVdID0gdGhpc1trU3RhdGVdLmZpbHRlcihlbnRyeSA9PiBlbnRyeS5uYW1lICE9PSBuYW1lKVxuICB9XG5cbiAgZ2V0IChuYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnRm9ybURhdGEuZ2V0JyB9KVxuXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhuYW1lKVxuXG4gICAgLy8gMS4gSWYgdGhlcmUgaXMgbm8gZW50cnkgd2hvc2UgbmFtZSBpcyBuYW1lIGluIHRoaXPigJlzIGVudHJ5IGxpc3QsXG4gICAgLy8gdGhlbiByZXR1cm4gbnVsbC5cbiAgICBjb25zdCBpZHggPSB0aGlzW2tTdGF0ZV0uZmluZEluZGV4KChlbnRyeSkgPT4gZW50cnkubmFtZSA9PT0gbmFtZSlcbiAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvLyAyLiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbnRyeSB3aG9zZSBuYW1lIGlzIG5hbWUgZnJvbVxuICAgIC8vIHRoaXPigJlzIGVudHJ5IGxpc3QuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXVtpZHhdLnZhbHVlXG4gIH1cblxuICBnZXRBbGwgKG5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdGb3JtRGF0YS5nZXRBbGwnIH0pXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUpXG5cbiAgICAvLyAxLiBJZiB0aGVyZSBpcyBubyBlbnRyeSB3aG9zZSBuYW1lIGlzIG5hbWUgaW4gdGhpc+KAmXMgZW50cnkgbGlzdCxcbiAgICAvLyB0aGVuIHJldHVybiB0aGUgZW1wdHkgbGlzdC5cbiAgICAvLyAyLiBSZXR1cm4gdGhlIHZhbHVlcyBvZiBhbGwgZW50cmllcyB3aG9zZSBuYW1lIGlzIG5hbWUsIGluIG9yZGVyLFxuICAgIC8vIGZyb20gdGhpc+KAmXMgZW50cnkgbGlzdC5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdXG4gICAgICAuZmlsdGVyKChlbnRyeSkgPT4gZW50cnkubmFtZSA9PT0gbmFtZSlcbiAgICAgIC5tYXAoKGVudHJ5KSA9PiBlbnRyeS52YWx1ZSlcbiAgfVxuXG4gIGhhcyAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZvcm1EYXRhKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0Zvcm1EYXRhLmhhcycgfSlcblxuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcobmFtZSlcblxuICAgIC8vIFRoZSBoYXMobmFtZSkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdHJ1ZSBpZiB0aGVyZSBpcyBhbiBlbnRyeVxuICAgIC8vIHdob3NlIG5hbWUgaXMgbmFtZSBpbiB0aGlz4oCZcyBlbnRyeSBsaXN0OyBvdGhlcndpc2UgZmFsc2UuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5maW5kSW5kZXgoKGVudHJ5KSA9PiBlbnRyeS5uYW1lID09PSBuYW1lKSAhPT0gLTFcbiAgfVxuXG4gIHNldCAobmFtZSwgdmFsdWUsIGZpbGVuYW1lID0gdW5kZWZpbmVkKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDIsIHsgaGVhZGVyOiAnRm9ybURhdGEuc2V0JyB9KVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgIWlzQmxvYkxpa2UodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkZhaWxlZCB0byBleGVjdXRlICdzZXQnIG9uICdGb3JtRGF0YSc6IHBhcmFtZXRlciAyIGlzIG5vdCBvZiB0eXBlICdCbG9iJ1wiXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gVGhlIHNldChuYW1lLCB2YWx1ZSkgYW5kIHNldChuYW1lLCBibG9iVmFsdWUsIGZpbGVuYW1lKSBtZXRob2Qgc3RlcHNcbiAgICAvLyBhcmU6XG5cbiAgICAvLyAxLiBMZXQgdmFsdWUgYmUgdmFsdWUgaWYgZ2l2ZW47IG90aGVyd2lzZSBibG9iVmFsdWUuXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUpXG4gICAgdmFsdWUgPSBpc0Jsb2JMaWtlKHZhbHVlKVxuICAgICAgPyB3ZWJpZGwuY29udmVydGVycy5CbG9iKHZhbHVlLCB7IHN0cmljdDogZmFsc2UgfSlcbiAgICAgIDogd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKHZhbHVlKVxuICAgIGZpbGVuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gM1xuICAgICAgPyB0b1VTVlN0cmluZyhmaWxlbmFtZSlcbiAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAvLyAyLiBMZXQgZW50cnkgYmUgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhbiBlbnRyeSB3aXRoIG5hbWUsIHZhbHVlLCBhbmRcbiAgICAvLyBmaWxlbmFtZSBpZiBnaXZlbi5cbiAgICBjb25zdCBlbnRyeSA9IG1ha2VFbnRyeShuYW1lLCB2YWx1ZSwgZmlsZW5hbWUpXG5cbiAgICAvLyAzLiBJZiB0aGVyZSBhcmUgZW50cmllcyBpbiB0aGlz4oCZcyBlbnRyeSBsaXN0IHdob3NlIG5hbWUgaXMgbmFtZSwgdGhlblxuICAgIC8vIHJlcGxhY2UgdGhlIGZpcnN0IHN1Y2ggZW50cnkgd2l0aCBlbnRyeSBhbmQgcmVtb3ZlIHRoZSBvdGhlcnMuXG4gICAgY29uc3QgaWR4ID0gdGhpc1trU3RhdGVdLmZpbmRJbmRleCgoZW50cnkpID0+IGVudHJ5Lm5hbWUgPT09IG5hbWUpXG4gICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgIHRoaXNba1N0YXRlXSA9IFtcbiAgICAgICAgLi4udGhpc1trU3RhdGVdLnNsaWNlKDAsIGlkeCksXG4gICAgICAgIGVudHJ5LFxuICAgICAgICAuLi50aGlzW2tTdGF0ZV0uc2xpY2UoaWR4ICsgMSkuZmlsdGVyKChlbnRyeSkgPT4gZW50cnkubmFtZSAhPT0gbmFtZSlcbiAgICAgIF1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gNC4gT3RoZXJ3aXNlLCBhcHBlbmQgZW50cnkgdG8gdGhpc+KAmXMgZW50cnkgbGlzdC5cbiAgICAgIHRoaXNba1N0YXRlXS5wdXNoKGVudHJ5KVxuICAgIH1cbiAgfVxuXG4gIGVudHJpZXMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZvcm1EYXRhKVxuXG4gICAgcmV0dXJuIG1ha2VJdGVyYXRvcihcbiAgICAgICgpID0+IHRoaXNba1N0YXRlXS5tYXAocGFpciA9PiBbcGFpci5uYW1lLCBwYWlyLnZhbHVlXSksXG4gICAgICAnRm9ybURhdGEnLFxuICAgICAgJ2tleSt2YWx1ZSdcbiAgICApXG4gIH1cblxuICBrZXlzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIHJldHVybiBtYWtlSXRlcmF0b3IoXG4gICAgICAoKSA9PiB0aGlzW2tTdGF0ZV0ubWFwKHBhaXIgPT4gW3BhaXIubmFtZSwgcGFpci52YWx1ZV0pLFxuICAgICAgJ0Zvcm1EYXRhJyxcbiAgICAgICdrZXknXG4gICAgKVxuICB9XG5cbiAgdmFsdWVzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIHJldHVybiBtYWtlSXRlcmF0b3IoXG4gICAgICAoKSA9PiB0aGlzW2tTdGF0ZV0ubWFwKHBhaXIgPT4gW3BhaXIubmFtZSwgcGFpci52YWx1ZV0pLFxuICAgICAgJ0Zvcm1EYXRhJyxcbiAgICAgICd2YWx1ZSdcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsodmFsdWU6IHN0cmluZywga2V5OiBzdHJpbmcsIHNlbGY6IEZvcm1EYXRhKSA9PiB2b2lkfSBjYWxsYmFja0ZuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gdGhpc0FyZ1xuICAgKi9cbiAgZm9yRWFjaCAoY2FsbGJhY2tGbiwgdGhpc0FyZyA9IGdsb2JhbFRoaXMpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdGb3JtRGF0YS5mb3JFYWNoJyB9KVxuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFja0ZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkZhaWxlZCB0byBleGVjdXRlICdmb3JFYWNoJyBvbiAnRm9ybURhdGEnOiBwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSAnRnVuY3Rpb24nLlwiXG4gICAgICApXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcykge1xuICAgICAgY2FsbGJhY2tGbi5hcHBseSh0aGlzQXJnLCBbdmFsdWUsIGtleSwgdGhpc10pXG4gICAgfVxuICB9XG59XG5cbkZvcm1EYXRhLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gRm9ybURhdGEucHJvdG90eXBlLmVudHJpZXNcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRm9ybURhdGEucHJvdG90eXBlLCB7XG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdGb3JtRGF0YScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pXG5cbi8qKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3JtLWNvbnRyb2wtaW5mcmFzdHJ1Y3R1cmUuaHRtbCNjcmVhdGUtYW4tZW50cnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ3xCbG9ifSB2YWx1ZVxuICogQHBhcmFtIHs/c3RyaW5nfSBmaWxlbmFtZVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gbWFrZUVudHJ5IChuYW1lLCB2YWx1ZSwgZmlsZW5hbWUpIHtcbiAgLy8gMS4gU2V0IG5hbWUgdG8gdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIG5hbWUgaW50byBhIHNjYWxhciB2YWx1ZSBzdHJpbmcuXG4gIC8vIFwiVG8gY29udmVydCBhIHN0cmluZyBpbnRvIGEgc2NhbGFyIHZhbHVlIHN0cmluZywgcmVwbGFjZSBhbnkgc3Vycm9nYXRlc1xuICAvLyAgd2l0aCBVK0ZGRkQuXCJcbiAgLy8gc2VlOiBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QtdjE4LngvZG9jcy9hcGkvYnVmZmVyLmh0bWwjYnVmdG9zdHJpbmdlbmNvZGluZy1zdGFydC1lbmRcbiAgbmFtZSA9IEJ1ZmZlci5mcm9tKG5hbWUpLnRvU3RyaW5nKCd1dGY4JylcblxuICAvLyAyLiBJZiB2YWx1ZSBpcyBhIHN0cmluZywgdGhlbiBzZXQgdmFsdWUgdG8gdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nXG4gIC8vICAgIHZhbHVlIGludG8gYSBzY2FsYXIgdmFsdWUgc3RyaW5nLlxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gQnVmZmVyLmZyb20odmFsdWUpLnRvU3RyaW5nKCd1dGY4JylcbiAgfSBlbHNlIHtcbiAgICAvLyAzLiBPdGhlcndpc2U6XG5cbiAgICAvLyAxLiBJZiB2YWx1ZSBpcyBub3QgYSBGaWxlIG9iamVjdCwgdGhlbiBzZXQgdmFsdWUgdG8gYSBuZXcgRmlsZSBvYmplY3QsXG4gICAgLy8gICAgcmVwcmVzZW50aW5nIHRoZSBzYW1lIGJ5dGVzLCB3aG9zZSBuYW1lIGF0dHJpYnV0ZSB2YWx1ZSBpcyBcImJsb2JcIlxuICAgIGlmICghaXNGaWxlTGlrZSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgaW5zdGFuY2VvZiBCbG9iXG4gICAgICAgID8gbmV3IEZpbGUoW3ZhbHVlXSwgJ2Jsb2InLCB7IHR5cGU6IHZhbHVlLnR5cGUgfSlcbiAgICAgICAgOiBuZXcgRmlsZUxpa2UodmFsdWUsICdibG9iJywgeyB0eXBlOiB2YWx1ZS50eXBlIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgZmlsZW5hbWUgaXMgZ2l2ZW4sIHRoZW4gc2V0IHZhbHVlIHRvIGEgbmV3IEZpbGUgb2JqZWN0LFxuICAgIC8vICAgIHJlcHJlc2VudGluZyB0aGUgc2FtZSBieXRlcywgd2hvc2UgbmFtZSBhdHRyaWJ1dGUgaXMgZmlsZW5hbWUuXG4gICAgaWYgKGZpbGVuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8qKiBAdHlwZSB7RmlsZVByb3BlcnR5QmFnfSAqL1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgdHlwZTogdmFsdWUudHlwZSxcbiAgICAgICAgbGFzdE1vZGlmaWVkOiB2YWx1ZS5sYXN0TW9kaWZpZWRcbiAgICAgIH1cblxuICAgICAgdmFsdWUgPSAoTmF0aXZlRmlsZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIE5hdGl2ZUZpbGUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVW5kaWNpRmlsZVxuICAgICAgICA/IG5ldyBGaWxlKFt2YWx1ZV0sIGZpbGVuYW1lLCBvcHRpb25zKVxuICAgICAgICA6IG5ldyBGaWxlTGlrZSh2YWx1ZSwgZmlsZW5hbWUsIG9wdGlvbnMpXG4gICAgfVxuICB9XG5cbiAgLy8gNC4gUmV0dXJuIGFuIGVudHJ5IHdob3NlIG5hbWUgaXMgbmFtZSBhbmQgd2hvc2UgdmFsdWUgaXMgdmFsdWUuXG4gIHJldHVybiB7IG5hbWUsIHZhbHVlIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IEZvcm1EYXRhIH1cbiJdLCJuYW1lcyI6WyJpc0Jsb2JMaWtlIiwidG9VU1ZTdHJpbmciLCJtYWtlSXRlcmF0b3IiLCJyZXF1aXJlIiwia1N0YXRlIiwiRmlsZSIsIlVuZGljaUZpbGUiLCJGaWxlTGlrZSIsImlzRmlsZUxpa2UiLCJ3ZWJpZGwiLCJCbG9iIiwiTmF0aXZlRmlsZSIsIkZvcm1EYXRhIiwiY29uc3RydWN0b3IiLCJmb3JtIiwidW5kZWZpbmVkIiwiZXJyb3JzIiwiY29udmVyc2lvbkZhaWxlZCIsInByZWZpeCIsImFyZ3VtZW50IiwidHlwZXMiLCJhcHBlbmQiLCJuYW1lIiwidmFsdWUiLCJmaWxlbmFtZSIsImJyYW5kQ2hlY2siLCJhcmd1bWVudExlbmd0aENoZWNrIiwiYXJndW1lbnRzIiwiaGVhZGVyIiwibGVuZ3RoIiwiVHlwZUVycm9yIiwiY29udmVydGVycyIsIlVTVlN0cmluZyIsInN0cmljdCIsImVudHJ5IiwibWFrZUVudHJ5IiwicHVzaCIsImRlbGV0ZSIsImZpbHRlciIsImdldCIsImlkeCIsImZpbmRJbmRleCIsImdldEFsbCIsIm1hcCIsImhhcyIsInNldCIsInNsaWNlIiwiZW50cmllcyIsInBhaXIiLCJrZXlzIiwidmFsdWVzIiwiZm9yRWFjaCIsImNhbGxiYWNrRm4iLCJ0aGlzQXJnIiwiZ2xvYmFsVGhpcyIsImtleSIsImFwcGx5IiwicHJvdG90eXBlIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwidG9TdHJpbmdUYWciLCJjb25maWd1cmFibGUiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJ0eXBlIiwib3B0aW9ucyIsImxhc3RNb2RpZmllZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/formdata.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/global.js":
/*!***********************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/fetch/global.js ***!
  \***********************************************************************/
/***/ ((module) => {

eval("\n// In case of breaking changes, increase the version\n// number to avoid conflicts.\nconst globalOrigin = Symbol.for(\"undici.globalOrigin.1\");\nfunction getGlobalOrigin() {\n    return globalThis[globalOrigin];\n}\nfunction setGlobalOrigin(newOrigin) {\n    if (newOrigin === undefined) {\n        Object.defineProperty(globalThis, globalOrigin, {\n            value: undefined,\n            writable: true,\n            enumerable: false,\n            configurable: false\n        });\n        return;\n    }\n    const parsedURL = new URL(newOrigin);\n    if (parsedURL.protocol !== \"http:\" && parsedURL.protocol !== \"https:\") {\n        throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);\n    }\n    Object.defineProperty(globalThis, globalOrigin, {\n        value: parsedURL,\n        writable: true,\n        enumerable: false,\n        configurable: false\n    });\n}\nmodule.exports = {\n    getGlobalOrigin,\n    setGlobalOrigin\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvZ2xvYmFsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsb0RBQW9EO0FBQ3BELDZCQUE2QjtBQUM3QixNQUFNQSxlQUFlQyxPQUFPQyxHQUFHLENBQUM7QUFFaEMsU0FBU0M7SUFDUCxPQUFPQyxVQUFVLENBQUNKLGFBQWE7QUFDakM7QUFFQSxTQUFTSyxnQkFBaUJDLFNBQVM7SUFDakMsSUFBSUEsY0FBY0MsV0FBVztRQUMzQkMsT0FBT0MsY0FBYyxDQUFDTCxZQUFZSixjQUFjO1lBQzlDVSxPQUFPSDtZQUNQSSxVQUFVO1lBQ1ZDLFlBQVk7WUFDWkMsY0FBYztRQUNoQjtRQUVBO0lBQ0Y7SUFFQSxNQUFNQyxZQUFZLElBQUlDLElBQUlUO0lBRTFCLElBQUlRLFVBQVVFLFFBQVEsS0FBSyxXQUFXRixVQUFVRSxRQUFRLEtBQUssVUFBVTtRQUNyRSxNQUFNLElBQUlDLFVBQVUsQ0FBQyw2Q0FBNkMsRUFBRUgsVUFBVUUsUUFBUSxDQUFDLENBQUM7SUFDMUY7SUFFQVIsT0FBT0MsY0FBYyxDQUFDTCxZQUFZSixjQUFjO1FBQzlDVSxPQUFPSTtRQUNQSCxVQUFVO1FBQ1ZDLFlBQVk7UUFDWkMsY0FBYztJQUNoQjtBQUNGO0FBRUFLLE9BQU9DLE9BQU8sR0FBRztJQUNmaEI7SUFDQUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL2dsb2JhbC5qcz9hZjRhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBJbiBjYXNlIG9mIGJyZWFraW5nIGNoYW5nZXMsIGluY3JlYXNlIHRoZSB2ZXJzaW9uXG4vLyBudW1iZXIgdG8gYXZvaWQgY29uZmxpY3RzLlxuY29uc3QgZ2xvYmFsT3JpZ2luID0gU3ltYm9sLmZvcigndW5kaWNpLmdsb2JhbE9yaWdpbi4xJylcblxuZnVuY3Rpb24gZ2V0R2xvYmFsT3JpZ2luICgpIHtcbiAgcmV0dXJuIGdsb2JhbFRoaXNbZ2xvYmFsT3JpZ2luXVxufVxuXG5mdW5jdGlvbiBzZXRHbG9iYWxPcmlnaW4gKG5ld09yaWdpbikge1xuICBpZiAobmV3T3JpZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgZ2xvYmFsT3JpZ2luLCB7XG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KVxuXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBwYXJzZWRVUkwgPSBuZXcgVVJMKG5ld09yaWdpbilcblxuICBpZiAocGFyc2VkVVJMLnByb3RvY29sICE9PSAnaHR0cDonICYmIHBhcnNlZFVSTC5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBPbmx5IGh0dHAgJiBodHRwcyB1cmxzIGFyZSBhbGxvd2VkLCByZWNlaXZlZCAke3BhcnNlZFVSTC5wcm90b2NvbH1gKVxuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbFRoaXMsIGdsb2JhbE9yaWdpbiwge1xuICAgIHZhbHVlOiBwYXJzZWRVUkwsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0R2xvYmFsT3JpZ2luLFxuICBzZXRHbG9iYWxPcmlnaW5cbn1cbiJdLCJuYW1lcyI6WyJnbG9iYWxPcmlnaW4iLCJTeW1ib2wiLCJmb3IiLCJnZXRHbG9iYWxPcmlnaW4iLCJnbG9iYWxUaGlzIiwic2V0R2xvYmFsT3JpZ2luIiwibmV3T3JpZ2luIiwidW5kZWZpbmVkIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsInBhcnNlZFVSTCIsIlVSTCIsInByb3RvY29sIiwiVHlwZUVycm9yIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/global.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/headers.js":
/*!************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/fetch/headers.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// https://github.com/Ethan-Arrowood/undici-fetch\n\nconst { kHeadersList, kConstruct } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\");\nconst { kGuard } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/symbols.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst { makeIterator, isValidHeaderName, isValidHeaderValue } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/util.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/webidl.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst kHeadersMap = Symbol(\"headers map\");\nconst kHeadersSortedMap = Symbol(\"headers map sorted\");\n/**\n * @param {number} code\n */ function isHTTPWhiteSpaceCharCode(code) {\n    return code === 0x00a || code === 0x00d || code === 0x009 || code === 0x020;\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize\n * @param {string} potentialValue\n */ function headerValueNormalize(potentialValue) {\n    //  To normalize a byte sequence potentialValue, remove\n    //  any leading and trailing HTTP whitespace bytes from\n    //  potentialValue.\n    let i = 0;\n    let j = potentialValue.length;\n    while(j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1)))--j;\n    while(j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i)))++i;\n    return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);\n}\nfunction fill(headers, object) {\n    // To fill a Headers object headers with a given object object, run these steps:\n    // 1. If object is a sequence, then for each header in object:\n    // Note: webidl conversion to array has already been done.\n    if (Array.isArray(object)) {\n        for(let i = 0; i < object.length; ++i){\n            const header = object[i];\n            // 1. If header does not contain exactly two items, then throw a TypeError.\n            if (header.length !== 2) {\n                throw webidl.errors.exception({\n                    header: \"Headers constructor\",\n                    message: `expected name/value pair to be length 2, found ${header.length}.`\n                });\n            }\n            // 2. Append (headers first item, headers second item) to headers.\n            appendHeader(headers, header[0], header[1]);\n        }\n    } else if (typeof object === \"object\" && object !== null) {\n        // Note: null should throw\n        // 2. Otherwise, object is a record, then for each key  value in object,\n        //    append (key, value) to headers\n        const keys = Object.keys(object);\n        for(let i = 0; i < keys.length; ++i){\n            appendHeader(headers, keys[i], object[keys[i]]);\n        }\n    } else {\n        throw webidl.errors.conversionFailed({\n            prefix: \"Headers constructor\",\n            argument: \"Argument 1\",\n            types: [\n                \"sequence<sequence<ByteString>>\",\n                \"record<ByteString, ByteString>\"\n            ]\n        });\n    }\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-headers-append\n */ function appendHeader(headers, name, value) {\n    // 1. Normalize value.\n    value = headerValueNormalize(value);\n    // 2. If name is not a header name or value is not a\n    //    header value, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n        throw webidl.errors.invalidArgument({\n            prefix: \"Headers.append\",\n            value: name,\n            type: \"header name\"\n        });\n    } else if (!isValidHeaderValue(value)) {\n        throw webidl.errors.invalidArgument({\n            prefix: \"Headers.append\",\n            value,\n            type: \"header value\"\n        });\n    }\n    // 3. If headerss guard is \"immutable\", then throw a TypeError.\n    // 4. Otherwise, if headerss guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // Note: undici does not implement forbidden header names\n    if (headers[kGuard] === \"immutable\") {\n        throw new TypeError(\"immutable\");\n    } else if (headers[kGuard] === \"request-no-cors\") {\n    // 5. Otherwise, if headerss guard is \"request-no-cors\":\n    // TODO\n    }\n    // 6. Otherwise, if headerss guard is \"response\" and name is a\n    //    forbidden response-header name, return.\n    // 7. Append (name, value) to headerss header list.\n    return headers[kHeadersList].append(name, value);\n// 8. If headerss guard is \"request-no-cors\", then remove\n//    privileged no-CORS request headers from headers\n}\nclass HeadersList {\n    constructor(init){\n        /** @type {[string, string][]|null} */ this.cookies = null;\n        if (init instanceof HeadersList) {\n            this[kHeadersMap] = new Map(init[kHeadersMap]);\n            this[kHeadersSortedMap] = init[kHeadersSortedMap];\n            this.cookies = init.cookies === null ? null : [\n                ...init.cookies\n            ];\n        } else {\n            this[kHeadersMap] = new Map(init);\n            this[kHeadersSortedMap] = null;\n        }\n    }\n    // https://fetch.spec.whatwg.org/#header-list-contains\n    contains(name) {\n        // A header list list contains a header name name if list\n        // contains a header whose name is a byte-case-insensitive\n        // match for name.\n        name = name.toLowerCase();\n        return this[kHeadersMap].has(name);\n    }\n    clear() {\n        this[kHeadersMap].clear();\n        this[kHeadersSortedMap] = null;\n        this.cookies = null;\n    }\n    // https://fetch.spec.whatwg.org/#concept-header-list-append\n    append(name, value) {\n        this[kHeadersSortedMap] = null;\n        // 1. If list contains name, then set name to the first such\n        //    headers name.\n        const lowercaseName = name.toLowerCase();\n        const exists = this[kHeadersMap].get(lowercaseName);\n        // 2. Append (name, value) to list.\n        if (exists) {\n            const delimiter = lowercaseName === \"cookie\" ? \"; \" : \", \";\n            this[kHeadersMap].set(lowercaseName, {\n                name: exists.name,\n                value: `${exists.value}${delimiter}${value}`\n            });\n        } else {\n            this[kHeadersMap].set(lowercaseName, {\n                name,\n                value\n            });\n        }\n        if (lowercaseName === \"set-cookie\") {\n            this.cookies ??= [];\n            this.cookies.push(value);\n        }\n    }\n    // https://fetch.spec.whatwg.org/#concept-header-list-set\n    set(name, value) {\n        this[kHeadersSortedMap] = null;\n        const lowercaseName = name.toLowerCase();\n        if (lowercaseName === \"set-cookie\") {\n            this.cookies = [\n                value\n            ];\n        }\n        // 1. If list contains name, then set the value of\n        //    the first such header to value and remove the\n        //    others.\n        // 2. Otherwise, append header (name, value) to list.\n        this[kHeadersMap].set(lowercaseName, {\n            name,\n            value\n        });\n    }\n    // https://fetch.spec.whatwg.org/#concept-header-list-delete\n    delete(name) {\n        this[kHeadersSortedMap] = null;\n        name = name.toLowerCase();\n        if (name === \"set-cookie\") {\n            this.cookies = null;\n        }\n        this[kHeadersMap].delete(name);\n    }\n    // https://fetch.spec.whatwg.org/#concept-header-list-get\n    get(name) {\n        const value = this[kHeadersMap].get(name.toLowerCase());\n        // 1. If list does not contain name, then return null.\n        // 2. Return the values of all headers in list whose name\n        //    is a byte-case-insensitive match for name,\n        //    separated from each other by 0x2C 0x20, in order.\n        return value === undefined ? null : value.value;\n    }\n    *[Symbol.iterator]() {\n        // use the lowercased name\n        for (const [name, { value }] of this[kHeadersMap]){\n            yield [\n                name,\n                value\n            ];\n        }\n    }\n    get entries() {\n        const headers = {};\n        if (this[kHeadersMap].size) {\n            for (const { name, value } of this[kHeadersMap].values()){\n                headers[name] = value;\n            }\n        }\n        return headers;\n    }\n}\n// https://fetch.spec.whatwg.org/#headers-class\nclass Headers {\n    constructor(init = undefined){\n        if (init === kConstruct) {\n            return;\n        }\n        this[kHeadersList] = new HeadersList();\n        // The new Headers(init) constructor steps are:\n        // 1. Set thiss guard to \"none\".\n        this[kGuard] = \"none\";\n        // 2. If init is given, then fill this with init.\n        if (init !== undefined) {\n            init = webidl.converters.HeadersInit(init);\n            fill(this, init);\n        }\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-append\n    append(name, value) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 2, {\n            header: \"Headers.append\"\n        });\n        name = webidl.converters.ByteString(name);\n        value = webidl.converters.ByteString(value);\n        return appendHeader(this, name, value);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-delete\n    delete(name) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Headers.delete\"\n        });\n        name = webidl.converters.ByteString(name);\n        // 1. If name is not a header name, then throw a TypeError.\n        if (!isValidHeaderName(name)) {\n            throw webidl.errors.invalidArgument({\n                prefix: \"Headers.delete\",\n                value: name,\n                type: \"header name\"\n            });\n        }\n        // 2. If thiss guard is \"immutable\", then throw a TypeError.\n        // 3. Otherwise, if thiss guard is \"request\" and name is a\n        //    forbidden header name, return.\n        // 4. Otherwise, if thiss guard is \"request-no-cors\", name\n        //    is not a no-CORS-safelisted request-header name, and\n        //    name is not a privileged no-CORS request-header name,\n        //    return.\n        // 5. Otherwise, if thiss guard is \"response\" and name is\n        //    a forbidden response-header name, return.\n        // Note: undici does not implement forbidden header names\n        if (this[kGuard] === \"immutable\") {\n            throw new TypeError(\"immutable\");\n        } else if (this[kGuard] === \"request-no-cors\") {\n        // TODO\n        }\n        // 6. If thiss header list does not contain name, then\n        //    return.\n        if (!this[kHeadersList].contains(name)) {\n            return;\n        }\n        // 7. Delete name from thiss header list.\n        // 8. If thiss guard is \"request-no-cors\", then remove\n        //    privileged no-CORS request headers from this.\n        this[kHeadersList].delete(name);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-get\n    get(name) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Headers.get\"\n        });\n        name = webidl.converters.ByteString(name);\n        // 1. If name is not a header name, then throw a TypeError.\n        if (!isValidHeaderName(name)) {\n            throw webidl.errors.invalidArgument({\n                prefix: \"Headers.get\",\n                value: name,\n                type: \"header name\"\n            });\n        }\n        // 2. Return the result of getting name from thiss header\n        //    list.\n        return this[kHeadersList].get(name);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-has\n    has(name) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Headers.has\"\n        });\n        name = webidl.converters.ByteString(name);\n        // 1. If name is not a header name, then throw a TypeError.\n        if (!isValidHeaderName(name)) {\n            throw webidl.errors.invalidArgument({\n                prefix: \"Headers.has\",\n                value: name,\n                type: \"header name\"\n            });\n        }\n        // 2. Return true if thiss header list contains name;\n        //    otherwise false.\n        return this[kHeadersList].contains(name);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-set\n    set(name, value) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 2, {\n            header: \"Headers.set\"\n        });\n        name = webidl.converters.ByteString(name);\n        value = webidl.converters.ByteString(value);\n        // 1. Normalize value.\n        value = headerValueNormalize(value);\n        // 2. If name is not a header name or value is not a\n        //    header value, then throw a TypeError.\n        if (!isValidHeaderName(name)) {\n            throw webidl.errors.invalidArgument({\n                prefix: \"Headers.set\",\n                value: name,\n                type: \"header name\"\n            });\n        } else if (!isValidHeaderValue(value)) {\n            throw webidl.errors.invalidArgument({\n                prefix: \"Headers.set\",\n                value,\n                type: \"header value\"\n            });\n        }\n        // 3. If thiss guard is \"immutable\", then throw a TypeError.\n        // 4. Otherwise, if thiss guard is \"request\" and name is a\n        //    forbidden header name, return.\n        // 5. Otherwise, if thiss guard is \"request-no-cors\" and\n        //    name/value is not a no-CORS-safelisted request-header,\n        //    return.\n        // 6. Otherwise, if thiss guard is \"response\" and name is a\n        //    forbidden response-header name, return.\n        // Note: undici does not implement forbidden header names\n        if (this[kGuard] === \"immutable\") {\n            throw new TypeError(\"immutable\");\n        } else if (this[kGuard] === \"request-no-cors\") {\n        // TODO\n        }\n        // 7. Set (name, value) in thiss header list.\n        // 8. If thiss guard is \"request-no-cors\", then remove\n        //    privileged no-CORS request headers from this\n        this[kHeadersList].set(name, value);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie\n    getSetCookie() {\n        webidl.brandCheck(this, Headers);\n        // 1. If thiss header list does not contain `Set-Cookie`, then return  .\n        // 2. Return the values of all headers in thiss header list whose name is\n        //    a byte-case-insensitive match for `Set-Cookie`, in order.\n        const list = this[kHeadersList].cookies;\n        if (list) {\n            return [\n                ...list\n            ];\n        }\n        return [];\n    }\n    // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n    get [kHeadersSortedMap]() {\n        if (this[kHeadersList][kHeadersSortedMap]) {\n            return this[kHeadersList][kHeadersSortedMap];\n        }\n        // 1. Let headers be an empty list of headers with the key being the name\n        //    and value the value.\n        const headers = [];\n        // 2. Let names be the result of convert header names to a sorted-lowercase\n        //    set with all the names of the headers in list.\n        const names = [\n            ...this[kHeadersList]\n        ].sort((a, b)=>a[0] < b[0] ? -1 : 1);\n        const cookies = this[kHeadersList].cookies;\n        // 3. For each name of names:\n        for(let i = 0; i < names.length; ++i){\n            const [name, value] = names[i];\n            // 1. If name is `set-cookie`, then:\n            if (name === \"set-cookie\") {\n                // 1. Let values be a list of all values of headers in list whose name\n                //    is a byte-case-insensitive match for name, in order.\n                // 2. For each value of values:\n                // 1. Append (name, value) to headers.\n                for(let j = 0; j < cookies.length; ++j){\n                    headers.push([\n                        name,\n                        cookies[j]\n                    ]);\n                }\n            } else {\n                // 2. Otherwise:\n                // 1. Let value be the result of getting name from list.\n                // 2. Assert: value is non-null.\n                assert(value !== null);\n                // 3. Append (name, value) to headers.\n                headers.push([\n                    name,\n                    value\n                ]);\n            }\n        }\n        this[kHeadersList][kHeadersSortedMap] = headers;\n        // 4. Return headers.\n        return headers;\n    }\n    keys() {\n        webidl.brandCheck(this, Headers);\n        if (this[kGuard] === \"immutable\") {\n            const value = this[kHeadersSortedMap];\n            return makeIterator(()=>value, \"Headers\", \"key\");\n        }\n        return makeIterator(()=>[\n                ...this[kHeadersSortedMap].values()\n            ], \"Headers\", \"key\");\n    }\n    values() {\n        webidl.brandCheck(this, Headers);\n        if (this[kGuard] === \"immutable\") {\n            const value = this[kHeadersSortedMap];\n            return makeIterator(()=>value, \"Headers\", \"value\");\n        }\n        return makeIterator(()=>[\n                ...this[kHeadersSortedMap].values()\n            ], \"Headers\", \"value\");\n    }\n    entries() {\n        webidl.brandCheck(this, Headers);\n        if (this[kGuard] === \"immutable\") {\n            const value = this[kHeadersSortedMap];\n            return makeIterator(()=>value, \"Headers\", \"key+value\");\n        }\n        return makeIterator(()=>[\n                ...this[kHeadersSortedMap].values()\n            ], \"Headers\", \"key+value\");\n    }\n    /**\n   * @param {(value: string, key: string, self: Headers) => void} callbackFn\n   * @param {unknown} thisArg\n   */ forEach(callbackFn, thisArg = globalThis) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Headers.forEach\"\n        });\n        if (typeof callbackFn !== \"function\") {\n            throw new TypeError(\"Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.\");\n        }\n        for (const [key, value] of this){\n            callbackFn.apply(thisArg, [\n                value,\n                key,\n                this\n            ]);\n        }\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        webidl.brandCheck(this, Headers);\n        return this[kHeadersList];\n    }\n}\nHeaders.prototype[Symbol.iterator] = Headers.prototype.entries;\nObject.defineProperties(Headers.prototype, {\n    append: kEnumerableProperty,\n    delete: kEnumerableProperty,\n    get: kEnumerableProperty,\n    has: kEnumerableProperty,\n    set: kEnumerableProperty,\n    getSetCookie: kEnumerableProperty,\n    keys: kEnumerableProperty,\n    values: kEnumerableProperty,\n    entries: kEnumerableProperty,\n    forEach: kEnumerableProperty,\n    [Symbol.iterator]: {\n        enumerable: false\n    },\n    [Symbol.toStringTag]: {\n        value: \"Headers\",\n        configurable: true\n    }\n});\nwebidl.converters.HeadersInit = function(V) {\n    if (webidl.util.Type(V) === \"Object\") {\n        if (V[Symbol.iterator]) {\n            return webidl.converters[\"sequence<sequence<ByteString>>\"](V);\n        }\n        return webidl.converters[\"record<ByteString, ByteString>\"](V);\n    }\n    throw webidl.errors.conversionFailed({\n        prefix: \"Headers constructor\",\n        argument: \"Argument 1\",\n        types: [\n            \"sequence<sequence<ByteString>>\",\n            \"record<ByteString, ByteString>\"\n        ]\n    });\n};\nmodule.exports = {\n    fill,\n    Headers,\n    HeadersList\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvaGVhZGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpREFBaUQ7QUFFakQ7QUFFQSxNQUFNLEVBQUVBLFlBQVksRUFBRUMsVUFBVSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzdDLE1BQU0sRUFBRUMsTUFBTSxFQUFFLEdBQUdELG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRUUsbUJBQW1CLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDeEMsTUFBTSxFQUNKRyxZQUFZLEVBQ1pDLGlCQUFpQixFQUNqQkMsa0JBQWtCLEVBQ25CLEdBQUdMLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFTSxNQUFNLEVBQUUsR0FBR04sbUJBQU9BLENBQUM7QUFDM0IsTUFBTU8sU0FBU1AsbUJBQU9BLENBQUM7QUFFdkIsTUFBTVEsY0FBY0MsT0FBTztBQUMzQixNQUFNQyxvQkFBb0JELE9BQU87QUFFakM7O0NBRUMsR0FDRCxTQUFTRSx5QkFBMEJDLElBQUk7SUFDckMsT0FBT0EsU0FBUyxTQUFTQSxTQUFTLFNBQVNBLFNBQVMsU0FBU0EsU0FBUztBQUN4RTtBQUVBOzs7Q0FHQyxHQUNELFNBQVNDLHFCQUFzQkMsY0FBYztJQUMzQyx1REFBdUQ7SUFDdkQsdURBQXVEO0lBQ3ZELG1CQUFtQjtJQUNuQixJQUFJQyxJQUFJO0lBQUcsSUFBSUMsSUFBSUYsZUFBZUcsTUFBTTtJQUV4QyxNQUFPRCxJQUFJRCxLQUFLSix5QkFBeUJHLGVBQWVJLFVBQVUsQ0FBQ0YsSUFBSSxJQUFLLEVBQUVBO0lBQzlFLE1BQU9BLElBQUlELEtBQUtKLHlCQUF5QkcsZUFBZUksVUFBVSxDQUFDSCxJQUFLLEVBQUVBO0lBRTFFLE9BQU9BLE1BQU0sS0FBS0MsTUFBTUYsZUFBZUcsTUFBTSxHQUFHSCxpQkFBaUJBLGVBQWVLLFNBQVMsQ0FBQ0osR0FBR0M7QUFDL0Y7QUFFQSxTQUFTSSxLQUFN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T0FBT2tELFFBQVEsQ0FBQyxHQUFHSSxRQUFRb0IsU0FBUyxDQUFDdkIsT0FBTztBQUU5RDdCLE9BQU9xRCxnQkFBZ0IsQ0FBQ3JCLFFBQVFvQixTQUFTLEVBQUU7SUFDekMxQyxRQUFRdkM7SUFDUnVELFFBQVF2RDtJQUNSbUQsS0FBS25EO0lBQ0wrQyxLQUFLL0M7SUFDTHFELEtBQUtyRDtJQUNMb0UsY0FBY3BFO0lBQ2Q0QixNQUFNNUI7SUFDTjRELFFBQVE1RDtJQUNSMEQsU0FBUzFEO0lBQ1QwRSxTQUFTMUU7SUFDVCxDQUFDTyxPQUFPa0QsUUFBUSxDQUFDLEVBQUU7UUFBRTBCLFlBQVk7SUFBTTtJQUN2QyxDQUFDNUUsT0FBTzZFLFdBQVcsQ0FBQyxFQUFFO1FBQ3BCakQsT0FBTztRQUNQa0QsY0FBYztJQUNoQjtBQUNGO0FBRUFqRixPQUFPMEQsVUFBVSxDQUFDQyxXQUFXLEdBQUcsU0FBVXVCLENBQUM7SUFDekMsSUFBSWxGLE9BQU9tRixJQUFJLENBQUNDLElBQUksQ0FBQ0YsT0FBTyxVQUFVO1FBQ3BDLElBQUlBLENBQUMsQ0FBQy9FLE9BQU9rRCxRQUFRLENBQUMsRUFBRTtZQUN0QixPQUFPckQsT0FBTzBELFVBQVUsQ0FBQyxpQ0FBaUMsQ0FBQ3dCO1FBQzdEO1FBRUEsT0FBT2xGLE9BQU8wRCxVQUFVLENBQUMsaUNBQWlDLENBQUN3QjtJQUM3RDtJQUVBLE1BQU1sRixPQUFPb0IsTUFBTSxDQUFDTSxnQkFBZ0IsQ0FBQztRQUNuQ0MsUUFBUTtRQUNSQyxVQUFVO1FBQ1ZDLE9BQU87WUFBQztZQUFrQztTQUFpQztJQUM3RTtBQUNGO0FBRUF3RCxPQUFPQyxPQUFPLEdBQUc7SUFDZnhFO0lBQ0EyQztJQUNBckI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL2hlYWRlcnMuanM/M2QzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2dpdGh1Yi5jb20vRXRoYW4tQXJyb3dvb2QvdW5kaWNpLWZldGNoXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGtIZWFkZXJzTGlzdCwga0NvbnN0cnVjdCB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IHsga0d1YXJkIH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3Qge1xuICBtYWtlSXRlcmF0b3IsXG4gIGlzVmFsaWRIZWFkZXJOYW1lLFxuICBpc1ZhbGlkSGVhZGVyVmFsdWVcbn0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4vd2ViaWRsJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5cbmNvbnN0IGtIZWFkZXJzTWFwID0gU3ltYm9sKCdoZWFkZXJzIG1hcCcpXG5jb25zdCBrSGVhZGVyc1NvcnRlZE1hcCA9IFN5bWJvbCgnaGVhZGVycyBtYXAgc29ydGVkJylcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICovXG5mdW5jdGlvbiBpc0hUVFBXaGl0ZVNwYWNlQ2hhckNvZGUgKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDB4MDBhIHx8IGNvZGUgPT09IDB4MDBkIHx8IGNvZGUgPT09IDB4MDA5IHx8IGNvZGUgPT09IDB4MDIwXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItdmFsdWUtbm9ybWFsaXplXG4gKiBAcGFyYW0ge3N0cmluZ30gcG90ZW50aWFsVmFsdWVcbiAqL1xuZnVuY3Rpb24gaGVhZGVyVmFsdWVOb3JtYWxpemUgKHBvdGVudGlhbFZhbHVlKSB7XG4gIC8vICBUbyBub3JtYWxpemUgYSBieXRlIHNlcXVlbmNlIHBvdGVudGlhbFZhbHVlLCByZW1vdmVcbiAgLy8gIGFueSBsZWFkaW5nIGFuZCB0cmFpbGluZyBIVFRQIHdoaXRlc3BhY2UgYnl0ZXMgZnJvbVxuICAvLyAgcG90ZW50aWFsVmFsdWUuXG4gIGxldCBpID0gMDsgbGV0IGogPSBwb3RlbnRpYWxWYWx1ZS5sZW5ndGhcblxuICB3aGlsZSAoaiA+IGkgJiYgaXNIVFRQV2hpdGVTcGFjZUNoYXJDb2RlKHBvdGVudGlhbFZhbHVlLmNoYXJDb2RlQXQoaiAtIDEpKSkgLS1qXG4gIHdoaWxlIChqID4gaSAmJiBpc0hUVFBXaGl0ZVNwYWNlQ2hhckNvZGUocG90ZW50aWFsVmFsdWUuY2hhckNvZGVBdChpKSkpICsraVxuXG4gIHJldHVybiBpID09PSAwICYmIGogPT09IHBvdGVudGlhbFZhbHVlLmxlbmd0aCA/IHBvdGVudGlhbFZhbHVlIDogcG90ZW50aWFsVmFsdWUuc3Vic3RyaW5nKGksIGopXG59XG5cbmZ1bmN0aW9uIGZpbGwgKGhlYWRlcnMsIG9iamVjdCkge1xuICAvLyBUbyBmaWxsIGEgSGVhZGVycyBvYmplY3QgaGVhZGVycyB3aXRoIGEgZ2l2ZW4gb2JqZWN0IG9iamVjdCwgcnVuIHRoZXNlIHN0ZXBzOlxuXG4gIC8vIDEuIElmIG9iamVjdCBpcyBhIHNlcXVlbmNlLCB0aGVuIGZvciBlYWNoIGhlYWRlciBpbiBvYmplY3Q6XG4gIC8vIE5vdGU6IHdlYmlkbCBjb252ZXJzaW9uIHRvIGFycmF5IGhhcyBhbHJlYWR5IGJlZW4gZG9uZS5cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBoZWFkZXIgPSBvYmplY3RbaV1cbiAgICAgIC8vIDEuIElmIGhlYWRlciBkb2VzIG5vdCBjb250YWluIGV4YWN0bHkgdHdvIGl0ZW1zLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKGhlYWRlci5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgIGhlYWRlcjogJ0hlYWRlcnMgY29uc3RydWN0b3InLFxuICAgICAgICAgIG1lc3NhZ2U6IGBleHBlY3RlZCBuYW1lL3ZhbHVlIHBhaXIgdG8gYmUgbGVuZ3RoIDIsIGZvdW5kICR7aGVhZGVyLmxlbmd0aH0uYFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBBcHBlbmQgKGhlYWRlcuKAmXMgZmlyc3QgaXRlbSwgaGVhZGVy4oCZcyBzZWNvbmQgaXRlbSkgdG8gaGVhZGVycy5cbiAgICAgIGFwcGVuZEhlYWRlcihoZWFkZXJzLCBoZWFkZXJbMF0sIGhlYWRlclsxXSlcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgLy8gTm90ZTogbnVsbCBzaG91bGQgdGhyb3dcblxuICAgIC8vIDIuIE90aGVyd2lzZSwgb2JqZWN0IGlzIGEgcmVjb3JkLCB0aGVuIGZvciBlYWNoIGtleSDihpIgdmFsdWUgaW4gb2JqZWN0LFxuICAgIC8vICAgIGFwcGVuZCAoa2V5LCB2YWx1ZSkgdG8gaGVhZGVyc1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBhcHBlbmRIZWFkZXIoaGVhZGVycywga2V5c1tpXSwgb2JqZWN0W2tleXNbaV1dKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgICAgcHJlZml4OiAnSGVhZGVycyBjb25zdHJ1Y3RvcicsXG4gICAgICBhcmd1bWVudDogJ0FyZ3VtZW50IDEnLFxuICAgICAgdHlwZXM6IFsnc2VxdWVuY2U8c2VxdWVuY2U8Qnl0ZVN0cmluZz4+JywgJ3JlY29yZDxCeXRlU3RyaW5nLCBCeXRlU3RyaW5nPiddXG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVycy1hcHBlbmRcbiAqL1xuZnVuY3Rpb24gYXBwZW5kSGVhZGVyIChoZWFkZXJzLCBuYW1lLCB2YWx1ZSkge1xuICAvLyAxLiBOb3JtYWxpemUgdmFsdWUuXG4gIHZhbHVlID0gaGVhZGVyVmFsdWVOb3JtYWxpemUodmFsdWUpXG5cbiAgLy8gMi4gSWYgbmFtZSBpcyBub3QgYSBoZWFkZXIgbmFtZSBvciB2YWx1ZSBpcyBub3QgYVxuICAvLyAgICBoZWFkZXIgdmFsdWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICBwcmVmaXg6ICdIZWFkZXJzLmFwcGVuZCcsXG4gICAgICB2YWx1ZTogbmFtZSxcbiAgICAgIHR5cGU6ICdoZWFkZXIgbmFtZSdcbiAgICB9KVxuICB9IGVsc2UgaWYgKCFpc1ZhbGlkSGVhZGVyVmFsdWUodmFsdWUpKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe1xuICAgICAgcHJlZml4OiAnSGVhZGVycy5hcHBlbmQnLFxuICAgICAgdmFsdWUsXG4gICAgICB0eXBlOiAnaGVhZGVyIHZhbHVlJ1xuICAgIH0pXG4gIH1cblxuICAvLyAzLiBJZiBoZWFkZXJz4oCZcyBndWFyZCBpcyBcImltbXV0YWJsZVwiLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAvLyA0LiBPdGhlcndpc2UsIGlmIGhlYWRlcnPigJlzIGd1YXJkIGlzIFwicmVxdWVzdFwiIGFuZCBuYW1lIGlzIGFcbiAgLy8gICAgZm9yYmlkZGVuIGhlYWRlciBuYW1lLCByZXR1cm4uXG4gIC8vIE5vdGU6IHVuZGljaSBkb2VzIG5vdCBpbXBsZW1lbnQgZm9yYmlkZGVuIGhlYWRlciBuYW1lc1xuICBpZiAoaGVhZGVyc1trR3VhcmRdID09PSAnaW1tdXRhYmxlJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ltbXV0YWJsZScpXG4gIH0gZWxzZSBpZiAoaGVhZGVyc1trR3VhcmRdID09PSAncmVxdWVzdC1uby1jb3JzJykge1xuICAgIC8vIDUuIE90aGVyd2lzZSwgaWYgaGVhZGVyc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0LW5vLWNvcnNcIjpcbiAgICAvLyBUT0RPXG4gIH1cblxuICAvLyA2LiBPdGhlcndpc2UsIGlmIGhlYWRlcnPigJlzIGd1YXJkIGlzIFwicmVzcG9uc2VcIiBhbmQgbmFtZSBpcyBhXG4gIC8vICAgIGZvcmJpZGRlbiByZXNwb25zZS1oZWFkZXIgbmFtZSwgcmV0dXJuLlxuXG4gIC8vIDcuIEFwcGVuZCAobmFtZSwgdmFsdWUpIHRvIGhlYWRlcnPigJlzIGhlYWRlciBsaXN0LlxuICByZXR1cm4gaGVhZGVyc1trSGVhZGVyc0xpc3RdLmFwcGVuZChuYW1lLCB2YWx1ZSlcblxuICAvLyA4LiBJZiBoZWFkZXJz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiLCB0aGVuIHJlbW92ZVxuICAvLyAgICBwcml2aWxlZ2VkIG5vLUNPUlMgcmVxdWVzdCBoZWFkZXJzIGZyb20gaGVhZGVyc1xufVxuXG5jbGFzcyBIZWFkZXJzTGlzdCB7XG4gIC8qKiBAdHlwZSB7W3N0cmluZywgc3RyaW5nXVtdfG51bGx9ICovXG4gIGNvb2tpZXMgPSBudWxsXG5cbiAgY29uc3RydWN0b3IgKGluaXQpIHtcbiAgICBpZiAoaW5pdCBpbnN0YW5jZW9mIEhlYWRlcnNMaXN0KSB7XG4gICAgICB0aGlzW2tIZWFkZXJzTWFwXSA9IG5ldyBNYXAoaW5pdFtrSGVhZGVyc01hcF0pXG4gICAgICB0aGlzW2tIZWFkZXJzU29ydGVkTWFwXSA9IGluaXRba0hlYWRlcnNTb3J0ZWRNYXBdXG4gICAgICB0aGlzLmNvb2tpZXMgPSBpbml0LmNvb2tpZXMgPT09IG51bGwgPyBudWxsIDogWy4uLmluaXQuY29va2llc11cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trSGVhZGVyc01hcF0gPSBuZXcgTWFwKGluaXQpXG4gICAgICB0aGlzW2tIZWFkZXJzU29ydGVkTWFwXSA9IG51bGxcbiAgICB9XG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaGVhZGVyLWxpc3QtY29udGFpbnNcbiAgY29udGFpbnMgKG5hbWUpIHtcbiAgICAvLyBBIGhlYWRlciBsaXN0IGxpc3QgY29udGFpbnMgYSBoZWFkZXIgbmFtZSBuYW1lIGlmIGxpc3RcbiAgICAvLyBjb250YWlucyBhIGhlYWRlciB3aG9zZSBuYW1lIGlzIGEgYnl0ZS1jYXNlLWluc2Vuc2l0aXZlXG4gICAgLy8gbWF0Y2ggZm9yIG5hbWUuXG4gICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKVxuXG4gICAgcmV0dXJuIHRoaXNba0hlYWRlcnNNYXBdLmhhcyhuYW1lKVxuICB9XG5cbiAgY2xlYXIgKCkge1xuICAgIHRoaXNba0hlYWRlcnNNYXBdLmNsZWFyKClcbiAgICB0aGlzW2tIZWFkZXJzU29ydGVkTWFwXSA9IG51bGxcbiAgICB0aGlzLmNvb2tpZXMgPSBudWxsXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1hcHBlbmRcbiAgYXBwZW5kIChuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdID0gbnVsbFxuXG4gICAgLy8gMS4gSWYgbGlzdCBjb250YWlucyBuYW1lLCB0aGVuIHNldCBuYW1lIHRvIHRoZSBmaXJzdCBzdWNoXG4gICAgLy8gICAgaGVhZGVy4oCZcyBuYW1lLlxuICAgIGNvbnN0IGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKClcbiAgICBjb25zdCBleGlzdHMgPSB0aGlzW2tIZWFkZXJzTWFwXS5nZXQobG93ZXJjYXNlTmFtZSlcblxuICAgIC8vIDIuIEFwcGVuZCAobmFtZSwgdmFsdWUpIHRvIGxpc3QuXG4gICAgaWYgKGV4aXN0cykge1xuICAgICAgY29uc3QgZGVsaW1pdGVyID0gbG93ZXJjYXNlTmFtZSA9PT0gJ2Nvb2tpZScgPyAnOyAnIDogJywgJ1xuICAgICAgdGhpc1trSGVhZGVyc01hcF0uc2V0KGxvd2VyY2FzZU5hbWUsIHtcbiAgICAgICAgbmFtZTogZXhpc3RzLm5hbWUsXG4gICAgICAgIHZhbHVlOiBgJHtleGlzdHMudmFsdWV9JHtkZWxpbWl0ZXJ9JHt2YWx1ZX1gXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tIZWFkZXJzTWFwXS5zZXQobG93ZXJjYXNlTmFtZSwgeyBuYW1lLCB2YWx1ZSB9KVxuICAgIH1cblxuICAgIGlmIChsb3dlcmNhc2VOYW1lID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgIHRoaXMuY29va2llcyA/Pz0gW11cbiAgICAgIHRoaXMuY29va2llcy5wdXNoKHZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LXNldFxuICBzZXQgKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpc1trSGVhZGVyc1NvcnRlZE1hcF0gPSBudWxsXG4gICAgY29uc3QgbG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKVxuXG4gICAgaWYgKGxvd2VyY2FzZU5hbWUgPT09ICdzZXQtY29va2llJykge1xuICAgICAgdGhpcy5jb29raWVzID0gW3ZhbHVlXVxuICAgIH1cblxuICAgIC8vIDEuIElmIGxpc3QgY29udGFpbnMgbmFtZSwgdGhlbiBzZXQgdGhlIHZhbHVlIG9mXG4gICAgLy8gICAgdGhlIGZpcnN0IHN1Y2ggaGVhZGVyIHRvIHZhbHVlIGFuZCByZW1vdmUgdGhlXG4gICAgLy8gICAgb3RoZXJzLlxuICAgIC8vIDIuIE90aGVyd2lzZSwgYXBwZW5kIGhlYWRlciAobmFtZSwgdmFsdWUpIHRvIGxpc3QuXG4gICAgdGhpc1trSGVhZGVyc01hcF0uc2V0KGxvd2VyY2FzZU5hbWUsIHsgbmFtZSwgdmFsdWUgfSlcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LWRlbGV0ZVxuICBkZWxldGUgKG5hbWUpIHtcbiAgICB0aGlzW2tIZWFkZXJzU29ydGVkTWFwXSA9IG51bGxcblxuICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKClcblxuICAgIGlmIChuYW1lID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgIHRoaXMuY29va2llcyA9IG51bGxcbiAgICB9XG5cbiAgICB0aGlzW2tIZWFkZXJzTWFwXS5kZWxldGUobmFtZSlcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LWdldFxuICBnZXQgKG5hbWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXNba0hlYWRlcnNNYXBdLmdldChuYW1lLnRvTG93ZXJDYXNlKCkpXG5cbiAgICAvLyAxLiBJZiBsaXN0IGRvZXMgbm90IGNvbnRhaW4gbmFtZSwgdGhlbiByZXR1cm4gbnVsbC5cbiAgICAvLyAyLiBSZXR1cm4gdGhlIHZhbHVlcyBvZiBhbGwgaGVhZGVycyBpbiBsaXN0IHdob3NlIG5hbWVcbiAgICAvLyAgICBpcyBhIGJ5dGUtY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3IgbmFtZSxcbiAgICAvLyAgICBzZXBhcmF0ZWQgZnJvbSBlYWNoIG90aGVyIGJ5IDB4MkMgMHgyMCwgaW4gb3JkZXIuXG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyBudWxsIDogdmFsdWUudmFsdWVcbiAgfVxuXG4gICogW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgIC8vIHVzZSB0aGUgbG93ZXJjYXNlZCBuYW1lXG4gICAgZm9yIChjb25zdCBbbmFtZSwgeyB2YWx1ZSB9XSBvZiB0aGlzW2tIZWFkZXJzTWFwXSkge1xuICAgICAgeWllbGQgW25hbWUsIHZhbHVlXVxuICAgIH1cbiAgfVxuXG4gIGdldCBlbnRyaWVzICgpIHtcbiAgICBjb25zdCBoZWFkZXJzID0ge31cblxuICAgIGlmICh0aGlzW2tIZWFkZXJzTWFwXS5zaXplKSB7XG4gICAgICBmb3IgKGNvbnN0IHsgbmFtZSwgdmFsdWUgfSBvZiB0aGlzW2tIZWFkZXJzTWFwXS52YWx1ZXMoKSkge1xuICAgICAgICBoZWFkZXJzW25hbWVdID0gdmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNoZWFkZXJzLWNsYXNzXG5jbGFzcyBIZWFkZXJzIHtcbiAgY29uc3RydWN0b3IgKGluaXQgPSB1bmRlZmluZWQpIHtcbiAgICBpZiAoaW5pdCA9PT0ga0NvbnN0cnVjdCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXNba0hlYWRlcnNMaXN0XSA9IG5ldyBIZWFkZXJzTGlzdCgpXG5cbiAgICAvLyBUaGUgbmV3IEhlYWRlcnMoaW5pdCkgY29uc3RydWN0b3Igc3RlcHMgYXJlOlxuXG4gICAgLy8gMS4gU2V0IHRoaXPigJlzIGd1YXJkIHRvIFwibm9uZVwiLlxuICAgIHRoaXNba0d1YXJkXSA9ICdub25lJ1xuXG4gICAgLy8gMi4gSWYgaW5pdCBpcyBnaXZlbiwgdGhlbiBmaWxsIHRoaXMgd2l0aCBpbml0LlxuICAgIGlmIChpbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGluaXQgPSB3ZWJpZGwuY29udmVydGVycy5IZWFkZXJzSW5pdChpbml0KVxuICAgICAgZmlsbCh0aGlzLCBpbml0KVxuICAgIH1cbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20taGVhZGVycy1hcHBlbmRcbiAgYXBwZW5kIChuYW1lLCB2YWx1ZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDIsIHsgaGVhZGVyOiAnSGVhZGVycy5hcHBlbmQnIH0pXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lKVxuICAgIHZhbHVlID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyh2YWx1ZSlcblxuICAgIHJldHVybiBhcHBlbmRIZWFkZXIodGhpcywgbmFtZSwgdmFsdWUpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtZGVsZXRlXG4gIGRlbGV0ZSAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnSGVhZGVycy5kZWxldGUnIH0pXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lKVxuXG4gICAgLy8gMS4gSWYgbmFtZSBpcyBub3QgYSBoZWFkZXIgbmFtZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICAgIHByZWZpeDogJ0hlYWRlcnMuZGVsZXRlJyxcbiAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgIHR5cGU6ICdoZWFkZXIgbmFtZSdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJpbW11dGFibGVcIiwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAvLyAzLiBPdGhlcndpc2UsIGlmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVxdWVzdFwiIGFuZCBuYW1lIGlzIGFcbiAgICAvLyAgICBmb3JiaWRkZW4gaGVhZGVyIG5hbWUsIHJldHVybi5cbiAgICAvLyA0LiBPdGhlcndpc2UsIGlmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVxdWVzdC1uby1jb3JzXCIsIG5hbWVcbiAgICAvLyAgICBpcyBub3QgYSBuby1DT1JTLXNhZmVsaXN0ZWQgcmVxdWVzdC1oZWFkZXIgbmFtZSwgYW5kXG4gICAgLy8gICAgbmFtZSBpcyBub3QgYSBwcml2aWxlZ2VkIG5vLUNPUlMgcmVxdWVzdC1oZWFkZXIgbmFtZSxcbiAgICAvLyAgICByZXR1cm4uXG4gICAgLy8gNS4gT3RoZXJ3aXNlLCBpZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlc3BvbnNlXCIgYW5kIG5hbWUgaXNcbiAgICAvLyAgICBhIGZvcmJpZGRlbiByZXNwb25zZS1oZWFkZXIgbmFtZSwgcmV0dXJuLlxuICAgIC8vIE5vdGU6IHVuZGljaSBkb2VzIG5vdCBpbXBsZW1lbnQgZm9yYmlkZGVuIGhlYWRlciBuYW1lc1xuICAgIGlmICh0aGlzW2tHdWFyZF0gPT09ICdpbW11dGFibGUnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbW11dGFibGUnKVxuICAgIH0gZWxzZSBpZiAodGhpc1trR3VhcmRdID09PSAncmVxdWVzdC1uby1jb3JzJykge1xuICAgICAgLy8gVE9ET1xuICAgIH1cblxuICAgIC8vIDYuIElmIHRoaXPigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gbmFtZSwgdGhlblxuICAgIC8vICAgIHJldHVybi5cbiAgICBpZiAoIXRoaXNba0hlYWRlcnNMaXN0XS5jb250YWlucyhuYW1lKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gNy4gRGVsZXRlIG5hbWUgZnJvbSB0aGlz4oCZcyBoZWFkZXIgbGlzdC5cbiAgICAvLyA4LiBJZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiLCB0aGVuIHJlbW92ZVxuICAgIC8vICAgIHByaXZpbGVnZWQgbm8tQ09SUyByZXF1ZXN0IGhlYWRlcnMgZnJvbSB0aGlzLlxuICAgIHRoaXNba0hlYWRlcnNMaXN0XS5kZWxldGUobmFtZSlcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20taGVhZGVycy1nZXRcbiAgZ2V0IChuYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgSGVhZGVycylcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdIZWFkZXJzLmdldCcgfSlcblxuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nKG5hbWUpXG5cbiAgICAvLyAxLiBJZiBuYW1lIGlzIG5vdCBhIGhlYWRlciBuYW1lLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgcHJlZml4OiAnSGVhZGVycy5nZXQnLFxuICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgdHlwZTogJ2hlYWRlciBuYW1lJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBnZXR0aW5nIG5hbWUgZnJvbSB0aGlz4oCZcyBoZWFkZXJcbiAgICAvLyAgICBsaXN0LlxuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTGlzdF0uZ2V0KG5hbWUpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtaGFzXG4gIGhhcyAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnSGVhZGVycy5oYXMnIH0pXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lKVxuXG4gICAgLy8gMS4gSWYgbmFtZSBpcyBub3QgYSBoZWFkZXIgbmFtZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICAgIHByZWZpeDogJ0hlYWRlcnMuaGFzJyxcbiAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgIHR5cGU6ICdoZWFkZXIgbmFtZSdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gUmV0dXJuIHRydWUgaWYgdGhpc+KAmXMgaGVhZGVyIGxpc3QgY29udGFpbnMgbmFtZTtcbiAgICAvLyAgICBvdGhlcndpc2UgZmFsc2UuXG4gICAgcmV0dXJuIHRoaXNba0hlYWRlcnNMaXN0XS5jb250YWlucyhuYW1lKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1oZWFkZXJzLXNldFxuICBzZXQgKG5hbWUsIHZhbHVlKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgSGVhZGVycylcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMiwgeyBoZWFkZXI6ICdIZWFkZXJzLnNldCcgfSlcblxuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nKG5hbWUpXG4gICAgdmFsdWUgPSB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nKHZhbHVlKVxuXG4gICAgLy8gMS4gTm9ybWFsaXplIHZhbHVlLlxuICAgIHZhbHVlID0gaGVhZGVyVmFsdWVOb3JtYWxpemUodmFsdWUpXG5cbiAgICAvLyAyLiBJZiBuYW1lIGlzIG5vdCBhIGhlYWRlciBuYW1lIG9yIHZhbHVlIGlzIG5vdCBhXG4gICAgLy8gICAgaGVhZGVyIHZhbHVlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgcHJlZml4OiAnSGVhZGVycy5zZXQnLFxuICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgdHlwZTogJ2hlYWRlciBuYW1lJ1xuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKCFpc1ZhbGlkSGVhZGVyVmFsdWUodmFsdWUpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICAgIHByZWZpeDogJ0hlYWRlcnMuc2V0JyxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHR5cGU6ICdoZWFkZXIgdmFsdWUnXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDMuIElmIHRoaXPigJlzIGd1YXJkIGlzIFwiaW1tdXRhYmxlXCIsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgLy8gNC4gT3RoZXJ3aXNlLCBpZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlcXVlc3RcIiBhbmQgbmFtZSBpcyBhXG4gICAgLy8gICAgZm9yYmlkZGVuIGhlYWRlciBuYW1lLCByZXR1cm4uXG4gICAgLy8gNS4gT3RoZXJ3aXNlLCBpZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiIGFuZFxuICAgIC8vICAgIG5hbWUvdmFsdWUgaXMgbm90IGEgbm8tQ09SUy1zYWZlbGlzdGVkIHJlcXVlc3QtaGVhZGVyLFxuICAgIC8vICAgIHJldHVybi5cbiAgICAvLyA2LiBPdGhlcndpc2UsIGlmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVzcG9uc2VcIiBhbmQgbmFtZSBpcyBhXG4gICAgLy8gICAgZm9yYmlkZGVuIHJlc3BvbnNlLWhlYWRlciBuYW1lLCByZXR1cm4uXG4gICAgLy8gTm90ZTogdW5kaWNpIGRvZXMgbm90IGltcGxlbWVudCBmb3JiaWRkZW4gaGVhZGVyIG5hbWVzXG4gICAgaWYgKHRoaXNba0d1YXJkXSA9PT0gJ2ltbXV0YWJsZScpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ltbXV0YWJsZScpXG4gICAgfSBlbHNlIGlmICh0aGlzW2tHdWFyZF0gPT09ICdyZXF1ZXN0LW5vLWNvcnMnKSB7XG4gICAgICAvLyBUT0RPXG4gICAgfVxuXG4gICAgLy8gNy4gU2V0IChuYW1lLCB2YWx1ZSkgaW4gdGhpc+KAmXMgaGVhZGVyIGxpc3QuXG4gICAgLy8gOC4gSWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0LW5vLWNvcnNcIiwgdGhlbiByZW1vdmVcbiAgICAvLyAgICBwcml2aWxlZ2VkIG5vLUNPUlMgcmVxdWVzdCBoZWFkZXJzIGZyb20gdGhpc1xuICAgIHRoaXNba0hlYWRlcnNMaXN0XS5zZXQobmFtZSwgdmFsdWUpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtZ2V0c2V0Y29va2llXG4gIGdldFNldENvb2tpZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgSGVhZGVycylcblxuICAgIC8vIDEuIElmIHRoaXPigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYFNldC1Db29raWVgLCB0aGVuIHJldHVybiDCqyDCuy5cbiAgICAvLyAyLiBSZXR1cm4gdGhlIHZhbHVlcyBvZiBhbGwgaGVhZGVycyBpbiB0aGlz4oCZcyBoZWFkZXIgbGlzdCB3aG9zZSBuYW1lIGlzXG4gICAgLy8gICAgYSBieXRlLWNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIGBTZXQtQ29va2llYCwgaW4gb3JkZXIuXG5cbiAgICBjb25zdCBsaXN0ID0gdGhpc1trSGVhZGVyc0xpc3RdLmNvb2tpZXNcblxuICAgIGlmIChsaXN0KSB7XG4gICAgICByZXR1cm4gWy4uLmxpc3RdXG4gICAgfVxuXG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1zb3J0LWFuZC1jb21iaW5lXG4gIGdldCBba0hlYWRlcnNTb3J0ZWRNYXBdICgpIHtcbiAgICBpZiAodGhpc1trSGVhZGVyc0xpc3RdW2tIZWFkZXJzU29ydGVkTWFwXSkge1xuICAgICAgcmV0dXJuIHRoaXNba0hlYWRlcnNMaXN0XVtrSGVhZGVyc1NvcnRlZE1hcF1cbiAgICB9XG5cbiAgICAvLyAxLiBMZXQgaGVhZGVycyBiZSBhbiBlbXB0eSBsaXN0IG9mIGhlYWRlcnMgd2l0aCB0aGUga2V5IGJlaW5nIHRoZSBuYW1lXG4gICAgLy8gICAgYW5kIHZhbHVlIHRoZSB2YWx1ZS5cbiAgICBjb25zdCBoZWFkZXJzID0gW11cblxuICAgIC8vIDIuIExldCBuYW1lcyBiZSB0aGUgcmVzdWx0IG9mIGNvbnZlcnQgaGVhZGVyIG5hbWVzIHRvIGEgc29ydGVkLWxvd2VyY2FzZVxuICAgIC8vICAgIHNldCB3aXRoIGFsbCB0aGUgbmFtZXMgb2YgdGhlIGhlYWRlcnMgaW4gbGlzdC5cbiAgICBjb25zdCBuYW1lcyA9IFsuLi50aGlzW2tIZWFkZXJzTGlzdF1dLnNvcnQoKGEsIGIpID0+IGFbMF0gPCBiWzBdID8gLTEgOiAxKVxuICAgIGNvbnN0IGNvb2tpZXMgPSB0aGlzW2tIZWFkZXJzTGlzdF0uY29va2llc1xuXG4gICAgLy8gMy4gRm9yIGVhY2ggbmFtZSBvZiBuYW1lczpcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBbbmFtZSwgdmFsdWVdID0gbmFtZXNbaV1cbiAgICAgIC8vIDEuIElmIG5hbWUgaXMgYHNldC1jb29raWVgLCB0aGVuOlxuICAgICAgaWYgKG5hbWUgPT09ICdzZXQtY29va2llJykge1xuICAgICAgICAvLyAxLiBMZXQgdmFsdWVzIGJlIGEgbGlzdCBvZiBhbGwgdmFsdWVzIG9mIGhlYWRlcnMgaW4gbGlzdCB3aG9zZSBuYW1lXG4gICAgICAgIC8vICAgIGlzIGEgYnl0ZS1jYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvciBuYW1lLCBpbiBvcmRlci5cblxuICAgICAgICAvLyAyLiBGb3IgZWFjaCB2YWx1ZSBvZiB2YWx1ZXM6XG4gICAgICAgIC8vIDEuIEFwcGVuZCAobmFtZSwgdmFsdWUpIHRvIGhlYWRlcnMuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29va2llcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgIGhlYWRlcnMucHVzaChbbmFtZSwgY29va2llc1tqXV0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDIuIE90aGVyd2lzZTpcblxuICAgICAgICAvLyAxLiBMZXQgdmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nIG5hbWUgZnJvbSBsaXN0LlxuXG4gICAgICAgIC8vIDIuIEFzc2VydDogdmFsdWUgaXMgbm9uLW51bGwuXG4gICAgICAgIGFzc2VydCh2YWx1ZSAhPT0gbnVsbClcblxuICAgICAgICAvLyAzLiBBcHBlbmQgKG5hbWUsIHZhbHVlKSB0byBoZWFkZXJzLlxuICAgICAgICBoZWFkZXJzLnB1c2goW25hbWUsIHZhbHVlXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzW2tIZWFkZXJzTGlzdF1ba0hlYWRlcnNTb3J0ZWRNYXBdID0gaGVhZGVyc1xuXG4gICAgLy8gNC4gUmV0dXJuIGhlYWRlcnMuXG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIGtleXMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICBpZiAodGhpc1trR3VhcmRdID09PSAnaW1tdXRhYmxlJykge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2tIZWFkZXJzU29ydGVkTWFwXVxuICAgICAgcmV0dXJuIG1ha2VJdGVyYXRvcigoKSA9PiB2YWx1ZSwgJ0hlYWRlcnMnLFxuICAgICAgICAna2V5JylcbiAgICB9XG5cbiAgICByZXR1cm4gbWFrZUl0ZXJhdG9yKFxuICAgICAgKCkgPT4gWy4uLnRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdLnZhbHVlcygpXSxcbiAgICAgICdIZWFkZXJzJyxcbiAgICAgICdrZXknXG4gICAgKVxuICB9XG5cbiAgdmFsdWVzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBIZWFkZXJzKVxuXG4gICAgaWYgKHRoaXNba0d1YXJkXSA9PT0gJ2ltbXV0YWJsZScpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpc1trSGVhZGVyc1NvcnRlZE1hcF1cbiAgICAgIHJldHVybiBtYWtlSXRlcmF0b3IoKCkgPT4gdmFsdWUsICdIZWFkZXJzJyxcbiAgICAgICAgJ3ZhbHVlJylcbiAgICB9XG5cbiAgICByZXR1cm4gbWFrZUl0ZXJhdG9yKFxuICAgICAgKCkgPT4gWy4uLnRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdLnZhbHVlcygpXSxcbiAgICAgICdIZWFkZXJzJyxcbiAgICAgICd2YWx1ZSdcbiAgICApXG4gIH1cblxuICBlbnRyaWVzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBIZWFkZXJzKVxuXG4gICAgaWYgKHRoaXNba0d1YXJkXSA9PT0gJ2ltbXV0YWJsZScpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpc1trSGVhZGVyc1NvcnRlZE1hcF1cbiAgICAgIHJldHVybiBtYWtlSXRlcmF0b3IoKCkgPT4gdmFsdWUsICdIZWFkZXJzJyxcbiAgICAgICAgJ2tleSt2YWx1ZScpXG4gICAgfVxuXG4gICAgcmV0dXJuIG1ha2VJdGVyYXRvcihcbiAgICAgICgpID0+IFsuLi50aGlzW2tIZWFkZXJzU29ydGVkTWFwXS52YWx1ZXMoKV0sXG4gICAgICAnSGVhZGVycycsXG4gICAgICAna2V5K3ZhbHVlJ1xuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyh2YWx1ZTogc3RyaW5nLCBrZXk6IHN0cmluZywgc2VsZjogSGVhZGVycykgPT4gdm9pZH0gY2FsbGJhY2tGblxuICAgKiBAcGFyYW0ge3Vua25vd259IHRoaXNBcmdcbiAgICovXG4gIGZvckVhY2ggKGNhbGxiYWNrRm4sIHRoaXNBcmcgPSBnbG9iYWxUaGlzKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgSGVhZGVycylcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdIZWFkZXJzLmZvckVhY2gnIH0pXG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrRm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ2ZvckVhY2gnIG9uICdIZWFkZXJzJzogcGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgJ0Z1bmN0aW9uJy5cIlxuICAgICAgKVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMpIHtcbiAgICAgIGNhbGxiYWNrRm4uYXBwbHkodGhpc0FyZywgW3ZhbHVlLCBrZXksIHRoaXNdKVxuICAgIH1cbiAgfVxuXG4gIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgSGVhZGVycylcblxuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTGlzdF1cbiAgfVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllc1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhIZWFkZXJzLnByb3RvdHlwZSwge1xuICBhcHBlbmQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGRlbGV0ZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZ2V0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBoYXM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHNldDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZ2V0U2V0Q29va2llOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBrZXlzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICB2YWx1ZXM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGVudHJpZXM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGZvckVhY2g6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wuaXRlcmF0b3JdOiB7IGVudW1lcmFibGU6IGZhbHNlIH0sXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdIZWFkZXJzJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSlcblxud2ViaWRsLmNvbnZlcnRlcnMuSGVhZGVyc0luaXQgPSBmdW5jdGlvbiAoVikge1xuICBpZiAod2ViaWRsLnV0aWwuVHlwZShWKSA9PT0gJ09iamVjdCcpIHtcbiAgICBpZiAoVltTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPHNlcXVlbmNlPEJ5dGVTdHJpbmc+PiddKFYpXG4gICAgfVxuXG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzWydyZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz4nXShWKVxuICB9XG5cbiAgdGhyb3cgd2ViaWRsLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtcbiAgICBwcmVmaXg6ICdIZWFkZXJzIGNvbnN0cnVjdG9yJyxcbiAgICBhcmd1bWVudDogJ0FyZ3VtZW50IDEnLFxuICAgIHR5cGVzOiBbJ3NlcXVlbmNlPHNlcXVlbmNlPEJ5dGVTdHJpbmc+PicsICdyZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz4nXVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZmlsbCxcbiAgSGVhZGVycyxcbiAgSGVhZGVyc0xpc3Rcbn1cbiJdLCJuYW1lcyI6WyJrSGVhZGVyc0xpc3QiLCJrQ29uc3RydWN0IiwicmVxdWlyZSIsImtHdWFyZCIsImtFbnVtZXJhYmxlUHJvcGVydHkiLCJtYWtlSXRlcmF0b3IiLCJpc1ZhbGlkSGVhZGVyTmFtZSIsImlzVmFsaWRIZWFkZXJWYWx1ZSIsIndlYmlkbCIsImFzc2VydCIsImtIZWFkZXJzTWFwIiwiU3ltYm9sIiwia0hlYWRlcnNTb3J0ZWRNYXAiLCJpc0hUVFBXaGl0ZVNwYWNlQ2hhckNvZGUiLCJjb2RlIiwiaGVhZGVyVmFsdWVOb3JtYWxpemUiLCJwb3RlbnRpYWxWYWx1ZSIsImkiLCJqIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsInN1YnN0cmluZyIsImZpbGwiLCJoZWFkZXJzIiwib2JqZWN0IiwiQXJyYXkiLCJpc0FycmF5IiwiaGVhZGVyIiwiZXJyb3JzIiwiZXhjZXB0aW9uIiwibWVzc2FnZSIsImFwcGVuZEhlYWRlciIsImtleXMiLCJPYmplY3QiLCJjb252ZXJzaW9uRmFpbGVkIiwicHJlZml4IiwiYXJndW1lbnQiLCJ0eXBlcyIsIm5hbWUiLCJ2YWx1ZSIsImludmFsaWRBcmd1bWVudCIsInR5cGUiLCJUeXBlRXJyb3IiLCJhcHBlbmQiLCJIZWFkZXJzTGlzdCIsImNvbnN0cnVjdG9yIiwiaW5pdCIsImNvb2tpZXMiLCJNYXAiLCJjb250YWlucyIsInRvTG93ZXJDYXNlIiwiaGFzIiwiY2xlYXIiLCJsb3dlcmNhc2VOYW1lIiwiZXhpc3RzIiwiZ2V0IiwiZGVsaW1pdGVyIiwic2V0IiwicHVzaCIsImRlbGV0ZSIsInVuZGVmaW5lZCIsIml0ZXJhdG9yIiwiZW50cmllcyIsInNpemUiLCJ2YWx1ZXMiLCJIZWFkZXJzIiwiY29udmVydGVycyIsIkhlYWRlcnNJbml0IiwiYnJhbmRDaGVjayIsImFyZ3VtZW50TGVuZ3RoQ2hlY2siLCJhcmd1bWVudHMiLCJCeXRlU3RyaW5nIiwiZ2V0U2V0Q29va2llIiwibGlzdCIsIm5hbWVzIiwic29ydCIsImEiLCJiIiwiZm9yRWFjaCIsImNhbGxiYWNrRm4iLCJ0aGlzQXJnIiwiZ2xvYmFsVGhpcyIsImtleSIsImFwcGx5IiwiZm9yIiwicHJvdG90eXBlIiwiZGVmaW5lUHJvcGVydGllcyIsImVudW1lcmFibGUiLCJ0b1N0cmluZ1RhZyIsImNvbmZpZ3VyYWJsZSIsIlYiLCJ1dGlsIiwiVHlwZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/headers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/fetch/index.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// https://github.com/Ethan-Arrowood/undici-fetch\n\nconst { Response, makeNetworkError, makeAppropriateNetworkError, filterResponse, makeResponse } = __webpack_require__(/*! ./response */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/response.js\");\nconst { Headers } = __webpack_require__(/*! ./headers */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/headers.js\");\nconst { Request, makeRequest } = __webpack_require__(/*! ./request */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/request.js\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst { bytesMatch, makePolicyContainer, clonePolicyContainer, requestBadPort, TAOCheck, appendRequestOriginHeader, responseLocationURL, requestCurrentURL, setRequestReferrerPolicyOnRedirect, tryUpgradeRequestToAPotentiallyTrustworthyURL, createOpaqueTimingInfo, appendFetchMetadata, corsCheck, crossOriginResourcePolicyCheck, determineRequestsReferrer, coarsenedSharedCurrentTime, createDeferredPromise, isBlobLike, sameOrigin, isCancelled, isAborted, isErrorLike, fullyReadBody, readableStreamClose, isomorphicEncode, urlIsLocal, urlIsHttpHttpsScheme, urlHasHttpsScheme } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/util.js\");\nconst { kState, kHeaders, kGuard, kRealm } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/symbols.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { safelyExtractBody } = __webpack_require__(/*! ./body */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/body.js\");\nconst { redirectStatusSet, nullBodyStatus, safeMethodsSet, requestBodyHeader, subresourceSet, DOMException } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/constants.js\");\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\");\nconst EE = __webpack_require__(/*! events */ \"events\");\nconst { Readable, pipeline } = __webpack_require__(/*! stream */ \"stream\");\nconst { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst { dataURLProcessor, serializeAMimeType } = __webpack_require__(/*! ./dataURL */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/dataURL.js\");\nconst { TransformStream } = __webpack_require__(/*! stream/web */ \"stream/web\");\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../global */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/global.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/webidl.js\");\nconst { STATUS_CODES } = __webpack_require__(/*! http */ \"http\");\nconst GET_OR_HEAD = [\n    \"GET\",\n    \"HEAD\"\n];\n/** @type {import('buffer').resolveObjectURL} */ let resolveObjectURL;\nlet ReadableStream = globalThis.ReadableStream;\nclass Fetch extends EE {\n    constructor(dispatcher){\n        super();\n        this.dispatcher = dispatcher;\n        this.connection = null;\n        this.dump = false;\n        this.state = \"ongoing\";\n        // 2 terminated listeners get added per request,\n        // but only 1 gets removed. If there are 20 redirects,\n        // 21 listeners will be added.\n        // See https://github.com/nodejs/undici/issues/1711\n        // TODO (fix): Find and fix root cause for leaked listener.\n        this.setMaxListeners(21);\n    }\n    terminate(reason) {\n        if (this.state !== \"ongoing\") {\n            return;\n        }\n        this.state = \"terminated\";\n        this.connection?.destroy(reason);\n        this.emit(\"terminated\", reason);\n    }\n    // https://fetch.spec.whatwg.org/#fetch-controller-abort\n    abort(error) {\n        if (this.state !== \"ongoing\") {\n            return;\n        }\n        // 1. Set controllers state to \"aborted\".\n        this.state = \"aborted\";\n        // 2. Let fallbackError be an \"AbortError\" DOMException.\n        // 3. Set error to fallbackError if it is not given.\n        if (!error) {\n            error = new DOMException(\"The operation was aborted.\", \"AbortError\");\n        }\n        // 4. Let serializedError be StructuredSerialize(error).\n        //    If that threw an exception, catch it, and let\n        //    serializedError be StructuredSerialize(fallbackError).\n        // 5. Set controllers serialized abort reason to serializedError.\n        this.serializedAbortReason = error;\n        this.connection?.destroy(error);\n        this.emit(\"terminated\", error);\n    }\n}\n// https://fetch.spec.whatwg.org/#fetch-method\nfunction fetch(input, init = {}) {\n    webidl.argumentLengthCheck(arguments, 1, {\n        header: \"globalThis.fetch\"\n    });\n    // 1. Let p be a new promise.\n    const p = createDeferredPromise();\n    // 2. Let requestObject be the result of invoking the initial value of\n    // Request as constructor with input and init as arguments. If this throws\n    // an exception, reject p with it and return p.\n    let requestObject;\n    try {\n        requestObject = new Request(input, init);\n    } catch (e) {\n        p.reject(e);\n        return p.promise;\n    }\n    // 3. Let request be requestObjects request.\n    const request = requestObject[kState];\n    // 4. If requestObjects signals aborted flag is set, then:\n    if (requestObject.signal.aborted) {\n        // 1. Abort the fetch() call with p, request, null, and\n        //    requestObjects signals abort reason.\n        abortFetch(p, request, null, requestObject.signal.reason);\n        // 2. Return p.\n        return p.promise;\n    }\n    // 5. Let globalObject be requests clients global object.\n    const globalObject = request.client.globalObject;\n    // 6. If globalObject is a ServiceWorkerGlobalScope object, then set\n    // requests service-workers mode to \"none\".\n    if (globalObject?.constructor?.name === \"ServiceWorkerGlobalScope\") {\n        request.serviceWorkers = \"none\";\n    }\n    // 7. Let responseObject be null.\n    let responseObject = null;\n    // 8. Let relevantRealm be thiss relevant Realm.\n    const relevantRealm = null;\n    // 9. Let locallyAborted be false.\n    let locallyAborted = false;\n    // 10. Let controller be null.\n    let controller = null;\n    // 11. Add the following abort steps to requestObjects signal:\n    addAbortListener(requestObject.signal, ()=>{\n        // 1. Set locallyAborted to true.\n        locallyAborted = true;\n        // 2. Assert: controller is non-null.\n        assert(controller != null);\n        // 3. Abort controller with requestObjects signals abort reason.\n        controller.abort(requestObject.signal.reason);\n        // 4. Abort the fetch() call with p, request, responseObject,\n        //    and requestObjects signals abort reason.\n        abortFetch(p, request, responseObject, requestObject.signal.reason);\n    });\n    // 12. Let handleFetchDone given response response be to finalize and\n    // report timing with response, globalObject, and \"fetch\".\n    const handleFetchDone = (response)=>finalizeAndReportTiming(response, \"fetch\");\n    // 13. Set controller to the result of calling fetch given request,\n    // with processResponseEndOfBody set to handleFetchDone, and processResponse\n    // given response being these substeps:\n    const processResponse = (response)=>{\n        // 1. If locallyAborted is true, terminate these substeps.\n        if (locallyAborted) {\n            return Promise.resolve();\n        }\n        // 2. If responses aborted flag is set, then:\n        if (response.aborted) {\n            // 1. Let deserializedError be the result of deserialize a serialized\n            //    abort reason given controllers serialized abort reason and\n            //    relevantRealm.\n            // 2. Abort the fetch() call with p, request, responseObject, and\n            //    deserializedError.\n            abortFetch(p, request, responseObject, controller.serializedAbortReason);\n            return Promise.resolve();\n        }\n        // 3. If response is a network error, then reject p with a TypeError\n        // and terminate these substeps.\n        if (response.type === \"error\") {\n            p.reject(Object.assign(new TypeError(\"fetch failed\"), {\n                cause: response.error\n            }));\n            return Promise.resolve();\n        }\n        // 4. Set responseObject to the result of creating a Response object,\n        // given response, \"immutable\", and relevantRealm.\n        responseObject = new Response();\n        responseObject[kState] = response;\n        responseObject[kRealm] = relevantRealm;\n        responseObject[kHeaders][kHeadersList] = response.headersList;\n        responseObject[kHeaders][kGuard] = \"immutable\";\n        responseObject[kHeaders][kRealm] = relevantRealm;\n        // 5. Resolve p with responseObject.\n        p.resolve(responseObject);\n    };\n    controller = fetching({\n        request,\n        processResponseEndOfBody: handleFetchDone,\n        processResponse,\n        dispatcher: init.dispatcher ?? getGlobalDispatcher() // undici\n    });\n    // 14. Return p.\n    return p.promise;\n}\n// https://fetch.spec.whatwg.org/#finalize-and-report-timing\nfunction finalizeAndReportTiming(response, initiatorType = \"other\") {\n    // 1. If response is an aborted network error, then return.\n    if (response.type === \"error\" && response.aborted) {\n        return;\n    }\n    // 2. If responses URL list is null or empty, then return.\n    if (!response.urlList?.length) {\n        return;\n    }\n    // 3. Let originalURL be responses URL list[0].\n    const originalURL = response.urlList[0];\n    // 4. Let timingInfo be responses timing info.\n    let timingInfo = response.timingInfo;\n    // 5. Let cacheState be responses cache state.\n    let cacheState = response.cacheState;\n    // 6. If originalURLs scheme is not an HTTP(S) scheme, then return.\n    if (!urlIsHttpHttpsScheme(originalURL)) {\n        return;\n    }\n    // 7. If timingInfo is null, then return.\n    if (timingInfo === null) {\n        return;\n    }\n    // 8. If responses timing allow passed flag is not set, then:\n    if (!response.timingAllowPassed) {\n        //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.\n        timingInfo = createOpaqueTimingInfo({\n            startTime: timingInfo.startTime\n        });\n        //  2. Set cacheState to the empty string.\n        cacheState = \"\";\n    }\n    // 9. Set timingInfos end time to the coarsened shared current time\n    // given globals relevant settings objects cross-origin isolated\n    // capability.\n    // TODO: given globals relevant settings objects cross-origin isolated\n    // capability?\n    timingInfo.endTime = coarsenedSharedCurrentTime();\n    // 10. Set responses timing info to timingInfo.\n    response.timingInfo = timingInfo;\n    // 11. Mark resource timing for timingInfo, originalURL, initiatorType,\n    // global, and cacheState.\n    markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState);\n}\n// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing\nfunction markResourceTiming(timingInfo, originalURL, initiatorType, globalThis1, cacheState) {\n    if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2) {\n        performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis1, cacheState);\n    }\n}\n// https://fetch.spec.whatwg.org/#abort-fetch\nfunction abortFetch(p, request, responseObject, error) {\n    // Note: AbortSignal.reason was added in node v17.2.0\n    // which would give us an undefined error to reject with.\n    // Remove this once node v16 is no longer supported.\n    if (!error) {\n        error = new DOMException(\"The operation was aborted.\", \"AbortError\");\n    }\n    // 1. Reject promise with error.\n    p.reject(error);\n    // 2. If requests body is not null and is readable, then cancel requests\n    // body with error.\n    if (request.body != null && isReadable(request.body?.stream)) {\n        request.body.stream.cancel(error).catch((err)=>{\n            if (err.code === \"ERR_INVALID_STATE\") {\n                // Node bug?\n                return;\n            }\n            throw err;\n        });\n    }\n    // 3. If responseObject is null, then return.\n    if (responseObject == null) {\n        return;\n    }\n    // 4. Let response be responseObjects response.\n    const response = responseObject[kState];\n    // 5. If responses body is not null and is readable, then error responses\n    // body with error.\n    if (response.body != null && isReadable(response.body?.stream)) {\n        response.body.stream.cancel(error).catch((err)=>{\n            if (err.code === \"ERR_INVALID_STATE\") {\n                // Node bug?\n                return;\n            }\n            throw err;\n        });\n    }\n}\n// https://fetch.spec.whatwg.org/#fetching\nfunction fetching({ request, processRequestBodyChunkLength, processRequestEndOfBody, processResponse, processResponseEndOfBody, processResponseConsumeBody, useParallelQueue = false, dispatcher// undici\n }) {\n    // 1. Let taskDestination be null.\n    let taskDestination = null;\n    // 2. Let crossOriginIsolatedCapability be false.\n    let crossOriginIsolatedCapability = false;\n    // 3. If requests client is non-null, then:\n    if (request.client != null) {\n        // 1. Set taskDestination to requests clients global object.\n        taskDestination = request.client.globalObject;\n        // 2. Set crossOriginIsolatedCapability to requests clients cross-origin\n        // isolated capability.\n        crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;\n    }\n    // 4. If useParallelQueue is true, then set taskDestination to the result of\n    // starting a new parallel queue.\n    // TODO\n    // 5. Let timingInfo be a new fetch timing info whose start time and\n    // post-redirect start time are the coarsened shared current time given\n    // crossOriginIsolatedCapability.\n    const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);\n    const timingInfo = createOpaqueTimingInfo({\n        startTime: currenTime\n    });\n    // 6. Let fetchParams be a new fetch params whose\n    // request is request,\n    // timing info is timingInfo,\n    // process request body chunk length is processRequestBodyChunkLength,\n    // process request end-of-body is processRequestEndOfBody,\n    // process response is processResponse,\n    // process response consume body is processResponseConsumeBody,\n    // process response end-of-body is processResponseEndOfBody,\n    // task destination is taskDestination,\n    // and cross-origin isolated capability is crossOriginIsolatedCapability.\n    const fetchParams = {\n        controller: new Fetch(dispatcher),\n        request,\n        timingInfo,\n        processRequestBodyChunkLength,\n        processRequestEndOfBody,\n        processResponse,\n        processResponseConsumeBody,\n        processResponseEndOfBody,\n        taskDestination,\n        crossOriginIsolatedCapability\n    };\n    // 7. If requests body is a byte sequence, then set requests body to\n    //    requests body as a body.\n    // NOTE: Since fetching is only called from fetch, body should already be\n    // extracted.\n    assert(!request.body || request.body.stream);\n    // 8. If requests window is \"client\", then set requests window to requests\n    // client, if requests clients global object is a Window object; otherwise\n    // \"no-window\".\n    if (request.window === \"client\") {\n        // TODO: What if request.client is null?\n        request.window = request.client?.globalObject?.constructor?.name === \"Window\" ? request.client : \"no-window\";\n    }\n    // 9. If requests origin is \"client\", then set requests origin to requests\n    // clients origin.\n    if (request.origin === \"client\") {\n        // TODO: What if request.client is null?\n        request.origin = request.client?.origin;\n    }\n    // 10. If all of the following conditions are true:\n    // TODO\n    // 11. If requests policy container is \"client\", then:\n    if (request.policyContainer === \"client\") {\n        // 1. If requests client is non-null, then set requests policy\n        // container to a clone of requests clients policy container. [HTML]\n        if (request.client != null) {\n            request.policyContainer = clonePolicyContainer(request.client.policyContainer);\n        } else {\n            // 2. Otherwise, set requests policy container to a new policy\n            // container.\n            request.policyContainer = makePolicyContainer();\n        }\n    }\n    // 12. If requests header list does not contain `Accept`, then:\n    if (!request.headersList.contains(\"accept\")) {\n        // 1. Let value be `*/*`.\n        const value = \"*/*\";\n        // 2. A user agent should set value to the first matching statement, if\n        // any, switching on requests destination:\n        // \"document\"\n        // \"frame\"\n        // \"iframe\"\n        // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`\n        // \"image\"\n        // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`\n        // \"style\"\n        // `text/css,*/*;q=0.1`\n        // TODO\n        // 3. Append `Accept`/value to requests header list.\n        request.headersList.append(\"accept\", value);\n    }\n    // 13. If requests header list does not contain `Accept-Language`, then\n    // user agents should append `Accept-Language`/an appropriate value to\n    // requests header list.\n    if (!request.headersList.contains(\"accept-language\")) {\n        request.headersList.append(\"accept-language\", \"*\");\n    }\n    // 14. If requests priority is null, then use requests initiator and\n    // destination appropriately in setting requests priority to a\n    // user-agent-defined object.\n    if (request.priority === null) {\n    // TODO\n    }\n    // 15. If request is a subresource request, then:\n    if (subresourceSet.has(request.destination)) {\n    // TODO\n    }\n    // 16. Run main fetch given fetchParams.\n    mainFetch(fetchParams).catch((err)=>{\n        fetchParams.controller.terminate(err);\n    });\n    // 17. Return fetchParam's controller\n    return fetchParams.controller;\n}\n// https://fetch.spec.whatwg.org/#concept-main-fetch\nasync function mainFetch(fetchParams, recursive = false) {\n    // 1. Let request be fetchParamss request.\n    const request = fetchParams.request;\n    // 2. Let response be null.\n    let response = null;\n    // 3. If requests local-URLs-only flag is set and requests current URL is\n    // not local, then set response to a network error.\n    if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {\n        response = makeNetworkError(\"local URLs only\");\n    }\n    // 4. Run report Content Security Policy violations for request.\n    // TODO\n    // 5. Upgrade request to a potentially trustworthy URL, if appropriate.\n    tryUpgradeRequestToAPotentiallyTrustworthyURL(request);\n    // 6. If should request be blocked due to a bad port, should fetching request\n    // be blocked as mixed content, or should request be blocked by Content\n    // Security Policy returns blocked, then set response to a network error.\n    if (requestBadPort(request) === \"blocked\") {\n        response = makeNetworkError(\"bad port\");\n    }\n    // TODO: should fetching request be blocked as mixed content?\n    // TODO: should request be blocked by Content Security Policy?\n    // 7. If requests referrer policy is the empty string, then set requests\n    // referrer policy to requests policy containers referrer policy.\n    if (request.referrerPolicy === \"\") {\n        request.referrerPolicy = request.policyContainer.referrerPolicy;\n    }\n    // 8. If requests referrer is not \"no-referrer\", then set requests\n    // referrer to the result of invoking determine requests referrer.\n    if (request.referrer !== \"no-referrer\") {\n        request.referrer = determineRequestsReferrer(request);\n    }\n    // 9. Set requests current URLs scheme to \"https\" if all of the following\n    // conditions are true:\n    // - requests current URLs scheme is \"http\"\n    // - requests current URLs host is a domain\n    // - Matching requests current URLs host per Known HSTS Host Domain Name\n    //   Matching results in either a superdomain match with an asserted\n    //   includeSubDomains directive or a congruent match (with or without an\n    //   asserted includeSubDomains directive). [HSTS]\n    // TODO\n    // 10. If recursive is false, then run the remaining steps in parallel.\n    // TODO\n    // 11. If response is null, then set response to the result of running\n    // the steps corresponding to the first matching statement:\n    if (response === null) {\n        response = await (async ()=>{\n            const currentURL = requestCurrentURL(request);\n            if (// - requests current URLs origin is same origin with requests origin,\n            //   and requests response tainting is \"basic\"\n            sameOrigin(currentURL, request.url) && request.responseTainting === \"basic\" || // requests current URLs scheme is \"data\"\n            currentURL.protocol === \"data:\" || // - requests mode is \"navigate\" or \"websocket\"\n            request.mode === \"navigate\" || request.mode === \"websocket\") {\n                // 1. Set requests response tainting to \"basic\".\n                request.responseTainting = \"basic\";\n                // 2. Return the result of running scheme fetch given fetchParams.\n                return await schemeFetch(fetchParams);\n            }\n            // requests mode is \"same-origin\"\n            if (request.mode === \"same-origin\") {\n                // 1. Return a network error.\n                return makeNetworkError('request mode cannot be \"same-origin\"');\n            }\n            // requests mode is \"no-cors\"\n            if (request.mode === \"no-cors\") {\n                // 1. If requests redirect mode is not \"follow\", then return a network\n                // error.\n                if (request.redirect !== \"follow\") {\n                    return makeNetworkError('redirect mode cannot be \"follow\" for \"no-cors\" request');\n                }\n                // 2. Set requests response tainting to \"opaque\".\n                request.responseTainting = \"opaque\";\n                // 3. Return the result of running scheme fetch given fetchParams.\n                return await schemeFetch(fetchParams);\n            }\n            // requests current URLs scheme is not an HTTP(S) scheme\n            if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {\n                // Return a network error.\n                return makeNetworkError(\"URL scheme must be a HTTP(S) scheme\");\n            }\n            // - requests use-CORS-preflight flag is set\n            // - requests unsafe-request flag is set and either requests method is\n            //   not a CORS-safelisted method or CORS-unsafe request-header names with\n            //   requests header list is not empty\n            //    1. Set requests response tainting to \"cors\".\n            //    2. Let corsWithPreflightResponse be the result of running HTTP fetch\n            //    given fetchParams and true.\n            //    3. If corsWithPreflightResponse is a network error, then clear cache\n            //    entries using request.\n            //    4. Return corsWithPreflightResponse.\n            // TODO\n            // Otherwise\n            //    1. Set requests response tainting to \"cors\".\n            request.responseTainting = \"cors\";\n            //    2. Return the result of running HTTP fetch given fetchParams.\n            return await httpFetch(fetchParams);\n        })();\n    }\n    // 12. If recursive is true, then return response.\n    if (recursive) {\n        return response;\n    }\n    // 13. If response is not a network error and response is not a filtered\n    // response, then:\n    if (response.status !== 0 && !response.internalResponse) {\n        // If requests response tainting is \"cors\", then:\n        if (request.responseTainting === \"cors\") {\n        // 1. Let headerNames be the result of extracting header list values\n        // given `Access-Control-Expose-Headers` and responses header list.\n        // TODO\n        // 2. If requests credentials mode is not \"include\" and headerNames\n        // contains `*`, then set responses CORS-exposed header-name list to\n        // all unique header names in responses header list.\n        // TODO\n        // 3. Otherwise, if headerNames is not null or failure, then set\n        // responses CORS-exposed header-name list to headerNames.\n        // TODO\n        }\n        // Set response to the following filtered response with response as its\n        // internal response, depending on requests response tainting:\n        if (request.responseTainting === \"basic\") {\n            response = filterResponse(response, \"basic\");\n        } else if (request.responseTainting === \"cors\") {\n            response = filterResponse(response, \"cors\");\n        } else if (request.responseTainting === \"opaque\") {\n            response = filterResponse(response, \"opaque\");\n        } else {\n            assert(false);\n        }\n    }\n    // 14. Let internalResponse be response, if response is a network error,\n    // and responses internal response otherwise.\n    let internalResponse = response.status === 0 ? response : response.internalResponse;\n    // 15. If internalResponses URL list is empty, then set it to a clone of\n    // requests URL list.\n    if (internalResponse.urlList.length === 0) {\n        internalResponse.urlList.push(...request.urlList);\n    }\n    // 16. If requests timing allow failed flag is unset, then set\n    // internalResponses timing allow passed flag.\n    if (!request.timingAllowFailed) {\n        response.timingAllowPassed = true;\n    }\n    // 17. If response is not a network error and any of the following returns\n    // blocked\n    // - should internalResponse to request be blocked as mixed content\n    // - should internalResponse to request be blocked by Content Security Policy\n    // - should internalResponse to request be blocked due to its MIME type\n    // - should internalResponse to request be blocked due to nosniff\n    // TODO\n    // 18. If responses type is \"opaque\", internalResponses status is 206,\n    // internalResponses range-requested flag is set, and requests header\n    // list does not contain `Range`, then set response and internalResponse\n    // to a network error.\n    if (response.type === \"opaque\" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains(\"range\")) {\n        response = internalResponse = makeNetworkError();\n    }\n    // 19. If response is not a network error and either requests method is\n    // `HEAD` or `CONNECT`, or internalResponses status is a null body status,\n    // set internalResponses body to null and disregard any enqueuing toward\n    // it (if any).\n    if (response.status !== 0 && (request.method === \"HEAD\" || request.method === \"CONNECT\" || nullBodyStatus.includes(internalResponse.status))) {\n        internalResponse.body = null;\n        fetchParams.controller.dump = true;\n    }\n    // 20. If requests integrity metadata is not the empty string, then:\n    if (request.integrity) {\n        // 1. Let processBodyError be this step: run fetch finale given fetchParams\n        // and a network error.\n        const processBodyError = (reason)=>fetchFinale(fetchParams, makeNetworkError(reason));\n        // 2. If requests response tainting is \"opaque\", or responses body is null,\n        // then run processBodyError and abort these steps.\n        if (request.responseTainting === \"opaque\" || response.body == null) {\n            processBodyError(response.error);\n            return;\n        }\n        // 3. Let processBody given bytes be these steps:\n        const processBody = (bytes)=>{\n            // 1. If bytes do not match requests integrity metadata,\n            // then run processBodyError and abort these steps. [SRI]\n            if (!bytesMatch(bytes, request.integrity)) {\n                processBodyError(\"integrity mismatch\");\n                return;\n            }\n            // 2. Set responses body to bytes as a body.\n            response.body = safelyExtractBody(bytes)[0];\n            // 3. Run fetch finale given fetchParams and response.\n            fetchFinale(fetchParams, response);\n        };\n        // 4. Fully read responses body given processBody and processBodyError.\n        await fullyReadBody(response.body, processBody, processBodyError);\n    } else {\n        // 21. Otherwise, run fetch finale given fetchParams and response.\n        fetchFinale(fetchParams, response);\n    }\n}\n// https://fetch.spec.whatwg.org/#concept-scheme-fetch\n// given a fetch params fetchParams\nfunction schemeFetch(fetchParams) {\n    // Note: since the connection is destroyed on redirect, which sets fetchParams to a\n    // cancelled state, we do not want this condition to trigger *unless* there have been\n    // no redirects. See https://github.com/nodejs/undici/issues/1776\n    // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {\n        return Promise.resolve(makeAppropriateNetworkError(fetchParams));\n    }\n    // 2. Let request be fetchParamss request.\n    const { request } = fetchParams;\n    const { protocol: scheme } = requestCurrentURL(request);\n    // 3. Switch on requests current URLs scheme and run the associated steps:\n    switch(scheme){\n        case \"about:\":\n            {\n                // If requests current URLs path is the string \"blank\", then return a new response\n                // whose status message is `OK`, header list is  (`Content-Type`, `text/html;charset=utf-8`) ,\n                // and body is the empty byte sequence as a body.\n                // Otherwise, return a network error.\n                return Promise.resolve(makeNetworkError(\"about scheme is not supported\"));\n            }\n        case \"blob:\":\n            {\n                if (!resolveObjectURL) {\n                    resolveObjectURL = (__webpack_require__(/*! buffer */ \"buffer\").resolveObjectURL);\n                }\n                // 1. Let blobURLEntry be requests current URLs blob URL entry.\n                const blobURLEntry = requestCurrentURL(request);\n                // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56\n                // Buffer.resolveObjectURL does not ignore URL queries.\n                if (blobURLEntry.search.length !== 0) {\n                    return Promise.resolve(makeNetworkError(\"NetworkError when attempting to fetch resource.\"));\n                }\n                const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());\n                // 2. If requests method is not `GET`, blobURLEntry is null, or blobURLEntrys\n                //    object is not a Blob object, then return a network error.\n                if (request.method !== \"GET\" || !isBlobLike(blobURLEntryObject)) {\n                    return Promise.resolve(makeNetworkError(\"invalid method\"));\n                }\n                // 3. Let bodyWithType be the result of safely extracting blobURLEntrys object.\n                const bodyWithType = safelyExtractBody(blobURLEntryObject);\n                // 4. Let body be bodyWithTypes body.\n                const body = bodyWithType[0];\n                // 5. Let length be bodys length, serialized and isomorphic encoded.\n                const length = isomorphicEncode(`${body.length}`);\n                // 6. Let type be bodyWithTypes type if it is non-null; otherwise the empty byte sequence.\n                const type = bodyWithType[1] ?? \"\";\n                // 7. Return a new response whose status message is `OK`, header list is\n                //     (`Content-Length`, length), (`Content-Type`, type) , and body is body.\n                const response = makeResponse({\n                    statusText: \"OK\",\n                    headersList: [\n                        [\n                            \"content-length\",\n                            {\n                                name: \"Content-Length\",\n                                value: length\n                            }\n                        ],\n                        [\n                            \"content-type\",\n                            {\n                                name: \"Content-Type\",\n                                value: type\n                            }\n                        ]\n                    ]\n                });\n                response.body = body;\n                return Promise.resolve(response);\n            }\n        case \"data:\":\n            {\n                // 1. Let dataURLStruct be the result of running the\n                //    data: URL processor on requests current URL.\n                const currentURL = requestCurrentURL(request);\n                const dataURLStruct = dataURLProcessor(currentURL);\n                // 2. If dataURLStruct is failure, then return a\n                //    network error.\n                if (dataURLStruct === \"failure\") {\n                    return Promise.resolve(makeNetworkError(\"failed to fetch the data URL\"));\n                }\n                // 3. Let mimeType be dataURLStructs MIME type, serialized.\n                const mimeType = serializeAMimeType(dataURLStruct.mimeType);\n                // 4. Return a response whose status message is `OK`,\n                //    header list is  (`Content-Type`, mimeType) ,\n                //    and body is dataURLStructs body as a body.\n                return Promise.resolve(makeResponse({\n                    statusText: \"OK\",\n                    headersList: [\n                        [\n                            \"content-type\",\n                            {\n                                name: \"Content-Type\",\n                                value: mimeType\n                            }\n                        ]\n                    ],\n                    body: safelyExtractBody(dataURLStruct.body)[0]\n                }));\n            }\n        case \"file:\":\n            {\n                // For now, unfortunate as it is, file URLs are left as an exercise for the reader.\n                // When in doubt, return a network error.\n                return Promise.resolve(makeNetworkError(\"not implemented... yet...\"));\n            }\n        case \"http:\":\n        case \"https:\":\n            {\n                // Return the result of running HTTP fetch given fetchParams.\n                return httpFetch(fetchParams).catch((err)=>makeNetworkError(err));\n            }\n        default:\n            {\n                return Promise.resolve(makeNetworkError(\"unknown scheme\"));\n            }\n    }\n}\n// https://fetch.spec.whatwg.org/#finalize-response\nfunction finalizeResponse(fetchParams, response) {\n    // 1. Set fetchParamss requests done flag.\n    fetchParams.request.done = true;\n    // 2, If fetchParamss process response done is not null, then queue a fetch\n    // task to run fetchParamss process response done given response, with\n    // fetchParamss task destination.\n    if (fetchParams.processResponseDone != null) {\n        queueMicrotask(()=>fetchParams.processResponseDone(response));\n    }\n}\n// https://fetch.spec.whatwg.org/#fetch-finale\nfunction fetchFinale(fetchParams, response) {\n    // 1. If response is a network error, then:\n    if (response.type === \"error\") {\n        // 1. Set responses URL list to  fetchParamss requests URL list[0] .\n        response.urlList = [\n            fetchParams.request.urlList[0]\n        ];\n        // 2. Set responses timing info to the result of creating an opaque timing\n        // info for fetchParamss timing info.\n        response.timingInfo = createOpaqueTimingInfo({\n            startTime: fetchParams.timingInfo.startTime\n        });\n    }\n    // 2. Let processResponseEndOfBody be the following steps:\n    const processResponseEndOfBody = ()=>{\n        // 1. Set fetchParamss requests done flag.\n        fetchParams.request.done = true;\n        // If fetchParamss process response end-of-body is not null,\n        // then queue a fetch task to run fetchParamss process response\n        // end-of-body given response with fetchParamss task destination.\n        if (fetchParams.processResponseEndOfBody != null) {\n            queueMicrotask(()=>fetchParams.processResponseEndOfBody(response));\n        }\n    };\n    // 3. If fetchParamss process response is non-null, then queue a fetch task\n    // to run fetchParamss process response given response, with fetchParamss\n    // task destination.\n    if (fetchParams.processResponse != null) {\n        queueMicrotask(()=>fetchParams.processResponse(response));\n    }\n    // 4. If responses body is null, then run processResponseEndOfBody.\n    if (response.body == null) {\n        processResponseEndOfBody();\n    } else {\n        // 5. Otherwise:\n        // 1. Let transformStream be a new a TransformStream.\n        // 2. Let identityTransformAlgorithm be an algorithm which, given chunk,\n        // enqueues chunk in transformStream.\n        const identityTransformAlgorithm = (chunk, controller)=>{\n            controller.enqueue(chunk);\n        };\n        // 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm\n        // and flushAlgorithm set to processResponseEndOfBody.\n        const transformStream = new TransformStream({\n            start () {},\n            transform: identityTransformAlgorithm,\n            flush: processResponseEndOfBody\n        }, {\n            size () {\n                return 1;\n            }\n        }, {\n            size () {\n                return 1;\n            }\n        });\n        // 4. Set responses body to the result of piping responses body through transformStream.\n        response.body = {\n            stream: response.body.stream.pipeThrough(transformStream)\n        };\n    }\n    // 6. If fetchParamss process response consume body is non-null, then:\n    if (fetchParams.processResponseConsumeBody != null) {\n        // 1. Let processBody given nullOrBytes be this step: run fetchParamss\n        // process response consume body given response and nullOrBytes.\n        const processBody = (nullOrBytes)=>fetchParams.processResponseConsumeBody(response, nullOrBytes);\n        // 2. Let processBodyError be this step: run fetchParamss process\n        // response consume body given response and failure.\n        const processBodyError = (failure)=>fetchParams.processResponseConsumeBody(response, failure);\n        // 3. If responses body is null, then queue a fetch task to run processBody\n        // given null, with fetchParamss task destination.\n        if (response.body == null) {\n            queueMicrotask(()=>processBody(null));\n        } else {\n            // 4. Otherwise, fully read responses body given processBody, processBodyError,\n            // and fetchParamss task destination.\n            return fullyReadBody(response.body, processBody, processBodyError);\n        }\n        return Promise.resolve();\n    }\n}\n// https://fetch.spec.whatwg.org/#http-fetch\nasync function httpFetch(fetchParams) {\n    // 1. Let request be fetchParamss request.\n    const request = fetchParams.request;\n    // 2. Let response be null.\n    let response = null;\n    // 3. Let actualResponse be null.\n    let actualResponse = null;\n    // 4. Let timingInfo be fetchParamss timing info.\n    const timingInfo = fetchParams.timingInfo;\n    // 5. If requests service-workers mode is \"all\", then:\n    if (request.serviceWorkers === \"all\") {\n    // TODO\n    }\n    // 6. If response is null, then:\n    if (response === null) {\n        // 1. If makeCORSPreflight is true and one of these conditions is true:\n        // TODO\n        // 2. If requests redirect mode is \"follow\", then set requests\n        // service-workers mode to \"none\".\n        if (request.redirect === \"follow\") {\n            request.serviceWorkers = \"none\";\n        }\n        // 3. Set response and actualResponse to the result of running\n        // HTTP-network-or-cache fetch given fetchParams.\n        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);\n        // 4. If requests response tainting is \"cors\" and a CORS check\n        // for request and response returns failure, then return a network error.\n        if (request.responseTainting === \"cors\" && corsCheck(request, response) === \"failure\") {\n            return makeNetworkError(\"cors failure\");\n        }\n        // 5. If the TAO check for request and response returns failure, then set\n        // requests timing allow failed flag.\n        if (TAOCheck(request, response) === \"failure\") {\n            request.timingAllowFailed = true;\n        }\n    }\n    // 7. If either requests response tainting or responses type\n    // is \"opaque\", and the cross-origin resource policy check with\n    // requests origin, requests client, requests destination,\n    // and actualResponse returns blocked, then return a network error.\n    if ((request.responseTainting === \"opaque\" || response.type === \"opaque\") && crossOriginResourcePolicyCheck(request.origin, request.client, request.destination, actualResponse) === \"blocked\") {\n        return makeNetworkError(\"blocked\");\n    }\n    // 8. If actualResponses status is a redirect status, then:\n    if (redirectStatusSet.has(actualResponse.status)) {\n        // 1. If actualResponses status is not 303, requests body is not null,\n        // and the connection uses HTTP/2, then user agents may, and are even\n        // encouraged to, transmit an RST_STREAM frame.\n        // See, https://github.com/whatwg/fetch/issues/1288\n        if (request.redirect !== \"manual\") {\n            fetchParams.controller.connection.destroy();\n        }\n        // 2. Switch on requests redirect mode:\n        if (request.redirect === \"error\") {\n            // Set response to a network error.\n            response = makeNetworkError(\"unexpected redirect\");\n        } else if (request.redirect === \"manual\") {\n            // Set response to an opaque-redirect filtered response whose internal\n            // response is actualResponse.\n            // NOTE(spec): On the web this would return an `opaqueredirect` response,\n            // but that doesn't make sense server side.\n            // See https://github.com/nodejs/undici/issues/1193.\n            response = actualResponse;\n        } else if (request.redirect === \"follow\") {\n            // Set response to the result of running HTTP-redirect fetch given\n            // fetchParams and response.\n            response = await httpRedirectFetch(fetchParams, response);\n        } else {\n            assert(false);\n        }\n    }\n    // 9. Set responses timing info to timingInfo.\n    response.timingInfo = timingInfo;\n    // 10. Return response.\n    return response;\n}\n// https://fetch.spec.whatwg.org/#http-redirect-fetch\nfunction httpRedirectFetch(fetchParams, response) {\n    // 1. Let request be fetchParamss request.\n    const request = fetchParams.request;\n    // 2. Let actualResponse be response, if response is not a filtered response,\n    // and responses internal response otherwise.\n    const actualResponse = response.internalResponse ? response.internalResponse : response;\n    // 3. Let locationURL be actualResponses location URL given requests current\n    // URLs fragment.\n    let locationURL;\n    try {\n        locationURL = responseLocationURL(actualResponse, requestCurrentURL(request).hash);\n        // 4. If locationURL is null, then return response.\n        if (locationURL == null) {\n            return response;\n        }\n    } catch (err) {\n        // 5. If locationURL is failure, then return a network error.\n        return Promise.resolve(makeNetworkError(err));\n    }\n    // 6. If locationURLs scheme is not an HTTP(S) scheme, then return a network\n    // error.\n    if (!urlIsHttpHttpsScheme(locationURL)) {\n        return Promise.resolve(makeNetworkError(\"URL scheme must be a HTTP(S) scheme\"));\n    }\n    // 7. If requests redirect count is 20, then return a network error.\n    if (request.redirectCount === 20) {\n        return Promise.resolve(makeNetworkError(\"redirect count exceeded\"));\n    }\n    // 8. Increase requests redirect count by 1.\n    request.redirectCount += 1;\n    // 9. If requests mode is \"cors\", locationURL includes credentials, and\n    // requests origin is not same origin with locationURLs origin, then return\n    //  a network error.\n    if (request.mode === \"cors\" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {\n        return Promise.resolve(makeNetworkError('cross origin not allowed for request mode \"cors\"'));\n    }\n    // 10. If requests response tainting is \"cors\" and locationURL includes\n    // credentials, then return a network error.\n    if (request.responseTainting === \"cors\" && (locationURL.username || locationURL.password)) {\n        return Promise.resolve(makeNetworkError('URL cannot contain credentials for request mode \"cors\"'));\n    }\n    // 11. If actualResponses status is not 303, requests body is non-null,\n    // and requests bodys source is null, then return a network error.\n    if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {\n        return Promise.resolve(makeNetworkError());\n    }\n    // 12. If one of the following is true\n    // - actualResponses status is 301 or 302 and requests method is `POST`\n    // - actualResponses status is 303 and requests method is not `GET` or `HEAD`\n    if ([\n        301,\n        302\n    ].includes(actualResponse.status) && request.method === \"POST\" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {\n        // then:\n        // 1. Set requests method to `GET` and requests body to null.\n        request.method = \"GET\";\n        request.body = null;\n        // 2. For each headerName of request-body-header name, delete headerName from\n        // requests header list.\n        for (const headerName of requestBodyHeader){\n            request.headersList.delete(headerName);\n        }\n    }\n    // 13. If requests current URLs origin is not same origin with locationURLs\n    //     origin, then for each headerName of CORS non-wildcard request-header name,\n    //     delete headerName from requests header list.\n    if (!sameOrigin(requestCurrentURL(request), locationURL)) {\n        // https://fetch.spec.whatwg.org/#cors-non-wildcard-request-header-name\n        request.headersList.delete(\"authorization\");\n        // https://fetch.spec.whatwg.org/#authentication-entries\n        request.headersList.delete(\"proxy-authorization\", true);\n        // \"Cookie\" and \"Host\" are forbidden request-headers, which undici doesn't implement.\n        request.headersList.delete(\"cookie\");\n        request.headersList.delete(\"host\");\n    }\n    // 14. If requests body is non-null, then set requests body to the first return\n    // value of safely extracting requests bodys source.\n    if (request.body != null) {\n        assert(request.body.source != null);\n        request.body = safelyExtractBody(request.body.source)[0];\n    }\n    // 15. Let timingInfo be fetchParamss timing info.\n    const timingInfo = fetchParams.timingInfo;\n    // 16. Set timingInfos redirect end time and post-redirect start time to the\n    // coarsened shared current time given fetchParamss cross-origin isolated\n    // capability.\n    timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);\n    // 17. If timingInfos redirect start time is 0, then set timingInfos\n    //  redirect start time to timingInfos start time.\n    if (timingInfo.redirectStartTime === 0) {\n        timingInfo.redirectStartTime = timingInfo.startTime;\n    }\n    // 18. Append locationURL to requests URL list.\n    request.urlList.push(locationURL);\n    // 19. Invoke set requests referrer policy on redirect on request and\n    // actualResponse.\n    setRequestReferrerPolicyOnRedirect(request, actualResponse);\n    // 20. Return the result of running main fetch given fetchParams and true.\n    return mainFetch(fetchParams, true);\n}\n// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\nasync function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {\n    // 1. Let request be fetchParamss request.\n    const request = fetchParams.request;\n    // 2. Let httpFetchParams be null.\n    let httpFetchParams = null;\n    // 3. Let httpRequest be null.\n    let httpRequest = null;\n    // 4. Let response be null.\n    let response = null;\n    // 5. Let storedResponse be null.\n    // TODO: cache\n    // 6. Let httpCache be null.\n    const httpCache = null;\n    // 7. Let the revalidatingFlag be unset.\n    const revalidatingFlag = false;\n    // 8. Run these steps, but abort when the ongoing fetch is terminated:\n    //    1. If requests window is \"no-window\" and requests redirect mode is\n    //    \"error\", then set httpFetchParams to fetchParams and httpRequest to\n    //    request.\n    if (request.window === \"no-window\" && request.redirect === \"error\") {\n        httpFetchParams = fetchParams;\n        httpRequest = request;\n    } else {\n        // Otherwise:\n        // 1. Set httpRequest to a clone of request.\n        httpRequest = makeRequest(request);\n        // 2. Set httpFetchParams to a copy of fetchParams.\n        httpFetchParams = {\n            ...fetchParams\n        };\n        // 3. Set httpFetchParamss request to httpRequest.\n        httpFetchParams.request = httpRequest;\n    }\n    //    3. Let includeCredentials be true if one of\n    const includeCredentials = request.credentials === \"include\" || request.credentials === \"same-origin\" && request.responseTainting === \"basic\";\n    //    4. Let contentLength be httpRequests bodys length, if httpRequests\n    //    body is non-null; otherwise null.\n    const contentLength = httpRequest.body ? httpRequest.body.length : null;\n    //    5. Let contentLengthHeaderValue be null.\n    let contentLengthHeaderValue = null;\n    //    6. If httpRequests body is null and httpRequests method is `POST` or\n    //    `PUT`, then set contentLengthHeaderValue to `0`.\n    if (httpRequest.body == null && [\n        \"POST\",\n        \"PUT\"\n    ].includes(httpRequest.method)) {\n        contentLengthHeaderValue = \"0\";\n    }\n    //    7. If contentLength is non-null, then set contentLengthHeaderValue to\n    //    contentLength, serialized and isomorphic encoded.\n    if (contentLength != null) {\n        contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);\n    }\n    //    8. If contentLengthHeaderValue is non-null, then append\n    //    `Content-Length`/contentLengthHeaderValue to httpRequests header\n    //    list.\n    if (contentLengthHeaderValue != null) {\n        httpRequest.headersList.append(\"content-length\", contentLengthHeaderValue);\n    }\n    //    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,\n    //    contentLengthHeaderValue) to httpRequests header list.\n    //    10. If contentLength is non-null and httpRequests keepalive is true,\n    //    then:\n    if (contentLength != null && httpRequest.keepalive) {\n    // NOTE: keepalive is a noop outside of browser context.\n    }\n    //    11. If httpRequests referrer is a URL, then append\n    //    `Referer`/httpRequests referrer, serialized and isomorphic encoded,\n    //     to httpRequests header list.\n    if (httpRequest.referrer instanceof URL) {\n        httpRequest.headersList.append(\"referer\", isomorphicEncode(httpRequest.referrer.href));\n    }\n    //    12. Append a request `Origin` header for httpRequest.\n    appendRequestOriginHeader(httpRequest);\n    //    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]\n    appendFetchMetadata(httpRequest);\n    //    14. If httpRequests header list does not contain `User-Agent`, then\n    //    user agents should append `User-Agent`/default `User-Agent` value to\n    //    httpRequests header list.\n    if (!httpRequest.headersList.contains(\"user-agent\")) {\n        httpRequest.headersList.append(\"user-agent\", typeof esbuildDetection === \"undefined\" ? \"undici\" : \"node\");\n    }\n    //    15. If httpRequests cache mode is \"default\" and httpRequests header\n    //    list contains `If-Modified-Since`, `If-None-Match`,\n    //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set\n    //    httpRequests cache mode to \"no-store\".\n    if (httpRequest.cache === \"default\" && (httpRequest.headersList.contains(\"if-modified-since\") || httpRequest.headersList.contains(\"if-none-match\") || httpRequest.headersList.contains(\"if-unmodified-since\") || httpRequest.headersList.contains(\"if-match\") || httpRequest.headersList.contains(\"if-range\"))) {\n        httpRequest.cache = \"no-store\";\n    }\n    //    16. If httpRequests cache mode is \"no-cache\", httpRequests prevent\n    //    no-cache cache-control header modification flag is unset, and\n    //    httpRequests header list does not contain `Cache-Control`, then append\n    //    `Cache-Control`/`max-age=0` to httpRequests header list.\n    if (httpRequest.cache === \"no-cache\" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains(\"cache-control\")) {\n        httpRequest.headersList.append(\"cache-control\", \"max-age=0\");\n    }\n    //    17. If httpRequests cache mode is \"no-store\" or \"reload\", then:\n    if (httpRequest.cache === \"no-store\" || httpRequest.cache === \"reload\") {\n        // 1. If httpRequests header list does not contain `Pragma`, then append\n        // `Pragma`/`no-cache` to httpRequests header list.\n        if (!httpRequest.headersList.contains(\"pragma\")) {\n            httpRequest.headersList.append(\"pragma\", \"no-cache\");\n        }\n        // 2. If httpRequests header list does not contain `Cache-Control`,\n        // then append `Cache-Control`/`no-cache` to httpRequests header list.\n        if (!httpRequest.headersList.contains(\"cache-control\")) {\n            httpRequest.headersList.append(\"cache-control\", \"no-cache\");\n        }\n    }\n    //    18. If httpRequests header list contains `Range`, then append\n    //    `Accept-Encoding`/`identity` to httpRequests header list.\n    if (httpRequest.headersList.contains(\"range\")) {\n        httpRequest.headersList.append(\"accept-encoding\", \"identity\");\n    }\n    //    19. Modify httpRequests header list per HTTP. Do not append a given\n    //    header if httpRequests header list contains that headers name.\n    //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129\n    if (!httpRequest.headersList.contains(\"accept-encoding\")) {\n        if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {\n            httpRequest.headersList.append(\"accept-encoding\", \"br, gzip, deflate\");\n        } else {\n            httpRequest.headersList.append(\"accept-encoding\", \"gzip, deflate\");\n        }\n    }\n    httpRequest.headersList.delete(\"host\");\n    //    20. If includeCredentials is true, then:\n    if (includeCredentials) {\n    // 1. If the user agent is not configured to block cookies for httpRequest\n    // (see section 7 of [COOKIES]), then:\n    // TODO: credentials\n    // 2. If httpRequests header list does not contain `Authorization`, then:\n    // TODO: credentials\n    }\n    //    21. If theres a proxy-authentication entry, use it as appropriate.\n    //    TODO: proxy-authentication\n    //    22. Set httpCache to the result of determining the HTTP cache\n    //    partition, given httpRequest.\n    //    TODO: cache\n    //    23. If httpCache is null, then set httpRequests cache mode to\n    //    \"no-store\".\n    if (httpCache == null) {\n        httpRequest.cache = \"no-store\";\n    }\n    //    24. If httpRequests cache mode is neither \"no-store\" nor \"reload\",\n    //    then:\n    if (httpRequest.mode !== \"no-store\" && httpRequest.mode !== \"reload\") {\n    // TODO: cache\n    }\n    // 9. If aborted, then return the appropriate network error for fetchParams.\n    // TODO\n    // 10. If response is null, then:\n    if (response == null) {\n        // 1. If httpRequests cache mode is \"only-if-cached\", then return a\n        // network error.\n        if (httpRequest.mode === \"only-if-cached\") {\n            return makeNetworkError(\"only if cached\");\n        }\n        // 2. Let forwardResponse be the result of running HTTP-network fetch\n        // given httpFetchParams, includeCredentials, and isNewConnectionFetch.\n        const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);\n        // 3. If httpRequests method is unsafe and forwardResponses status is\n        // in the range 200 to 399, inclusive, invalidate appropriate stored\n        // responses in httpCache, as per the \"Invalidation\" chapter of HTTP\n        // Caching, and set storedResponse to null. [HTTP-CACHING]\n        if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {\n        // TODO: cache\n        }\n        // 4. If the revalidatingFlag is set and forwardResponses status is 304,\n        // then:\n        if (revalidatingFlag && forwardResponse.status === 304) {\n        // TODO: cache\n        }\n        // 5. If response is null, then:\n        if (response == null) {\n            // 1. Set response to forwardResponse.\n            response = forwardResponse;\n        // 2. Store httpRequest and forwardResponse in httpCache, as per the\n        // \"Storing Responses in Caches\" chapter of HTTP Caching. [HTTP-CACHING]\n        // TODO: cache\n        }\n    }\n    // 11. Set responses URL list to a clone of httpRequests URL list.\n    response.urlList = [\n        ...httpRequest.urlList\n    ];\n    // 12. If httpRequests header list contains `Range`, then set responses\n    // range-requested flag.\n    if (httpRequest.headersList.contains(\"range\")) {\n        response.rangeRequested = true;\n    }\n    // 13. Set responses request-includes-credentials to includeCredentials.\n    response.requestIncludesCredentials = includeCredentials;\n    // 14. If responses status is 401, httpRequests response tainting is not\n    // \"cors\", includeCredentials is true, and requests window is an environment\n    // settings object, then:\n    // TODO\n    // 15. If responses status is 407, then:\n    if (response.status === 407) {\n        // 1. If requests window is \"no-window\", then return a network error.\n        if (request.window === \"no-window\") {\n            return makeNetworkError();\n        }\n        // 2. ???\n        // 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n        if (isCancelled(fetchParams)) {\n            return makeAppropriateNetworkError(fetchParams);\n        }\n        // 4. Prompt the end user as appropriate in requests window and store\n        // the result as a proxy-authentication entry. [HTTP-AUTH]\n        // TODO: Invoke some kind of callback?\n        // 5. Set response to the result of running HTTP-network-or-cache fetch given\n        // fetchParams.\n        // TODO\n        return makeNetworkError(\"proxy authentication required\");\n    }\n    // 16. If all of the following are true\n    if (// responses status is 421\n    response.status === 421 && // isNewConnectionFetch is false\n    !isNewConnectionFetch && // requests body is null, or requests body is non-null and requests bodys source is non-null\n    (request.body == null || request.body.source != null)) {\n        // then:\n        // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n        if (isCancelled(fetchParams)) {\n            return makeAppropriateNetworkError(fetchParams);\n        }\n        // 2. Set response to the result of running HTTP-network-or-cache\n        // fetch given fetchParams, isAuthenticationFetch, and true.\n        // TODO (spec): The spec doesn't specify this but we need to cancel\n        // the active response before we can start a new one.\n        // https://github.com/whatwg/fetch/issues/1293\n        fetchParams.controller.connection.destroy();\n        response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);\n    }\n    // 17. If isAuthenticationFetch is true, then create an authentication entry\n    if (isAuthenticationFetch) {\n    // TODO\n    }\n    // 18. Return response.\n    return response;\n}\n// https://fetch.spec.whatwg.org/#http-network-fetch\nasync function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {\n    assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);\n    fetchParams.controller.connection = {\n        abort: null,\n        destroyed: false,\n        destroy (err) {\n            if (!this.destroyed) {\n                this.destroyed = true;\n                this.abort?.(err ?? new DOMException(\"The operation was aborted.\", \"AbortError\"));\n            }\n        }\n    };\n    // 1. Let request be fetchParamss request.\n    const request = fetchParams.request;\n    // 2. Let response be null.\n    let response = null;\n    // 3. Let timingInfo be fetchParamss timing info.\n    const timingInfo = fetchParams.timingInfo;\n    // 4. Let httpCache be the result of determining the HTTP cache partition,\n    // given request.\n    // TODO: cache\n    const httpCache = null;\n    // 5. If httpCache is null, then set requests cache mode to \"no-store\".\n    if (httpCache == null) {\n        request.cache = \"no-store\";\n    }\n    // 6. Let networkPartitionKey be the result of determining the network\n    // partition key given request.\n    // TODO\n    // 7. Let newConnection be \"yes\" if forceNewConnection is true; otherwise\n    // \"no\".\n    const newConnection = forceNewConnection ? \"yes\" : \"no\" // eslint-disable-line no-unused-vars\n    ;\n    // 8. Switch on requests mode:\n    if (request.mode === \"websocket\") {\n    // Let connection be the result of obtaining a WebSocket connection,\n    // given requests current URL.\n    // TODO\n    } else {\n    // Let connection be the result of obtaining a connection, given\n    // networkPartitionKey, requests current URLs origin,\n    // includeCredentials, and forceNewConnection.\n    // TODO\n    }\n    // 9. Run these steps, but abort when the ongoing fetch is terminated:\n    //    1. If connection is failure, then return a network error.\n    //    2. Set timingInfos final connection timing info to the result of\n    //    calling clamp and coarsen connection timing info with connections\n    //    timing info, timingInfos post-redirect start time, and fetchParamss\n    //    cross-origin isolated capability.\n    //    3. If connection is not an HTTP/2 connection, requests body is non-null,\n    //    and requests bodys source is null, then append (`Transfer-Encoding`,\n    //    `chunked`) to requests header list.\n    //    4. Set timingInfos final network-request start time to the coarsened\n    //    shared current time given fetchParamss cross-origin isolated\n    //    capability.\n    //    5. Set response to the result of making an HTTP request over connection\n    //    using request with the following caveats:\n    //        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]\n    //        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]\n    //        - If requests body is non-null, and requests bodys source is null,\n    //        then the user agent may have a buffer of up to 64 kibibytes and store\n    //        a part of requests body in that buffer. If the user agent reads from\n    //        requests body beyond that buffers size and the user agent needs to\n    //        resend request, then instead return a network error.\n    //        - Set timingInfos final network-response start time to the coarsened\n    //        shared current time given fetchParamss cross-origin isolated capability,\n    //        immediately after the user agents HTTP parser receives the first byte\n    //        of the response (e.g., frame header bytes for HTTP/2 or response status\n    //        line for HTTP/1.x).\n    //        - Wait until all the headers are transmitted.\n    //        - Any responses whose status is in the range 100 to 199, inclusive,\n    //        and is not 101, are to be ignored, except for the purposes of setting\n    //        timingInfos final network-response start time above.\n    //    - If requests header list contains `Transfer-Encoding`/`chunked` and\n    //    response is transferred via HTTP/1.0 or older, then return a network\n    //    error.\n    //    - If the HTTP request results in a TLS client certificate dialog, then:\n    //        1. If requests window is an environment settings object, make the\n    //        dialog available in requests window.\n    //        2. Otherwise, return a network error.\n    // To transmit requests body body, run these steps:\n    let requestBody = null;\n    // 1. If body is null and fetchParamss process request end-of-body is\n    // non-null, then queue a fetch task given fetchParamss process request\n    // end-of-body and fetchParamss task destination.\n    if (request.body == null && fetchParams.processRequestEndOfBody) {\n        queueMicrotask(()=>fetchParams.processRequestEndOfBody());\n    } else if (request.body != null) {\n        // 2. Otherwise, if body is non-null:\n        //    1. Let processBodyChunk given bytes be these steps:\n        const processBodyChunk = async function*(bytes) {\n            // 1. If the ongoing fetch is terminated, then abort these steps.\n            if (isCancelled(fetchParams)) {\n                return;\n            }\n            // 2. Run this step in parallel: transmit bytes.\n            yield bytes;\n            // 3. If fetchParamss process request body is non-null, then run\n            // fetchParamss process request body given bytess length.\n            fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);\n        };\n        // 2. Let processEndOfBody be these steps:\n        const processEndOfBody = ()=>{\n            // 1. If fetchParams is canceled, then abort these steps.\n            if (isCancelled(fetchParams)) {\n                return;\n            }\n            // 2. If fetchParamss process request end-of-body is non-null,\n            // then run fetchParamss process request end-of-body.\n            if (fetchParams.processRequestEndOfBody) {\n                fetchParams.processRequestEndOfBody();\n            }\n        };\n        // 3. Let processBodyError given e be these steps:\n        const processBodyError = (e)=>{\n            // 1. If fetchParams is canceled, then abort these steps.\n            if (isCancelled(fetchParams)) {\n                return;\n            }\n            // 2. If e is an \"AbortError\" DOMException, then abort fetchParamss controller.\n            if (e.name === \"AbortError\") {\n                fetchParams.controller.abort();\n            } else {\n                fetchParams.controller.terminate(e);\n            }\n        };\n        // 4. Incrementally read requests body given processBodyChunk, processEndOfBody,\n        // processBodyError, and fetchParamss task destination.\n        requestBody = async function*() {\n            try {\n                for await (const bytes of request.body.stream){\n                    yield* processBodyChunk(bytes);\n                }\n                processEndOfBody();\n            } catch (err) {\n                processBodyError(err);\n            }\n        }();\n    }\n    try {\n        // socket is only provided for websockets\n        const { body, status, statusText, headersList, socket } = await dispatch({\n            body: requestBody\n        });\n        if (socket) {\n            response = makeResponse({\n                status,\n                statusText,\n                headersList,\n                socket\n            });\n        } else {\n            const iterator = body[Symbol.asyncIterator]();\n            fetchParams.controller.next = ()=>iterator.next();\n            response = makeResponse({\n                status,\n                statusText,\n                headersList\n            });\n        }\n    } catch (err) {\n        // 10. If aborted, then:\n        if (err.name === \"AbortError\") {\n            // 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n            fetchParams.controller.connection.destroy();\n            // 2. Return the appropriate network error for fetchParams.\n            return makeAppropriateNetworkError(fetchParams, err);\n        }\n        return makeNetworkError(err);\n    }\n    // 11. Let pullAlgorithm be an action that resumes the ongoing fetch\n    // if it is suspended.\n    const pullAlgorithm = ()=>{\n        fetchParams.controller.resume();\n    };\n    // 12. Let cancelAlgorithm be an algorithm that aborts fetchParamss\n    // controller with reason, given reason.\n    const cancelAlgorithm = (reason)=>{\n        fetchParams.controller.abort(reason);\n    };\n    // 13. Let highWaterMark be a non-negative, non-NaN number, chosen by\n    // the user agent.\n    // TODO\n    // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object\n    // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.\n    // TODO\n    // 15. Let stream be a new ReadableStream.\n    // 16. Set up stream with pullAlgorithm set to pullAlgorithm,\n    // cancelAlgorithm set to cancelAlgorithm, highWaterMark set to\n    // highWaterMark, and sizeAlgorithm set to sizeAlgorithm.\n    if (!ReadableStream) {\n        ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n    }\n    const stream = new ReadableStream({\n        async start (controller) {\n            fetchParams.controller.controller = controller;\n        },\n        async pull (controller) {\n            await pullAlgorithm(controller);\n        },\n        async cancel (reason) {\n            await cancelAlgorithm(reason);\n        }\n    }, {\n        highWaterMark: 0,\n        size () {\n            return 1;\n        }\n    });\n    // 17. Run these steps, but abort when the ongoing fetch is terminated:\n    //    1. Set responses body to a new body whose stream is stream.\n    response.body = {\n        stream\n    };\n    //    2. If response is not a network error and requests cache mode is\n    //    not \"no-store\", then update response in httpCache for request.\n    //    TODO\n    //    3. If includeCredentials is true and the user agent is not configured\n    //    to block cookies for request (see section 7 of [COOKIES]), then run the\n    //    \"set-cookie-string\" parsing algorithm (see section 5.2 of [COOKIES]) on\n    //    the value of each header whose name is a byte-case-insensitive match for\n    //    `Set-Cookie` in responses header list, if any, and requests current URL.\n    //    TODO\n    // 18. If aborted, then:\n    // TODO\n    // 19. Run these steps in parallel:\n    //    1. Run these steps, but abort when fetchParams is canceled:\n    fetchParams.controller.on(\"terminated\", onAborted);\n    fetchParams.controller.resume = async ()=>{\n        // 1. While true\n        while(true){\n            // 1-3. See onData...\n            // 4. Set bytes to the result of handling content codings given\n            // codings and bytes.\n            let bytes;\n            let isFailure;\n            try {\n                const { done, value } = await fetchParams.controller.next();\n                if (isAborted(fetchParams)) {\n                    break;\n                }\n                bytes = done ? undefined : value;\n            } catch (err) {\n                if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {\n                    // zlib doesn't like empty streams.\n                    bytes = undefined;\n                } else {\n                    bytes = err;\n                    // err may be propagated from the result of calling readablestream.cancel,\n                    // which might not be an error. https://github.com/nodejs/undici/issues/2009\n                    isFailure = true;\n                }\n            }\n            if (bytes === undefined) {\n                // 2. Otherwise, if the bytes transmission for responses message\n                // body is done normally and stream is readable, then close\n                // stream, finalize response for fetchParams and response, and\n                // abort these in-parallel steps.\n                readableStreamClose(fetchParams.controller.controller);\n                finalizeResponse(fetchParams, response);\n                return;\n            }\n            // 5. Increase timingInfos decoded body size by bytess length.\n            timingInfo.decodedBodySize += bytes?.byteLength ?? 0;\n            // 6. If bytes is failure, then terminate fetchParamss controller.\n            if (isFailure) {\n                fetchParams.controller.terminate(bytes);\n                return;\n            }\n            // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes\n            // into stream.\n            fetchParams.controller.controller.enqueue(new Uint8Array(bytes));\n            // 8. If stream is errored, then terminate the ongoing fetch.\n            if (isErrored(stream)) {\n                fetchParams.controller.terminate();\n                return;\n            }\n            // 9. If stream doesnt need more data ask the user agent to suspend\n            // the ongoing fetch.\n            if (!fetchParams.controller.controller.desiredSize) {\n                return;\n            }\n        }\n    };\n    //    2. If aborted, then:\n    function onAborted(reason) {\n        // 2. If fetchParams is aborted, then:\n        if (isAborted(fetchParams)) {\n            // 1. Set responses aborted flag.\n            response.aborted = true;\n            // 2. If stream is readable, then error stream with the result of\n            //    deserialize a serialized abort reason given fetchParamss\n            //    controllers serialized abort reason and an\n            //    implementation-defined realm.\n            if (isReadable(stream)) {\n                fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);\n            }\n        } else {\n            // 3. Otherwise, if stream is readable, error stream with a TypeError.\n            if (isReadable(stream)) {\n                fetchParams.controller.controller.error(new TypeError(\"terminated\", {\n                    cause: isErrorLike(reason) ? reason : undefined\n                }));\n            }\n        }\n        // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n        // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.\n        fetchParams.controller.connection.destroy();\n    }\n    // 20. Return response.\n    return response;\n    async function dispatch({ body }) {\n        const url = requestCurrentURL(request);\n        /** @type {import('../..').Agent} */ const agent = fetchParams.controller.dispatcher;\n        return new Promise((resolve, reject)=>agent.dispatch({\n                path: url.pathname + url.search,\n                origin: url.origin,\n                method: request.method,\n                body: fetchParams.controller.dispatcher.isMockActive ? request.body && (request.body.source || request.body.stream) : body,\n                headers: request.headersList.entries,\n                maxRedirections: 0,\n                upgrade: request.mode === \"websocket\" ? \"websocket\" : undefined\n            }, {\n                body: null,\n                abort: null,\n                onConnect (abort) {\n                    // TODO (fix): Do we need connection here?\n                    const { connection } = fetchParams.controller;\n                    if (connection.destroyed) {\n                        abort(new DOMException(\"The operation was aborted.\", \"AbortError\"));\n                    } else {\n                        fetchParams.controller.on(\"terminated\", abort);\n                        this.abort = connection.abort = abort;\n                    }\n                },\n                onHeaders (status, headersList, resume, statusText) {\n                    if (status < 200) {\n                        return;\n                    }\n                    let codings = [];\n                    let location = \"\";\n                    const headers = new Headers();\n                    // For H2, the headers are a plain JS object\n                    // We distinguish between them and iterate accordingly\n                    if (Array.isArray(headersList)) {\n                        for(let n = 0; n < headersList.length; n += 2){\n                            const key = headersList[n + 0].toString(\"latin1\");\n                            const val = headersList[n + 1].toString(\"latin1\");\n                            if (key.toLowerCase() === \"content-encoding\") {\n                                // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1\n                                // \"All content-coding values are case-insensitive...\"\n                                codings = val.toLowerCase().split(\",\").map((x)=>x.trim());\n                            } else if (key.toLowerCase() === \"location\") {\n                                location = val;\n                            }\n                            headers[kHeadersList].append(key, val);\n                        }\n                    } else {\n                        const keys = Object.keys(headersList);\n                        for (const key of keys){\n                            const val = headersList[key];\n                            if (key.toLowerCase() === \"content-encoding\") {\n                                // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1\n                                // \"All content-coding values are case-insensitive...\"\n                                codings = val.toLowerCase().split(\",\").map((x)=>x.trim()).reverse();\n                            } else if (key.toLowerCase() === \"location\") {\n                                location = val;\n                            }\n                            headers[kHeadersList].append(key, val);\n                        }\n                    }\n                    this.body = new Readable({\n                        read: resume\n                    });\n                    const decoders = [];\n                    const willFollow = request.redirect === \"follow\" && location && redirectStatusSet.has(status);\n                    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding\n                    if (request.method !== \"HEAD\" && request.method !== \"CONNECT\" && !nullBodyStatus.includes(status) && !willFollow) {\n                        for (const coding of codings){\n                            // https://www.rfc-editor.org/rfc/rfc9112.html#section-7.2\n                            if (coding === \"x-gzip\" || coding === \"gzip\") {\n                                decoders.push(zlib.createGunzip({\n                                    // Be less strict when decoding compressed responses, since sometimes\n                                    // servers send slightly invalid responses that are still accepted\n                                    // by common browsers.\n                                    // Always using Z_SYNC_FLUSH is what cURL does.\n                                    flush: zlib.constants.Z_SYNC_FLUSH,\n                                    finishFlush: zlib.constants.Z_SYNC_FLUSH\n                                }));\n                            } else if (coding === \"deflate\") {\n                                decoders.push(zlib.createInflate());\n                            } else if (coding === \"br\") {\n                                decoders.push(zlib.createBrotliDecompress());\n                            } else {\n                                decoders.length = 0;\n                                break;\n                            }\n                        }\n                    }\n                    resolve({\n                        status,\n                        statusText,\n                        headersList: headers[kHeadersList],\n                        body: decoders.length ? pipeline(this.body, ...decoders, ()=>{}) : this.body.on(\"error\", ()=>{})\n                    });\n                    return true;\n                },\n                onData (chunk) {\n                    if (fetchParams.controller.dump) {\n                        return;\n                    }\n                    // 1. If one or more bytes have been transmitted from responses\n                    // message body, then:\n                    //  1. Let bytes be the transmitted bytes.\n                    const bytes = chunk;\n                    //  2. Let codings be the result of extracting header list values\n                    //  given `Content-Encoding` and responses header list.\n                    //  See pullAlgorithm.\n                    //  3. Increase timingInfos encoded body size by bytess length.\n                    timingInfo.encodedBodySize += bytes.byteLength;\n                    //  4. See pullAlgorithm...\n                    return this.body.push(bytes);\n                },\n                onComplete () {\n                    if (this.abort) {\n                        fetchParams.controller.off(\"terminated\", this.abort);\n                    }\n                    fetchParams.controller.ended = true;\n                    this.body.push(null);\n                },\n                onError (error) {\n                    if (this.abort) {\n                        fetchParams.controller.off(\"terminated\", this.abort);\n                    }\n                    this.body?.destroy(error);\n                    fetchParams.controller.terminate(error);\n                    reject(error);\n                },\n                onUpgrade (status, headersList, socket) {\n                    if (status !== 101) {\n                        return;\n                    }\n                    const headers = new Headers();\n                    for(let n = 0; n < headersList.length; n += 2){\n                        const key = headersList[n + 0].toString(\"latin1\");\n                        const val = headersList[n + 1].toString(\"latin1\");\n                        headers[kHeadersList].append(key, val);\n                    }\n                    resolve({\n                        status,\n                        statusText: STATUS_CODES[status],\n                        headersList: headers[kHeadersList],\n                        socket\n                    });\n                    return true;\n                }\n            }));\n    }\n}\nmodule.exports = {\n    fetch,\n    Fetch,\n    fetching,\n    finalizeAndReportTiming\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsaURBQWlEO0FBRWpEO0FBRUEsTUFBTSxFQUNKQSxRQUFRLEVBQ1JDLGdCQUFnQixFQUNoQkMsMkJBQTJCLEVBQzNCQyxjQUFjLEVBQ2RDLFlBQVksRUFDYixHQUFHQyxtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRUMsT0FBTyxFQUFFLEdBQUdELG1CQUFPQSxDQUFDO0FBQzVCLE1BQU0sRUFBRUUsT0FBTyxFQUFFQyxXQUFXLEVBQUUsR0FBR0gsbUJBQU9BLENBQUM7QUFDekMsTUFBTUksT0FBT0osbUJBQU9BLENBQUM7QUFDckIsTUFBTSxFQUNKSyxVQUFVLEVBQ1ZDLG1CQUFtQixFQUNuQkMsb0JBQW9CLEVBQ3BCQyxjQUFjLEVBQ2RDLFFBQVEsRUFDUkMseUJBQXlCLEVBQ3pCQyxtQkFBbUIsRUFDbkJDLGlCQUFpQixFQUNqQkMsa0NBQWtDLEVBQ2xDQyw2Q0FBNkMsRUFDN0NDLHNCQUFzQixFQUN0QkMsbUJBQW1CLEVBQ25CQyxTQUFTLEVBQ1RDLDhCQUE4QixFQUM5QkMseUJBQXlCLEVBQ3pCQywwQkFBMEIsRUFDMUJDLHFCQUFxQixFQUNyQkMsVUFBVSxFQUNWQyxVQUFVLEVBQ1ZDLFdBQVcsRUFDWEMsU0FBUyxFQUNUQyxXQUFXLEVBQ1hDLGFBQWEsRUFDYkMsbUJBQW1CLEVBQ25CQyxnQkFBZ0IsRUFDaEJDLFVBQVUsRUFDVkMsb0JBQW9CLEVBQ3BCQyxpQkFBaUIsRUFDbEIsR0FBR2hDLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFaUMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsTUFBTSxFQUFFLEdBQUdwQyxtQkFBT0EsQ0FBQztBQUNyRCxNQUFNcUMsU0FBU3JDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRXNDLGlCQUFpQixFQUFFLEdBQUd0QyxtQkFBT0EsQ0FBQztB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QUksQ0FBQztnQkFDakI7Z0JBRUFrSSxTQUFTM04sS0FBSztvQkFDWixJQUFJLElBQUksQ0FBQ0QsS0FBSyxFQUFFO3dCQUNkaUUsWUFBWXhDLFVBQVUsQ0FBQ2tNLEdBQUcsQ0FBQyxjQUFjLElBQUksQ0FBQzNOLEtBQUs7b0JBQ3JEO29CQUVBLElBQUksQ0FBQ29ELElBQUksRUFBRXRELFFBQVFHO29CQUVuQmdFLFlBQVl4QyxVQUFVLENBQUM3QixTQUFTLENBQUNLO29CQUVqQ1csT0FBT1g7Z0JBQ1Q7Z0JBRUE0TixXQUFXckksTUFBTSxFQUFFbkQsV0FBVyxFQUFFK0gsTUFBTTtvQkFDcEMsSUFBSTVFLFdBQVcsS0FBSzt3QkFDbEI7b0JBQ0Y7b0JBRUEsTUFBTUssVUFBVSxJQUFJdks7b0JBRXBCLElBQUssSUFBSStRLElBQUksR0FBR0EsSUFBSWhLLFlBQVlLLE1BQU0sRUFBRTJKLEtBQUssRUFBRzt3QkFDOUMsTUFBTUMsTUFBTWpLLFdBQVcsQ0FBQ2dLLElBQUksRUFBRSxDQUFDM0YsUUFBUSxDQUFDO3dCQUN4QyxNQUFNNkYsTUFBTWxLLFdBQVcsQ0FBQ2dLLElBQUksRUFBRSxDQUFDM0YsUUFBUSxDQUFDO3dCQUV4Q2IsT0FBTyxDQUFDM0gsYUFBYSxDQUFDcUcsTUFBTSxDQUFDK0gsS0FBS0M7b0JBQ3BDO29CQUVBeEssUUFBUTt3QkFDTnlEO3dCQUNBb0IsWUFBWTVILFlBQVksQ0FBQ3dHLE9BQU87d0JBQ2hDbkQsYUFBYXdELE9BQU8sQ0FBQzNILGFBQWE7d0JBQ2xDa007b0JBQ0Y7b0JBRUEsT0FBTztnQkFDVDtZQUNGO0lBRUo7QUFDRjtBQUVBMEQsT0FBT0MsT0FBTyxHQUFHO0lBQ2Y1TjtJQUNBZDtJQUNBaUQ7SUFDQVY7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL2luZGV4LmpzPzQ5ZjkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9naXRodWIuY29tL0V0aGFuLUFycm93b29kL3VuZGljaS1mZXRjaFxuXG4ndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBSZXNwb25zZSxcbiAgbWFrZU5ldHdvcmtFcnJvcixcbiAgbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yLFxuICBmaWx0ZXJSZXNwb25zZSxcbiAgbWFrZVJlc3BvbnNlXG59ID0gcmVxdWlyZSgnLi9yZXNwb25zZScpXG5jb25zdCB7IEhlYWRlcnMgfSA9IHJlcXVpcmUoJy4vaGVhZGVycycpXG5jb25zdCB7IFJlcXVlc3QsIG1ha2VSZXF1ZXN0IH0gPSByZXF1aXJlKCcuL3JlcXVlc3QnKVxuY29uc3QgemxpYiA9IHJlcXVpcmUoJ3psaWInKVxuY29uc3Qge1xuICBieXRlc01hdGNoLFxuICBtYWtlUG9saWN5Q29udGFpbmVyLFxuICBjbG9uZVBvbGljeUNvbnRhaW5lcixcbiAgcmVxdWVzdEJhZFBvcnQsXG4gIFRBT0NoZWNrLFxuICBhcHBlbmRSZXF1ZXN0T3JpZ2luSGVhZGVyLFxuICByZXNwb25zZUxvY2F0aW9uVVJMLFxuICByZXF1ZXN0Q3VycmVudFVSTCxcbiAgc2V0UmVxdWVzdFJlZmVycmVyUG9saWN5T25SZWRpcmVjdCxcbiAgdHJ5VXBncmFkZVJlcXVlc3RUb0FQb3RlbnRpYWxseVRydXN0d29ydGh5VVJMLFxuICBjcmVhdGVPcGFxdWVUaW1pbmdJbmZvLFxuICBhcHBlbmRGZXRjaE1ldGFkYXRhLFxuICBjb3JzQ2hlY2ssXG4gIGNyb3NzT3JpZ2luUmVzb3VyY2VQb2xpY3lDaGVjayxcbiAgZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlcixcbiAgY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUsXG4gIGNyZWF0ZURlZmVycmVkUHJvbWlzZSxcbiAgaXNCbG9iTGlrZSxcbiAgc2FtZU9yaWdpbixcbiAgaXNDYW5jZWxsZWQsXG4gIGlzQWJvcnRlZCxcbiAgaXNFcnJvckxpa2UsXG4gIGZ1bGx5UmVhZEJvZHksXG4gIHJlYWRhYmxlU3RyZWFtQ2xvc2UsXG4gIGlzb21vcnBoaWNFbmNvZGUsXG4gIHVybElzTG9jYWwsXG4gIHVybElzSHR0cEh0dHBzU2NoZW1lLFxuICB1cmxIYXNIdHRwc1NjaGVtZVxufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IGtTdGF0ZSwga0hlYWRlcnMsIGtHdWFyZCwga1JlYWxtIH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IHsgc2FmZWx5RXh0cmFjdEJvZHkgfSA9IHJlcXVpcmUoJy4vYm9keScpXG5jb25zdCB7XG4gIHJlZGlyZWN0U3RhdHVzU2V0LFxuICBudWxsQm9keVN0YXR1cyxcbiAgc2FmZU1ldGhvZHNTZXQsXG4gIHJlcXVlc3RCb2R5SGVhZGVyLFxuICBzdWJyZXNvdXJjZVNldCxcbiAgRE9NRXhjZXB0aW9uXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBrSGVhZGVyc0xpc3QgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpXG5jb25zdCB7IFJlYWRhYmxlLCBwaXBlbGluZSB9ID0gcmVxdWlyZSgnc3RyZWFtJylcbmNvbnN0IHsgYWRkQWJvcnRMaXN0ZW5lciwgaXNFcnJvcmVkLCBpc1JlYWRhYmxlLCBub2RlTWFqb3IsIG5vZGVNaW5vciB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgZGF0YVVSTFByb2Nlc3Nvciwgc2VyaWFsaXplQU1pbWVUeXBlIH0gPSByZXF1aXJlKCcuL2RhdGFVUkwnKVxuY29uc3QgeyBUcmFuc2Zvcm1TdHJlYW0gfSA9IHJlcXVpcmUoJ3N0cmVhbS93ZWInKVxuY29uc3QgeyBnZXRHbG9iYWxEaXNwYXRjaGVyIH0gPSByZXF1aXJlKCcuLi9nbG9iYWwnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4vd2ViaWRsJylcbmNvbnN0IHsgU1RBVFVTX0NPREVTIH0gPSByZXF1aXJlKCdodHRwJylcbmNvbnN0IEdFVF9PUl9IRUFEID0gWydHRVQnLCAnSEVBRCddXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCdidWZmZXInKS5yZXNvbHZlT2JqZWN0VVJMfSAqL1xubGV0IHJlc29sdmVPYmplY3RVUkxcbmxldCBSZWFkYWJsZVN0cmVhbSA9IGdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW1cblxuY2xhc3MgRmV0Y2ggZXh0ZW5kcyBFRSB7XG4gIGNvbnN0cnVjdG9yIChkaXNwYXRjaGVyKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlclxuICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGxcbiAgICB0aGlzLmR1bXAgPSBmYWxzZVxuICAgIHRoaXMuc3RhdGUgPSAnb25nb2luZydcbiAgICAvLyAyIHRlcm1pbmF0ZWQgbGlzdGVuZXJzIGdldCBhZGRlZCBwZXIgcmVxdWVzdCxcbiAgICAvLyBidXQgb25seSAxIGdldHMgcmVtb3ZlZC4gSWYgdGhlcmUgYXJlIDIwIHJlZGlyZWN0cyxcbiAgICAvLyAyMSBsaXN0ZW5lcnMgd2lsbCBiZSBhZGRlZC5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzE3MTFcbiAgICAvLyBUT0RPIChmaXgpOiBGaW5kIGFuZCBmaXggcm9vdCBjYXVzZSBmb3IgbGVha2VkIGxpc3RlbmVyLlxuICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKDIxKVxuICB9XG5cbiAgdGVybWluYXRlIChyZWFzb24pIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ29uZ29pbmcnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gJ3Rlcm1pbmF0ZWQnXG4gICAgdGhpcy5jb25uZWN0aW9uPy5kZXN0cm95KHJlYXNvbilcbiAgICB0aGlzLmVtaXQoJ3Rlcm1pbmF0ZWQnLCByZWFzb24pXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZmV0Y2gtY29udHJvbGxlci1hYm9ydFxuICBhYm9ydCAoZXJyb3IpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ29uZ29pbmcnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyAxLiBTZXQgY29udHJvbGxlcuKAmXMgc3RhdGUgdG8gXCJhYm9ydGVkXCIuXG4gICAgdGhpcy5zdGF0ZSA9ICdhYm9ydGVkJ1xuXG4gICAgLy8gMi4gTGV0IGZhbGxiYWNrRXJyb3IgYmUgYW4gXCJBYm9ydEVycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgIC8vIDMuIFNldCBlcnJvciB0byBmYWxsYmFja0Vycm9yIGlmIGl0IGlzIG5vdCBnaXZlbi5cbiAgICBpZiAoIWVycm9yKSB7XG4gICAgICBlcnJvciA9IG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKVxuICAgIH1cblxuICAgIC8vIDQuIExldCBzZXJpYWxpemVkRXJyb3IgYmUgU3RydWN0dXJlZFNlcmlhbGl6ZShlcnJvcikuXG4gICAgLy8gICAgSWYgdGhhdCB0aHJldyBhbiBleGNlcHRpb24sIGNhdGNoIGl0LCBhbmQgbGV0XG4gICAgLy8gICAgc2VyaWFsaXplZEVycm9yIGJlIFN0cnVjdHVyZWRTZXJpYWxpemUoZmFsbGJhY2tFcnJvcikuXG5cbiAgICAvLyA1LiBTZXQgY29udHJvbGxlcuKAmXMgc2VyaWFsaXplZCBhYm9ydCByZWFzb24gdG8gc2VyaWFsaXplZEVycm9yLlxuICAgIHRoaXMuc2VyaWFsaXplZEFib3J0UmVhc29uID0gZXJyb3JcblxuICAgIHRoaXMuY29ubmVjdGlvbj8uZGVzdHJveShlcnJvcilcbiAgICB0aGlzLmVtaXQoJ3Rlcm1pbmF0ZWQnLCBlcnJvcilcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZmV0Y2gtbWV0aG9kXG5mdW5jdGlvbiBmZXRjaCAoaW5wdXQsIGluaXQgPSB7fSkge1xuICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnZ2xvYmFsVGhpcy5mZXRjaCcgfSlcblxuICAvLyAxLiBMZXQgcCBiZSBhIG5ldyBwcm9taXNlLlxuICBjb25zdCBwID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKClcblxuICAvLyAyLiBMZXQgcmVxdWVzdE9iamVjdCBiZSB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBpbml0aWFsIHZhbHVlIG9mXG4gIC8vIFJlcXVlc3QgYXMgY29uc3RydWN0b3Igd2l0aCBpbnB1dCBhbmQgaW5pdCBhcyBhcmd1bWVudHMuIElmIHRoaXMgdGhyb3dzXG4gIC8vIGFuIGV4Y2VwdGlvbiwgcmVqZWN0IHAgd2l0aCBpdCBhbmQgcmV0dXJuIHAuXG4gIGxldCByZXF1ZXN0T2JqZWN0XG5cbiAgdHJ5IHtcbiAgICByZXF1ZXN0T2JqZWN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBwLnJlamVjdChlKVxuICAgIHJldHVybiBwLnByb21pc2VcbiAgfVxuXG4gIC8vIDMuIExldCByZXF1ZXN0IGJlIHJlcXVlc3RPYmplY3TigJlzIHJlcXVlc3QuXG4gIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0T2JqZWN0W2tTdGF0ZV1cblxuICAvLyA0LiBJZiByZXF1ZXN0T2JqZWN04oCZcyBzaWduYWzigJlzIGFib3J0ZWQgZmxhZyBpcyBzZXQsIHRoZW46XG4gIGlmIChyZXF1ZXN0T2JqZWN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgLy8gMS4gQWJvcnQgdGhlIGZldGNoKCkgY2FsbCB3aXRoIHAsIHJlcXVlc3QsIG51bGwsIGFuZFxuICAgIC8vICAgIHJlcXVlc3RPYmplY3TigJlzIHNpZ25hbOKAmXMgYWJvcnQgcmVhc29uLlxuICAgIGFib3J0RmV0Y2gocCwgcmVxdWVzdCwgbnVsbCwgcmVxdWVzdE9iamVjdC5zaWduYWwucmVhc29uKVxuXG4gICAgLy8gMi4gUmV0dXJuIHAuXG4gICAgcmV0dXJuIHAucHJvbWlzZVxuICB9XG5cbiAgLy8gNS4gTGV0IGdsb2JhbE9iamVjdCBiZSByZXF1ZXN04oCZcyBjbGllbnTigJlzIGdsb2JhbCBvYmplY3QuXG4gIGNvbnN0IGdsb2JhbE9iamVjdCA9IHJlcXVlc3QuY2xpZW50Lmdsb2JhbE9iamVjdFxuXG4gIC8vIDYuIElmIGdsb2JhbE9iamVjdCBpcyBhIFNlcnZpY2VXb3JrZXJHbG9iYWxTY29wZSBvYmplY3QsIHRoZW4gc2V0XG4gIC8vIHJlcXVlc3TigJlzIHNlcnZpY2Utd29ya2VycyBtb2RlIHRvIFwibm9uZVwiLlxuICBpZiAoZ2xvYmFsT2JqZWN0Py5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ1NlcnZpY2VXb3JrZXJHbG9iYWxTY29wZScpIHtcbiAgICByZXF1ZXN0LnNlcnZpY2VXb3JrZXJzID0gJ25vbmUnXG4gIH1cblxuICAvLyA3LiBMZXQgcmVzcG9uc2VPYmplY3QgYmUgbnVsbC5cbiAgbGV0IHJlc3BvbnNlT2JqZWN0ID0gbnVsbFxuXG4gIC8vIDguIExldCByZWxldmFudFJlYWxtIGJlIHRoaXPigJlzIHJlbGV2YW50IFJlYWxtLlxuICBjb25zdCByZWxldmFudFJlYWxtID0gbnVsbFxuXG4gIC8vIDkuIExldCBsb2NhbGx5QWJvcnRlZCBiZSBmYWxzZS5cbiAgbGV0IGxvY2FsbHlBYm9ydGVkID0gZmFsc2VcblxuICAvLyAxMC4gTGV0IGNvbnRyb2xsZXIgYmUgbnVsbC5cbiAgbGV0IGNvbnRyb2xsZXIgPSBudWxsXG5cbiAgLy8gMTEuIEFkZCB0aGUgZm9sbG93aW5nIGFib3J0IHN0ZXBzIHRvIHJlcXVlc3RPYmplY3TigJlzIHNpZ25hbDpcbiAgYWRkQWJvcnRMaXN0ZW5lcihcbiAgICByZXF1ZXN0T2JqZWN0LnNpZ25hbCxcbiAgICAoKSA9PiB7XG4gICAgICAvLyAxLiBTZXQgbG9jYWxseUFib3J0ZWQgdG8gdHJ1ZS5cbiAgICAgIGxvY2FsbHlBYm9ydGVkID0gdHJ1ZVxuXG4gICAgICAvLyAyLiBBc3NlcnQ6IGNvbnRyb2xsZXIgaXMgbm9uLW51bGwuXG4gICAgICBhc3NlcnQoY29udHJvbGxlciAhPSBudWxsKVxuXG4gICAgICAvLyAzLiBBYm9ydCBjb250cm9sbGVyIHdpdGggcmVxdWVzdE9iamVjdOKAmXMgc2lnbmFs4oCZcyBhYm9ydCByZWFzb24uXG4gICAgICBjb250cm9sbGVyLmFib3J0KHJlcXVlc3RPYmplY3Quc2lnbmFsLnJlYXNvbilcblxuICAgICAgLy8gNC4gQWJvcnQgdGhlIGZldGNoKCkgY2FsbCB3aXRoIHAsIHJlcXVlc3QsIHJlc3BvbnNlT2JqZWN0LFxuICAgICAgLy8gICAgYW5kIHJlcXVlc3RPYmplY3TigJlzIHNpZ25hbOKAmXMgYWJvcnQgcmVhc29uLlxuICAgICAgYWJvcnRGZXRjaChwLCByZXF1ZXN0LCByZXNwb25zZU9iamVjdCwgcmVxdWVzdE9iamVjdC5zaWduYWwucmVhc29uKVxuICAgIH1cbiAgKVxuXG4gIC8vIDEyLiBMZXQgaGFuZGxlRmV0Y2hEb25lIGdpdmVuIHJlc3BvbnNlIHJlc3BvbnNlIGJlIHRvIGZpbmFsaXplIGFuZFxuICAvLyByZXBvcnQgdGltaW5nIHdpdGggcmVzcG9uc2UsIGdsb2JhbE9iamVjdCwgYW5kIFwiZmV0Y2hcIi5cbiAgY29uc3QgaGFuZGxlRmV0Y2hEb25lID0gKHJlc3BvbnNlKSA9PlxuICAgIGZpbmFsaXplQW5kUmVwb3J0VGltaW5nKHJlc3BvbnNlLCAnZmV0Y2gnKVxuXG4gIC8vIDEzLiBTZXQgY29udHJvbGxlciB0byB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgZmV0Y2ggZ2l2ZW4gcmVxdWVzdCxcbiAgLy8gd2l0aCBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgc2V0IHRvIGhhbmRsZUZldGNoRG9uZSwgYW5kIHByb2Nlc3NSZXNwb25zZVxuICAvLyBnaXZlbiByZXNwb25zZSBiZWluZyB0aGVzZSBzdWJzdGVwczpcblxuICBjb25zdCBwcm9jZXNzUmVzcG9uc2UgPSAocmVzcG9uc2UpID0+IHtcbiAgICAvLyAxLiBJZiBsb2NhbGx5QWJvcnRlZCBpcyB0cnVlLCB0ZXJtaW5hdGUgdGhlc2Ugc3Vic3RlcHMuXG4gICAgaWYgKGxvY2FsbHlBYm9ydGVkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9XG5cbiAgICAvLyAyLiBJZiByZXNwb25zZeKAmXMgYWJvcnRlZCBmbGFnIGlzIHNldCwgdGhlbjpcbiAgICBpZiAocmVzcG9uc2UuYWJvcnRlZCkge1xuICAgICAgLy8gMS4gTGV0IGRlc2VyaWFsaXplZEVycm9yIGJlIHRoZSByZXN1bHQgb2YgZGVzZXJpYWxpemUgYSBzZXJpYWxpemVkXG4gICAgICAvLyAgICBhYm9ydCByZWFzb24gZ2l2ZW4gY29udHJvbGxlcuKAmXMgc2VyaWFsaXplZCBhYm9ydCByZWFzb24gYW5kXG4gICAgICAvLyAgICByZWxldmFudFJlYWxtLlxuXG4gICAgICAvLyAyLiBBYm9ydCB0aGUgZmV0Y2goKSBjYWxsIHdpdGggcCwgcmVxdWVzdCwgcmVzcG9uc2VPYmplY3QsIGFuZFxuICAgICAgLy8gICAgZGVzZXJpYWxpemVkRXJyb3IuXG5cbiAgICAgIGFib3J0RmV0Y2gocCwgcmVxdWVzdCwgcmVzcG9uc2VPYmplY3QsIGNvbnRyb2xsZXIuc2VyaWFsaXplZEFib3J0UmVhc29uKVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgLy8gMy4gSWYgcmVzcG9uc2UgaXMgYSBuZXR3b3JrIGVycm9yLCB0aGVuIHJlamVjdCBwIHdpdGggYSBUeXBlRXJyb3JcbiAgICAvLyBhbmQgdGVybWluYXRlIHRoZXNlIHN1YnN0ZXBzLlxuICAgIGlmIChyZXNwb25zZS50eXBlID09PSAnZXJyb3InKSB7XG4gICAgICBwLnJlamVjdChcbiAgICAgICAgT2JqZWN0LmFzc2lnbihuZXcgVHlwZUVycm9yKCdmZXRjaCBmYWlsZWQnKSwgeyBjYXVzZTogcmVzcG9uc2UuZXJyb3IgfSlcbiAgICAgIClcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cblxuICAgIC8vIDQuIFNldCByZXNwb25zZU9iamVjdCB0byB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgUmVzcG9uc2Ugb2JqZWN0LFxuICAgIC8vIGdpdmVuIHJlc3BvbnNlLCBcImltbXV0YWJsZVwiLCBhbmQgcmVsZXZhbnRSZWFsbS5cbiAgICByZXNwb25zZU9iamVjdCA9IG5ldyBSZXNwb25zZSgpXG4gICAgcmVzcG9uc2VPYmplY3Rba1N0YXRlXSA9IHJlc3BvbnNlXG4gICAgcmVzcG9uc2VPYmplY3Rba1JlYWxtXSA9IHJlbGV2YW50UmVhbG1cbiAgICByZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba0hlYWRlcnNMaXN0XSA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0XG4gICAgcmVzcG9uc2VPYmplY3Rba0hlYWRlcnNdW2tHdWFyZF0gPSAnaW1tdXRhYmxlJ1xuICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrUmVhbG1dID0gcmVsZXZhbnRSZWFsbVxuXG4gICAgLy8gNS4gUmVzb2x2ZSBwIHdpdGggcmVzcG9uc2VPYmplY3QuXG4gICAgcC5yZXNvbHZlKHJlc3BvbnNlT2JqZWN0KVxuICB9XG5cbiAgY29udHJvbGxlciA9IGZldGNoaW5nKHtcbiAgICByZXF1ZXN0LFxuICAgIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keTogaGFuZGxlRmV0Y2hEb25lLFxuICAgIHByb2Nlc3NSZXNwb25zZSxcbiAgICBkaXNwYXRjaGVyOiBpbml0LmRpc3BhdGNoZXIgPz8gZ2V0R2xvYmFsRGlzcGF0Y2hlcigpIC8vIHVuZGljaVxuICB9KVxuXG4gIC8vIDE0LiBSZXR1cm4gcC5cbiAgcmV0dXJuIHAucHJvbWlzZVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZmluYWxpemUtYW5kLXJlcG9ydC10aW1pbmdcbmZ1bmN0aW9uIGZpbmFsaXplQW5kUmVwb3J0VGltaW5nIChyZXNwb25zZSwgaW5pdGlhdG9yVHlwZSA9ICdvdGhlcicpIHtcbiAgLy8gMS4gSWYgcmVzcG9uc2UgaXMgYW4gYWJvcnRlZCBuZXR3b3JrIGVycm9yLCB0aGVuIHJldHVybi5cbiAgaWYgKHJlc3BvbnNlLnR5cGUgPT09ICdlcnJvcicgJiYgcmVzcG9uc2UuYWJvcnRlZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gMi4gSWYgcmVzcG9uc2XigJlzIFVSTCBsaXN0IGlzIG51bGwgb3IgZW1wdHksIHRoZW4gcmV0dXJuLlxuICBpZiAoIXJlc3BvbnNlLnVybExpc3Q/Lmxlbmd0aCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gMy4gTGV0IG9yaWdpbmFsVVJMIGJlIHJlc3BvbnNl4oCZcyBVUkwgbGlzdFswXS5cbiAgY29uc3Qgb3JpZ2luYWxVUkwgPSByZXNwb25zZS51cmxMaXN0WzBdXG5cbiAgLy8gNC4gTGV0IHRpbWluZ0luZm8gYmUgcmVzcG9uc2XigJlzIHRpbWluZyBpbmZvLlxuICBsZXQgdGltaW5nSW5mbyA9IHJlc3BvbnNlLnRpbWluZ0luZm9cblxuICAvLyA1LiBMZXQgY2FjaGVTdGF0ZSBiZSByZXNwb25zZeKAmXMgY2FjaGUgc3RhdGUuXG4gIGxldCBjYWNoZVN0YXRlID0gcmVzcG9uc2UuY2FjaGVTdGF0ZVxuXG4gIC8vIDYuIElmIG9yaWdpbmFsVVJM4oCZcyBzY2hlbWUgaXMgbm90IGFuIEhUVFAoUykgc2NoZW1lLCB0aGVuIHJldHVybi5cbiAgaWYgKCF1cmxJc0h0dHBIdHRwc1NjaGVtZShvcmlnaW5hbFVSTCkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDcuIElmIHRpbWluZ0luZm8gaXMgbnVsbCwgdGhlbiByZXR1cm4uXG4gIGlmICh0aW1pbmdJbmZvID09PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyA4LiBJZiByZXNwb25zZeKAmXMgdGltaW5nIGFsbG93IHBhc3NlZCBmbGFnIGlzIG5vdCBzZXQsIHRoZW46XG4gIGlmICghcmVzcG9uc2UudGltaW5nQWxsb3dQYXNzZWQpIHtcbiAgICAvLyAgMS4gU2V0IHRpbWluZ0luZm8gdG8gYSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGFuIG9wYXF1ZSB0aW1pbmcgaW5mbyBmb3IgdGltaW5nSW5mby5cbiAgICB0aW1pbmdJbmZvID0gY3JlYXRlT3BhcXVlVGltaW5nSW5mbyh7XG4gICAgICBzdGFydFRpbWU6IHRpbWluZ0luZm8uc3RhcnRUaW1lXG4gICAgfSlcblxuICAgIC8vICAyLiBTZXQgY2FjaGVTdGF0ZSB0byB0aGUgZW1wdHkgc3RyaW5nLlxuICAgIGNhY2hlU3RhdGUgPSAnJ1xuICB9XG5cbiAgLy8gOS4gU2V0IHRpbWluZ0luZm/igJlzIGVuZCB0aW1lIHRvIHRoZSBjb2Fyc2VuZWQgc2hhcmVkIGN1cnJlbnQgdGltZVxuICAvLyBnaXZlbiBnbG9iYWzigJlzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdOKAmXMgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkXG4gIC8vIGNhcGFiaWxpdHkuXG4gIC8vIFRPRE86IGdpdmVuIGdsb2JhbOKAmXMgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN04oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWRcbiAgLy8gY2FwYWJpbGl0eT9cbiAgdGltaW5nSW5mby5lbmRUaW1lID0gY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUoKVxuXG4gIC8vIDEwLiBTZXQgcmVzcG9uc2XigJlzIHRpbWluZyBpbmZvIHRvIHRpbWluZ0luZm8uXG4gIHJlc3BvbnNlLnRpbWluZ0luZm8gPSB0aW1pbmdJbmZvXG5cbiAgLy8gMTEuIE1hcmsgcmVzb3VyY2UgdGltaW5nIGZvciB0aW1pbmdJbmZvLCBvcmlnaW5hbFVSTCwgaW5pdGlhdG9yVHlwZSxcbiAgLy8gZ2xvYmFsLCBhbmQgY2FjaGVTdGF0ZS5cbiAgbWFya1Jlc291cmNlVGltaW5nKFxuICAgIHRpbWluZ0luZm8sXG4gICAgb3JpZ2luYWxVUkwsXG4gICAgaW5pdGlhdG9yVHlwZSxcbiAgICBnbG9iYWxUaGlzLFxuICAgIGNhY2hlU3RhdGVcbiAgKVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vcmVzb3VyY2UtdGltaW5nLyNkZm4tbWFyay1yZXNvdXJjZS10aW1pbmdcbmZ1bmN0aW9uIG1hcmtSZXNvdXJjZVRpbWluZyAodGltaW5nSW5mbywgb3JpZ2luYWxVUkwsIGluaXRpYXRvclR5cGUsIGdsb2JhbFRoaXMsIGNhY2hlU3RhdGUpIHtcbiAgaWYgKG5vZGVNYWpvciA+IDE4IHx8IChub2RlTWFqb3IgPT09IDE4ICYmIG5vZGVNaW5vciA+PSAyKSkge1xuICAgIHBlcmZvcm1hbmNlLm1hcmtSZXNvdXJjZVRpbWluZyh0aW1pbmdJbmZvLCBvcmlnaW5hbFVSTC5ocmVmLCBpbml0aWF0b3JUeXBlLCBnbG9iYWxUaGlzLCBjYWNoZVN0YXRlKVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNhYm9ydC1mZXRjaFxuZnVuY3Rpb24gYWJvcnRGZXRjaCAocCwgcmVxdWVzdCwgcmVzcG9uc2VPYmplY3QsIGVycm9yKSB7XG4gIC8vIE5vdGU6IEFib3J0U2lnbmFsLnJlYXNvbiB3YXMgYWRkZWQgaW4gbm9kZSB2MTcuMi4wXG4gIC8vIHdoaWNoIHdvdWxkIGdpdmUgdXMgYW4gdW5kZWZpbmVkIGVycm9yIHRvIHJlamVjdCB3aXRoLlxuICAvLyBSZW1vdmUgdGhpcyBvbmNlIG5vZGUgdjE2IGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuXG4gIGlmICghZXJyb3IpIHtcbiAgICBlcnJvciA9IG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKVxuICB9XG5cbiAgLy8gMS4gUmVqZWN0IHByb21pc2Ugd2l0aCBlcnJvci5cbiAgcC5yZWplY3QoZXJyb3IpXG5cbiAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgYm9keSBpcyBub3QgbnVsbCBhbmQgaXMgcmVhZGFibGUsIHRoZW4gY2FuY2VsIHJlcXVlc3TigJlzXG4gIC8vIGJvZHkgd2l0aCBlcnJvci5cbiAgaWYgKHJlcXVlc3QuYm9keSAhPSBudWxsICYmIGlzUmVhZGFibGUocmVxdWVzdC5ib2R5Py5zdHJlYW0pKSB7XG4gICAgcmVxdWVzdC5ib2R5LnN0cmVhbS5jYW5jZWwoZXJyb3IpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VSUl9JTlZBTElEX1NUQVRFJykge1xuICAgICAgICAvLyBOb2RlIGJ1Zz9cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9KVxuICB9XG5cbiAgLy8gMy4gSWYgcmVzcG9uc2VPYmplY3QgaXMgbnVsbCwgdGhlbiByZXR1cm4uXG4gIGlmIChyZXNwb25zZU9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyA0LiBMZXQgcmVzcG9uc2UgYmUgcmVzcG9uc2VPYmplY3TigJlzIHJlc3BvbnNlLlxuICBjb25zdCByZXNwb25zZSA9IHJlc3BvbnNlT2JqZWN0W2tTdGF0ZV1cblxuICAvLyA1LiBJZiByZXNwb25zZeKAmXMgYm9keSBpcyBub3QgbnVsbCBhbmQgaXMgcmVhZGFibGUsIHRoZW4gZXJyb3IgcmVzcG9uc2XigJlzXG4gIC8vIGJvZHkgd2l0aCBlcnJvci5cbiAgaWYgKHJlc3BvbnNlLmJvZHkgIT0gbnVsbCAmJiBpc1JlYWRhYmxlKHJlc3BvbnNlLmJvZHk/LnN0cmVhbSkpIHtcbiAgICByZXNwb25zZS5ib2R5LnN0cmVhbS5jYW5jZWwoZXJyb3IpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VSUl9JTlZBTElEX1NUQVRFJykge1xuICAgICAgICAvLyBOb2RlIGJ1Zz9cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9KVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNmZXRjaGluZ1xuZnVuY3Rpb24gZmV0Y2hpbmcgKHtcbiAgcmVxdWVzdCxcbiAgcHJvY2Vzc1JlcXVlc3RCb2R5Q2h1bmtMZW5ndGgsXG4gIHByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5LFxuICBwcm9jZXNzUmVzcG9uc2UsXG4gIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSxcbiAgcHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHksXG4gIHVzZVBhcmFsbGVsUXVldWUgPSBmYWxzZSxcbiAgZGlzcGF0Y2hlciAvLyB1bmRpY2lcbn0pIHtcbiAgLy8gMS4gTGV0IHRhc2tEZXN0aW5hdGlvbiBiZSBudWxsLlxuICBsZXQgdGFza0Rlc3RpbmF0aW9uID0gbnVsbFxuXG4gIC8vIDIuIExldCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSBiZSBmYWxzZS5cbiAgbGV0IGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5ID0gZmFsc2VcblxuICAvLyAzLiBJZiByZXF1ZXN04oCZcyBjbGllbnQgaXMgbm9uLW51bGwsIHRoZW46XG4gIGlmIChyZXF1ZXN0LmNsaWVudCAhPSBudWxsKSB7XG4gICAgLy8gMS4gU2V0IHRhc2tEZXN0aW5hdGlvbiB0byByZXF1ZXN04oCZcyBjbGllbnTigJlzIGdsb2JhbCBvYmplY3QuXG4gICAgdGFza0Rlc3RpbmF0aW9uID0gcmVxdWVzdC5jbGllbnQuZ2xvYmFsT2JqZWN0XG5cbiAgICAvLyAyLiBTZXQgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkgdG8gcmVxdWVzdOKAmXMgY2xpZW504oCZcyBjcm9zcy1vcmlnaW5cbiAgICAvLyBpc29sYXRlZCBjYXBhYmlsaXR5LlxuICAgIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5ID1cbiAgICAgIHJlcXVlc3QuY2xpZW50LmNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5XG4gIH1cblxuICAvLyA0LiBJZiB1c2VQYXJhbGxlbFF1ZXVlIGlzIHRydWUsIHRoZW4gc2V0IHRhc2tEZXN0aW5hdGlvbiB0byB0aGUgcmVzdWx0IG9mXG4gIC8vIHN0YXJ0aW5nIGEgbmV3IHBhcmFsbGVsIHF1ZXVlLlxuICAvLyBUT0RPXG5cbiAgLy8gNS4gTGV0IHRpbWluZ0luZm8gYmUgYSBuZXcgZmV0Y2ggdGltaW5nIGluZm8gd2hvc2Ugc3RhcnQgdGltZSBhbmRcbiAgLy8gcG9zdC1yZWRpcmVjdCBzdGFydCB0aW1lIGFyZSB0aGUgY29hcnNlbmVkIHNoYXJlZCBjdXJyZW50IHRpbWUgZ2l2ZW5cbiAgLy8gY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkuXG4gIGNvbnN0IGN1cnJlblRpbWUgPSBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZShjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSlcbiAgY29uc3QgdGltaW5nSW5mbyA9IGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8oe1xuICAgIHN0YXJ0VGltZTogY3VycmVuVGltZVxuICB9KVxuXG4gIC8vIDYuIExldCBmZXRjaFBhcmFtcyBiZSBhIG5ldyBmZXRjaCBwYXJhbXMgd2hvc2VcbiAgLy8gcmVxdWVzdCBpcyByZXF1ZXN0LFxuICAvLyB0aW1pbmcgaW5mbyBpcyB0aW1pbmdJbmZvLFxuICAvLyBwcm9jZXNzIHJlcXVlc3QgYm9keSBjaHVuayBsZW5ndGggaXMgcHJvY2Vzc1JlcXVlc3RCb2R5Q2h1bmtMZW5ndGgsXG4gIC8vIHByb2Nlc3MgcmVxdWVzdCBlbmQtb2YtYm9keSBpcyBwcm9jZXNzUmVxdWVzdEVuZE9mQm9keSxcbiAgLy8gcHJvY2VzcyByZXNwb25zZSBpcyBwcm9jZXNzUmVzcG9uc2UsXG4gIC8vIHByb2Nlc3MgcmVzcG9uc2UgY29uc3VtZSBib2R5IGlzIHByb2Nlc3NSZXNwb25zZUNvbnN1bWVCb2R5LFxuICAvLyBwcm9jZXNzIHJlc3BvbnNlIGVuZC1vZi1ib2R5IGlzIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSxcbiAgLy8gdGFzayBkZXN0aW5hdGlvbiBpcyB0YXNrRGVzdGluYXRpb24sXG4gIC8vIGFuZCBjcm9zcy1vcmlnaW4gaXNvbGF0ZWQgY2FwYWJpbGl0eSBpcyBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eS5cbiAgY29uc3QgZmV0Y2hQYXJhbXMgPSB7XG4gICAgY29udHJvbGxlcjogbmV3IEZldGNoKGRpc3BhdGNoZXIpLFxuICAgIHJlcXVlc3QsXG4gICAgdGltaW5nSW5mbyxcbiAgICBwcm9jZXNzUmVxdWVzdEJvZHlDaHVua0xlbmd0aCxcbiAgICBwcm9jZXNzUmVxdWVzdEVuZE9mQm9keSxcbiAgICBwcm9jZXNzUmVzcG9uc2UsXG4gICAgcHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHksXG4gICAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5LFxuICAgIHRhc2tEZXN0aW5hdGlvbixcbiAgICBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eVxuICB9XG5cbiAgLy8gNy4gSWYgcmVxdWVzdOKAmXMgYm9keSBpcyBhIGJ5dGUgc2VxdWVuY2UsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGJvZHkgdG9cbiAgLy8gICAgcmVxdWVzdOKAmXMgYm9keSBhcyBhIGJvZHkuXG4gIC8vIE5PVEU6IFNpbmNlIGZldGNoaW5nIGlzIG9ubHkgY2FsbGVkIGZyb20gZmV0Y2gsIGJvZHkgc2hvdWxkIGFscmVhZHkgYmVcbiAgLy8gZXh0cmFjdGVkLlxuICBhc3NlcnQoIXJlcXVlc3QuYm9keSB8fCByZXF1ZXN0LmJvZHkuc3RyZWFtKVxuXG4gIC8vIDguIElmIHJlcXVlc3TigJlzIHdpbmRvdyBpcyBcImNsaWVudFwiLCB0aGVuIHNldCByZXF1ZXN04oCZcyB3aW5kb3cgdG8gcmVxdWVzdOKAmXNcbiAgLy8gY2xpZW50LCBpZiByZXF1ZXN04oCZcyBjbGllbnTigJlzIGdsb2JhbCBvYmplY3QgaXMgYSBXaW5kb3cgb2JqZWN0OyBvdGhlcndpc2VcbiAgLy8gXCJuby13aW5kb3dcIi5cbiAgaWYgKHJlcXVlc3Qud2luZG93ID09PSAnY2xpZW50Jykge1xuICAgIC8vIFRPRE86IFdoYXQgaWYgcmVxdWVzdC5jbGllbnQgaXMgbnVsbD9cbiAgICByZXF1ZXN0LndpbmRvdyA9XG4gICAgICByZXF1ZXN0LmNsaWVudD8uZ2xvYmFsT2JqZWN0Py5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ1dpbmRvdydcbiAgICAgICAgPyByZXF1ZXN0LmNsaWVudFxuICAgICAgICA6ICduby13aW5kb3cnXG4gIH1cblxuICAvLyA5LiBJZiByZXF1ZXN04oCZcyBvcmlnaW4gaXMgXCJjbGllbnRcIiwgdGhlbiBzZXQgcmVxdWVzdOKAmXMgb3JpZ2luIHRvIHJlcXVlc3TigJlzXG4gIC8vIGNsaWVudOKAmXMgb3JpZ2luLlxuICBpZiAocmVxdWVzdC5vcmlnaW4gPT09ICdjbGllbnQnKSB7XG4gICAgLy8gVE9ETzogV2hhdCBpZiByZXF1ZXN0LmNsaWVudCBpcyBudWxsP1xuICAgIHJlcXVlc3Qub3JpZ2luID0gcmVxdWVzdC5jbGllbnQ/Lm9yaWdpblxuICB9XG5cbiAgLy8gMTAuIElmIGFsbCBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIHRydWU6XG4gIC8vIFRPRE9cblxuICAvLyAxMS4gSWYgcmVxdWVzdOKAmXMgcG9saWN5IGNvbnRhaW5lciBpcyBcImNsaWVudFwiLCB0aGVuOlxuICBpZiAocmVxdWVzdC5wb2xpY3lDb250YWluZXIgPT09ICdjbGllbnQnKSB7XG4gICAgLy8gMS4gSWYgcmVxdWVzdOKAmXMgY2xpZW50IGlzIG5vbi1udWxsLCB0aGVuIHNldCByZXF1ZXN04oCZcyBwb2xpY3lcbiAgICAvLyBjb250YWluZXIgdG8gYSBjbG9uZSBvZiByZXF1ZXN04oCZcyBjbGllbnTigJlzIHBvbGljeSBjb250YWluZXIuIFtIVE1MXVxuICAgIGlmIChyZXF1ZXN0LmNsaWVudCAhPSBudWxsKSB7XG4gICAgICByZXF1ZXN0LnBvbGljeUNvbnRhaW5lciA9IGNsb25lUG9saWN5Q29udGFpbmVyKFxuICAgICAgICByZXF1ZXN0LmNsaWVudC5wb2xpY3lDb250YWluZXJcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMi4gT3RoZXJ3aXNlLCBzZXQgcmVxdWVzdOKAmXMgcG9saWN5IGNvbnRhaW5lciB0byBhIG5ldyBwb2xpY3lcbiAgICAgIC8vIGNvbnRhaW5lci5cbiAgICAgIHJlcXVlc3QucG9saWN5Q29udGFpbmVyID0gbWFrZVBvbGljeUNvbnRhaW5lcigpXG4gICAgfVxuICB9XG5cbiAgLy8gMTIuIElmIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYEFjY2VwdGAsIHRoZW46XG4gIGlmICghcmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnYWNjZXB0JykpIHtcbiAgICAvLyAxLiBMZXQgdmFsdWUgYmUgYCovKmAuXG4gICAgY29uc3QgdmFsdWUgPSAnKi8qJ1xuXG4gICAgLy8gMi4gQSB1c2VyIGFnZW50IHNob3VsZCBzZXQgdmFsdWUgdG8gdGhlIGZpcnN0IG1hdGNoaW5nIHN0YXRlbWVudCwgaWZcbiAgICAvLyBhbnksIHN3aXRjaGluZyBvbiByZXF1ZXN04oCZcyBkZXN0aW5hdGlvbjpcbiAgICAvLyBcImRvY3VtZW50XCJcbiAgICAvLyBcImZyYW1lXCJcbiAgICAvLyBcImlmcmFtZVwiXG4gICAgLy8gYHRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LCovKjtxPTAuOGBcbiAgICAvLyBcImltYWdlXCJcbiAgICAvLyBgaW1hZ2UvcG5nLGltYWdlL3N2Zyt4bWwsaW1hZ2UvKjtxPTAuOCwqLyo7cT0wLjVgXG4gICAgLy8gXCJzdHlsZVwiXG4gICAgLy8gYHRleHQvY3NzLCovKjtxPTAuMWBcbiAgICAvLyBUT0RPXG5cbiAgICAvLyAzLiBBcHBlbmQgYEFjY2VwdGAvdmFsdWUgdG8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2FjY2VwdCcsIHZhbHVlKVxuICB9XG5cbiAgLy8gMTMuIElmIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYEFjY2VwdC1MYW5ndWFnZWAsIHRoZW5cbiAgLy8gdXNlciBhZ2VudHMgc2hvdWxkIGFwcGVuZCBgQWNjZXB0LUxhbmd1YWdlYC9hbiBhcHByb3ByaWF0ZSB2YWx1ZSB0b1xuICAvLyByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgaWYgKCFyZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdhY2NlcHQtbGFuZ3VhZ2UnKSkge1xuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdhY2NlcHQtbGFuZ3VhZ2UnLCAnKicpXG4gIH1cblxuICAvLyAxNC4gSWYgcmVxdWVzdOKAmXMgcHJpb3JpdHkgaXMgbnVsbCwgdGhlbiB1c2UgcmVxdWVzdOKAmXMgaW5pdGlhdG9yIGFuZFxuICAvLyBkZXN0aW5hdGlvbiBhcHByb3ByaWF0ZWx5IGluIHNldHRpbmcgcmVxdWVzdOKAmXMgcHJpb3JpdHkgdG8gYVxuICAvLyB1c2VyLWFnZW50LWRlZmluZWQgb2JqZWN0LlxuICBpZiAocmVxdWVzdC5wcmlvcml0eSA9PT0gbnVsbCkge1xuICAgIC8vIFRPRE9cbiAgfVxuXG4gIC8vIDE1LiBJZiByZXF1ZXN0IGlzIGEgc3VicmVzb3VyY2UgcmVxdWVzdCwgdGhlbjpcbiAgaWYgKHN1YnJlc291cmNlU2V0LmhhcyhyZXF1ZXN0LmRlc3RpbmF0aW9uKSkge1xuICAgIC8vIFRPRE9cbiAgfVxuXG4gIC8vIDE2LiBSdW4gbWFpbiBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcy5cbiAgbWFpbkZldGNoKGZldGNoUGFyYW1zKVxuICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci50ZXJtaW5hdGUoZXJyKVxuICAgIH0pXG5cbiAgLy8gMTcuIFJldHVybiBmZXRjaFBhcmFtJ3MgY29udHJvbGxlclxuICByZXR1cm4gZmV0Y2hQYXJhbXMuY29udHJvbGxlclxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1tYWluLWZldGNoXG5hc3luYyBmdW5jdGlvbiBtYWluRmV0Y2ggKGZldGNoUGFyYW1zLCByZWN1cnNpdmUgPSBmYWxzZSkge1xuICAvLyAxLiBMZXQgcmVxdWVzdCBiZSBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdC5cbiAgY29uc3QgcmVxdWVzdCA9IGZldGNoUGFyYW1zLnJlcXVlc3RcblxuICAvLyAyLiBMZXQgcmVzcG9uc2UgYmUgbnVsbC5cbiAgbGV0IHJlc3BvbnNlID0gbnVsbFxuXG4gIC8vIDMuIElmIHJlcXVlc3TigJlzIGxvY2FsLVVSTHMtb25seSBmbGFnIGlzIHNldCBhbmQgcmVxdWVzdOKAmXMgY3VycmVudCBVUkwgaXNcbiAgLy8gbm90IGxvY2FsLCB0aGVuIHNldCByZXNwb25zZSB0byBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChyZXF1ZXN0LmxvY2FsVVJMc09ubHkgJiYgIXVybElzTG9jYWwocmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdCkpKSB7XG4gICAgcmVzcG9uc2UgPSBtYWtlTmV0d29ya0Vycm9yKCdsb2NhbCBVUkxzIG9ubHknKVxuICB9XG5cbiAgLy8gNC4gUnVuIHJlcG9ydCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB2aW9sYXRpb25zIGZvciByZXF1ZXN0LlxuICAvLyBUT0RPXG5cbiAgLy8gNS4gVXBncmFkZSByZXF1ZXN0IHRvIGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLCBpZiBhcHByb3ByaWF0ZS5cbiAgdHJ5VXBncmFkZVJlcXVlc3RUb0FQb3RlbnRpYWxseVRydXN0d29ydGh5VVJMKHJlcXVlc3QpXG5cbiAgLy8gNi4gSWYgc2hvdWxkIHJlcXVlc3QgYmUgYmxvY2tlZCBkdWUgdG8gYSBiYWQgcG9ydCwgc2hvdWxkIGZldGNoaW5nIHJlcXVlc3RcbiAgLy8gYmUgYmxvY2tlZCBhcyBtaXhlZCBjb250ZW50LCBvciBzaG91bGQgcmVxdWVzdCBiZSBibG9ja2VkIGJ5IENvbnRlbnRcbiAgLy8gU2VjdXJpdHkgUG9saWN5IHJldHVybnMgYmxvY2tlZCwgdGhlbiBzZXQgcmVzcG9uc2UgdG8gYSBuZXR3b3JrIGVycm9yLlxuICBpZiAocmVxdWVzdEJhZFBvcnQocmVxdWVzdCkgPT09ICdibG9ja2VkJykge1xuICAgIHJlc3BvbnNlID0gbWFrZU5ldHdvcmtFcnJvcignYmFkIHBvcnQnKVxuICB9XG4gIC8vIFRPRE86IHNob3VsZCBmZXRjaGluZyByZXF1ZXN0IGJlIGJsb2NrZWQgYXMgbWl4ZWQgY29udGVudD9cbiAgLy8gVE9ETzogc2hvdWxkIHJlcXVlc3QgYmUgYmxvY2tlZCBieSBDb250ZW50IFNlY3VyaXR5IFBvbGljeT9cblxuICAvLyA3LiBJZiByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3kgaXMgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBzZXQgcmVxdWVzdOKAmXNcbiAgLy8gcmVmZXJyZXIgcG9saWN5IHRvIHJlcXVlc3TigJlzIHBvbGljeSBjb250YWluZXLigJlzIHJlZmVycmVyIHBvbGljeS5cbiAgaWYgKHJlcXVlc3QucmVmZXJyZXJQb2xpY3kgPT09ICcnKSB7XG4gICAgcmVxdWVzdC5yZWZlcnJlclBvbGljeSA9IHJlcXVlc3QucG9saWN5Q29udGFpbmVyLnJlZmVycmVyUG9saWN5XG4gIH1cblxuICAvLyA4LiBJZiByZXF1ZXN04oCZcyByZWZlcnJlciBpcyBub3QgXCJuby1yZWZlcnJlclwiLCB0aGVuIHNldCByZXF1ZXN04oCZc1xuICAvLyByZWZlcnJlciB0byB0aGUgcmVzdWx0IG9mIGludm9raW5nIGRldGVybWluZSByZXF1ZXN04oCZcyByZWZlcnJlci5cbiAgaWYgKHJlcXVlc3QucmVmZXJyZXIgIT09ICduby1yZWZlcnJlcicpIHtcbiAgICByZXF1ZXN0LnJlZmVycmVyID0gZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlcihyZXF1ZXN0KVxuICB9XG5cbiAgLy8gOS4gU2V0IHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBzY2hlbWUgdG8gXCJodHRwc1wiIGlmIGFsbCBvZiB0aGUgZm9sbG93aW5nXG4gIC8vIGNvbmRpdGlvbnMgYXJlIHRydWU6XG4gIC8vIC0gcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIHNjaGVtZSBpcyBcImh0dHBcIlxuICAvLyAtIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBob3N0IGlzIGEgZG9tYWluXG4gIC8vIC0gTWF0Y2hpbmcgcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIGhvc3QgcGVyIEtub3duIEhTVFMgSG9zdCBEb21haW4gTmFtZVxuICAvLyAgIE1hdGNoaW5nIHJlc3VsdHMgaW4gZWl0aGVyIGEgc3VwZXJkb21haW4gbWF0Y2ggd2l0aCBhbiBhc3NlcnRlZFxuICAvLyAgIGluY2x1ZGVTdWJEb21haW5zIGRpcmVjdGl2ZSBvciBhIGNvbmdydWVudCBtYXRjaCAod2l0aCBvciB3aXRob3V0IGFuXG4gIC8vICAgYXNzZXJ0ZWQgaW5jbHVkZVN1YkRvbWFpbnMgZGlyZWN0aXZlKS4gW0hTVFNdXG4gIC8vIFRPRE9cblxuICAvLyAxMC4gSWYgcmVjdXJzaXZlIGlzIGZhbHNlLCB0aGVuIHJ1biB0aGUgcmVtYWluaW5nIHN0ZXBzIGluIHBhcmFsbGVsLlxuICAvLyBUT0RPXG5cbiAgLy8gMTEuIElmIHJlc3BvbnNlIGlzIG51bGwsIHRoZW4gc2V0IHJlc3BvbnNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuICAvLyB0aGUgc3RlcHMgY29ycmVzcG9uZGluZyB0byB0aGUgZmlyc3QgbWF0Y2hpbmcgc3RhdGVtZW50OlxuICBpZiAocmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICByZXNwb25zZSA9IGF3YWl0IChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50VVJMID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcblxuICAgICAgaWYgKFxuICAgICAgICAvLyAtIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBvcmlnaW4gaXMgc2FtZSBvcmlnaW4gd2l0aCByZXF1ZXN04oCZcyBvcmlnaW4sXG4gICAgICAgIC8vICAgYW5kIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIFwiYmFzaWNcIlxuICAgICAgICAoc2FtZU9yaWdpbihjdXJyZW50VVJMLCByZXF1ZXN0LnVybCkgJiYgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnYmFzaWMnKSB8fFxuICAgICAgICAvLyByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgc2NoZW1lIGlzIFwiZGF0YVwiXG4gICAgICAgIChjdXJyZW50VVJMLnByb3RvY29sID09PSAnZGF0YTonKSB8fFxuICAgICAgICAvLyAtIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJuYXZpZ2F0ZVwiIG9yIFwid2Vic29ja2V0XCJcbiAgICAgICAgKHJlcXVlc3QubW9kZSA9PT0gJ25hdmlnYXRlJyB8fCByZXF1ZXN0Lm1vZGUgPT09ICd3ZWJzb2NrZXQnKVxuICAgICAgKSB7XG4gICAgICAgIC8vIDEuIFNldCByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyB0byBcImJhc2ljXCIuXG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9ICdiYXNpYydcblxuICAgICAgICAvLyAyLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nIHNjaGVtZSBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcy5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHNjaGVtZUZldGNoKGZldGNoUGFyYW1zKVxuICAgICAgfVxuXG4gICAgICAvLyByZXF1ZXN04oCZcyBtb2RlIGlzIFwic2FtZS1vcmlnaW5cIlxuICAgICAgaWYgKHJlcXVlc3QubW9kZSA9PT0gJ3NhbWUtb3JpZ2luJykge1xuICAgICAgICAvLyAxLiBSZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcigncmVxdWVzdCBtb2RlIGNhbm5vdCBiZSBcInNhbWUtb3JpZ2luXCInKVxuICAgICAgfVxuXG4gICAgICAvLyByZXF1ZXN04oCZcyBtb2RlIGlzIFwibm8tY29yc1wiXG4gICAgICBpZiAocmVxdWVzdC5tb2RlID09PSAnbm8tY29ycycpIHtcbiAgICAgICAgLy8gMS4gSWYgcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZSBpcyBub3QgXCJmb2xsb3dcIiwgdGhlbiByZXR1cm4gYSBuZXR3b3JrXG4gICAgICAgIC8vIGVycm9yLlxuICAgICAgICBpZiAocmVxdWVzdC5yZWRpcmVjdCAhPT0gJ2ZvbGxvdycpIHtcbiAgICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcihcbiAgICAgICAgICAgICdyZWRpcmVjdCBtb2RlIGNhbm5vdCBiZSBcImZvbGxvd1wiIGZvciBcIm5vLWNvcnNcIiByZXF1ZXN0J1xuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDIuIFNldCByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyB0byBcIm9wYXF1ZVwiLlxuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPSAnb3BhcXVlJ1xuXG4gICAgICAgIC8vIDMuIFJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgc2NoZW1lIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zLlxuICAgICAgICByZXR1cm4gYXdhaXQgc2NoZW1lRmV0Y2goZmV0Y2hQYXJhbXMpXG4gICAgICB9XG5cbiAgICAgIC8vIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBzY2hlbWUgaXMgbm90IGFuIEhUVFAoUykgc2NoZW1lXG4gICAgICBpZiAoIXVybElzSHR0cEh0dHBzU2NoZW1lKHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpKSkge1xuICAgICAgICAvLyBSZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcignVVJMIHNjaGVtZSBtdXN0IGJlIGEgSFRUUChTKSBzY2hlbWUnKVxuICAgICAgfVxuXG4gICAgICAvLyAtIHJlcXVlc3TigJlzIHVzZS1DT1JTLXByZWZsaWdodCBmbGFnIGlzIHNldFxuICAgICAgLy8gLSByZXF1ZXN04oCZcyB1bnNhZmUtcmVxdWVzdCBmbGFnIGlzIHNldCBhbmQgZWl0aGVyIHJlcXVlc3TigJlzIG1ldGhvZCBpc1xuICAgICAgLy8gICBub3QgYSBDT1JTLXNhZmVsaXN0ZWQgbWV0aG9kIG9yIENPUlMtdW5zYWZlIHJlcXVlc3QtaGVhZGVyIG5hbWVzIHdpdGhcbiAgICAgIC8vICAgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgaXMgbm90IGVtcHR5XG4gICAgICAvLyAgICAxLiBTZXQgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgdG8gXCJjb3JzXCIuXG4gICAgICAvLyAgICAyLiBMZXQgY29yc1dpdGhQcmVmbGlnaHRSZXNwb25zZSBiZSB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUCBmZXRjaFxuICAgICAgLy8gICAgZ2l2ZW4gZmV0Y2hQYXJhbXMgYW5kIHRydWUuXG4gICAgICAvLyAgICAzLiBJZiBjb3JzV2l0aFByZWZsaWdodFJlc3BvbnNlIGlzIGEgbmV0d29yayBlcnJvciwgdGhlbiBjbGVhciBjYWNoZVxuICAgICAgLy8gICAgZW50cmllcyB1c2luZyByZXF1ZXN0LlxuICAgICAgLy8gICAgNC4gUmV0dXJuIGNvcnNXaXRoUHJlZmxpZ2h0UmVzcG9uc2UuXG4gICAgICAvLyBUT0RPXG5cbiAgICAgIC8vIE90aGVyd2lzZVxuICAgICAgLy8gICAgMS4gU2V0IHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIHRvIFwiY29yc1wiLlxuICAgICAgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID0gJ2NvcnMnXG5cbiAgICAgIC8vICAgIDIuIFJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUCBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcy5cbiAgICAgIHJldHVybiBhd2FpdCBodHRwRmV0Y2goZmV0Y2hQYXJhbXMpXG4gICAgfSkoKVxuICB9XG5cbiAgLy8gMTIuIElmIHJlY3Vyc2l2ZSBpcyB0cnVlLCB0aGVuIHJldHVybiByZXNwb25zZS5cbiAgaWYgKHJlY3Vyc2l2ZSkge1xuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgLy8gMTMuIElmIHJlc3BvbnNlIGlzIG5vdCBhIG5ldHdvcmsgZXJyb3IgYW5kIHJlc3BvbnNlIGlzIG5vdCBhIGZpbHRlcmVkXG4gIC8vIHJlc3BvbnNlLCB0aGVuOlxuICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAwICYmICFyZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlKSB7XG4gICAgLy8gSWYgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgaXMgXCJjb3JzXCIsIHRoZW46XG4gICAgaWYgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2NvcnMnKSB7XG4gICAgICAvLyAxLiBMZXQgaGVhZGVyTmFtZXMgYmUgdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nIGhlYWRlciBsaXN0IHZhbHVlc1xuICAgICAgLy8gZ2l2ZW4gYEFjY2Vzcy1Db250cm9sLUV4cG9zZS1IZWFkZXJzYCBhbmQgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAgICAgLy8gVE9ET1xuICAgICAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgY3JlZGVudGlhbHMgbW9kZSBpcyBub3QgXCJpbmNsdWRlXCIgYW5kIGhlYWRlck5hbWVzXG4gICAgICAvLyBjb250YWlucyBgKmAsIHRoZW4gc2V0IHJlc3BvbnNl4oCZcyBDT1JTLWV4cG9zZWQgaGVhZGVyLW5hbWUgbGlzdCB0b1xuICAgICAgLy8gYWxsIHVuaXF1ZSBoZWFkZXIgbmFtZXMgaW4gcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAgICAgLy8gVE9ET1xuICAgICAgLy8gMy4gT3RoZXJ3aXNlLCBpZiBoZWFkZXJOYW1lcyBpcyBub3QgbnVsbCBvciBmYWlsdXJlLCB0aGVuIHNldFxuICAgICAgLy8gcmVzcG9uc2XigJlzIENPUlMtZXhwb3NlZCBoZWFkZXItbmFtZSBsaXN0IHRvIGhlYWRlck5hbWVzLlxuICAgICAgLy8gVE9ET1xuICAgIH1cblxuICAgIC8vIFNldCByZXNwb25zZSB0byB0aGUgZm9sbG93aW5nIGZpbHRlcmVkIHJlc3BvbnNlIHdpdGggcmVzcG9uc2UgYXMgaXRzXG4gICAgLy8gaW50ZXJuYWwgcmVzcG9uc2UsIGRlcGVuZGluZyBvbiByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZzpcbiAgICBpZiAocmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnYmFzaWMnKSB7XG4gICAgICByZXNwb25zZSA9IGZpbHRlclJlc3BvbnNlKHJlc3BvbnNlLCAnYmFzaWMnKVxuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnY29ycycpIHtcbiAgICAgIHJlc3BvbnNlID0gZmlsdGVyUmVzcG9uc2UocmVzcG9uc2UsICdjb3JzJylcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ29wYXF1ZScpIHtcbiAgICAgIHJlc3BvbnNlID0gZmlsdGVyUmVzcG9uc2UocmVzcG9uc2UsICdvcGFxdWUnKVxuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoZmFsc2UpXG4gICAgfVxuICB9XG5cbiAgLy8gMTQuIExldCBpbnRlcm5hbFJlc3BvbnNlIGJlIHJlc3BvbnNlLCBpZiByZXNwb25zZSBpcyBhIG5ldHdvcmsgZXJyb3IsXG4gIC8vIGFuZCByZXNwb25zZeKAmXMgaW50ZXJuYWwgcmVzcG9uc2Ugb3RoZXJ3aXNlLlxuICBsZXQgaW50ZXJuYWxSZXNwb25zZSA9XG4gICAgcmVzcG9uc2Uuc3RhdHVzID09PSAwID8gcmVzcG9uc2UgOiByZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlXG5cbiAgLy8gMTUuIElmIGludGVybmFsUmVzcG9uc2XigJlzIFVSTCBsaXN0IGlzIGVtcHR5LCB0aGVuIHNldCBpdCB0byBhIGNsb25lIG9mXG4gIC8vIHJlcXVlc3TigJlzIFVSTCBsaXN0LlxuICBpZiAoaW50ZXJuYWxSZXNwb25zZS51cmxMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIGludGVybmFsUmVzcG9uc2UudXJsTGlzdC5wdXNoKC4uLnJlcXVlc3QudXJsTGlzdClcbiAgfVxuXG4gIC8vIDE2LiBJZiByZXF1ZXN04oCZcyB0aW1pbmcgYWxsb3cgZmFpbGVkIGZsYWcgaXMgdW5zZXQsIHRoZW4gc2V0XG4gIC8vIGludGVybmFsUmVzcG9uc2XigJlzIHRpbWluZyBhbGxvdyBwYXNzZWQgZmxhZy5cbiAgaWYgKCFyZXF1ZXN0LnRpbWluZ0FsbG93RmFpbGVkKSB7XG4gICAgcmVzcG9uc2UudGltaW5nQWxsb3dQYXNzZWQgPSB0cnVlXG4gIH1cblxuICAvLyAxNy4gSWYgcmVzcG9uc2UgaXMgbm90IGEgbmV0d29yayBlcnJvciBhbmQgYW55IG9mIHRoZSBmb2xsb3dpbmcgcmV0dXJuc1xuICAvLyBibG9ja2VkXG4gIC8vIC0gc2hvdWxkIGludGVybmFsUmVzcG9uc2UgdG8gcmVxdWVzdCBiZSBibG9ja2VkIGFzIG1peGVkIGNvbnRlbnRcbiAgLy8gLSBzaG91bGQgaW50ZXJuYWxSZXNwb25zZSB0byByZXF1ZXN0IGJlIGJsb2NrZWQgYnkgQ29udGVudCBTZWN1cml0eSBQb2xpY3lcbiAgLy8gLSBzaG91bGQgaW50ZXJuYWxSZXNwb25zZSB0byByZXF1ZXN0IGJlIGJsb2NrZWQgZHVlIHRvIGl0cyBNSU1FIHR5cGVcbiAgLy8gLSBzaG91bGQgaW50ZXJuYWxSZXNwb25zZSB0byByZXF1ZXN0IGJlIGJsb2NrZWQgZHVlIHRvIG5vc25pZmZcbiAgLy8gVE9ET1xuXG4gIC8vIDE4LiBJZiByZXNwb25zZeKAmXMgdHlwZSBpcyBcIm9wYXF1ZVwiLCBpbnRlcm5hbFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgMjA2LFxuICAvLyBpbnRlcm5hbFJlc3BvbnNl4oCZcyByYW5nZS1yZXF1ZXN0ZWQgZmxhZyBpcyBzZXQsIGFuZCByZXF1ZXN04oCZcyBoZWFkZXJcbiAgLy8gbGlzdCBkb2VzIG5vdCBjb250YWluIGBSYW5nZWAsIHRoZW4gc2V0IHJlc3BvbnNlIGFuZCBpbnRlcm5hbFJlc3BvbnNlXG4gIC8vIHRvIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKFxuICAgIHJlc3BvbnNlLnR5cGUgPT09ICdvcGFxdWUnICYmXG4gICAgaW50ZXJuYWxSZXNwb25zZS5zdGF0dXMgPT09IDIwNiAmJlxuICAgIGludGVybmFsUmVzcG9uc2UucmFuZ2VSZXF1ZXN0ZWQgJiZcbiAgICAhcmVxdWVzdC5oZWFkZXJzLmNvbnRhaW5zKCdyYW5nZScpXG4gICkge1xuICAgIHJlc3BvbnNlID0gaW50ZXJuYWxSZXNwb25zZSA9IG1ha2VOZXR3b3JrRXJyb3IoKVxuICB9XG5cbiAgLy8gMTkuIElmIHJlc3BvbnNlIGlzIG5vdCBhIG5ldHdvcmsgZXJyb3IgYW5kIGVpdGhlciByZXF1ZXN04oCZcyBtZXRob2QgaXNcbiAgLy8gYEhFQURgIG9yIGBDT05ORUNUYCwgb3IgaW50ZXJuYWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIGEgbnVsbCBib2R5IHN0YXR1cyxcbiAgLy8gc2V0IGludGVybmFsUmVzcG9uc2XigJlzIGJvZHkgdG8gbnVsbCBhbmQgZGlzcmVnYXJkIGFueSBlbnF1ZXVpbmcgdG93YXJkXG4gIC8vIGl0IChpZiBhbnkpLlxuICBpZiAoXG4gICAgcmVzcG9uc2Uuc3RhdHVzICE9PSAwICYmXG4gICAgKHJlcXVlc3QubWV0aG9kID09PSAnSEVBRCcgfHxcbiAgICAgIHJlcXVlc3QubWV0aG9kID09PSAnQ09OTkVDVCcgfHxcbiAgICAgIG51bGxCb2R5U3RhdHVzLmluY2x1ZGVzKGludGVybmFsUmVzcG9uc2Uuc3RhdHVzKSlcbiAgKSB7XG4gICAgaW50ZXJuYWxSZXNwb25zZS5ib2R5ID0gbnVsbFxuICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZHVtcCA9IHRydWVcbiAgfVxuXG4gIC8vIDIwLiBJZiByZXF1ZXN04oCZcyBpbnRlZ3JpdHkgbWV0YWRhdGEgaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIHRoZW46XG4gIGlmIChyZXF1ZXN0LmludGVncml0eSkge1xuICAgIC8vIDEuIExldCBwcm9jZXNzQm9keUVycm9yIGJlIHRoaXMgc3RlcDogcnVuIGZldGNoIGZpbmFsZSBnaXZlbiBmZXRjaFBhcmFtc1xuICAgIC8vIGFuZCBhIG5ldHdvcmsgZXJyb3IuXG4gICAgY29uc3QgcHJvY2Vzc0JvZHlFcnJvciA9IChyZWFzb24pID0+XG4gICAgICBmZXRjaEZpbmFsZShmZXRjaFBhcmFtcywgbWFrZU5ldHdvcmtFcnJvcihyZWFzb24pKVxuXG4gICAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgaXMgXCJvcGFxdWVcIiwgb3IgcmVzcG9uc2XigJlzIGJvZHkgaXMgbnVsbCxcbiAgICAvLyB0aGVuIHJ1biBwcm9jZXNzQm9keUVycm9yIGFuZCBhYm9ydCB0aGVzZSBzdGVwcy5cbiAgICBpZiAocmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnb3BhcXVlJyB8fCByZXNwb25zZS5ib2R5ID09IG51bGwpIHtcbiAgICAgIHByb2Nlc3NCb2R5RXJyb3IocmVzcG9uc2UuZXJyb3IpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyAzLiBMZXQgcHJvY2Vzc0JvZHkgZ2l2ZW4gYnl0ZXMgYmUgdGhlc2Ugc3RlcHM6XG4gICAgY29uc3QgcHJvY2Vzc0JvZHkgPSAoYnl0ZXMpID0+IHtcbiAgICAgIC8vIDEuIElmIGJ5dGVzIGRvIG5vdCBtYXRjaCByZXF1ZXN04oCZcyBpbnRlZ3JpdHkgbWV0YWRhdGEsXG4gICAgICAvLyB0aGVuIHJ1biBwcm9jZXNzQm9keUVycm9yIGFuZCBhYm9ydCB0aGVzZSBzdGVwcy4gW1NSSV1cbiAgICAgIGlmICghYnl0ZXNNYXRjaChieXRlcywgcmVxdWVzdC5pbnRlZ3JpdHkpKSB7XG4gICAgICAgIHByb2Nlc3NCb2R5RXJyb3IoJ2ludGVncml0eSBtaXNtYXRjaCcpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAyLiBTZXQgcmVzcG9uc2XigJlzIGJvZHkgdG8gYnl0ZXMgYXMgYSBib2R5LlxuICAgICAgcmVzcG9uc2UuYm9keSA9IHNhZmVseUV4dHJhY3RCb2R5KGJ5dGVzKVswXVxuXG4gICAgICAvLyAzLiBSdW4gZmV0Y2ggZmluYWxlIGdpdmVuIGZldGNoUGFyYW1zIGFuZCByZXNwb25zZS5cbiAgICAgIGZldGNoRmluYWxlKGZldGNoUGFyYW1zLCByZXNwb25zZSlcbiAgICB9XG5cbiAgICAvLyA0LiBGdWxseSByZWFkIHJlc3BvbnNl4oCZcyBib2R5IGdpdmVuIHByb2Nlc3NCb2R5IGFuZCBwcm9jZXNzQm9keUVycm9yLlxuICAgIGF3YWl0IGZ1bGx5UmVhZEJvZHkocmVzcG9uc2UuYm9keSwgcHJvY2Vzc0JvZHksIHByb2Nlc3NCb2R5RXJyb3IpXG4gIH0gZWxzZSB7XG4gICAgLy8gMjEuIE90aGVyd2lzZSwgcnVuIGZldGNoIGZpbmFsZSBnaXZlbiBmZXRjaFBhcmFtcyBhbmQgcmVzcG9uc2UuXG4gICAgZmV0Y2hGaW5hbGUoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXNjaGVtZS1mZXRjaFxuLy8gZ2l2ZW4gYSBmZXRjaCBwYXJhbXMgZmV0Y2hQYXJhbXNcbmZ1bmN0aW9uIHNjaGVtZUZldGNoIChmZXRjaFBhcmFtcykge1xuICAvLyBOb3RlOiBzaW5jZSB0aGUgY29ubmVjdGlvbiBpcyBkZXN0cm95ZWQgb24gcmVkaXJlY3QsIHdoaWNoIHNldHMgZmV0Y2hQYXJhbXMgdG8gYVxuICAvLyBjYW5jZWxsZWQgc3RhdGUsIHdlIGRvIG5vdCB3YW50IHRoaXMgY29uZGl0aW9uIHRvIHRyaWdnZXIgKnVubGVzcyogdGhlcmUgaGF2ZSBiZWVuXG4gIC8vIG5vIHJlZGlyZWN0cy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xNzc2XG4gIC8vIDEuIElmIGZldGNoUGFyYW1zIGlzIGNhbmNlbGVkLCB0aGVuIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgbmV0d29yayBlcnJvciBmb3IgZmV0Y2hQYXJhbXMuXG4gIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykgJiYgZmV0Y2hQYXJhbXMucmVxdWVzdC5yZWRpcmVjdENvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IoZmV0Y2hQYXJhbXMpKVxuICB9XG5cbiAgLy8gMi4gTGV0IHJlcXVlc3QgYmUgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3QuXG4gIGNvbnN0IHsgcmVxdWVzdCB9ID0gZmV0Y2hQYXJhbXNcblxuICBjb25zdCB7IHByb3RvY29sOiBzY2hlbWUgfSA9IHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpXG5cbiAgLy8gMy4gU3dpdGNoIG9uIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBzY2hlbWUgYW5kIHJ1biB0aGUgYXNzb2NpYXRlZCBzdGVwczpcbiAgc3dpdGNoIChzY2hlbWUpIHtcbiAgICBjYXNlICdhYm91dDonOiB7XG4gICAgICAvLyBJZiByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgcGF0aCBpcyB0aGUgc3RyaW5nIFwiYmxhbmtcIiwgdGhlbiByZXR1cm4gYSBuZXcgcmVzcG9uc2VcbiAgICAgIC8vIHdob3NlIHN0YXR1cyBtZXNzYWdlIGlzIGBPS2AsIGhlYWRlciBsaXN0IGlzIMKrIChgQ29udGVudC1UeXBlYCwgYHRleHQvaHRtbDtjaGFyc2V0PXV0Zi04YCkgwrssXG4gICAgICAvLyBhbmQgYm9keSBpcyB0aGUgZW1wdHkgYnl0ZSBzZXF1ZW5jZSBhcyBhIGJvZHkuXG5cbiAgICAgIC8vIE90aGVyd2lzZSwgcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcignYWJvdXQgc2NoZW1lIGlzIG5vdCBzdXBwb3J0ZWQnKSlcbiAgICB9XG4gICAgY2FzZSAnYmxvYjonOiB7XG4gICAgICBpZiAoIXJlc29sdmVPYmplY3RVUkwpIHtcbiAgICAgICAgcmVzb2x2ZU9iamVjdFVSTCA9IHJlcXVpcmUoJ2J1ZmZlcicpLnJlc29sdmVPYmplY3RVUkxcbiAgICAgIH1cblxuICAgICAgLy8gMS4gTGV0IGJsb2JVUkxFbnRyeSBiZSByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgYmxvYiBVUkwgZW50cnkuXG4gICAgICBjb25zdCBibG9iVVJMRW50cnkgPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2ViLXBsYXRmb3JtLXRlc3RzL3dwdC9ibG9iLzdiMGViYWNjYzYyYjU2NmExOTY1Mzk2ZTViZTdiYjJiYzA2Zjg0MWYvRmlsZUFQSS91cmwvcmVzb3VyY2VzL2ZldGNoLXRlc3RzLmpzI0w1Mi1MNTZcbiAgICAgIC8vIEJ1ZmZlci5yZXNvbHZlT2JqZWN0VVJMIGRvZXMgbm90IGlnbm9yZSBVUkwgcXVlcmllcy5cbiAgICAgIGlmIChibG9iVVJMRW50cnkuc2VhcmNoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ05ldHdvcmtFcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gZmV0Y2ggcmVzb3VyY2UuJykpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJsb2JVUkxFbnRyeU9iamVjdCA9IHJlc29sdmVPYmplY3RVUkwoYmxvYlVSTEVudHJ5LnRvU3RyaW5nKCkpXG5cbiAgICAgIC8vIDIuIElmIHJlcXVlc3TigJlzIG1ldGhvZCBpcyBub3QgYEdFVGAsIGJsb2JVUkxFbnRyeSBpcyBudWxsLCBvciBibG9iVVJMRW50cnnigJlzXG4gICAgICAvLyAgICBvYmplY3QgaXMgbm90IGEgQmxvYiBvYmplY3QsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gJ0dFVCcgfHwgIWlzQmxvYkxpa2UoYmxvYlVSTEVudHJ5T2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ2ludmFsaWQgbWV0aG9kJykpXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIExldCBib2R5V2l0aFR5cGUgYmUgdGhlIHJlc3VsdCBvZiBzYWZlbHkgZXh0cmFjdGluZyBibG9iVVJMRW50cnnigJlzIG9iamVjdC5cbiAgICAgIGNvbnN0IGJvZHlXaXRoVHlwZSA9IHNhZmVseUV4dHJhY3RCb2R5KGJsb2JVUkxFbnRyeU9iamVjdClcblxuICAgICAgLy8gNC4gTGV0IGJvZHkgYmUgYm9keVdpdGhUeXBl4oCZcyBib2R5LlxuICAgICAgY29uc3QgYm9keSA9IGJvZHlXaXRoVHlwZVswXVxuXG4gICAgICAvLyA1LiBMZXQgbGVuZ3RoIGJlIGJvZHnigJlzIGxlbmd0aCwgc2VyaWFsaXplZCBhbmQgaXNvbW9ycGhpYyBlbmNvZGVkLlxuICAgICAgY29uc3QgbGVuZ3RoID0gaXNvbW9ycGhpY0VuY29kZShgJHtib2R5Lmxlbmd0aH1gKVxuXG4gICAgICAvLyA2LiBMZXQgdHlwZSBiZSBib2R5V2l0aFR5cGXigJlzIHR5cGUgaWYgaXQgaXMgbm9uLW51bGw7IG90aGVyd2lzZSB0aGUgZW1wdHkgYnl0ZSBzZXF1ZW5jZS5cbiAgICAgIGNvbnN0IHR5cGUgPSBib2R5V2l0aFR5cGVbMV0gPz8gJydcblxuICAgICAgLy8gNy4gUmV0dXJuIGEgbmV3IHJlc3BvbnNlIHdob3NlIHN0YXR1cyBtZXNzYWdlIGlzIGBPS2AsIGhlYWRlciBsaXN0IGlzXG4gICAgICAvLyAgICDCqyAoYENvbnRlbnQtTGVuZ3RoYCwgbGVuZ3RoKSwgKGBDb250ZW50LVR5cGVgLCB0eXBlKSDCuywgYW5kIGJvZHkgaXMgYm9keS5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gbWFrZVJlc3BvbnNlKHtcbiAgICAgICAgc3RhdHVzVGV4dDogJ09LJyxcbiAgICAgICAgaGVhZGVyc0xpc3Q6IFtcbiAgICAgICAgICBbJ2NvbnRlbnQtbGVuZ3RoJywgeyBuYW1lOiAnQ29udGVudC1MZW5ndGgnLCB2YWx1ZTogbGVuZ3RoIH1dLFxuICAgICAgICAgIFsnY29udGVudC10eXBlJywgeyBuYW1lOiAnQ29udGVudC1UeXBlJywgdmFsdWU6IHR5cGUgfV1cbiAgICAgICAgXVxuICAgICAgfSlcblxuICAgICAgcmVzcG9uc2UuYm9keSA9IGJvZHlcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSlcbiAgICB9XG4gICAgY2FzZSAnZGF0YTonOiB7XG4gICAgICAvLyAxLiBMZXQgZGF0YVVSTFN0cnVjdCBiZSB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgdGhlXG4gICAgICAvLyAgICBkYXRhOiBVUkwgcHJvY2Vzc29yIG9uIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJMLlxuICAgICAgY29uc3QgY3VycmVudFVSTCA9IHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpXG4gICAgICBjb25zdCBkYXRhVVJMU3RydWN0ID0gZGF0YVVSTFByb2Nlc3NvcihjdXJyZW50VVJMKVxuXG4gICAgICAvLyAyLiBJZiBkYXRhVVJMU3RydWN0IGlzIGZhaWx1cmUsIHRoZW4gcmV0dXJuIGFcbiAgICAgIC8vICAgIG5ldHdvcmsgZXJyb3IuXG4gICAgICBpZiAoZGF0YVVSTFN0cnVjdCA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcignZmFpbGVkIHRvIGZldGNoIHRoZSBkYXRhIFVSTCcpKVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBMZXQgbWltZVR5cGUgYmUgZGF0YVVSTFN0cnVjdOKAmXMgTUlNRSB0eXBlLCBzZXJpYWxpemVkLlxuICAgICAgY29uc3QgbWltZVR5cGUgPSBzZXJpYWxpemVBTWltZVR5cGUoZGF0YVVSTFN0cnVjdC5taW1lVHlwZSlcblxuICAgICAgLy8gNC4gUmV0dXJuIGEgcmVzcG9uc2Ugd2hvc2Ugc3RhdHVzIG1lc3NhZ2UgaXMgYE9LYCxcbiAgICAgIC8vICAgIGhlYWRlciBsaXN0IGlzIMKrIChgQ29udGVudC1UeXBlYCwgbWltZVR5cGUpIMK7LFxuICAgICAgLy8gICAgYW5kIGJvZHkgaXMgZGF0YVVSTFN0cnVjdOKAmXMgYm9keSBhcyBhIGJvZHkuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VSZXNwb25zZSh7XG4gICAgICAgIHN0YXR1c1RleHQ6ICdPSycsXG4gICAgICAgIGhlYWRlcnNMaXN0OiBbXG4gICAgICAgICAgWydjb250ZW50LXR5cGUnLCB7IG5hbWU6ICdDb250ZW50LVR5cGUnLCB2YWx1ZTogbWltZVR5cGUgfV1cbiAgICAgICAgXSxcbiAgICAgICAgYm9keTogc2FmZWx5RXh0cmFjdEJvZHkoZGF0YVVSTFN0cnVjdC5ib2R5KVswXVxuICAgICAgfSkpXG4gICAgfVxuICAgIGNhc2UgJ2ZpbGU6Jzoge1xuICAgICAgLy8gRm9yIG5vdywgdW5mb3J0dW5hdGUgYXMgaXQgaXMsIGZpbGUgVVJMcyBhcmUgbGVmdCBhcyBhbiBleGVyY2lzZSBmb3IgdGhlIHJlYWRlci5cbiAgICAgIC8vIFdoZW4gaW4gZG91YnQsIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ25vdCBpbXBsZW1lbnRlZC4uLiB5ZXQuLi4nKSlcbiAgICB9XG4gICAgY2FzZSAnaHR0cDonOlxuICAgIGNhc2UgJ2h0dHBzOic6IHtcbiAgICAgIC8vIFJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUCBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcy5cblxuICAgICAgcmV0dXJuIGh0dHBGZXRjaChmZXRjaFBhcmFtcylcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IG1ha2VOZXR3b3JrRXJyb3IoZXJyKSlcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCd1bmtub3duIHNjaGVtZScpKVxuICAgIH1cbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZmluYWxpemUtcmVzcG9uc2VcbmZ1bmN0aW9uIGZpbmFsaXplUmVzcG9uc2UgKGZldGNoUGFyYW1zLCByZXNwb25zZSkge1xuICAvLyAxLiBTZXQgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIGRvbmUgZmxhZy5cbiAgZmV0Y2hQYXJhbXMucmVxdWVzdC5kb25lID0gdHJ1ZVxuXG4gIC8vIDIsIElmIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlc3BvbnNlIGRvbmUgaXMgbm90IG51bGwsIHRoZW4gcXVldWUgYSBmZXRjaFxuICAvLyB0YXNrIHRvIHJ1biBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXNwb25zZSBkb25lIGdpdmVuIHJlc3BvbnNlLCB3aXRoXG4gIC8vIGZldGNoUGFyYW1z4oCZcyB0YXNrIGRlc3RpbmF0aW9uLlxuICBpZiAoZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlRG9uZSAhPSBudWxsKSB7XG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlRG9uZShyZXNwb25zZSkpXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2ZldGNoLWZpbmFsZVxuZnVuY3Rpb24gZmV0Y2hGaW5hbGUgKGZldGNoUGFyYW1zLCByZXNwb25zZSkge1xuICAvLyAxLiBJZiByZXNwb25zZSBpcyBhIG5ldHdvcmsgZXJyb3IsIHRoZW46XG4gIGlmIChyZXNwb25zZS50eXBlID09PSAnZXJyb3InKSB7XG4gICAgLy8gMS4gU2V0IHJlc3BvbnNl4oCZcyBVUkwgbGlzdCB0byDCqyBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgVVJMIGxpc3RbMF0gwrsuXG4gICAgcmVzcG9uc2UudXJsTGlzdCA9IFtmZXRjaFBhcmFtcy5yZXF1ZXN0LnVybExpc3RbMF1dXG5cbiAgICAvLyAyLiBTZXQgcmVzcG9uc2XigJlzIHRpbWluZyBpbmZvIHRvIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYW4gb3BhcXVlIHRpbWluZ1xuICAgIC8vIGluZm8gZm9yIGZldGNoUGFyYW1z4oCZcyB0aW1pbmcgaW5mby5cbiAgICByZXNwb25zZS50aW1pbmdJbmZvID0gY3JlYXRlT3BhcXVlVGltaW5nSW5mbyh7XG4gICAgICBzdGFydFRpbWU6IGZldGNoUGFyYW1zLnRpbWluZ0luZm8uc3RhcnRUaW1lXG4gICAgfSlcbiAgfVxuXG4gIC8vIDIuIExldCBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgYmUgdGhlIGZvbGxvd2luZyBzdGVwczpcbiAgY29uc3QgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5ID0gKCkgPT4ge1xuICAgIC8vIDEuIFNldCBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgZG9uZSBmbGFnLlxuICAgIGZldGNoUGFyYW1zLnJlcXVlc3QuZG9uZSA9IHRydWVcblxuICAgIC8vIElmIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlc3BvbnNlIGVuZC1vZi1ib2R5IGlzIG5vdCBudWxsLFxuICAgIC8vIHRoZW4gcXVldWUgYSBmZXRjaCB0YXNrIHRvIHJ1biBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXNwb25zZVxuICAgIC8vIGVuZC1vZi1ib2R5IGdpdmVuIHJlc3BvbnNlIHdpdGggZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb24uXG4gICAgaWYgKGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSAhPSBudWxsKSB7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkocmVzcG9uc2UpKVxuICAgIH1cbiAgfVxuXG4gIC8vIDMuIElmIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlc3BvbnNlIGlzIG5vbi1udWxsLCB0aGVuIHF1ZXVlIGEgZmV0Y2ggdGFza1xuICAvLyB0byBydW4gZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVzcG9uc2UgZ2l2ZW4gcmVzcG9uc2UsIHdpdGggZmV0Y2hQYXJhbXPigJlzXG4gIC8vIHRhc2sgZGVzdGluYXRpb24uXG4gIGlmIChmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZShyZXNwb25zZSkpXG4gIH1cblxuICAvLyA0LiBJZiByZXNwb25zZeKAmXMgYm9keSBpcyBudWxsLCB0aGVuIHJ1biBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkuXG4gIGlmIChyZXNwb25zZS5ib2R5ID09IG51bGwpIHtcbiAgICBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkoKVxuICB9IGVsc2Uge1xuICAvLyA1LiBPdGhlcndpc2U6XG5cbiAgICAvLyAxLiBMZXQgdHJhbnNmb3JtU3RyZWFtIGJlIGEgbmV3IGEgVHJhbnNmb3JtU3RyZWFtLlxuXG4gICAgLy8gMi4gTGV0IGlkZW50aXR5VHJhbnNmb3JtQWxnb3JpdGhtIGJlIGFuIGFsZ29yaXRobSB3aGljaCwgZ2l2ZW4gY2h1bmssXG4gICAgLy8gZW5xdWV1ZXMgY2h1bmsgaW4gdHJhbnNmb3JtU3RyZWFtLlxuICAgIGNvbnN0IGlkZW50aXR5VHJhbnNmb3JtQWxnb3JpdGhtID0gKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspXG4gICAgfVxuXG4gICAgLy8gMy4gU2V0IHVwIHRyYW5zZm9ybVN0cmVhbSB3aXRoIHRyYW5zZm9ybUFsZ29yaXRobSBzZXQgdG8gaWRlbnRpdHlUcmFuc2Zvcm1BbGdvcml0aG1cbiAgICAvLyBhbmQgZmx1c2hBbGdvcml0aG0gc2V0IHRvIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keS5cbiAgICBjb25zdCB0cmFuc2Zvcm1TdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHN0YXJ0ICgpIHt9LFxuICAgICAgdHJhbnNmb3JtOiBpZGVudGl0eVRyYW5zZm9ybUFsZ29yaXRobSxcbiAgICAgIGZsdXNoOiBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHlcbiAgICB9LCB7XG4gICAgICBzaXplICgpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBzaXplICgpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gNC4gU2V0IHJlc3BvbnNl4oCZcyBib2R5IHRvIHRoZSByZXN1bHQgb2YgcGlwaW5nIHJlc3BvbnNl4oCZcyBib2R5IHRocm91Z2ggdHJhbnNmb3JtU3RyZWFtLlxuICAgIHJlc3BvbnNlLmJvZHkgPSB7IHN0cmVhbTogcmVzcG9uc2UuYm9keS5zdHJlYW0ucGlwZVRocm91Z2godHJhbnNmb3JtU3RyZWFtKSB9XG4gIH1cblxuICAvLyA2LiBJZiBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXNwb25zZSBjb25zdW1lIGJvZHkgaXMgbm9uLW51bGwsIHRoZW46XG4gIGlmIChmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VDb25zdW1lQm9keSAhPSBudWxsKSB7XG4gICAgLy8gMS4gTGV0IHByb2Nlc3NCb2R5IGdpdmVuIG51bGxPckJ5dGVzIGJlIHRoaXMgc3RlcDogcnVuIGZldGNoUGFyYW1z4oCZc1xuICAgIC8vIHByb2Nlc3MgcmVzcG9uc2UgY29uc3VtZSBib2R5IGdpdmVuIHJlc3BvbnNlIGFuZCBudWxsT3JCeXRlcy5cbiAgICBjb25zdCBwcm9jZXNzQm9keSA9IChudWxsT3JCeXRlcykgPT4gZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHkocmVzcG9uc2UsIG51bGxPckJ5dGVzKVxuXG4gICAgLy8gMi4gTGV0IHByb2Nlc3NCb2R5RXJyb3IgYmUgdGhpcyBzdGVwOiBydW4gZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3NcbiAgICAvLyByZXNwb25zZSBjb25zdW1lIGJvZHkgZ2l2ZW4gcmVzcG9uc2UgYW5kIGZhaWx1cmUuXG4gICAgY29uc3QgcHJvY2Vzc0JvZHlFcnJvciA9IChmYWlsdXJlKSA9PiBmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VDb25zdW1lQm9keShyZXNwb25zZSwgZmFpbHVyZSlcblxuICAgIC8vIDMuIElmIHJlc3BvbnNl4oCZcyBib2R5IGlzIG51bGwsIHRoZW4gcXVldWUgYSBmZXRjaCB0YXNrIHRvIHJ1biBwcm9jZXNzQm9keVxuICAgIC8vIGdpdmVuIG51bGwsIHdpdGggZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb24uXG4gICAgaWYgKHJlc3BvbnNlLmJvZHkgPT0gbnVsbCkge1xuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gcHJvY2Vzc0JvZHkobnVsbCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDQuIE90aGVyd2lzZSwgZnVsbHkgcmVhZCByZXNwb25zZeKAmXMgYm9keSBnaXZlbiBwcm9jZXNzQm9keSwgcHJvY2Vzc0JvZHlFcnJvcixcbiAgICAgIC8vIGFuZCBmZXRjaFBhcmFtc+KAmXMgdGFzayBkZXN0aW5hdGlvbi5cbiAgICAgIHJldHVybiBmdWxseVJlYWRCb2R5KHJlc3BvbnNlLmJvZHksIHByb2Nlc3NCb2R5LCBwcm9jZXNzQm9keUVycm9yKVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC1mZXRjaFxuYXN5bmMgZnVuY3Rpb24gaHR0cEZldGNoIChmZXRjaFBhcmFtcykge1xuICAvLyAxLiBMZXQgcmVxdWVzdCBiZSBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdC5cbiAgY29uc3QgcmVxdWVzdCA9IGZldGNoUGFyYW1zLnJlcXVlc3RcblxuICAvLyAyLiBMZXQgcmVzcG9uc2UgYmUgbnVsbC5cbiAgbGV0IHJlc3BvbnNlID0gbnVsbFxuXG4gIC8vIDMuIExldCBhY3R1YWxSZXNwb25zZSBiZSBudWxsLlxuICBsZXQgYWN0dWFsUmVzcG9uc2UgPSBudWxsXG5cbiAgLy8gNC4gTGV0IHRpbWluZ0luZm8gYmUgZmV0Y2hQYXJhbXPigJlzIHRpbWluZyBpbmZvLlxuICBjb25zdCB0aW1pbmdJbmZvID0gZmV0Y2hQYXJhbXMudGltaW5nSW5mb1xuXG4gIC8vIDUuIElmIHJlcXVlc3TigJlzIHNlcnZpY2Utd29ya2VycyBtb2RlIGlzIFwiYWxsXCIsIHRoZW46XG4gIGlmIChyZXF1ZXN0LnNlcnZpY2VXb3JrZXJzID09PSAnYWxsJykge1xuICAgIC8vIFRPRE9cbiAgfVxuXG4gIC8vIDYuIElmIHJlc3BvbnNlIGlzIG51bGwsIHRoZW46XG4gIGlmIChyZXNwb25zZSA9PT0gbnVsbCkge1xuICAgIC8vIDEuIElmIG1ha2VDT1JTUHJlZmxpZ2h0IGlzIHRydWUgYW5kIG9uZSBvZiB0aGVzZSBjb25kaXRpb25zIGlzIHRydWU6XG4gICAgLy8gVE9ET1xuXG4gICAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZSBpcyBcImZvbGxvd1wiLCB0aGVuIHNldCByZXF1ZXN04oCZc1xuICAgIC8vIHNlcnZpY2Utd29ya2VycyBtb2RlIHRvIFwibm9uZVwiLlxuICAgIGlmIChyZXF1ZXN0LnJlZGlyZWN0ID09PSAnZm9sbG93Jykge1xuICAgICAgcmVxdWVzdC5zZXJ2aWNlV29ya2VycyA9ICdub25lJ1xuICAgIH1cblxuICAgIC8vIDMuIFNldCByZXNwb25zZSBhbmQgYWN0dWFsUmVzcG9uc2UgdG8gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgLy8gSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zLlxuICAgIGFjdHVhbFJlc3BvbnNlID0gcmVzcG9uc2UgPSBhd2FpdCBodHRwTmV0d29ya09yQ2FjaGVGZXRjaChmZXRjaFBhcmFtcylcblxuICAgIC8vIDQuIElmIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIFwiY29yc1wiIGFuZCBhIENPUlMgY2hlY2tcbiAgICAvLyBmb3IgcmVxdWVzdCBhbmQgcmVzcG9uc2UgcmV0dXJucyBmYWlsdXJlLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgaWYgKFxuICAgICAgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnY29ycycgJiZcbiAgICAgIGNvcnNDaGVjayhyZXF1ZXN0LCByZXNwb25zZSkgPT09ICdmYWlsdXJlJ1xuICAgICkge1xuICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoJ2NvcnMgZmFpbHVyZScpXG4gICAgfVxuXG4gICAgLy8gNS4gSWYgdGhlIFRBTyBjaGVjayBmb3IgcmVxdWVzdCBhbmQgcmVzcG9uc2UgcmV0dXJucyBmYWlsdXJlLCB0aGVuIHNldFxuICAgIC8vIHJlcXVlc3TigJlzIHRpbWluZyBhbGxvdyBmYWlsZWQgZmxhZy5cbiAgICBpZiAoVEFPQ2hlY2socmVxdWVzdCwgcmVzcG9uc2UpID09PSAnZmFpbHVyZScpIHtcbiAgICAgIHJlcXVlc3QudGltaW5nQWxsb3dGYWlsZWQgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgLy8gNy4gSWYgZWl0aGVyIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIG9yIHJlc3BvbnNl4oCZcyB0eXBlXG4gIC8vIGlzIFwib3BhcXVlXCIsIGFuZCB0aGUgY3Jvc3Mtb3JpZ2luIHJlc291cmNlIHBvbGljeSBjaGVjayB3aXRoXG4gIC8vIHJlcXVlc3TigJlzIG9yaWdpbiwgcmVxdWVzdOKAmXMgY2xpZW50LCByZXF1ZXN04oCZcyBkZXN0aW5hdGlvbixcbiAgLy8gYW5kIGFjdHVhbFJlc3BvbnNlIHJldHVybnMgYmxvY2tlZCwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICBpZiAoXG4gICAgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ29wYXF1ZScgfHwgcmVzcG9uc2UudHlwZSA9PT0gJ29wYXF1ZScpICYmXG4gICAgY3Jvc3NPcmlnaW5SZXNvdXJjZVBvbGljeUNoZWNrKFxuICAgICAgcmVxdWVzdC5vcmlnaW4sXG4gICAgICByZXF1ZXN0LmNsaWVudCxcbiAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24sXG4gICAgICBhY3R1YWxSZXNwb25zZVxuICAgICkgPT09ICdibG9ja2VkJ1xuICApIHtcbiAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcignYmxvY2tlZCcpXG4gIH1cblxuICAvLyA4LiBJZiBhY3R1YWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIGEgcmVkaXJlY3Qgc3RhdHVzLCB0aGVuOlxuICBpZiAocmVkaXJlY3RTdGF0dXNTZXQuaGFzKGFjdHVhbFJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAvLyAxLiBJZiBhY3R1YWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIG5vdCAzMDMsIHJlcXVlc3TigJlzIGJvZHkgaXMgbm90IG51bGwsXG4gICAgLy8gYW5kIHRoZSBjb25uZWN0aW9uIHVzZXMgSFRUUC8yLCB0aGVuIHVzZXIgYWdlbnRzIG1heSwgYW5kIGFyZSBldmVuXG4gICAgLy8gZW5jb3VyYWdlZCB0bywgdHJhbnNtaXQgYW4gUlNUX1NUUkVBTSBmcmFtZS5cbiAgICAvLyBTZWUsIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvZmV0Y2gvaXNzdWVzLzEyODhcbiAgICBpZiAocmVxdWVzdC5yZWRpcmVjdCAhPT0gJ21hbnVhbCcpIHtcbiAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95KClcbiAgICB9XG5cbiAgICAvLyAyLiBTd2l0Y2ggb24gcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZTpcbiAgICBpZiAocmVxdWVzdC5yZWRpcmVjdCA9PT0gJ2Vycm9yJykge1xuICAgICAgLy8gU2V0IHJlc3BvbnNlIHRvIGEgbmV0d29yayBlcnJvci5cbiAgICAgIHJlc3BvbnNlID0gbWFrZU5ldHdvcmtFcnJvcigndW5leHBlY3RlZCByZWRpcmVjdCcpXG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LnJlZGlyZWN0ID09PSAnbWFudWFsJykge1xuICAgICAgLy8gU2V0IHJlc3BvbnNlIHRvIGFuIG9wYXF1ZS1yZWRpcmVjdCBmaWx0ZXJlZCByZXNwb25zZSB3aG9zZSBpbnRlcm5hbFxuICAgICAgLy8gcmVzcG9uc2UgaXMgYWN0dWFsUmVzcG9uc2UuXG4gICAgICAvLyBOT1RFKHNwZWMpOiBPbiB0aGUgd2ViIHRoaXMgd291bGQgcmV0dXJuIGFuIGBvcGFxdWVyZWRpcmVjdGAgcmVzcG9uc2UsXG4gICAgICAvLyBidXQgdGhhdCBkb2Vzbid0IG1ha2Ugc2Vuc2Ugc2VydmVyIHNpZGUuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzExOTMuXG4gICAgICByZXNwb25zZSA9IGFjdHVhbFJlc3BvbnNlXG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LnJlZGlyZWN0ID09PSAnZm9sbG93Jykge1xuICAgICAgLy8gU2V0IHJlc3BvbnNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZyBIVFRQLXJlZGlyZWN0IGZldGNoIGdpdmVuXG4gICAgICAvLyBmZXRjaFBhcmFtcyBhbmQgcmVzcG9uc2UuXG4gICAgICByZXNwb25zZSA9IGF3YWl0IGh0dHBSZWRpcmVjdEZldGNoKGZldGNoUGFyYW1zLCByZXNwb25zZSlcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIC8vIDkuIFNldCByZXNwb25zZeKAmXMgdGltaW5nIGluZm8gdG8gdGltaW5nSW5mby5cbiAgcmVzcG9uc2UudGltaW5nSW5mbyA9IHRpbWluZ0luZm9cblxuICAvLyAxMC4gUmV0dXJuIHJlc3BvbnNlLlxuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtcmVkaXJlY3QtZmV0Y2hcbmZ1bmN0aW9uIGh0dHBSZWRpcmVjdEZldGNoIChmZXRjaFBhcmFtcywgcmVzcG9uc2UpIHtcbiAgLy8gMS4gTGV0IHJlcXVlc3QgYmUgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3QuXG4gIGNvbnN0IHJlcXVlc3QgPSBmZXRjaFBhcmFtcy5yZXF1ZXN0XG5cbiAgLy8gMi4gTGV0IGFjdHVhbFJlc3BvbnNlIGJlIHJlc3BvbnNlLCBpZiByZXNwb25zZSBpcyBub3QgYSBmaWx0ZXJlZCByZXNwb25zZSxcbiAgLy8gYW5kIHJlc3BvbnNl4oCZcyBpbnRlcm5hbCByZXNwb25zZSBvdGhlcndpc2UuXG4gIGNvbnN0IGFjdHVhbFJlc3BvbnNlID0gcmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZVxuICAgID8gcmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZVxuICAgIDogcmVzcG9uc2VcblxuICAvLyAzLiBMZXQgbG9jYXRpb25VUkwgYmUgYWN0dWFsUmVzcG9uc2XigJlzIGxvY2F0aW9uIFVSTCBnaXZlbiByZXF1ZXN04oCZcyBjdXJyZW50XG4gIC8vIFVSTOKAmXMgZnJhZ21lbnQuXG4gIGxldCBsb2NhdGlvblVSTFxuXG4gIHRyeSB7XG4gICAgbG9jYXRpb25VUkwgPSByZXNwb25zZUxvY2F0aW9uVVJMKFxuICAgICAgYWN0dWFsUmVzcG9uc2UsXG4gICAgICByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KS5oYXNoXG4gICAgKVxuXG4gICAgLy8gNC4gSWYgbG9jYXRpb25VUkwgaXMgbnVsbCwgdGhlbiByZXR1cm4gcmVzcG9uc2UuXG4gICAgaWYgKGxvY2F0aW9uVVJMID09IG51bGwpIHtcbiAgICAgIHJldHVybiByZXNwb25zZVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gNS4gSWYgbG9jYXRpb25VUkwgaXMgZmFpbHVyZSwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcihlcnIpKVxuICB9XG5cbiAgLy8gNi4gSWYgbG9jYXRpb25VUkzigJlzIHNjaGVtZSBpcyBub3QgYW4gSFRUUChTKSBzY2hlbWUsIHRoZW4gcmV0dXJuIGEgbmV0d29ya1xuICAvLyBlcnJvci5cbiAgaWYgKCF1cmxJc0h0dHBIdHRwc1NjaGVtZShsb2NhdGlvblVSTCkpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ1VSTCBzY2hlbWUgbXVzdCBiZSBhIEhUVFAoUykgc2NoZW1lJykpXG4gIH1cblxuICAvLyA3LiBJZiByZXF1ZXN04oCZcyByZWRpcmVjdCBjb3VudCBpcyAyMCwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICBpZiAocmVxdWVzdC5yZWRpcmVjdENvdW50ID09PSAyMCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcigncmVkaXJlY3QgY291bnQgZXhjZWVkZWQnKSlcbiAgfVxuXG4gIC8vIDguIEluY3JlYXNlIHJlcXVlc3TigJlzIHJlZGlyZWN0IGNvdW50IGJ5IDEuXG4gIHJlcXVlc3QucmVkaXJlY3RDb3VudCArPSAxXG5cbiAgLy8gOS4gSWYgcmVxdWVzdOKAmXMgbW9kZSBpcyBcImNvcnNcIiwgbG9jYXRpb25VUkwgaW5jbHVkZXMgY3JlZGVudGlhbHMsIGFuZFxuICAvLyByZXF1ZXN04oCZcyBvcmlnaW4gaXMgbm90IHNhbWUgb3JpZ2luIHdpdGggbG9jYXRpb25VUkzigJlzIG9yaWdpbiwgdGhlbiByZXR1cm5cbiAgLy8gIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKFxuICAgIHJlcXVlc3QubW9kZSA9PT0gJ2NvcnMnICYmXG4gICAgKGxvY2F0aW9uVVJMLnVzZXJuYW1lIHx8IGxvY2F0aW9uVVJMLnBhc3N3b3JkKSAmJlxuICAgICFzYW1lT3JpZ2luKHJlcXVlc3QsIGxvY2F0aW9uVVJMKVxuICApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ2Nyb3NzIG9yaWdpbiBub3QgYWxsb3dlZCBmb3IgcmVxdWVzdCBtb2RlIFwiY29yc1wiJykpXG4gIH1cblxuICAvLyAxMC4gSWYgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgaXMgXCJjb3JzXCIgYW5kIGxvY2F0aW9uVVJMIGluY2x1ZGVzXG4gIC8vIGNyZWRlbnRpYWxzLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChcbiAgICByZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdjb3JzJyAmJlxuICAgIChsb2NhdGlvblVSTC51c2VybmFtZSB8fCBsb2NhdGlvblVSTC5wYXNzd29yZClcbiAgKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKFxuICAgICAgJ1VSTCBjYW5ub3QgY29udGFpbiBjcmVkZW50aWFscyBmb3IgcmVxdWVzdCBtb2RlIFwiY29yc1wiJ1xuICAgICkpXG4gIH1cblxuICAvLyAxMS4gSWYgYWN0dWFsUmVzcG9uc2XigJlzIHN0YXR1cyBpcyBub3QgMzAzLCByZXF1ZXN04oCZcyBib2R5IGlzIG5vbi1udWxsLFxuICAvLyBhbmQgcmVxdWVzdOKAmXMgYm9keeKAmXMgc291cmNlIGlzIG51bGwsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKFxuICAgIGFjdHVhbFJlc3BvbnNlLnN0YXR1cyAhPT0gMzAzICYmXG4gICAgcmVxdWVzdC5ib2R5ICE9IG51bGwgJiZcbiAgICByZXF1ZXN0LmJvZHkuc291cmNlID09IG51bGxcbiAgKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCkpXG4gIH1cblxuICAvLyAxMi4gSWYgb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZVxuICAvLyAtIGFjdHVhbFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgMzAxIG9yIDMwMiBhbmQgcmVxdWVzdOKAmXMgbWV0aG9kIGlzIGBQT1NUYFxuICAvLyAtIGFjdHVhbFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgMzAzIGFuZCByZXF1ZXN04oCZcyBtZXRob2QgaXMgbm90IGBHRVRgIG9yIGBIRUFEYFxuICBpZiAoXG4gICAgKFszMDEsIDMwMl0uaW5jbHVkZXMoYWN0dWFsUmVzcG9uc2Uuc3RhdHVzKSAmJiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ1BPU1QnKSB8fFxuICAgIChhY3R1YWxSZXNwb25zZS5zdGF0dXMgPT09IDMwMyAmJlxuICAgICAgIUdFVF9PUl9IRUFELmluY2x1ZGVzKHJlcXVlc3QubWV0aG9kKSlcbiAgKSB7XG4gICAgLy8gdGhlbjpcbiAgICAvLyAxLiBTZXQgcmVxdWVzdOKAmXMgbWV0aG9kIHRvIGBHRVRgIGFuZCByZXF1ZXN04oCZcyBib2R5IHRvIG51bGwuXG4gICAgcmVxdWVzdC5tZXRob2QgPSAnR0VUJ1xuICAgIHJlcXVlc3QuYm9keSA9IG51bGxcblxuICAgIC8vIDIuIEZvciBlYWNoIGhlYWRlck5hbWUgb2YgcmVxdWVzdC1ib2R5LWhlYWRlciBuYW1lLCBkZWxldGUgaGVhZGVyTmFtZSBmcm9tXG4gICAgLy8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgZm9yIChjb25zdCBoZWFkZXJOYW1lIG9mIHJlcXVlc3RCb2R5SGVhZGVyKSB7XG4gICAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmRlbGV0ZShoZWFkZXJOYW1lKVxuICAgIH1cbiAgfVxuXG4gIC8vIDEzLiBJZiByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgb3JpZ2luIGlzIG5vdCBzYW1lIG9yaWdpbiB3aXRoIGxvY2F0aW9uVVJM4oCZc1xuICAvLyAgICAgb3JpZ2luLCB0aGVuIGZvciBlYWNoIGhlYWRlck5hbWUgb2YgQ09SUyBub24td2lsZGNhcmQgcmVxdWVzdC1oZWFkZXIgbmFtZSxcbiAgLy8gICAgIGRlbGV0ZSBoZWFkZXJOYW1lIGZyb20gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIGlmICghc2FtZU9yaWdpbihyZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KSwgbG9jYXRpb25VUkwpKSB7XG4gICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvcnMtbm9uLXdpbGRjYXJkLXJlcXVlc3QtaGVhZGVyLW5hbWVcbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmRlbGV0ZSgnYXV0aG9yaXphdGlvbicpXG5cbiAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYXV0aGVudGljYXRpb24tZW50cmllc1xuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuZGVsZXRlKCdwcm94eS1hdXRob3JpemF0aW9uJywgdHJ1ZSlcblxuICAgIC8vIFwiQ29va2llXCIgYW5kIFwiSG9zdFwiIGFyZSBmb3JiaWRkZW4gcmVxdWVzdC1oZWFkZXJzLCB3aGljaCB1bmRpY2kgZG9lc24ndCBpbXBsZW1lbnQuXG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5kZWxldGUoJ2Nvb2tpZScpXG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5kZWxldGUoJ2hvc3QnKVxuICB9XG5cbiAgLy8gMTQuIElmIHJlcXVlc3TigJlzIGJvZHkgaXMgbm9uLW51bGwsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGJvZHkgdG8gdGhlIGZpcnN0IHJldHVyblxuICAvLyB2YWx1ZSBvZiBzYWZlbHkgZXh0cmFjdGluZyByZXF1ZXN04oCZcyBib2R54oCZcyBzb3VyY2UuXG4gIGlmIChyZXF1ZXN0LmJvZHkgIT0gbnVsbCkge1xuICAgIGFzc2VydChyZXF1ZXN0LmJvZHkuc291cmNlICE9IG51bGwpXG4gICAgcmVxdWVzdC5ib2R5ID0gc2FmZWx5RXh0cmFjdEJvZHkocmVxdWVzdC5ib2R5LnNvdXJjZSlbMF1cbiAgfVxuXG4gIC8vIDE1LiBMZXQgdGltaW5nSW5mbyBiZSBmZXRjaFBhcmFtc+KAmXMgdGltaW5nIGluZm8uXG4gIGNvbnN0IHRpbWluZ0luZm8gPSBmZXRjaFBhcmFtcy50aW1pbmdJbmZvXG5cbiAgLy8gMTYuIFNldCB0aW1pbmdJbmZv4oCZcyByZWRpcmVjdCBlbmQgdGltZSBhbmQgcG9zdC1yZWRpcmVjdCBzdGFydCB0aW1lIHRvIHRoZVxuICAvLyBjb2Fyc2VuZWQgc2hhcmVkIGN1cnJlbnQgdGltZSBnaXZlbiBmZXRjaFBhcmFtc+KAmXMgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkXG4gIC8vIGNhcGFiaWxpdHkuXG4gIHRpbWluZ0luZm8ucmVkaXJlY3RFbmRUaW1lID0gdGltaW5nSW5mby5wb3N0UmVkaXJlY3RTdGFydFRpbWUgPVxuICAgIGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lKGZldGNoUGFyYW1zLmNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KVxuXG4gIC8vIDE3LiBJZiB0aW1pbmdJbmZv4oCZcyByZWRpcmVjdCBzdGFydCB0aW1lIGlzIDAsIHRoZW4gc2V0IHRpbWluZ0luZm/igJlzXG4gIC8vICByZWRpcmVjdCBzdGFydCB0aW1lIHRvIHRpbWluZ0luZm/igJlzIHN0YXJ0IHRpbWUuXG4gIGlmICh0aW1pbmdJbmZvLnJlZGlyZWN0U3RhcnRUaW1lID09PSAwKSB7XG4gICAgdGltaW5nSW5mby5yZWRpcmVjdFN0YXJ0VGltZSA9IHRpbWluZ0luZm8uc3RhcnRUaW1lXG4gIH1cblxuICAvLyAxOC4gQXBwZW5kIGxvY2F0aW9uVVJMIHRvIHJlcXVlc3TigJlzIFVSTCBsaXN0LlxuICByZXF1ZXN0LnVybExpc3QucHVzaChsb2NhdGlvblVSTClcblxuICAvLyAxOS4gSW52b2tlIHNldCByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3kgb24gcmVkaXJlY3Qgb24gcmVxdWVzdCBhbmRcbiAgLy8gYWN0dWFsUmVzcG9uc2UuXG4gIHNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3QocmVxdWVzdCwgYWN0dWFsUmVzcG9uc2UpXG5cbiAgLy8gMjAuIFJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgbWFpbiBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcyBhbmQgdHJ1ZS5cbiAgcmV0dXJuIG1haW5GZXRjaChmZXRjaFBhcmFtcywgdHJ1ZSlcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtbmV0d29yay1vci1jYWNoZS1mZXRjaFxuYXN5bmMgZnVuY3Rpb24gaHR0cE5ldHdvcmtPckNhY2hlRmV0Y2ggKFxuICBmZXRjaFBhcmFtcyxcbiAgaXNBdXRoZW50aWNhdGlvbkZldGNoID0gZmFsc2UsXG4gIGlzTmV3Q29ubmVjdGlvbkZldGNoID0gZmFsc2Vcbikge1xuICAvLyAxLiBMZXQgcmVxdWVzdCBiZSBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdC5cbiAgY29uc3QgcmVxdWVzdCA9IGZldGNoUGFyYW1zLnJlcXVlc3RcblxuICAvLyAyLiBMZXQgaHR0cEZldGNoUGFyYW1zIGJlIG51bGwuXG4gIGxldCBodHRwRmV0Y2hQYXJhbXMgPSBudWxsXG5cbiAgLy8gMy4gTGV0IGh0dHBSZXF1ZXN0IGJlIG51bGwuXG4gIGxldCBodHRwUmVxdWVzdCA9IG51bGxcblxuICAvLyA0LiBMZXQgcmVzcG9uc2UgYmUgbnVsbC5cbiAgbGV0IHJlc3BvbnNlID0gbnVsbFxuXG4gIC8vIDUuIExldCBzdG9yZWRSZXNwb25zZSBiZSBudWxsLlxuICAvLyBUT0RPOiBjYWNoZVxuXG4gIC8vIDYuIExldCBodHRwQ2FjaGUgYmUgbnVsbC5cbiAgY29uc3QgaHR0cENhY2hlID0gbnVsbFxuXG4gIC8vIDcuIExldCB0aGUgcmV2YWxpZGF0aW5nRmxhZyBiZSB1bnNldC5cbiAgY29uc3QgcmV2YWxpZGF0aW5nRmxhZyA9IGZhbHNlXG5cbiAgLy8gOC4gUnVuIHRoZXNlIHN0ZXBzLCBidXQgYWJvcnQgd2hlbiB0aGUgb25nb2luZyBmZXRjaCBpcyB0ZXJtaW5hdGVkOlxuXG4gIC8vICAgIDEuIElmIHJlcXVlc3TigJlzIHdpbmRvdyBpcyBcIm5vLXdpbmRvd1wiIGFuZCByZXF1ZXN04oCZcyByZWRpcmVjdCBtb2RlIGlzXG4gIC8vICAgIFwiZXJyb3JcIiwgdGhlbiBzZXQgaHR0cEZldGNoUGFyYW1zIHRvIGZldGNoUGFyYW1zIGFuZCBodHRwUmVxdWVzdCB0b1xuICAvLyAgICByZXF1ZXN0LlxuICBpZiAocmVxdWVzdC53aW5kb3cgPT09ICduby13aW5kb3cnICYmIHJlcXVlc3QucmVkaXJlY3QgPT09ICdlcnJvcicpIHtcbiAgICBodHRwRmV0Y2hQYXJhbXMgPSBmZXRjaFBhcmFtc1xuICAgIGh0dHBSZXF1ZXN0ID0gcmVxdWVzdFxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZTpcblxuICAgIC8vIDEuIFNldCBodHRwUmVxdWVzdCB0byBhIGNsb25lIG9mIHJlcXVlc3QuXG4gICAgaHR0cFJlcXVlc3QgPSBtYWtlUmVxdWVzdChyZXF1ZXN0KVxuXG4gICAgLy8gMi4gU2V0IGh0dHBGZXRjaFBhcmFtcyB0byBhIGNvcHkgb2YgZmV0Y2hQYXJhbXMuXG4gICAgaHR0cEZldGNoUGFyYW1zID0geyAuLi5mZXRjaFBhcmFtcyB9XG5cbiAgICAvLyAzLiBTZXQgaHR0cEZldGNoUGFyYW1z4oCZcyByZXF1ZXN0IHRvIGh0dHBSZXF1ZXN0LlxuICAgIGh0dHBGZXRjaFBhcmFtcy5yZXF1ZXN0ID0gaHR0cFJlcXVlc3RcbiAgfVxuXG4gIC8vICAgIDMuIExldCBpbmNsdWRlQ3JlZGVudGlhbHMgYmUgdHJ1ZSBpZiBvbmUgb2ZcbiAgY29uc3QgaW5jbHVkZUNyZWRlbnRpYWxzID1cbiAgICByZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScgfHxcbiAgICAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ3NhbWUtb3JpZ2luJyAmJlxuICAgICAgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnYmFzaWMnKVxuXG4gIC8vICAgIDQuIExldCBjb250ZW50TGVuZ3RoIGJlIGh0dHBSZXF1ZXN04oCZcyBib2R54oCZcyBsZW5ndGgsIGlmIGh0dHBSZXF1ZXN04oCZc1xuICAvLyAgICBib2R5IGlzIG5vbi1udWxsOyBvdGhlcndpc2UgbnVsbC5cbiAgY29uc3QgY29udGVudExlbmd0aCA9IGh0dHBSZXF1ZXN0LmJvZHkgPyBodHRwUmVxdWVzdC5ib2R5Lmxlbmd0aCA6IG51bGxcblxuICAvLyAgICA1LiBMZXQgY29udGVudExlbmd0aEhlYWRlclZhbHVlIGJlIG51bGwuXG4gIGxldCBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgPSBudWxsXG5cbiAgLy8gICAgNi4gSWYgaHR0cFJlcXVlc3TigJlzIGJvZHkgaXMgbnVsbCBhbmQgaHR0cFJlcXVlc3TigJlzIG1ldGhvZCBpcyBgUE9TVGAgb3JcbiAgLy8gICAgYFBVVGAsIHRoZW4gc2V0IGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSB0byBgMGAuXG4gIGlmIChcbiAgICBodHRwUmVxdWVzdC5ib2R5ID09IG51bGwgJiZcbiAgICBbJ1BPU1QnLCAnUFVUJ10uaW5jbHVkZXMoaHR0cFJlcXVlc3QubWV0aG9kKVxuICApIHtcbiAgICBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgPSAnMCdcbiAgfVxuXG4gIC8vICAgIDcuIElmIGNvbnRlbnRMZW5ndGggaXMgbm9uLW51bGwsIHRoZW4gc2V0IGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSB0b1xuICAvLyAgICBjb250ZW50TGVuZ3RoLCBzZXJpYWxpemVkIGFuZCBpc29tb3JwaGljIGVuY29kZWQuXG4gIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwpIHtcbiAgICBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgPSBpc29tb3JwaGljRW5jb2RlKGAke2NvbnRlbnRMZW5ndGh9YClcbiAgfVxuXG4gIC8vICAgIDguIElmIGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSBpcyBub24tbnVsbCwgdGhlbiBhcHBlbmRcbiAgLy8gICAgYENvbnRlbnQtTGVuZ3RoYC9jb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlclxuICAvLyAgICBsaXN0LlxuICBpZiAoY29udGVudExlbmd0aEhlYWRlclZhbHVlICE9IG51bGwpIHtcbiAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2NvbnRlbnQtbGVuZ3RoJywgY29udGVudExlbmd0aEhlYWRlclZhbHVlKVxuICB9XG5cbiAgLy8gICAgOS4gSWYgY29udGVudExlbmd0aEhlYWRlclZhbHVlIGlzIG5vbi1udWxsLCB0aGVuIGFwcGVuZCAoYENvbnRlbnQtTGVuZ3RoYCxcbiAgLy8gICAgY29udGVudExlbmd0aEhlYWRlclZhbHVlKSB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG5cbiAgLy8gICAgMTAuIElmIGNvbnRlbnRMZW5ndGggaXMgbm9uLW51bGwgYW5kIGh0dHBSZXF1ZXN04oCZcyBrZWVwYWxpdmUgaXMgdHJ1ZSxcbiAgLy8gICAgdGhlbjpcbiAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCAmJiBodHRwUmVxdWVzdC5rZWVwYWxpdmUpIHtcbiAgICAvLyBOT1RFOiBrZWVwYWxpdmUgaXMgYSBub29wIG91dHNpZGUgb2YgYnJvd3NlciBjb250ZXh0LlxuICB9XG5cbiAgLy8gICAgMTEuIElmIGh0dHBSZXF1ZXN04oCZcyByZWZlcnJlciBpcyBhIFVSTCwgdGhlbiBhcHBlbmRcbiAgLy8gICAgYFJlZmVyZXJgL2h0dHBSZXF1ZXN04oCZcyByZWZlcnJlciwgc2VyaWFsaXplZCBhbmQgaXNvbW9ycGhpYyBlbmNvZGVkLFxuICAvLyAgICAgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICBpZiAoaHR0cFJlcXVlc3QucmVmZXJyZXIgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3JlZmVyZXInLCBpc29tb3JwaGljRW5jb2RlKGh0dHBSZXF1ZXN0LnJlZmVycmVyLmhyZWYpKVxuICB9XG5cbiAgLy8gICAgMTIuIEFwcGVuZCBhIHJlcXVlc3QgYE9yaWdpbmAgaGVhZGVyIGZvciBodHRwUmVxdWVzdC5cbiAgYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlcihodHRwUmVxdWVzdClcblxuICAvLyAgICAxMy4gQXBwZW5kIHRoZSBGZXRjaCBtZXRhZGF0YSBoZWFkZXJzIGZvciBodHRwUmVxdWVzdC4gW0ZFVENILU1FVEFEQVRBXVxuICBhcHBlbmRGZXRjaE1ldGFkYXRhKGh0dHBSZXF1ZXN0KVxuXG4gIC8vICAgIDE0LiBJZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgVXNlci1BZ2VudGAsIHRoZW5cbiAgLy8gICAgdXNlciBhZ2VudHMgc2hvdWxkIGFwcGVuZCBgVXNlci1BZ2VudGAvZGVmYXVsdCBgVXNlci1BZ2VudGAgdmFsdWUgdG9cbiAgLy8gICAgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICBpZiAoIWh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCd1c2VyLWFnZW50JykpIHtcbiAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3VzZXItYWdlbnQnLCB0eXBlb2YgZXNidWlsZERldGVjdGlvbiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kaWNpJyA6ICdub2RlJylcbiAgfVxuXG4gIC8vICAgIDE1LiBJZiBodHRwUmVxdWVzdOKAmXMgY2FjaGUgbW9kZSBpcyBcImRlZmF1bHRcIiBhbmQgaHR0cFJlcXVlc3TigJlzIGhlYWRlclxuICAvLyAgICBsaXN0IGNvbnRhaW5zIGBJZi1Nb2RpZmllZC1TaW5jZWAsIGBJZi1Ob25lLU1hdGNoYCxcbiAgLy8gICAgYElmLVVubW9kaWZpZWQtU2luY2VgLCBgSWYtTWF0Y2hgLCBvciBgSWYtUmFuZ2VgLCB0aGVuIHNldFxuICAvLyAgICBodHRwUmVxdWVzdOKAmXMgY2FjaGUgbW9kZSB0byBcIm5vLXN0b3JlXCIuXG4gIGlmIChcbiAgICBodHRwUmVxdWVzdC5jYWNoZSA9PT0gJ2RlZmF1bHQnICYmXG4gICAgKGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdpZi1tb2RpZmllZC1zaW5jZScpIHx8XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnaWYtbm9uZS1tYXRjaCcpIHx8XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnaWYtdW5tb2RpZmllZC1zaW5jZScpIHx8XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnaWYtbWF0Y2gnKSB8fFxuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2lmLXJhbmdlJykpXG4gICkge1xuICAgIGh0dHBSZXF1ZXN0LmNhY2hlID0gJ25vLXN0b3JlJ1xuICB9XG5cbiAgLy8gICAgMTYuIElmIGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIGlzIFwibm8tY2FjaGVcIiwgaHR0cFJlcXVlc3TigJlzIHByZXZlbnRcbiAgLy8gICAgbm8tY2FjaGUgY2FjaGUtY29udHJvbCBoZWFkZXIgbW9kaWZpY2F0aW9uIGZsYWcgaXMgdW5zZXQsIGFuZFxuICAvLyAgICBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgQ2FjaGUtQ29udHJvbGAsIHRoZW4gYXBwZW5kXG4gIC8vICAgIGBDYWNoZS1Db250cm9sYC9gbWF4LWFnZT0wYCB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIGlmIChcbiAgICBodHRwUmVxdWVzdC5jYWNoZSA9PT0gJ25vLWNhY2hlJyAmJlxuICAgICFodHRwUmVxdWVzdC5wcmV2ZW50Tm9DYWNoZUNhY2hlQ29udHJvbEhlYWRlck1vZGlmaWNhdGlvbiAmJlxuICAgICFodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnY2FjaGUtY29udHJvbCcpXG4gICkge1xuICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnY2FjaGUtY29udHJvbCcsICdtYXgtYWdlPTAnKVxuICB9XG5cbiAgLy8gICAgMTcuIElmIGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIGlzIFwibm8tc3RvcmVcIiBvciBcInJlbG9hZFwiLCB0aGVuOlxuICBpZiAoaHR0cFJlcXVlc3QuY2FjaGUgPT09ICduby1zdG9yZScgfHwgaHR0cFJlcXVlc3QuY2FjaGUgPT09ICdyZWxvYWQnKSB7XG4gICAgLy8gMS4gSWYgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYFByYWdtYWAsIHRoZW4gYXBwZW5kXG4gICAgLy8gYFByYWdtYWAvYG5vLWNhY2hlYCB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgaWYgKCFodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygncHJhZ21hJykpIHtcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgncHJhZ21hJywgJ25vLWNhY2hlJylcbiAgICB9XG5cbiAgICAvLyAyLiBJZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgQ2FjaGUtQ29udHJvbGAsXG4gICAgLy8gdGhlbiBhcHBlbmQgYENhY2hlLUNvbnRyb2xgL2Buby1jYWNoZWAgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAgIGlmICghaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2NhY2hlLWNvbnRyb2wnKSkge1xuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdjYWNoZS1jb250cm9sJywgJ25vLWNhY2hlJylcbiAgICB9XG4gIH1cblxuICAvLyAgICAxOC4gSWYgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGNvbnRhaW5zIGBSYW5nZWAsIHRoZW4gYXBwZW5kXG4gIC8vICAgIGBBY2NlcHQtRW5jb2RpbmdgL2BpZGVudGl0eWAgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICBpZiAoaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3JhbmdlJykpIHtcbiAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2FjY2VwdC1lbmNvZGluZycsICdpZGVudGl0eScpXG4gIH1cblxuICAvLyAgICAxOS4gTW9kaWZ5IGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBwZXIgSFRUUC4gRG8gbm90IGFwcGVuZCBhIGdpdmVuXG4gIC8vICAgIGhlYWRlciBpZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgY29udGFpbnMgdGhhdCBoZWFkZXLigJlzIG5hbWUuXG4gIC8vICAgIFRPRE86IGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvZmV0Y2gvaXNzdWVzLzEyODUjaXNzdWVjb21tZW50LTg5NjU2MDEyOVxuICBpZiAoIWh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdhY2NlcHQtZW5jb2RpbmcnKSkge1xuICAgIGlmICh1cmxIYXNIdHRwc1NjaGVtZShyZXF1ZXN0Q3VycmVudFVSTChodHRwUmVxdWVzdCkpKSB7XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2FjY2VwdC1lbmNvZGluZycsICdiciwgZ3ppcCwgZGVmbGF0ZScpXG4gICAgfSBlbHNlIHtcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnYWNjZXB0LWVuY29kaW5nJywgJ2d6aXAsIGRlZmxhdGUnKVxuICAgIH1cbiAgfVxuXG4gIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmRlbGV0ZSgnaG9zdCcpXG5cbiAgLy8gICAgMjAuIElmIGluY2x1ZGVDcmVkZW50aWFscyBpcyB0cnVlLCB0aGVuOlxuICBpZiAoaW5jbHVkZUNyZWRlbnRpYWxzKSB7XG4gICAgLy8gMS4gSWYgdGhlIHVzZXIgYWdlbnQgaXMgbm90IGNvbmZpZ3VyZWQgdG8gYmxvY2sgY29va2llcyBmb3IgaHR0cFJlcXVlc3RcbiAgICAvLyAoc2VlIHNlY3Rpb24gNyBvZiBbQ09PS0lFU10pLCB0aGVuOlxuICAgIC8vIFRPRE86IGNyZWRlbnRpYWxzXG4gICAgLy8gMi4gSWYgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYEF1dGhvcml6YXRpb25gLCB0aGVuOlxuICAgIC8vIFRPRE86IGNyZWRlbnRpYWxzXG4gIH1cblxuICAvLyAgICAyMS4gSWYgdGhlcmXigJlzIGEgcHJveHktYXV0aGVudGljYXRpb24gZW50cnksIHVzZSBpdCBhcyBhcHByb3ByaWF0ZS5cbiAgLy8gICAgVE9ETzogcHJveHktYXV0aGVudGljYXRpb25cblxuICAvLyAgICAyMi4gU2V0IGh0dHBDYWNoZSB0byB0aGUgcmVzdWx0IG9mIGRldGVybWluaW5nIHRoZSBIVFRQIGNhY2hlXG4gIC8vICAgIHBhcnRpdGlvbiwgZ2l2ZW4gaHR0cFJlcXVlc3QuXG4gIC8vICAgIFRPRE86IGNhY2hlXG5cbiAgLy8gICAgMjMuIElmIGh0dHBDYWNoZSBpcyBudWxsLCB0aGVuIHNldCBodHRwUmVxdWVzdOKAmXMgY2FjaGUgbW9kZSB0b1xuICAvLyAgICBcIm5vLXN0b3JlXCIuXG4gIGlmIChodHRwQ2FjaGUgPT0gbnVsbCkge1xuICAgIGh0dHBSZXF1ZXN0LmNhY2hlID0gJ25vLXN0b3JlJ1xuICB9XG5cbiAgLy8gICAgMjQuIElmIGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIGlzIG5laXRoZXIgXCJuby1zdG9yZVwiIG5vciBcInJlbG9hZFwiLFxuICAvLyAgICB0aGVuOlxuICBpZiAoaHR0cFJlcXVlc3QubW9kZSAhPT0gJ25vLXN0b3JlJyAmJiBodHRwUmVxdWVzdC5tb2RlICE9PSAncmVsb2FkJykge1xuICAgIC8vIFRPRE86IGNhY2hlXG4gIH1cblxuICAvLyA5LiBJZiBhYm9ydGVkLCB0aGVuIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgbmV0d29yayBlcnJvciBmb3IgZmV0Y2hQYXJhbXMuXG4gIC8vIFRPRE9cblxuICAvLyAxMC4gSWYgcmVzcG9uc2UgaXMgbnVsbCwgdGhlbjpcbiAgaWYgKHJlc3BvbnNlID09IG51bGwpIHtcbiAgICAvLyAxLiBJZiBodHRwUmVxdWVzdOKAmXMgY2FjaGUgbW9kZSBpcyBcIm9ubHktaWYtY2FjaGVkXCIsIHRoZW4gcmV0dXJuIGFcbiAgICAvLyBuZXR3b3JrIGVycm9yLlxuICAgIGlmIChodHRwUmVxdWVzdC5tb2RlID09PSAnb25seS1pZi1jYWNoZWQnKSB7XG4gICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcignb25seSBpZiBjYWNoZWQnKVxuICAgIH1cblxuICAgIC8vIDIuIExldCBmb3J3YXJkUmVzcG9uc2UgYmUgdGhlIHJlc3VsdCBvZiBydW5uaW5nIEhUVFAtbmV0d29yayBmZXRjaFxuICAgIC8vIGdpdmVuIGh0dHBGZXRjaFBhcmFtcywgaW5jbHVkZUNyZWRlbnRpYWxzLCBhbmQgaXNOZXdDb25uZWN0aW9uRmV0Y2guXG4gICAgY29uc3QgZm9yd2FyZFJlc3BvbnNlID0gYXdhaXQgaHR0cE5ldHdvcmtGZXRjaChcbiAgICAgIGh0dHBGZXRjaFBhcmFtcyxcbiAgICAgIGluY2x1ZGVDcmVkZW50aWFscyxcbiAgICAgIGlzTmV3Q29ubmVjdGlvbkZldGNoXG4gICAgKVxuXG4gICAgLy8gMy4gSWYgaHR0cFJlcXVlc3TigJlzIG1ldGhvZCBpcyB1bnNhZmUgYW5kIGZvcndhcmRSZXNwb25zZeKAmXMgc3RhdHVzIGlzXG4gICAgLy8gaW4gdGhlIHJhbmdlIDIwMCB0byAzOTksIGluY2x1c2l2ZSwgaW52YWxpZGF0ZSBhcHByb3ByaWF0ZSBzdG9yZWRcbiAgICAvLyByZXNwb25zZXMgaW4gaHR0cENhY2hlLCBhcyBwZXIgdGhlIFwiSW52YWxpZGF0aW9uXCIgY2hhcHRlciBvZiBIVFRQXG4gICAgLy8gQ2FjaGluZywgYW5kIHNldCBzdG9yZWRSZXNwb25zZSB0byBudWxsLiBbSFRUUC1DQUNISU5HXVxuICAgIGlmIChcbiAgICAgICFzYWZlTWV0aG9kc1NldC5oYXMoaHR0cFJlcXVlc3QubWV0aG9kKSAmJlxuICAgICAgZm9yd2FyZFJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiZcbiAgICAgIGZvcndhcmRSZXNwb25zZS5zdGF0dXMgPD0gMzk5XG4gICAgKSB7XG4gICAgICAvLyBUT0RPOiBjYWNoZVxuICAgIH1cblxuICAgIC8vIDQuIElmIHRoZSByZXZhbGlkYXRpbmdGbGFnIGlzIHNldCBhbmQgZm9yd2FyZFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgMzA0LFxuICAgIC8vIHRoZW46XG4gICAgaWYgKHJldmFsaWRhdGluZ0ZsYWcgJiYgZm9yd2FyZFJlc3BvbnNlLnN0YXR1cyA9PT0gMzA0KSB7XG4gICAgICAvLyBUT0RPOiBjYWNoZVxuICAgIH1cblxuICAgIC8vIDUuIElmIHJlc3BvbnNlIGlzIG51bGwsIHRoZW46XG4gICAgaWYgKHJlc3BvbnNlID09IG51bGwpIHtcbiAgICAgIC8vIDEuIFNldCByZXNwb25zZSB0byBmb3J3YXJkUmVzcG9uc2UuXG4gICAgICByZXNwb25zZSA9IGZvcndhcmRSZXNwb25zZVxuXG4gICAgICAvLyAyLiBTdG9yZSBodHRwUmVxdWVzdCBhbmQgZm9yd2FyZFJlc3BvbnNlIGluIGh0dHBDYWNoZSwgYXMgcGVyIHRoZVxuICAgICAgLy8gXCJTdG9yaW5nIFJlc3BvbnNlcyBpbiBDYWNoZXNcIiBjaGFwdGVyIG9mIEhUVFAgQ2FjaGluZy4gW0hUVFAtQ0FDSElOR11cbiAgICAgIC8vIFRPRE86IGNhY2hlXG4gICAgfVxuICB9XG5cbiAgLy8gMTEuIFNldCByZXNwb25zZeKAmXMgVVJMIGxpc3QgdG8gYSBjbG9uZSBvZiBodHRwUmVxdWVzdOKAmXMgVVJMIGxpc3QuXG4gIHJlc3BvbnNlLnVybExpc3QgPSBbLi4uaHR0cFJlcXVlc3QudXJsTGlzdF1cblxuICAvLyAxMi4gSWYgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGNvbnRhaW5zIGBSYW5nZWAsIHRoZW4gc2V0IHJlc3BvbnNl4oCZc1xuICAvLyByYW5nZS1yZXF1ZXN0ZWQgZmxhZy5cbiAgaWYgKGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdyYW5nZScpKSB7XG4gICAgcmVzcG9uc2UucmFuZ2VSZXF1ZXN0ZWQgPSB0cnVlXG4gIH1cblxuICAvLyAxMy4gU2V0IHJlc3BvbnNl4oCZcyByZXF1ZXN0LWluY2x1ZGVzLWNyZWRlbnRpYWxzIHRvIGluY2x1ZGVDcmVkZW50aWFscy5cbiAgcmVzcG9uc2UucmVxdWVzdEluY2x1ZGVzQ3JlZGVudGlhbHMgPSBpbmNsdWRlQ3JlZGVudGlhbHNcblxuICAvLyAxNC4gSWYgcmVzcG9uc2XigJlzIHN0YXR1cyBpcyA0MDEsIGh0dHBSZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyBpcyBub3RcbiAgLy8gXCJjb3JzXCIsIGluY2x1ZGVDcmVkZW50aWFscyBpcyB0cnVlLCBhbmQgcmVxdWVzdOKAmXMgd2luZG93IGlzIGFuIGVudmlyb25tZW50XG4gIC8vIHNldHRpbmdzIG9iamVjdCwgdGhlbjpcbiAgLy8gVE9ET1xuXG4gIC8vIDE1LiBJZiByZXNwb25zZeKAmXMgc3RhdHVzIGlzIDQwNywgdGhlbjpcbiAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA3KSB7XG4gICAgLy8gMS4gSWYgcmVxdWVzdOKAmXMgd2luZG93IGlzIFwibm8td2luZG93XCIsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICBpZiAocmVxdWVzdC53aW5kb3cgPT09ICduby13aW5kb3cnKSB7XG4gICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcigpXG4gICAgfVxuXG4gICAgLy8gMi4gPz8/XG5cbiAgICAvLyAzLiBJZiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZCwgdGhlbiByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIG5ldHdvcmsgZXJyb3IgZm9yIGZldGNoUGFyYW1zLlxuICAgIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgIHJldHVybiBtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IoZmV0Y2hQYXJhbXMpXG4gICAgfVxuXG4gICAgLy8gNC4gUHJvbXB0IHRoZSBlbmQgdXNlciBhcyBhcHByb3ByaWF0ZSBpbiByZXF1ZXN04oCZcyB3aW5kb3cgYW5kIHN0b3JlXG4gICAgLy8gdGhlIHJlc3VsdCBhcyBhIHByb3h5LWF1dGhlbnRpY2F0aW9uIGVudHJ5LiBbSFRUUC1BVVRIXVxuICAgIC8vIFRPRE86IEludm9rZSBzb21lIGtpbmQgb2YgY2FsbGJhY2s/XG5cbiAgICAvLyA1LiBTZXQgcmVzcG9uc2UgdG8gdGhlIHJlc3VsdCBvZiBydW5uaW5nIEhUVFAtbmV0d29yay1vci1jYWNoZSBmZXRjaCBnaXZlblxuICAgIC8vIGZldGNoUGFyYW1zLlxuICAgIC8vIFRPRE9cbiAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcigncHJveHkgYXV0aGVudGljYXRpb24gcmVxdWlyZWQnKVxuICB9XG5cbiAgLy8gMTYuIElmIGFsbCBvZiB0aGUgZm9sbG93aW5nIGFyZSB0cnVlXG4gIGlmIChcbiAgICAvLyByZXNwb25zZeKAmXMgc3RhdHVzIGlzIDQyMVxuICAgIHJlc3BvbnNlLnN0YXR1cyA9PT0gNDIxICYmXG4gICAgLy8gaXNOZXdDb25uZWN0aW9uRmV0Y2ggaXMgZmFsc2VcbiAgICAhaXNOZXdDb25uZWN0aW9uRmV0Y2ggJiZcbiAgICAvLyByZXF1ZXN04oCZcyBib2R5IGlzIG51bGwsIG9yIHJlcXVlc3TigJlzIGJvZHkgaXMgbm9uLW51bGwgYW5kIHJlcXVlc3TigJlzIGJvZHnigJlzIHNvdXJjZSBpcyBub24tbnVsbFxuICAgIChyZXF1ZXN0LmJvZHkgPT0gbnVsbCB8fCByZXF1ZXN0LmJvZHkuc291cmNlICE9IG51bGwpXG4gICkge1xuICAgIC8vIHRoZW46XG5cbiAgICAvLyAxLiBJZiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZCwgdGhlbiByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIG5ldHdvcmsgZXJyb3IgZm9yIGZldGNoUGFyYW1zLlxuICAgIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgIHJldHVybiBtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IoZmV0Y2hQYXJhbXMpXG4gICAgfVxuXG4gICAgLy8gMi4gU2V0IHJlc3BvbnNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZyBIVFRQLW5ldHdvcmstb3ItY2FjaGVcbiAgICAvLyBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcywgaXNBdXRoZW50aWNhdGlvbkZldGNoLCBhbmQgdHJ1ZS5cblxuICAgIC8vIFRPRE8gKHNwZWMpOiBUaGUgc3BlYyBkb2Vzbid0IHNwZWNpZnkgdGhpcyBidXQgd2UgbmVlZCB0byBjYW5jZWxcbiAgICAvLyB0aGUgYWN0aXZlIHJlc3BvbnNlIGJlZm9yZSB3ZSBjYW4gc3RhcnQgYSBuZXcgb25lLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvZmV0Y2gvaXNzdWVzLzEyOTNcbiAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24uZGVzdHJveSgpXG5cbiAgICByZXNwb25zZSA9IGF3YWl0IGh0dHBOZXR3b3JrT3JDYWNoZUZldGNoKFxuICAgICAgZmV0Y2hQYXJhbXMsXG4gICAgICBpc0F1dGhlbnRpY2F0aW9uRmV0Y2gsXG4gICAgICB0cnVlXG4gICAgKVxuICB9XG5cbiAgLy8gMTcuIElmIGlzQXV0aGVudGljYXRpb25GZXRjaCBpcyB0cnVlLCB0aGVuIGNyZWF0ZSBhbiBhdXRoZW50aWNhdGlvbiBlbnRyeVxuICBpZiAoaXNBdXRoZW50aWNhdGlvbkZldGNoKSB7XG4gICAgLy8gVE9ET1xuICB9XG5cbiAgLy8gMTguIFJldHVybiByZXNwb25zZS5cbiAgcmV0dXJuIHJlc3BvbnNlXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLW5ldHdvcmstZmV0Y2hcbmFzeW5jIGZ1bmN0aW9uIGh0dHBOZXR3b3JrRmV0Y2ggKFxuICBmZXRjaFBhcmFtcyxcbiAgaW5jbHVkZUNyZWRlbnRpYWxzID0gZmFsc2UsXG4gIGZvcmNlTmV3Q29ubmVjdGlvbiA9IGZhbHNlXG4pIHtcbiAgYXNzZXJ0KCFmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24gfHwgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uLmRlc3Ryb3llZClcblxuICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24gPSB7XG4gICAgYWJvcnQ6IG51bGwsXG4gICAgZGVzdHJveWVkOiBmYWxzZSxcbiAgICBkZXN0cm95IChlcnIpIHtcbiAgICAgIGlmICghdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG4gICAgICAgIHRoaXMuYWJvcnQ/LihlcnIgPz8gbmV3IERPTUV4Y2VwdGlvbignVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC4nLCAnQWJvcnRFcnJvcicpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIDEuIExldCByZXF1ZXN0IGJlIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN0LlxuICBjb25zdCByZXF1ZXN0ID0gZmV0Y2hQYXJhbXMucmVxdWVzdFxuXG4gIC8vIDIuIExldCByZXNwb25zZSBiZSBudWxsLlxuICBsZXQgcmVzcG9uc2UgPSBudWxsXG5cbiAgLy8gMy4gTGV0IHRpbWluZ0luZm8gYmUgZmV0Y2hQYXJhbXPigJlzIHRpbWluZyBpbmZvLlxuICBjb25zdCB0aW1pbmdJbmZvID0gZmV0Y2hQYXJhbXMudGltaW5nSW5mb1xuXG4gIC8vIDQuIExldCBodHRwQ2FjaGUgYmUgdGhlIHJlc3VsdCBvZiBkZXRlcm1pbmluZyB0aGUgSFRUUCBjYWNoZSBwYXJ0aXRpb24sXG4gIC8vIGdpdmVuIHJlcXVlc3QuXG4gIC8vIFRPRE86IGNhY2hlXG4gIGNvbnN0IGh0dHBDYWNoZSA9IG51bGxcblxuICAvLyA1LiBJZiBodHRwQ2FjaGUgaXMgbnVsbCwgdGhlbiBzZXQgcmVxdWVzdOKAmXMgY2FjaGUgbW9kZSB0byBcIm5vLXN0b3JlXCIuXG4gIGlmIChodHRwQ2FjaGUgPT0gbnVsbCkge1xuICAgIHJlcXVlc3QuY2FjaGUgPSAnbm8tc3RvcmUnXG4gIH1cblxuICAvLyA2LiBMZXQgbmV0d29ya1BhcnRpdGlvbktleSBiZSB0aGUgcmVzdWx0IG9mIGRldGVybWluaW5nIHRoZSBuZXR3b3JrXG4gIC8vIHBhcnRpdGlvbiBrZXkgZ2l2ZW4gcmVxdWVzdC5cbiAgLy8gVE9ET1xuXG4gIC8vIDcuIExldCBuZXdDb25uZWN0aW9uIGJlIFwieWVzXCIgaWYgZm9yY2VOZXdDb25uZWN0aW9uIGlzIHRydWU7IG90aGVyd2lzZVxuICAvLyBcIm5vXCIuXG4gIGNvbnN0IG5ld0Nvbm5lY3Rpb24gPSBmb3JjZU5ld0Nvbm5lY3Rpb24gPyAneWVzJyA6ICdubycgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8vIDguIFN3aXRjaCBvbiByZXF1ZXN04oCZcyBtb2RlOlxuICBpZiAocmVxdWVzdC5tb2RlID09PSAnd2Vic29ja2V0Jykge1xuICAgIC8vIExldCBjb25uZWN0aW9uIGJlIHRoZSByZXN1bHQgb2Ygb2J0YWluaW5nIGEgV2ViU29ja2V0IGNvbm5lY3Rpb24sXG4gICAgLy8gZ2l2ZW4gcmVxdWVzdOKAmXMgY3VycmVudCBVUkwuXG4gICAgLy8gVE9ET1xuICB9IGVsc2Uge1xuICAgIC8vIExldCBjb25uZWN0aW9uIGJlIHRoZSByZXN1bHQgb2Ygb2J0YWluaW5nIGEgY29ubmVjdGlvbiwgZ2l2ZW5cbiAgICAvLyBuZXR3b3JrUGFydGl0aW9uS2V5LCByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgb3JpZ2luLFxuICAgIC8vIGluY2x1ZGVDcmVkZW50aWFscywgYW5kIGZvcmNlTmV3Q29ubmVjdGlvbi5cbiAgICAvLyBUT0RPXG4gIH1cblxuICAvLyA5LiBSdW4gdGhlc2Ugc3RlcHMsIGJ1dCBhYm9ydCB3aGVuIHRoZSBvbmdvaW5nIGZldGNoIGlzIHRlcm1pbmF0ZWQ6XG5cbiAgLy8gICAgMS4gSWYgY29ubmVjdGlvbiBpcyBmYWlsdXJlLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG5cbiAgLy8gICAgMi4gU2V0IHRpbWluZ0luZm/igJlzIGZpbmFsIGNvbm5lY3Rpb24gdGltaW5nIGluZm8gdG8gdGhlIHJlc3VsdCBvZlxuICAvLyAgICBjYWxsaW5nIGNsYW1wIGFuZCBjb2Fyc2VuIGNvbm5lY3Rpb24gdGltaW5nIGluZm8gd2l0aCBjb25uZWN0aW9u4oCZc1xuICAvLyAgICB0aW1pbmcgaW5mbywgdGltaW5nSW5mb+KAmXMgcG9zdC1yZWRpcmVjdCBzdGFydCB0aW1lLCBhbmQgZmV0Y2hQYXJhbXPigJlzXG4gIC8vICAgIGNyb3NzLW9yaWdpbiBpc29sYXRlZCBjYXBhYmlsaXR5LlxuXG4gIC8vICAgIDMuIElmIGNvbm5lY3Rpb24gaXMgbm90IGFuIEhUVFAvMiBjb25uZWN0aW9uLCByZXF1ZXN04oCZcyBib2R5IGlzIG5vbi1udWxsLFxuICAvLyAgICBhbmQgcmVxdWVzdOKAmXMgYm9keeKAmXMgc291cmNlIGlzIG51bGwsIHRoZW4gYXBwZW5kIChgVHJhbnNmZXItRW5jb2RpbmdgLFxuICAvLyAgICBgY2h1bmtlZGApIHRvIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuXG4gIC8vICAgIDQuIFNldCB0aW1pbmdJbmZv4oCZcyBmaW5hbCBuZXR3b3JrLXJlcXVlc3Qgc3RhcnQgdGltZSB0byB0aGUgY29hcnNlbmVkXG4gIC8vICAgIHNoYXJlZCBjdXJyZW50IHRpbWUgZ2l2ZW4gZmV0Y2hQYXJhbXPigJlzIGNyb3NzLW9yaWdpbiBpc29sYXRlZFxuICAvLyAgICBjYXBhYmlsaXR5LlxuXG4gIC8vICAgIDUuIFNldCByZXNwb25zZSB0byB0aGUgcmVzdWx0IG9mIG1ha2luZyBhbiBIVFRQIHJlcXVlc3Qgb3ZlciBjb25uZWN0aW9uXG4gIC8vICAgIHVzaW5nIHJlcXVlc3Qgd2l0aCB0aGUgZm9sbG93aW5nIGNhdmVhdHM6XG5cbiAgLy8gICAgICAgIC0gRm9sbG93IHRoZSByZWxldmFudCByZXF1aXJlbWVudHMgZnJvbSBIVFRQLiBbSFRUUF0gW0hUVFAtU0VNQU5USUNTXVxuICAvLyAgICAgICAgW0hUVFAtQ09ORF0gW0hUVFAtQ0FDSElOR10gW0hUVFAtQVVUSF1cblxuICAvLyAgICAgICAgLSBJZiByZXF1ZXN04oCZcyBib2R5IGlzIG5vbi1udWxsLCBhbmQgcmVxdWVzdOKAmXMgYm9keeKAmXMgc291cmNlIGlzIG51bGwsXG4gIC8vICAgICAgICB0aGVuIHRoZSB1c2VyIGFnZW50IG1heSBoYXZlIGEgYnVmZmVyIG9mIHVwIHRvIDY0IGtpYmlieXRlcyBhbmQgc3RvcmVcbiAgLy8gICAgICAgIGEgcGFydCBvZiByZXF1ZXN04oCZcyBib2R5IGluIHRoYXQgYnVmZmVyLiBJZiB0aGUgdXNlciBhZ2VudCByZWFkcyBmcm9tXG4gIC8vICAgICAgICByZXF1ZXN04oCZcyBib2R5IGJleW9uZCB0aGF0IGJ1ZmZlcuKAmXMgc2l6ZSBhbmQgdGhlIHVzZXIgYWdlbnQgbmVlZHMgdG9cbiAgLy8gICAgICAgIHJlc2VuZCByZXF1ZXN0LCB0aGVuIGluc3RlYWQgcmV0dXJuIGEgbmV0d29yayBlcnJvci5cblxuICAvLyAgICAgICAgLSBTZXQgdGltaW5nSW5mb+KAmXMgZmluYWwgbmV0d29yay1yZXNwb25zZSBzdGFydCB0aW1lIHRvIHRoZSBjb2Fyc2VuZWRcbiAgLy8gICAgICAgIHNoYXJlZCBjdXJyZW50IHRpbWUgZ2l2ZW4gZmV0Y2hQYXJhbXPigJlzIGNyb3NzLW9yaWdpbiBpc29sYXRlZCBjYXBhYmlsaXR5LFxuICAvLyAgICAgICAgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHVzZXIgYWdlbnTigJlzIEhUVFAgcGFyc2VyIHJlY2VpdmVzIHRoZSBmaXJzdCBieXRlXG4gIC8vICAgICAgICBvZiB0aGUgcmVzcG9uc2UgKGUuZy4sIGZyYW1lIGhlYWRlciBieXRlcyBmb3IgSFRUUC8yIG9yIHJlc3BvbnNlIHN0YXR1c1xuICAvLyAgICAgICAgbGluZSBmb3IgSFRUUC8xLngpLlxuXG4gIC8vICAgICAgICAtIFdhaXQgdW50aWwgYWxsIHRoZSBoZWFkZXJzIGFyZSB0cmFuc21pdHRlZC5cblxuICAvLyAgICAgICAgLSBBbnkgcmVzcG9uc2VzIHdob3NlIHN0YXR1cyBpcyBpbiB0aGUgcmFuZ2UgMTAwIHRvIDE5OSwgaW5jbHVzaXZlLFxuICAvLyAgICAgICAgYW5kIGlzIG5vdCAxMDEsIGFyZSB0byBiZSBpZ25vcmVkLCBleGNlcHQgZm9yIHRoZSBwdXJwb3NlcyBvZiBzZXR0aW5nXG4gIC8vICAgICAgICB0aW1pbmdJbmZv4oCZcyBmaW5hbCBuZXR3b3JrLXJlc3BvbnNlIHN0YXJ0IHRpbWUgYWJvdmUuXG5cbiAgLy8gICAgLSBJZiByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBjb250YWlucyBgVHJhbnNmZXItRW5jb2RpbmdgL2BjaHVua2VkYCBhbmRcbiAgLy8gICAgcmVzcG9uc2UgaXMgdHJhbnNmZXJyZWQgdmlhIEhUVFAvMS4wIG9yIG9sZGVyLCB0aGVuIHJldHVybiBhIG5ldHdvcmtcbiAgLy8gICAgZXJyb3IuXG5cbiAgLy8gICAgLSBJZiB0aGUgSFRUUCByZXF1ZXN0IHJlc3VsdHMgaW4gYSBUTFMgY2xpZW50IGNlcnRpZmljYXRlIGRpYWxvZywgdGhlbjpcblxuICAvLyAgICAgICAgMS4gSWYgcmVxdWVzdOKAmXMgd2luZG93IGlzIGFuIGVudmlyb25tZW50IHNldHRpbmdzIG9iamVjdCwgbWFrZSB0aGVcbiAgLy8gICAgICAgIGRpYWxvZyBhdmFpbGFibGUgaW4gcmVxdWVzdOKAmXMgd2luZG93LlxuXG4gIC8vICAgICAgICAyLiBPdGhlcndpc2UsIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG5cbiAgLy8gVG8gdHJhbnNtaXQgcmVxdWVzdOKAmXMgYm9keSBib2R5LCBydW4gdGhlc2Ugc3RlcHM6XG4gIGxldCByZXF1ZXN0Qm9keSA9IG51bGxcbiAgLy8gMS4gSWYgYm9keSBpcyBudWxsIGFuZCBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXF1ZXN0IGVuZC1vZi1ib2R5IGlzXG4gIC8vIG5vbi1udWxsLCB0aGVuIHF1ZXVlIGEgZmV0Y2ggdGFzayBnaXZlbiBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXF1ZXN0XG4gIC8vIGVuZC1vZi1ib2R5IGFuZCBmZXRjaFBhcmFtc+KAmXMgdGFzayBkZXN0aW5hdGlvbi5cbiAgaWYgKHJlcXVlc3QuYm9keSA9PSBudWxsICYmIGZldGNoUGFyYW1zLnByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5KSB7XG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gZmV0Y2hQYXJhbXMucHJvY2Vzc1JlcXVlc3RFbmRPZkJvZHkoKSlcbiAgfSBlbHNlIGlmIChyZXF1ZXN0LmJvZHkgIT0gbnVsbCkge1xuICAgIC8vIDIuIE90aGVyd2lzZSwgaWYgYm9keSBpcyBub24tbnVsbDpcblxuICAgIC8vICAgIDEuIExldCBwcm9jZXNzQm9keUNodW5rIGdpdmVuIGJ5dGVzIGJlIHRoZXNlIHN0ZXBzOlxuICAgIGNvbnN0IHByb2Nlc3NCb2R5Q2h1bmsgPSBhc3luYyBmdW5jdGlvbiAqIChieXRlcykge1xuICAgICAgLy8gMS4gSWYgdGhlIG9uZ29pbmcgZmV0Y2ggaXMgdGVybWluYXRlZCwgdGhlbiBhYm9ydCB0aGVzZSBzdGVwcy5cbiAgICAgIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIFJ1biB0aGlzIHN0ZXAgaW4gcGFyYWxsZWw6IHRyYW5zbWl0IGJ5dGVzLlxuICAgICAgeWllbGQgYnl0ZXNcblxuICAgICAgLy8gMy4gSWYgZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVxdWVzdCBib2R5IGlzIG5vbi1udWxsLCB0aGVuIHJ1blxuICAgICAgLy8gZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVxdWVzdCBib2R5IGdpdmVuIGJ5dGVz4oCZcyBsZW5ndGguXG4gICAgICBmZXRjaFBhcmFtcy5wcm9jZXNzUmVxdWVzdEJvZHlDaHVua0xlbmd0aD8uKGJ5dGVzLmJ5dGVMZW5ndGgpXG4gICAgfVxuXG4gICAgLy8gMi4gTGV0IHByb2Nlc3NFbmRPZkJvZHkgYmUgdGhlc2Ugc3RlcHM6XG4gICAgY29uc3QgcHJvY2Vzc0VuZE9mQm9keSA9ICgpID0+IHtcbiAgICAgIC8vIDEuIElmIGZldGNoUGFyYW1zIGlzIGNhbmNlbGVkLCB0aGVuIGFib3J0IHRoZXNlIHN0ZXBzLlxuICAgICAgaWYgKGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gMi4gSWYgZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVxdWVzdCBlbmQtb2YtYm9keSBpcyBub24tbnVsbCxcbiAgICAgIC8vIHRoZW4gcnVuIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlcXVlc3QgZW5kLW9mLWJvZHkuXG4gICAgICBpZiAoZmV0Y2hQYXJhbXMucHJvY2Vzc1JlcXVlc3RFbmRPZkJvZHkpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMucHJvY2Vzc1JlcXVlc3RFbmRPZkJvZHkoKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDMuIExldCBwcm9jZXNzQm9keUVycm9yIGdpdmVuIGUgYmUgdGhlc2Ugc3RlcHM6XG4gICAgY29uc3QgcHJvY2Vzc0JvZHlFcnJvciA9IChlKSA9PiB7XG4gICAgICAvLyAxLiBJZiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZCwgdGhlbiBhYm9ydCB0aGVzZSBzdGVwcy5cbiAgICAgIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIElmIGUgaXMgYW4gXCJBYm9ydEVycm9yXCIgRE9NRXhjZXB0aW9uLCB0aGVuIGFib3J0IGZldGNoUGFyYW1z4oCZcyBjb250cm9sbGVyLlxuICAgICAgaWYgKGUubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuYWJvcnQoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci50ZXJtaW5hdGUoZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0LiBJbmNyZW1lbnRhbGx5IHJlYWQgcmVxdWVzdOKAmXMgYm9keSBnaXZlbiBwcm9jZXNzQm9keUNodW5rLCBwcm9jZXNzRW5kT2ZCb2R5LFxuICAgIC8vIHByb2Nlc3NCb2R5RXJyb3IsIGFuZCBmZXRjaFBhcmFtc+KAmXMgdGFzayBkZXN0aW5hdGlvbi5cbiAgICByZXF1ZXN0Qm9keSA9IChhc3luYyBmdW5jdGlvbiAqICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgYnl0ZXMgb2YgcmVxdWVzdC5ib2R5LnN0cmVhbSkge1xuICAgICAgICAgIHlpZWxkICogcHJvY2Vzc0JvZHlDaHVuayhieXRlcylcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzRW5kT2ZCb2R5KClcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBwcm9jZXNzQm9keUVycm9yKGVycilcbiAgICAgIH1cbiAgICB9KSgpXG4gIH1cblxuICB0cnkge1xuICAgIC8vIHNvY2tldCBpcyBvbmx5IHByb3ZpZGVkIGZvciB3ZWJzb2NrZXRzXG4gICAgY29uc3QgeyBib2R5LCBzdGF0dXMsIHN0YXR1c1RleHQsIGhlYWRlcnNMaXN0LCBzb2NrZXQgfSA9IGF3YWl0IGRpc3BhdGNoKHsgYm9keTogcmVxdWVzdEJvZHkgfSlcblxuICAgIGlmIChzb2NrZXQpIHtcbiAgICAgIHJlc3BvbnNlID0gbWFrZVJlc3BvbnNlKHsgc3RhdHVzLCBzdGF0dXNUZXh0LCBoZWFkZXJzTGlzdCwgc29ja2V0IH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gYm9keVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKVxuICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5uZXh0ID0gKCkgPT4gaXRlcmF0b3IubmV4dCgpXG5cbiAgICAgIHJlc3BvbnNlID0gbWFrZVJlc3BvbnNlKHsgc3RhdHVzLCBzdGF0dXNUZXh0LCBoZWFkZXJzTGlzdCB9KVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gMTAuIElmIGFib3J0ZWQsIHRoZW46XG4gICAgaWYgKGVyci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgIC8vIDEuIElmIGNvbm5lY3Rpb24gdXNlcyBIVFRQLzIsIHRoZW4gdHJhbnNtaXQgYW4gUlNUX1NUUkVBTSBmcmFtZS5cbiAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95KClcblxuICAgICAgLy8gMi4gUmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBuZXR3b3JrIGVycm9yIGZvciBmZXRjaFBhcmFtcy5cbiAgICAgIHJldHVybiBtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IoZmV0Y2hQYXJhbXMsIGVycilcbiAgICB9XG5cbiAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcihlcnIpXG4gIH1cblxuICAvLyAxMS4gTGV0IHB1bGxBbGdvcml0aG0gYmUgYW4gYWN0aW9uIHRoYXQgcmVzdW1lcyB0aGUgb25nb2luZyBmZXRjaFxuICAvLyBpZiBpdCBpcyBzdXNwZW5kZWQuXG4gIGNvbnN0IHB1bGxBbGdvcml0aG0gPSAoKSA9PiB7XG4gICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5yZXN1bWUoKVxuICB9XG5cbiAgLy8gMTIuIExldCBjYW5jZWxBbGdvcml0aG0gYmUgYW4gYWxnb3JpdGhtIHRoYXQgYWJvcnRzIGZldGNoUGFyYW1z4oCZc1xuICAvLyBjb250cm9sbGVyIHdpdGggcmVhc29uLCBnaXZlbiByZWFzb24uXG4gIGNvbnN0IGNhbmNlbEFsZ29yaXRobSA9IChyZWFzb24pID0+IHtcbiAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmFib3J0KHJlYXNvbilcbiAgfVxuXG4gIC8vIDEzLiBMZXQgaGlnaFdhdGVyTWFyayBiZSBhIG5vbi1uZWdhdGl2ZSwgbm9uLU5hTiBudW1iZXIsIGNob3NlbiBieVxuICAvLyB0aGUgdXNlciBhZ2VudC5cbiAgLy8gVE9ET1xuXG4gIC8vIDE0LiBMZXQgc2l6ZUFsZ29yaXRobSBiZSBhbiBhbGdvcml0aG0gdGhhdCBhY2NlcHRzIGEgY2h1bmsgb2JqZWN0XG4gIC8vIGFuZCByZXR1cm5zIGEgbm9uLW5lZ2F0aXZlLCBub24tTmFOLCBub24taW5maW5pdGUgbnVtYmVyLCBjaG9zZW4gYnkgdGhlIHVzZXIgYWdlbnQuXG4gIC8vIFRPRE9cblxuICAvLyAxNS4gTGV0IHN0cmVhbSBiZSBhIG5ldyBSZWFkYWJsZVN0cmVhbS5cbiAgLy8gMTYuIFNldCB1cCBzdHJlYW0gd2l0aCBwdWxsQWxnb3JpdGhtIHNldCB0byBwdWxsQWxnb3JpdGhtLFxuICAvLyBjYW5jZWxBbGdvcml0aG0gc2V0IHRvIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyayBzZXQgdG9cbiAgLy8gaGlnaFdhdGVyTWFyaywgYW5kIHNpemVBbGdvcml0aG0gc2V0IHRvIHNpemVBbGdvcml0aG0uXG4gIGlmICghUmVhZGFibGVTdHJlYW0pIHtcbiAgICBSZWFkYWJsZVN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbS93ZWInKS5SZWFkYWJsZVN0cmVhbVxuICB9XG5cbiAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKFxuICAgIHtcbiAgICAgIGFzeW5jIHN0YXJ0IChjb250cm9sbGVyKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlciA9IGNvbnRyb2xsZXJcbiAgICAgIH0sXG4gICAgICBhc3luYyBwdWxsIChjb250cm9sbGVyKSB7XG4gICAgICAgIGF3YWl0IHB1bGxBbGdvcml0aG0oY29udHJvbGxlcilcbiAgICAgIH0sXG4gICAgICBhc3luYyBjYW5jZWwgKHJlYXNvbikge1xuICAgICAgICBhd2FpdCBjYW5jZWxBbGdvcml0aG0ocmVhc29uKVxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgaGlnaFdhdGVyTWFyazogMCxcbiAgICAgIHNpemUgKCkge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfVxuICAgIH1cbiAgKVxuXG4gIC8vIDE3LiBSdW4gdGhlc2Ugc3RlcHMsIGJ1dCBhYm9ydCB3aGVuIHRoZSBvbmdvaW5nIGZldGNoIGlzIHRlcm1pbmF0ZWQ6XG5cbiAgLy8gICAgMS4gU2V0IHJlc3BvbnNl4oCZcyBib2R5IHRvIGEgbmV3IGJvZHkgd2hvc2Ugc3RyZWFtIGlzIHN0cmVhbS5cbiAgcmVzcG9uc2UuYm9keSA9IHsgc3RyZWFtIH1cblxuICAvLyAgICAyLiBJZiByZXNwb25zZSBpcyBub3QgYSBuZXR3b3JrIGVycm9yIGFuZCByZXF1ZXN04oCZcyBjYWNoZSBtb2RlIGlzXG4gIC8vICAgIG5vdCBcIm5vLXN0b3JlXCIsIHRoZW4gdXBkYXRlIHJlc3BvbnNlIGluIGh0dHBDYWNoZSBmb3IgcmVxdWVzdC5cbiAgLy8gICAgVE9ET1xuXG4gIC8vICAgIDMuIElmIGluY2x1ZGVDcmVkZW50aWFscyBpcyB0cnVlIGFuZCB0aGUgdXNlciBhZ2VudCBpcyBub3QgY29uZmlndXJlZFxuICAvLyAgICB0byBibG9jayBjb29raWVzIGZvciByZXF1ZXN0IChzZWUgc2VjdGlvbiA3IG9mIFtDT09LSUVTXSksIHRoZW4gcnVuIHRoZVxuICAvLyAgICBcInNldC1jb29raWUtc3RyaW5nXCIgcGFyc2luZyBhbGdvcml0aG0gKHNlZSBzZWN0aW9uIDUuMiBvZiBbQ09PS0lFU10pIG9uXG4gIC8vICAgIHRoZSB2YWx1ZSBvZiBlYWNoIGhlYWRlciB3aG9zZSBuYW1lIGlzIGEgYnl0ZS1jYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvclxuICAvLyAgICBgU2V0LUNvb2tpZWAgaW4gcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LCBpZiBhbnksIGFuZCByZXF1ZXN04oCZcyBjdXJyZW50IFVSTC5cbiAgLy8gICAgVE9ET1xuXG4gIC8vIDE4LiBJZiBhYm9ydGVkLCB0aGVuOlxuICAvLyBUT0RPXG5cbiAgLy8gMTkuIFJ1biB0aGVzZSBzdGVwcyBpbiBwYXJhbGxlbDpcblxuICAvLyAgICAxLiBSdW4gdGhlc2Ugc3RlcHMsIGJ1dCBhYm9ydCB3aGVuIGZldGNoUGFyYW1zIGlzIGNhbmNlbGVkOlxuICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm9uKCd0ZXJtaW5hdGVkJywgb25BYm9ydGVkKVxuICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnJlc3VtZSA9IGFzeW5jICgpID0+IHtcbiAgICAvLyAxLiBXaGlsZSB0cnVlXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIDEtMy4gU2VlIG9uRGF0YS4uLlxuXG4gICAgICAvLyA0LiBTZXQgYnl0ZXMgdG8gdGhlIHJlc3VsdCBvZiBoYW5kbGluZyBjb250ZW50IGNvZGluZ3MgZ2l2ZW5cbiAgICAgIC8vIGNvZGluZ3MgYW5kIGJ5dGVzLlxuICAgICAgbGV0IGJ5dGVzXG4gICAgICBsZXQgaXNGYWlsdXJlXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm5leHQoKVxuXG4gICAgICAgIGlmIChpc0Fib3J0ZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ5dGVzID0gZG9uZSA/IHVuZGVmaW5lZCA6IHZhbHVlXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZW5kZWQgJiYgIXRpbWluZ0luZm8uZW5jb2RlZEJvZHlTaXplKSB7XG4gICAgICAgICAgLy8gemxpYiBkb2Vzbid0IGxpa2UgZW1wdHkgc3RyZWFtcy5cbiAgICAgICAgICBieXRlcyA9IHVuZGVmaW5lZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ5dGVzID0gZXJyXG5cbiAgICAgICAgICAvLyBlcnIgbWF5IGJlIHByb3BhZ2F0ZWQgZnJvbSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgcmVhZGFibGVzdHJlYW0uY2FuY2VsLFxuICAgICAgICAgIC8vIHdoaWNoIG1pZ2h0IG5vdCBiZSBhbiBlcnJvci4gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzIwMDlcbiAgICAgICAgICBpc0ZhaWx1cmUgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGJ5dGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gMi4gT3RoZXJ3aXNlLCBpZiB0aGUgYnl0ZXMgdHJhbnNtaXNzaW9uIGZvciByZXNwb25zZeKAmXMgbWVzc2FnZVxuICAgICAgICAvLyBib2R5IGlzIGRvbmUgbm9ybWFsbHkgYW5kIHN0cmVhbSBpcyByZWFkYWJsZSwgdGhlbiBjbG9zZVxuICAgICAgICAvLyBzdHJlYW0sIGZpbmFsaXplIHJlc3BvbnNlIGZvciBmZXRjaFBhcmFtcyBhbmQgcmVzcG9uc2UsIGFuZFxuICAgICAgICAvLyBhYm9ydCB0aGVzZSBpbi1wYXJhbGxlbCBzdGVwcy5cbiAgICAgICAgcmVhZGFibGVTdHJlYW1DbG9zZShmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2xsZXIpXG5cbiAgICAgICAgZmluYWxpemVSZXNwb25zZShmZXRjaFBhcmFtcywgcmVzcG9uc2UpXG5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDUuIEluY3JlYXNlIHRpbWluZ0luZm/igJlzIGRlY29kZWQgYm9keSBzaXplIGJ5IGJ5dGVz4oCZcyBsZW5ndGguXG4gICAgICB0aW1pbmdJbmZvLmRlY29kZWRCb2R5U2l6ZSArPSBieXRlcz8uYnl0ZUxlbmd0aCA/PyAwXG5cbiAgICAgIC8vIDYuIElmIGJ5dGVzIGlzIGZhaWx1cmUsIHRoZW4gdGVybWluYXRlIGZldGNoUGFyYW1z4oCZcyBjb250cm9sbGVyLlxuICAgICAgaWYgKGlzRmFpbHVyZSkge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnRlcm1pbmF0ZShieXRlcylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDcuIEVucXVldWUgYSBVaW50OEFycmF5IHdyYXBwaW5nIGFuIEFycmF5QnVmZmVyIGNvbnRhaW5pbmcgYnl0ZXNcbiAgICAgIC8vIGludG8gc3RyZWFtLlxuICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb250cm9sbGVyLmVucXVldWUobmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKVxuXG4gICAgICAvLyA4LiBJZiBzdHJlYW0gaXMgZXJyb3JlZCwgdGhlbiB0ZXJtaW5hdGUgdGhlIG9uZ29pbmcgZmV0Y2guXG4gICAgICBpZiAoaXNFcnJvcmVkKHN0cmVhbSkpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci50ZXJtaW5hdGUoKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gOS4gSWYgc3RyZWFtIGRvZXNu4oCZdCBuZWVkIG1vcmUgZGF0YSBhc2sgdGhlIHVzZXIgYWdlbnQgdG8gc3VzcGVuZFxuICAgICAgLy8gdGhlIG9uZ29pbmcgZmV0Y2guXG4gICAgICBpZiAoIWZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlci5kZXNpcmVkU2l6ZSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAgICAyLiBJZiBhYm9ydGVkLCB0aGVuOlxuICBmdW5jdGlvbiBvbkFib3J0ZWQgKHJlYXNvbikge1xuICAgIC8vIDIuIElmIGZldGNoUGFyYW1zIGlzIGFib3J0ZWQsIHRoZW46XG4gICAgaWYgKGlzQWJvcnRlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgIC8vIDEuIFNldCByZXNwb25zZeKAmXMgYWJvcnRlZCBmbGFnLlxuICAgICAgcmVzcG9uc2UuYWJvcnRlZCA9IHRydWVcblxuICAgICAgLy8gMi4gSWYgc3RyZWFtIGlzIHJlYWRhYmxlLCB0aGVuIGVycm9yIHN0cmVhbSB3aXRoIHRoZSByZXN1bHQgb2ZcbiAgICAgIC8vICAgIGRlc2VyaWFsaXplIGEgc2VyaWFsaXplZCBhYm9ydCByZWFzb24gZ2l2ZW4gZmV0Y2hQYXJhbXPigJlzXG4gICAgICAvLyAgICBjb250cm9sbGVy4oCZcyBzZXJpYWxpemVkIGFib3J0IHJlYXNvbiBhbmQgYW5cbiAgICAgIC8vICAgIGltcGxlbWVudGF0aW9uLWRlZmluZWQgcmVhbG0uXG4gICAgICBpZiAoaXNSZWFkYWJsZShzdHJlYW0pKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlci5lcnJvcihcbiAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnNlcmlhbGl6ZWRBYm9ydFJlYXNvblxuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDMuIE90aGVyd2lzZSwgaWYgc3RyZWFtIGlzIHJlYWRhYmxlLCBlcnJvciBzdHJlYW0gd2l0aCBhIFR5cGVFcnJvci5cbiAgICAgIGlmIChpc1JlYWRhYmxlKHN0cmVhbSkpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb250cm9sbGVyLmVycm9yKG5ldyBUeXBlRXJyb3IoJ3Rlcm1pbmF0ZWQnLCB7XG4gICAgICAgICAgY2F1c2U6IGlzRXJyb3JMaWtlKHJlYXNvbikgPyByZWFzb24gOiB1bmRlZmluZWRcbiAgICAgICAgfSkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNC4gSWYgY29ubmVjdGlvbiB1c2VzIEhUVFAvMiwgdGhlbiB0cmFuc21pdCBhbiBSU1RfU1RSRUFNIGZyYW1lLlxuICAgIC8vIDUuIE90aGVyd2lzZSwgdGhlIHVzZXIgYWdlbnQgc2hvdWxkIGNsb3NlIGNvbm5lY3Rpb24gdW5sZXNzIGl0IHdvdWxkIGJlIGJhZCBmb3IgcGVyZm9ybWFuY2UgdG8gZG8gc28uXG4gICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uLmRlc3Ryb3koKVxuICB9XG5cbiAgLy8gMjAuIFJldHVybiByZXNwb25zZS5cbiAgcmV0dXJuIHJlc3BvbnNlXG5cbiAgYXN5bmMgZnVuY3Rpb24gZGlzcGF0Y2ggKHsgYm9keSB9KSB7XG4gICAgY29uc3QgdXJsID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi4vLi4nKS5BZ2VudH0gKi9cbiAgICBjb25zdCBhZ2VudCA9IGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZGlzcGF0Y2hlclxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IGFnZW50LmRpc3BhdGNoKFxuICAgICAge1xuICAgICAgICBwYXRoOiB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoLFxuICAgICAgICBvcmlnaW46IHVybC5vcmlnaW4sXG4gICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgIGJvZHk6IGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZGlzcGF0Y2hlci5pc01vY2tBY3RpdmUgPyByZXF1ZXN0LmJvZHkgJiYgKHJlcXVlc3QuYm9keS5zb3VyY2UgfHwgcmVxdWVzdC5ib2R5LnN0cmVhbSkgOiBib2R5LFxuICAgICAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnNMaXN0LmVudHJpZXMsXG4gICAgICAgIG1heFJlZGlyZWN0aW9uczogMCxcbiAgICAgICAgdXBncmFkZTogcmVxdWVzdC5tb2RlID09PSAnd2Vic29ja2V0JyA/ICd3ZWJzb2NrZXQnIDogdW5kZWZpbmVkXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBib2R5OiBudWxsLFxuICAgICAgICBhYm9ydDogbnVsbCxcblxuICAgICAgICBvbkNvbm5lY3QgKGFib3J0KSB7XG4gICAgICAgICAgLy8gVE9ETyAoZml4KTogRG8gd2UgbmVlZCBjb25uZWN0aW9uIGhlcmU/XG4gICAgICAgICAgY29uc3QgeyBjb25uZWN0aW9uIH0gPSBmZXRjaFBhcmFtcy5jb250cm9sbGVyXG5cbiAgICAgICAgICBpZiAoY29ubmVjdGlvbi5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIGFib3J0KG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5vbigndGVybWluYXRlZCcsIGFib3J0KVxuICAgICAgICAgICAgdGhpcy5hYm9ydCA9IGNvbm5lY3Rpb24uYWJvcnQgPSBhYm9ydFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbkhlYWRlcnMgKHN0YXR1cywgaGVhZGVyc0xpc3QsIHJlc3VtZSwgc3RhdHVzVGV4dCkge1xuICAgICAgICAgIGlmIChzdGF0dXMgPCAyMDApIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBjb2RpbmdzID0gW11cbiAgICAgICAgICBsZXQgbG9jYXRpb24gPSAnJ1xuXG4gICAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKClcblxuICAgICAgICAgIC8vIEZvciBIMiwgdGhlIGhlYWRlcnMgYXJlIGEgcGxhaW4gSlMgb2JqZWN0XG4gICAgICAgICAgLy8gV2UgZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGVtIGFuZCBpdGVyYXRlIGFjY29yZGluZ2x5XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVyc0xpc3QpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBuID0gMDsgbiA8IGhlYWRlcnNMaXN0Lmxlbmd0aDsgbiArPSAyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGtleSA9IGhlYWRlcnNMaXN0W24gKyAwXS50b1N0cmluZygnbGF0aW4xJylcbiAgICAgICAgICAgICAgY29uc3QgdmFsID0gaGVhZGVyc0xpc3RbbiArIDFdLnRvU3RyaW5nKCdsYXRpbjEnKVxuICAgICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LWVuY29kaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3MjMxI3NlY3Rpb24tMy4xLjIuMVxuICAgICAgICAgICAgICAgIC8vIFwiQWxsIGNvbnRlbnQtY29kaW5nIHZhbHVlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZS4uLlwiXG4gICAgICAgICAgICAgICAgY29kaW5ncyA9IHZhbC50b0xvd2VyQ2FzZSgpLnNwbGl0KCcsJykubWFwKCh4KSA9PiB4LnRyaW0oKSlcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2xvY2F0aW9uJykge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gdmFsXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBoZWFkZXJzW2tIZWFkZXJzTGlzdF0uYXBwZW5kKGtleSwgdmFsKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaGVhZGVyc0xpc3QpXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGhlYWRlcnNMaXN0W2tleV1cbiAgICAgICAgICAgICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC1lbmNvZGluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNzIzMSNzZWN0aW9uLTMuMS4yLjFcbiAgICAgICAgICAgICAgICAvLyBcIkFsbCBjb250ZW50LWNvZGluZyB2YWx1ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUuLi5cIlxuICAgICAgICAgICAgICAgIGNvZGluZ3MgPSB2YWwudG9Mb3dlckNhc2UoKS5zcGxpdCgnLCcpLm1hcCgoeCkgPT4geC50cmltKCkpLnJldmVyc2UoKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSAnbG9jYXRpb24nKSB7XG4gICAgICAgICAgICAgICAgbG9jYXRpb24gPSB2YWxcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGhlYWRlcnNba0hlYWRlcnNMaXN0XS5hcHBlbmQoa2V5LCB2YWwpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5ib2R5ID0gbmV3IFJlYWRhYmxlKHsgcmVhZDogcmVzdW1lIH0pXG5cbiAgICAgICAgICBjb25zdCBkZWNvZGVycyA9IFtdXG5cbiAgICAgICAgICBjb25zdCB3aWxsRm9sbG93ID0gcmVxdWVzdC5yZWRpcmVjdCA9PT0gJ2ZvbGxvdycgJiZcbiAgICAgICAgICAgIGxvY2F0aW9uICYmXG4gICAgICAgICAgICByZWRpcmVjdFN0YXR1c1NldC5oYXMoc3RhdHVzKVxuXG4gICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0NvbnRlbnQtRW5jb2RpbmdcbiAgICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgIT09ICdIRUFEJyAmJiByZXF1ZXN0Lm1ldGhvZCAhPT0gJ0NPTk5FQ1QnICYmICFudWxsQm9keVN0YXR1cy5pbmNsdWRlcyhzdGF0dXMpICYmICF3aWxsRm9sbG93KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvZGluZyBvZiBjb2RpbmdzKSB7XG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MTEyLmh0bWwjc2VjdGlvbi03LjJcbiAgICAgICAgICAgICAgaWYgKGNvZGluZyA9PT0gJ3gtZ3ppcCcgfHwgY29kaW5nID09PSAnZ3ppcCcpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVycy5wdXNoKHpsaWIuY3JlYXRlR3VuemlwKHtcbiAgICAgICAgICAgICAgICAgIC8vIEJlIGxlc3Mgc3RyaWN0IHdoZW4gZGVjb2RpbmcgY29tcHJlc3NlZCByZXNwb25zZXMsIHNpbmNlIHNvbWV0aW1lc1xuICAgICAgICAgICAgICAgICAgLy8gc2VydmVycyBzZW5kIHNsaWdodGx5IGludmFsaWQgcmVzcG9uc2VzIHRoYXQgYXJlIHN0aWxsIGFjY2VwdGVkXG4gICAgICAgICAgICAgICAgICAvLyBieSBjb21tb24gYnJvd3NlcnMuXG4gICAgICAgICAgICAgICAgICAvLyBBbHdheXMgdXNpbmcgWl9TWU5DX0ZMVVNIIGlzIHdoYXQgY1VSTCBkb2VzLlxuICAgICAgICAgICAgICAgICAgZmx1c2g6IHpsaWIuY29uc3RhbnRzLlpfU1lOQ19GTFVTSCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaEZsdXNoOiB6bGliLmNvbnN0YW50cy5aX1NZTkNfRkxVU0hcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RpbmcgPT09ICdkZWZsYXRlJykge1xuICAgICAgICAgICAgICAgIGRlY29kZXJzLnB1c2goemxpYi5jcmVhdGVJbmZsYXRlKCkpXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kaW5nID09PSAnYnInKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlcnMucHVzaCh6bGliLmNyZWF0ZUJyb3RsaURlY29tcHJlc3MoKSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVycy5sZW5ndGggPSAwXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIGhlYWRlcnNMaXN0OiBoZWFkZXJzW2tIZWFkZXJzTGlzdF0sXG4gICAgICAgICAgICBib2R5OiBkZWNvZGVycy5sZW5ndGhcbiAgICAgICAgICAgICAgPyBwaXBlbGluZSh0aGlzLmJvZHksIC4uLmRlY29kZXJzLCAoKSA9PiB7IH0pXG4gICAgICAgICAgICAgIDogdGhpcy5ib2R5Lm9uKCdlcnJvcicsICgpID0+IHt9KVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uRGF0YSAoY2h1bmspIHtcbiAgICAgICAgICBpZiAoZmV0Y2hQYXJhbXMuY29udHJvbGxlci5kdW1wKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAxLiBJZiBvbmUgb3IgbW9yZSBieXRlcyBoYXZlIGJlZW4gdHJhbnNtaXR0ZWQgZnJvbSByZXNwb25zZeKAmXNcbiAgICAgICAgICAvLyBtZXNzYWdlIGJvZHksIHRoZW46XG5cbiAgICAgICAgICAvLyAgMS4gTGV0IGJ5dGVzIGJlIHRoZSB0cmFuc21pdHRlZCBieXRlcy5cbiAgICAgICAgICBjb25zdCBieXRlcyA9IGNodW5rXG5cbiAgICAgICAgICAvLyAgMi4gTGV0IGNvZGluZ3MgYmUgdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nIGhlYWRlciBsaXN0IHZhbHVlc1xuICAgICAgICAgIC8vICBnaXZlbiBgQ29udGVudC1FbmNvZGluZ2AgYW5kIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cbiAgICAgICAgICAvLyAgU2VlIHB1bGxBbGdvcml0aG0uXG5cbiAgICAgICAgICAvLyAgMy4gSW5jcmVhc2UgdGltaW5nSW5mb+KAmXMgZW5jb2RlZCBib2R5IHNpemUgYnkgYnl0ZXPigJlzIGxlbmd0aC5cbiAgICAgICAgICB0aW1pbmdJbmZvLmVuY29kZWRCb2R5U2l6ZSArPSBieXRlcy5ieXRlTGVuZ3RoXG5cbiAgICAgICAgICAvLyAgNC4gU2VlIHB1bGxBbGdvcml0aG0uLi5cblxuICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkucHVzaChieXRlcylcbiAgICAgICAgfSxcblxuICAgICAgICBvbkNvbXBsZXRlICgpIHtcbiAgICAgICAgICBpZiAodGhpcy5hYm9ydCkge1xuICAgICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5vZmYoJ3Rlcm1pbmF0ZWQnLCB0aGlzLmFib3J0KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZW5kZWQgPSB0cnVlXG5cbiAgICAgICAgICB0aGlzLmJvZHkucHVzaChudWxsKVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uRXJyb3IgKGVycm9yKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYWJvcnQpIHtcbiAgICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIub2ZmKCd0ZXJtaW5hdGVkJywgdGhpcy5hYm9ydClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmJvZHk/LmRlc3Ryb3koZXJyb3IpXG5cbiAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnRlcm1pbmF0ZShlcnJvcilcblxuICAgICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgICAgfSxcblxuICAgICAgICBvblVwZ3JhZGUgKHN0YXR1cywgaGVhZGVyc0xpc3QsIHNvY2tldCkge1xuICAgICAgICAgIGlmIChzdGF0dXMgIT09IDEwMSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKClcblxuICAgICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgaGVhZGVyc0xpc3QubGVuZ3RoOyBuICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGhlYWRlcnNMaXN0W24gKyAwXS50b1N0cmluZygnbGF0aW4xJylcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IGhlYWRlcnNMaXN0W24gKyAxXS50b1N0cmluZygnbGF0aW4xJylcblxuICAgICAgICAgICAgaGVhZGVyc1trSGVhZGVyc0xpc3RdLmFwcGVuZChrZXksIHZhbClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IFNUQVRVU19DT0RFU1tzdGF0dXNdLFxuICAgICAgICAgICAgaGVhZGVyc0xpc3Q6IGhlYWRlcnNba0hlYWRlcnNMaXN0XSxcbiAgICAgICAgICAgIHNvY2tldFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZmV0Y2gsXG4gIEZldGNoLFxuICBmZXRjaGluZyxcbiAgZmluYWxpemVBbmRSZXBvcnRUaW1pbmdcbn1cbiJdLCJuYW1lcyI6WyJSZXNwb25zZSIsIm1ha2VOZXR3b3JrRXJyb3IiLCJtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IiLCJmaWx0ZXJSZXNwb25zZSIsIm1ha2VSZXNwb25zZSIsInJlcXVpcmUiLCJIZWFkZXJzIiwiUmVxdWVzdCIsIm1ha2VSZXF1ZXN0IiwiemxpYiIsImJ5dGVzTWF0Y2giLCJtYWtlUG9saWN5Q29udGFpbmVyIiwiY2xvbmVQb2xpY3lDb250YWluZXIiLCJyZXF1ZXN0QmFkUG9ydCIsIlRBT0NoZWNrIiwiYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlciIsInJlc3BvbnNlTG9jYXRpb25VUkwiLCJyZXF1ZXN0Q3VycmVudFVSTCIsInNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3QiLCJ0cnlVcGdyYWRlUmVxdWVzdFRvQVBvdGVudGlhbGx5VHJ1c3R3b3J0aHlVUkwiLCJjcmVhdGVPcGFxdWVUaW1pbmdJbmZvIiwiYXBwZW5kRmV0Y2hNZXRhZGF0YSIsImNvcnNDaGVjayIsImNyb3NzT3JpZ2luUmVzb3VyY2VQb2xpY3lDaGVjayIsImRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIiLCJjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZSIsImNyZWF0ZURlZmVycmVkUHJvbWlzZSIsImlzQmxvYkxpa2UiLCJzYW1lT3JpZ2luIiwiaXNDYW5jZWxsZWQiLCJpc0Fib3J0ZWQiLCJpc0Vycm9yTGlrZSIsImZ1bGx5UmVhZEJvZHkiLCJyZWFkYWJsZVN0cmVhbUNsb3NlIiwiaXNvbW9ycGhpY0VuY29kZSIsInVybElzTG9jYWwiLCJ1cmxJc0h0dHBIdHRwc1NjaGVtZSIsInVybEhhc0h0dHBzU2NoZW1lIiwia1N0YXRlIiwia0hlYWRlcnMiLCJrR3VhcmQiLCJrUmVhbG0iLCJhc3NlcnQiLCJzYWZlbHlFeHRyYWN0Qm9keSIsInJlZGlyZWN0U3RhdHVzU2V0IiwibnVsbEJvZHlTdGF0dXMiLCJzYWZlTWV0aG9kc1NldCIsInJlcXVlc3RCb2R5SGVhZGVyIiwic3VicmVzb3VyY2VTZXQiLCJET01FeGNlcHRpb24iLCJrSGVhZGVyc0xpc3QiLCJFRSIsIlJlYWRhYmxlIiwicGlwZWxpbmUiLCJhZGRBYm9ydExpc3RlbmVyIiwiaXNFcnJvcmVkIiwiaXNSZWFkYWJsZSIsIm5vZGVNYWpvciIsIm5vZGVNaW5vciIsImRhdGFVUkxQcm9jZXNzb3IiLCJzZXJpYWxpemVBTWltZVR5cGUiLCJUcmFuc2Zvcm1TdHJlYW0iLCJnZXRHbG9iYWxEaXNwYXRjaGVyIiwid2ViaWRsIiwiU1RBVFVTX0NPREVTIiwiR0VUX09SX0hFQUQiLCJyZXNvbHZlT2JqZWN0VVJMIiwiUmVhZGFibGVTdHJlYW0iLCJnbG9iYWxUaGlzIiwiRmV0Y2giLCJjb25zdHJ1Y3RvciIsImRpc3BhdGNoZXIiLCJjb25uZWN0aW9uIiwiZHVtcCIsInN0YXRlIiwic2V0TWF4TGlzdGVuZXJzIiwidGVybWluYXRlIiwicmVhc29uIiwiZGVzdHJveSIsImVtaXQiLCJhYm9ydCIsImVycm9yIiwic2VyaWFsaXplZEFib3J0UmVhc29uIiwiZmV0Y2giLCJpbnB1dCIsImluaXQiLCJhcmd1bWVudExlbmd0aENoZWNrIiwiYXJndW1lbnRzIiwiaGVhZGVyIiwicCIsInJlcXVlc3RPYmplY3QiLCJlIiwicmVqZWN0IiwicHJvbWlzZSIsInJlcXVlc3QiLCJzaWduYWwiLCJhYm9ydGVkIiwiYWJvcnRGZXRjaCIsImdsb2JhbE9iamVjdCIsImNsaWVudCIsIm5hbWUiLCJzZXJ2aWNlV29ya2VycyIsInJlc3BvbnNlT2JqZWN0IiwicmVsZXZhbnRSZWFsbSIsImxvY2FsbHlBYm9ydGVkIiwiY29udHJvbGxlciIsImhhbmRsZUZldGNoRG9uZSIsInJlc3BvbnNlIiwiZmluYWxpemVBbmRSZXBvcnRUaW1pbmciLCJwcm9jZXNzUmVzcG9uc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInR5cGUiLCJPYmplY3QiLCJhc3NpZ24iLCJUeXBlRXJyb3IiLCJjYXVzZSIsImhlYWRlcnNMaXN0IiwiZmV0Y2hpbmciLCJwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkiLCJpbml0aWF0b3JUeXBlIiwidXJsTGlzdCIsImxlbmd0aCIsIm9yaWdpbmFsVVJMIiwidGltaW5nSW5mbyIsImNhY2hlU3RhdGUiLCJ0aW1pbmdBbGxvd1Bhc3NlZCIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJtYXJrUmVzb3VyY2VUaW1pbmciLCJwZXJmb3JtYW5jZSIsImhyZWYiLCJib2R5Iiwic3RyZWFtIiwiY2FuY2VsIiwiY2F0Y2giLCJlcnIiLCJjb2RlIiwicHJvY2Vzc1JlcXVlc3RCb2R5Q2h1bmtMZW5ndGgiLCJwcm9jZXNzUmVxdWVzdEVuZE9mQm9keSIsInByb2Nlc3NSZXNwb25zZUNvbnN1bWVCb2R5IiwidXNlUGFyYWxsZWxRdWV1ZSIsInRhc2tEZXN0aW5hdGlvbiIsImNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5IiwiY3VycmVuVGltZSIsImZldGNoUGFyYW1zIiwid2luZG93Iiwib3JpZ2luIiwicG9saWN5Q29udGFpbmVyIiwiY29udGFpbnMiLCJ2YWx1ZSIsImFwcGVuZCIsInByaW9yaXR5IiwiaGFzIiwiZGVzdGluYXRpb24iLCJtYWluRmV0Y2giLCJyZWN1cnNpdmUiLCJsb2NhbFVSTHNPbmx5IiwicmVmZXJyZXJQb2xpY3kiLCJyZWZlcnJlciIsImN1cnJlbnRVUkwiLCJ1cmwiLCJyZXNwb25zZVRhaW50aW5nIiwicHJvdG9jb2wiLCJtb2RlIiwic2NoZW1lRmV0Y2giLCJyZWRpcmVjdCIsImh0dHBGZXRjaCIsInN0YXR1cyIsImludGVybmFsUmVzcG9uc2UiLCJwdXNoIiwidGltaW5nQWxsb3dGYWlsZWQiLCJyYW5nZVJlcXVlc3RlZCIsImhlYWRlcnMiLCJtZXRob2QiLCJpbmNsdWRlcyIsImludGVncml0eSIsInByb2Nlc3NCb2R5RXJyb3IiLCJmZXRjaEZpbmFsZSIsInByb2Nlc3NCb2R5IiwiYnl0ZXMiLCJyZWRpcmVjdENvdW50Iiwic2NoZW1lIiwiYmxvYlVSTEVudHJ5Iiwic2VhcmNoIiwiYmxvYlVSTEVudHJ5T2JqZWN0IiwidG9TdHJpbmciLCJib2R5V2l0aFR5cGUiLCJzdGF0dXNUZXh0IiwiZGF0YVVSTFN0cnVjdCIsIm1pbWVUeXBlIiwiZmluYWxpemVSZXNwb25zZSIsImRvbmUiLCJwcm9jZXNzUmVzcG9uc2VEb25lIiwicXVldWVNaWNyb3Rhc2siLCJpZGVudGl0eVRyYW5zZm9ybUFsZ29yaXRobSIsImNodW5rIiwiZW5xdWV1ZSIsInRyYW5zZm9ybVN0cmVhbSIsInN0YXJ0IiwidHJhbnNmb3JtIiwiZmx1c2giLCJzaXplIiwicGlwZVRocm91Z2giLCJudWxsT3JCeXRlcyIsImZhaWx1cmUiLCJhY3R1YWxSZXNwb25zZSIsImh0dHBOZXR3b3JrT3JDYWNoZUZldGNoIiwiaHR0cFJlZGlyZWN0RmV0Y2giLCJsb2NhdGlvblVSTCIsImhhc2giLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwic291cmNlIiwiaGVhZGVyTmFtZSIsImRlbGV0ZSIsInJlZGlyZWN0RW5kVGltZSIsInBvc3RSZWRpcmVjdFN0YXJ0VGltZSIsInJlZGlyZWN0U3RhcnRUaW1lIiwiaXNBdXRoZW50aWNhdGlvbkZldGNoIiwiaXNOZXdDb25uZWN0aW9uRmV0Y2giLCJodHRwRmV0Y2hQYXJhbXMiLCJodHRwUmVxdWVzdCIsImh0dHBDYWNoZSIsInJldmFsaWRhdGluZ0ZsYWciLCJpbmNsdWRlQ3JlZGVudGlhbHMiLCJjcmVkZW50aWFscyIsImNvbnRlbnRMZW5ndGgiLCJjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUiLCJrZWVwYWxpdmUiLCJVUkwiLCJlc2J1aWxkRGV0ZWN0aW9uIiwiY2FjaGUiLCJwcmV2ZW50Tm9DYWNoZUNhY2hlQ29udHJvbEhlYWRlck1vZGlmaWNhdGlvbiIsImZvcndhcmRSZXNwb25zZSIsImh0dHBOZXR3b3JrRmV0Y2giLCJyZXF1ZXN0SW5jbHVkZXNDcmVkZW50aWFscyIsImZvcmNlTmV3Q29ubmVjdGlvbiIsImRlc3Ryb3llZCIsIm5ld0Nvbm5lY3Rpb24iLCJyZXF1ZXN0Qm9keSIsInByb2Nlc3NCb2R5Q2h1bmsiLCJieXRlTGVuZ3RoIiwicHJvY2Vzc0VuZE9mQm9keSIsInNvY2tldCIsImRpc3BhdGNoIiwiaXRlcmF0b3IiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwibmV4dCIsInB1bGxBbGdvcml0aG0iLCJyZXN1bWUiLCJjYW5jZWxBbGdvcml0aG0iLCJwdWxsIiwiaGlnaFdhdGVyTWFyayIsIm9uIiwib25BYm9ydGVkIiwiaXNGYWlsdXJlIiwidW5kZWZpbmVkIiwiZW5kZWQiLCJlbmNvZGVkQm9keVNpemUiLCJkZWNvZGVkQm9keVNpemUiLCJVaW50OEFycmF5IiwiZGVzaXJlZFNpemUiLCJhZ2VudCIsInBhdGgiLCJwYXRobmFtZSIsImlzTW9ja0FjdGl2ZSIsImVudHJpZXMiLCJtYXhSZWRpcmVjdGlvbnMiLCJ1cGdyYWRlIiwib25Db25uZWN0Iiwib25IZWFkZXJzIiwiY29kaW5ncyIsImxvY2F0aW9uIiwiQXJyYXkiLCJpc0FycmF5IiwibiIsImtleSIsInZhbCIsInRvTG93ZXJDYXNlIiwic3BsaXQiLCJtYXAiLCJ4IiwidHJpbSIsImtleXMiLCJyZXZlcnNlIiwicmVhZCIsImRlY29kZXJzIiwid2lsbEZvbGxvdyIsImNvZGluZyIsImNyZWF0ZUd1bnppcCIsImNvbnN0YW50cyIsIlpfU1lOQ19GTFVTSCIsImZpbmlzaEZsdXNoIiwiY3JlYXRlSW5mbGF0ZSIsImNyZWF0ZUJyb3RsaURlY29tcHJlc3MiLCJvbkRhdGEiLCJvbkNvbXBsZXRlIiwib2ZmIiwib25FcnJvciIsIm9uVXBncmFkZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/request.js":
/*!************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/fetch/request.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* globals AbortController */ \nconst { extractBody, mixinBody, cloneBody } = __webpack_require__(/*! ./body */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/body.js\");\nconst { Headers, fill: fillHeaders, HeadersList } = __webpack_require__(/*! ./headers */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/headers.js\");\nconst { FinalizationRegistry } = __webpack_require__(/*! ../compat/dispatcher-weakref */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/compat/dispatcher-weakref.js\")();\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst { isValidHTTPToken, sameOrigin, normalizeMethod, makePolicyContainer, normalizeMethodRecord } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/util.js\");\nconst { forbiddenMethodsSet, corsSafeListedMethodsSet, referrerPolicy, requestRedirect, requestMode, requestCredentials, requestCache, requestDuplex } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/constants.js\");\nconst { kEnumerableProperty } = util;\nconst { kHeaders, kSignal, kState, kGuard, kRealm } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/webidl.js\");\nconst { getGlobalOrigin } = __webpack_require__(/*! ./global */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/global.js\");\nconst { URLSerializer } = __webpack_require__(/*! ./dataURL */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/dataURL.js\");\nconst { kHeadersList, kConstruct } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = __webpack_require__(/*! events */ \"events\");\nlet TransformStream = globalThis.TransformStream;\nconst kAbortController = Symbol(\"abortController\");\nconst requestFinalizer = new FinalizationRegistry(({ signal, abort })=>{\n    signal.removeEventListener(\"abort\", abort);\n});\n// https://fetch.spec.whatwg.org/#request-class\nclass Request {\n    // https://fetch.spec.whatwg.org/#dom-request\n    constructor(input, init = {}){\n        if (input === kConstruct) {\n            return;\n        }\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Request constructor\"\n        });\n        input = webidl.converters.RequestInfo(input);\n        init = webidl.converters.RequestInit(init);\n        // https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object\n        this[kRealm] = {\n            settingsObject: {\n                baseUrl: getGlobalOrigin(),\n                get origin () {\n                    return this.baseUrl?.origin;\n                },\n                policyContainer: makePolicyContainer()\n            }\n        };\n        // 1. Let request be null.\n        let request = null;\n        // 2. Let fallbackMode be null.\n        let fallbackMode = null;\n        // 3. Let baseURL be thiss relevant settings objects API base URL.\n        const baseUrl = this[kRealm].settingsObject.baseUrl;\n        // 4. Let signal be null.\n        let signal = null;\n        // 5. If input is a string, then:\n        if (typeof input === \"string\") {\n            // 1. Let parsedURL be the result of parsing input with baseURL.\n            // 2. If parsedURL is failure, then throw a TypeError.\n            let parsedURL;\n            try {\n                parsedURL = new URL(input, baseUrl);\n            } catch (err) {\n                throw new TypeError(\"Failed to parse URL from \" + input, {\n                    cause: err\n                });\n            }\n            // 3. If parsedURL includes credentials, then throw a TypeError.\n            if (parsedURL.username || parsedURL.password) {\n                throw new TypeError(\"Request cannot be constructed from a URL that includes credentials: \" + input);\n            }\n            // 4. Set request to a new request whose URL is parsedURL.\n            request = makeRequest({\n                urlList: [\n                    parsedURL\n                ]\n            });\n            // 5. Set fallbackMode to \"cors\".\n            fallbackMode = \"cors\";\n        } else {\n            // 6. Otherwise:\n            // 7. Assert: input is a Request object.\n            assert(input instanceof Request);\n            // 8. Set request to inputs request.\n            request = input[kState];\n            // 9. Set signal to inputs signal.\n            signal = input[kSignal];\n        }\n        // 7. Let origin be thiss relevant settings objects origin.\n        const origin = this[kRealm].settingsObject.origin;\n        // 8. Let window be \"client\".\n        let window = \"client\";\n        // 9. If requests window is an environment settings object and its origin\n        // is same origin with origin, then set window to requests window.\n        if (request.window?.constructor?.name === \"EnvironmentSettingsObject\" && sameOrigin(request.window, origin)) {\n            window = request.window;\n        }\n        // 10. If init[\"window\"] exists and is non-null, then throw a TypeError.\n        if (init.window != null) {\n            throw new TypeError(`'window' option '${window}' must be null`);\n        }\n        // 11. If init[\"window\"] exists, then set window to \"no-window\".\n        if (\"window\" in init) {\n            window = \"no-window\";\n        }\n        // 12. Set request to a new request with the following properties:\n        request = makeRequest({\n            // URL requests URL.\n            // undici implementation note: this is set as the first item in request's urlList in makeRequest\n            // method requests method.\n            method: request.method,\n            // header list A copy of requests header list.\n            // undici implementation note: headersList is cloned in makeRequest\n            headersList: request.headersList,\n            // unsafe-request flag Set.\n            unsafeRequest: request.unsafeRequest,\n            // client Thiss relevant settings object.\n            client: this[kRealm].settingsObject,\n            // window window.\n            window,\n            // priority requests priority.\n            priority: request.priority,\n            // origin requests origin. The propagation of the origin is only significant for navigation requests\n            // being handled by a service worker. In this scenario a request can have an origin that is different\n            // from the current client.\n            origin: request.origin,\n            // referrer requests referrer.\n            referrer: request.referrer,\n            // referrer policy requests referrer policy.\n            referrerPolicy: request.referrerPolicy,\n            // mode requests mode.\n            mode: request.mode,\n            // credentials mode requests credentials mode.\n            credentials: request.credentials,\n            // cache mode requests cache mode.\n            cache: request.cache,\n            // redirect mode requests redirect mode.\n            redirect: request.redirect,\n            // integrity metadata requests integrity metadata.\n            integrity: request.integrity,\n            // keepalive requests keepalive.\n            keepalive: request.keepalive,\n            // reload-navigation flag requests reload-navigation flag.\n            reloadNavigation: request.reloadNavigation,\n            // history-navigation flag requests history-navigation flag.\n            historyNavigation: request.historyNavigation,\n            // URL list A clone of requests URL list.\n            urlList: [\n                ...request.urlList\n            ]\n        });\n        const initHasKey = Object.keys(init).length !== 0;\n        // 13. If init is not empty, then:\n        if (initHasKey) {\n            // 1. If requests mode is \"navigate\", then set it to \"same-origin\".\n            if (request.mode === \"navigate\") {\n                request.mode = \"same-origin\";\n            }\n            // 2. Unset requests reload-navigation flag.\n            request.reloadNavigation = false;\n            // 3. Unset requests history-navigation flag.\n            request.historyNavigation = false;\n            // 4. Set requests origin to \"client\".\n            request.origin = \"client\";\n            // 5. Set requests referrer to \"client\"\n            request.referrer = \"client\";\n            // 6. Set requests referrer policy to the empty string.\n            request.referrerPolicy = \"\";\n            // 7. Set requests URL to requests current URL.\n            request.url = request.urlList[request.urlList.length - 1];\n            // 8. Set requests URL list to  requests URL .\n            request.urlList = [\n                request.url\n            ];\n        }\n        // 14. If init[\"referrer\"] exists, then:\n        if (init.referrer !== undefined) {\n            // 1. Let referrer be init[\"referrer\"].\n            const referrer = init.referrer;\n            // 2. If referrer is the empty string, then set requests referrer to \"no-referrer\".\n            if (referrer === \"\") {\n                request.referrer = \"no-referrer\";\n            } else {\n                // 1. Let parsedReferrer be the result of parsing referrer with\n                // baseURL.\n                // 2. If parsedReferrer is failure, then throw a TypeError.\n                let parsedReferrer;\n                try {\n                    parsedReferrer = new URL(referrer, baseUrl);\n                } catch (err) {\n                    throw new TypeError(`Referrer \"${referrer}\" is not a valid URL.`, {\n                        cause: err\n                    });\n                }\n                // 3. If one of the following is true\n                // - parsedReferrers scheme is \"about\" and path is the string \"client\"\n                // - parsedReferrers origin is not same origin with origin\n                // then set requests referrer to \"client\".\n                if (parsedReferrer.protocol === \"about:\" && parsedReferrer.hostname === \"client\" || origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl)) {\n                    request.referrer = \"client\";\n                } else {\n                    // 4. Otherwise, set requests referrer to parsedReferrer.\n                    request.referrer = parsedReferrer;\n                }\n            }\n        }\n        // 15. If init[\"referrerPolicy\"] exists, then set requests referrer policy\n        // to it.\n        if (init.referrerPolicy !== undefined) {\n            request.referrerPolicy = init.referrerPolicy;\n        }\n        // 16. Let mode be init[\"mode\"] if it exists, and fallbackMode otherwise.\n        let mode;\n        if (init.mode !== undefined) {\n            mode = init.mode;\n        } else {\n            mode = fallbackMode;\n        }\n        // 17. If mode is \"navigate\", then throw a TypeError.\n        if (mode === \"navigate\") {\n            throw webidl.errors.exception({\n                header: \"Request constructor\",\n                message: \"invalid request mode navigate.\"\n            });\n        }\n        // 18. If mode is non-null, set requests mode to mode.\n        if (mode != null) {\n            request.mode = mode;\n        }\n        // 19. If init[\"credentials\"] exists, then set requests credentials mode\n        // to it.\n        if (init.credentials !== undefined) {\n            request.credentials = init.credentials;\n        }\n        // 18. If init[\"cache\"] exists, then set requests cache mode to it.\n        if (init.cache !== undefined) {\n            request.cache = init.cache;\n        }\n        // 21. If requests cache mode is \"only-if-cached\" and requests mode is\n        // not \"same-origin\", then throw a TypeError.\n        if (request.cache === \"only-if-cached\" && request.mode !== \"same-origin\") {\n            throw new TypeError(\"'only-if-cached' can be set only with 'same-origin' mode\");\n        }\n        // 22. If init[\"redirect\"] exists, then set requests redirect mode to it.\n        if (init.redirect !== undefined) {\n            request.redirect = init.redirect;\n        }\n        // 23. If init[\"integrity\"] exists, then set requests integrity metadata to it.\n        if (init.integrity != null) {\n            request.integrity = String(init.integrity);\n        }\n        // 24. If init[\"keepalive\"] exists, then set requests keepalive to it.\n        if (init.keepalive !== undefined) {\n            request.keepalive = Boolean(init.keepalive);\n        }\n        // 25. If init[\"method\"] exists, then:\n        if (init.method !== undefined) {\n            // 1. Let method be init[\"method\"].\n            let method = init.method;\n            // 2. If method is not a method or method is a forbidden method, then\n            // throw a TypeError.\n            if (!isValidHTTPToken(method)) {\n                throw new TypeError(`'${method}' is not a valid HTTP method.`);\n            }\n            if (forbiddenMethodsSet.has(method.toUpperCase())) {\n                throw new TypeError(`'${method}' HTTP method is unsupported.`);\n            }\n            // 3. Normalize method.\n            method = normalizeMethodRecord[method] ?? normalizeMethod(method);\n            // 4. Set requests method to method.\n            request.method = method;\n        }\n        // 26. If init[\"signal\"] exists, then set signal to it.\n        if (init.signal !== undefined) {\n            signal = init.signal;\n        }\n        // 27. Set thiss request to request.\n        this[kState] = request;\n        // 28. Set thiss signal to a new AbortSignal object with thiss relevant\n        // Realm.\n        // TODO: could this be simplified with AbortSignal.any\n        // (https://dom.spec.whatwg.org/#dom-abortsignal-any)\n        const ac = new AbortController();\n        this[kSignal] = ac.signal;\n        this[kSignal][kRealm] = this[kRealm];\n        // 29. If signal is not null, then make thiss signal follow signal.\n        if (signal != null) {\n            if (!signal || typeof signal.aborted !== \"boolean\" || typeof signal.addEventListener !== \"function\") {\n                throw new TypeError(\"Failed to construct 'Request': member signal is not of type AbortSignal.\");\n            }\n            if (signal.aborted) {\n                ac.abort(signal.reason);\n            } else {\n                // Keep a strong ref to ac while request object\n                // is alive. This is needed to prevent AbortController\n                // from being prematurely garbage collected.\n                // See, https://github.com/nodejs/undici/issues/1926.\n                this[kAbortController] = ac;\n                const acRef = new WeakRef(ac);\n                const abort = function() {\n                    const ac = acRef.deref();\n                    if (ac !== undefined) {\n                        ac.abort(this.reason);\n                    }\n                };\n                // Third-party AbortControllers may not work with these.\n                // See, https://github.com/nodejs/undici/pull/1910#issuecomment-1464495619.\n                try {\n                    // If the max amount of listeners is equal to the default, increase it\n                    // This is only available in node >= v19.9.0\n                    if (typeof getMaxListeners === \"function\" && getMaxListeners(signal) === defaultMaxListeners) {\n                        setMaxListeners(100, signal);\n                    } else if (getEventListeners(signal, \"abort\").length >= defaultMaxListeners) {\n                        setMaxListeners(100, signal);\n                    }\n                } catch  {}\n                util.addAbortListener(signal, abort);\n                requestFinalizer.register(ac, {\n                    signal,\n                    abort\n                });\n            }\n        }\n        // 30. Set thiss headers to a new Headers object with thiss relevant\n        // Realm, whose header list is requests header list and guard is\n        // \"request\".\n        this[kHeaders] = new Headers(kConstruct);\n        this[kHeaders][kHeadersList] = request.headersList;\n        this[kHeaders][kGuard] = \"request\";\n        this[kHeaders][kRealm] = this[kRealm];\n        // 31. If thiss requests mode is \"no-cors\", then:\n        if (mode === \"no-cors\") {\n            // 1. If thiss requests method is not a CORS-safelisted method,\n            // then throw a TypeError.\n            if (!corsSafeListedMethodsSet.has(request.method)) {\n                throw new TypeError(`'${request.method} is unsupported in no-cors mode.`);\n            }\n            // 2. Set thiss headerss guard to \"request-no-cors\".\n            this[kHeaders][kGuard] = \"request-no-cors\";\n        }\n        // 32. If init is not empty, then:\n        if (initHasKey) {\n            /** @type {HeadersList} */ const headersList = this[kHeaders][kHeadersList];\n            // 1. Let headers be a copy of thiss headers and its associated header\n            // list.\n            // 2. If init[\"headers\"] exists, then set headers to init[\"headers\"].\n            const headers = init.headers !== undefined ? init.headers : new HeadersList(headersList);\n            // 3. Empty thiss headerss header list.\n            headersList.clear();\n            // 4. If headers is a Headers object, then for each header in its header\n            // list, append headers name/headers value to thiss headers.\n            if (headers instanceof HeadersList) {\n                for (const [key, val] of headers){\n                    headersList.append(key, val);\n                }\n                // Note: Copy the `set-cookie` meta-data.\n                headersList.cookies = headers.cookies;\n            } else {\n                // 5. Otherwise, fill thiss headers with headers.\n                fillHeaders(this[kHeaders], headers);\n            }\n        }\n        // 33. Let inputBody be inputs requests body if input is a Request\n        // object; otherwise null.\n        const inputBody = input instanceof Request ? input[kState].body : null;\n        // 34. If either init[\"body\"] exists and is non-null or inputBody is\n        // non-null, and requests method is `GET` or `HEAD`, then throw a\n        // TypeError.\n        if ((init.body != null || inputBody != null) && (request.method === \"GET\" || request.method === \"HEAD\")) {\n            throw new TypeError(\"Request with GET/HEAD method cannot have body.\");\n        }\n        // 35. Let initBody be null.\n        let initBody = null;\n        // 36. If init[\"body\"] exists and is non-null, then:\n        if (init.body != null) {\n            // 1. Let Content-Type be null.\n            // 2. Set initBody and Content-Type to the result of extracting\n            // init[\"body\"], with keepalive set to requests keepalive.\n            const [extractedBody, contentType] = extractBody(init.body, request.keepalive);\n            initBody = extractedBody;\n            // 3, If Content-Type is non-null and thiss headerss header list does\n            // not contain `Content-Type`, then append `Content-Type`/Content-Type to\n            // thiss headers.\n            if (contentType && !this[kHeaders][kHeadersList].contains(\"content-type\")) {\n                this[kHeaders].append(\"content-type\", contentType);\n            }\n        }\n        // 37. Let inputOrInitBody be initBody if it is non-null; otherwise\n        // inputBody.\n        const inputOrInitBody = initBody ?? inputBody;\n        // 38. If inputOrInitBody is non-null and inputOrInitBodys source is\n        // null, then:\n        if (inputOrInitBody != null && inputOrInitBody.source == null) {\n            // 1. If initBody is non-null and init[\"duplex\"] does not exist,\n            //    then throw a TypeError.\n            if (initBody != null && init.duplex == null) {\n                throw new TypeError(\"RequestInit: duplex option is required when sending a body.\");\n            }\n            // 2. If thiss requests mode is neither \"same-origin\" nor \"cors\",\n            // then throw a TypeError.\n            if (request.mode !== \"same-origin\" && request.mode !== \"cors\") {\n                throw new TypeError('If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"');\n            }\n            // 3. Set thiss requests use-CORS-preflight flag.\n            request.useCORSPreflightFlag = true;\n        }\n        // 39. Let finalBody be inputOrInitBody.\n        let finalBody = inputOrInitBody;\n        // 40. If initBody is null and inputBody is non-null, then:\n        if (initBody == null && inputBody != null) {\n            // 1. If input is unusable, then throw a TypeError.\n            if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {\n                throw new TypeError(\"Cannot construct a Request with a Request object that has already been used.\");\n            }\n            // 2. Set finalBody to the result of creating a proxy for inputBody.\n            if (!TransformStream) {\n                TransformStream = (__webpack_require__(/*! stream/web */ \"stream/web\").TransformStream);\n            }\n            // https://streams.spec.whatwg.org/#readablestream-create-a-proxy\n            const identityTransform = new TransformStream();\n            inputBody.stream.pipeThrough(identityTransform);\n            finalBody = {\n                source: inputBody.source,\n                length: inputBody.length,\n                stream: identityTransform.readable\n            };\n        }\n        // 41. Set thiss requests body to finalBody.\n        this[kState].body = finalBody;\n    }\n    // Returns requests HTTP method, which is \"GET\" by default.\n    get method() {\n        webidl.brandCheck(this, Request);\n        // The method getter steps are to return thiss requests method.\n        return this[kState].method;\n    }\n    // Returns the URL of request as a string.\n    get url() {\n        webidl.brandCheck(this, Request);\n        // The url getter steps are to return thiss requests URL, serialized.\n        return URLSerializer(this[kState].url);\n    }\n    // Returns a Headers object consisting of the headers associated with request.\n    // Note that headers added in the network layer by the user agent will not\n    // be accounted for in this object, e.g., the \"Host\" header.\n    get headers() {\n        webidl.brandCheck(this, Request);\n        // The headers getter steps are to return thiss headers.\n        return this[kHeaders];\n    }\n    // Returns the kind of resource requested by request, e.g., \"document\"\n    // or \"script\".\n    get destination() {\n        webidl.brandCheck(this, Request);\n        // The destination getter are to return thiss requests destination.\n        return this[kState].destination;\n    }\n    // Returns the referrer of request. Its value can be a same-origin URL if\n    // explicitly set in init, the empty string to indicate no referrer, and\n    // \"about:client\" when defaulting to the globals default. This is used\n    // during fetching to determine the value of the `Referer` header of the\n    // request being made.\n    get referrer() {\n        webidl.brandCheck(this, Request);\n        // 1. If thiss requests referrer is \"no-referrer\", then return the\n        // empty string.\n        if (this[kState].referrer === \"no-referrer\") {\n            return \"\";\n        }\n        // 2. If thiss requests referrer is \"client\", then return\n        // \"about:client\".\n        if (this[kState].referrer === \"client\") {\n            return \"about:client\";\n        }\n        // Return thiss requests referrer, serialized.\n        return this[kState].referrer.toString();\n    }\n    // Returns the referrer policy associated with request.\n    // This is used during fetching to compute the value of the requests\n    // referrer.\n    get referrerPolicy() {\n        webidl.brandCheck(this, Request);\n        // The referrerPolicy getter steps are to return thiss requests referrer policy.\n        return this[kState].referrerPolicy;\n    }\n    // Returns the mode associated with request, which is a string indicating\n    // whether the request will use CORS, or will be restricted to same-origin\n    // URLs.\n    get mode() {\n        webidl.brandCheck(this, Request);\n        // The mode getter steps are to return thiss requests mode.\n        return this[kState].mode;\n    }\n    // Returns the credentials mode associated with request,\n    // which is a string indicating whether credentials will be sent with the\n    // request always, never, or only when sent to a same-origin URL.\n    get credentials() {\n        // The credentials getter steps are to return thiss requests credentials mode.\n        return this[kState].credentials;\n    }\n    // Returns the cache mode associated with request,\n    // which is a string indicating how the request will\n    // interact with the browsers cache when fetching.\n    get cache() {\n        webidl.brandCheck(this, Request);\n        // The cache getter steps are to return thiss requests cache mode.\n        return this[kState].cache;\n    }\n    // Returns the redirect mode associated with request,\n    // which is a string indicating how redirects for the\n    // request will be handled during fetching. A request\n    // will follow redirects by default.\n    get redirect() {\n        webidl.brandCheck(this, Request);\n        // The redirect getter steps are to return thiss requests redirect mode.\n        return this[kState].redirect;\n    }\n    // Returns requests subresource integrity metadata, which is a\n    // cryptographic hash of the resource being fetched. Its value\n    // consists of multiple hashes separated by whitespace. [SRI]\n    get integrity() {\n        webidl.brandCheck(this, Request);\n        // The integrity getter steps are to return thiss requests integrity\n        // metadata.\n        return this[kState].integrity;\n    }\n    // Returns a boolean indicating whether or not request can outlive the\n    // global in which it was created.\n    get keepalive() {\n        webidl.brandCheck(this, Request);\n        // The keepalive getter steps are to return thiss requests keepalive.\n        return this[kState].keepalive;\n    }\n    // Returns a boolean indicating whether or not request is for a reload\n    // navigation.\n    get isReloadNavigation() {\n        webidl.brandCheck(this, Request);\n        // The isReloadNavigation getter steps are to return true if thiss\n        // requests reload-navigation flag is set; otherwise false.\n        return this[kState].reloadNavigation;\n    }\n    // Returns a boolean indicating whether or not request is for a history\n    // navigation (a.k.a. back-foward navigation).\n    get isHistoryNavigation() {\n        webidl.brandCheck(this, Request);\n        // The isHistoryNavigation getter steps are to return true if thiss requests\n        // history-navigation flag is set; otherwise false.\n        return this[kState].historyNavigation;\n    }\n    // Returns the signal associated with request, which is an AbortSignal\n    // object indicating whether or not request has been aborted, and its\n    // abort event handler.\n    get signal() {\n        webidl.brandCheck(this, Request);\n        // The signal getter steps are to return thiss signal.\n        return this[kSignal];\n    }\n    get body() {\n        webidl.brandCheck(this, Request);\n        return this[kState].body ? this[kState].body.stream : null;\n    }\n    get bodyUsed() {\n        webidl.brandCheck(this, Request);\n        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);\n    }\n    get duplex() {\n        webidl.brandCheck(this, Request);\n        return \"half\";\n    }\n    // Returns a clone of request.\n    clone() {\n        webidl.brandCheck(this, Request);\n        // 1. If this is unusable, then throw a TypeError.\n        if (this.bodyUsed || this.body?.locked) {\n            throw new TypeError(\"unusable\");\n        }\n        // 2. Let clonedRequest be the result of cloning thiss request.\n        const clonedRequest = cloneRequest(this[kState]);\n        // 3. Let clonedRequestObject be the result of creating a Request object,\n        // given clonedRequest, thiss headerss guard, and thiss relevant Realm.\n        const clonedRequestObject = new Request(kConstruct);\n        clonedRequestObject[kState] = clonedRequest;\n        clonedRequestObject[kRealm] = this[kRealm];\n        clonedRequestObject[kHeaders] = new Headers(kConstruct);\n        clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;\n        clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];\n        clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];\n        // 4. Make clonedRequestObjects signal follow thiss signal.\n        const ac = new AbortController();\n        if (this.signal.aborted) {\n            ac.abort(this.signal.reason);\n        } else {\n            util.addAbortListener(this.signal, ()=>{\n                ac.abort(this.signal.reason);\n            });\n        }\n        clonedRequestObject[kSignal] = ac.signal;\n        // 4. Return clonedRequestObject.\n        return clonedRequestObject;\n    }\n}\nmixinBody(Request);\nfunction makeRequest(init) {\n    // https://fetch.spec.whatwg.org/#requests\n    const request = {\n        method: \"GET\",\n        localURLsOnly: false,\n        unsafeRequest: false,\n        body: null,\n        client: null,\n        reservedClient: null,\n        replacesClientId: \"\",\n        window: \"client\",\n        keepalive: false,\n        serviceWorkers: \"all\",\n        initiator: \"\",\n        destination: \"\",\n        priority: null,\n        origin: \"client\",\n        policyContainer: \"client\",\n        referrer: \"client\",\n        referrerPolicy: \"\",\n        mode: \"no-cors\",\n        useCORSPreflightFlag: false,\n        credentials: \"same-origin\",\n        useCredentials: false,\n        cache: \"default\",\n        redirect: \"follow\",\n        integrity: \"\",\n        cryptoGraphicsNonceMetadata: \"\",\n        parserMetadata: \"\",\n        reloadNavigation: false,\n        historyNavigation: false,\n        userActivation: false,\n        taintedOrigin: false,\n        redirectCount: 0,\n        responseTainting: \"basic\",\n        preventNoCacheCacheControlHeaderModification: false,\n        done: false,\n        timingAllowFailed: false,\n        ...init,\n        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()\n    };\n    request.url = request.urlList[0];\n    return request;\n}\n// https://fetch.spec.whatwg.org/#concept-request-clone\nfunction cloneRequest(request) {\n    // To clone a request request, run these steps:\n    // 1. Let newRequest be a copy of request, except for its body.\n    const newRequest = makeRequest({\n        ...request,\n        body: null\n    });\n    // 2. If requests body is non-null, set newRequests body to the\n    // result of cloning requests body.\n    if (request.body != null) {\n        newRequest.body = cloneBody(request.body);\n    }\n    // 3. Return newRequest.\n    return newRequest;\n}\nObject.defineProperties(Request.prototype, {\n    method: kEnumerableProperty,\n    url: kEnumerableProperty,\n    headers: kEnumerableProperty,\n    redirect: kEnumerableProperty,\n    clone: kEnumerableProperty,\n    signal: kEnumerableProperty,\n    duplex: kEnumerableProperty,\n    destination: kEnumerableProperty,\n    body: kEnumerableProperty,\n    bodyUsed: kEnumerableProperty,\n    isHistoryNavigation: kEnumerableProperty,\n    isReloadNavigation: kEnumerableProperty,\n    keepalive: kEnumerableProperty,\n    integrity: kEnumerableProperty,\n    cache: kEnumerableProperty,\n    credentials: kEnumerableProperty,\n    attribute: kEnumerableProperty,\n    referrerPolicy: kEnumerableProperty,\n    referrer: kEnumerableProperty,\n    mode: kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: \"Request\",\n        configurable: true\n    }\n});\nwebidl.converters.Request = webidl.interfaceConverter(Request);\n// https://fetch.spec.whatwg.org/#requestinfo\nwebidl.converters.RequestInfo = function(V) {\n    if (typeof V === \"string\") {\n        return webidl.converters.USVString(V);\n    }\n    if (V instanceof Request) {\n        return webidl.converters.Request(V);\n    }\n    return webidl.converters.USVString(V);\n};\nwebidl.converters.AbortSignal = webidl.interfaceConverter(AbortSignal);\n// https://fetch.spec.whatwg.org/#requestinit\nwebidl.converters.RequestInit = webidl.dictionaryConverter([\n    {\n        key: \"method\",\n        converter: webidl.converters.ByteString\n    },\n    {\n        key: \"headers\",\n        converter: webidl.converters.HeadersInit\n    },\n    {\n        key: \"body\",\n        converter: webidl.nullableConverter(webidl.converters.BodyInit)\n    },\n    {\n        key: \"referrer\",\n        converter: webidl.converters.USVString\n    },\n    {\n        key: \"referrerPolicy\",\n        converter: webidl.converters.DOMString,\n        // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy\n        allowedValues: referrerPolicy\n    },\n    {\n        key: \"mode\",\n        converter: webidl.converters.DOMString,\n        // https://fetch.spec.whatwg.org/#concept-request-mode\n        allowedValues: requestMode\n    },\n    {\n        key: \"credentials\",\n        converter: webidl.converters.DOMString,\n        // https://fetch.spec.whatwg.org/#requestcredentials\n        allowedValues: requestCredentials\n    },\n    {\n        key: \"cache\",\n        converter: webidl.converters.DOMString,\n        // https://fetch.spec.whatwg.org/#requestcache\n        allowedValues: requestCache\n    },\n    {\n        key: \"redirect\",\n        converter: webidl.converters.DOMString,\n        // https://fetch.spec.whatwg.org/#requestredirect\n        allowedValues: requestRedirect\n    },\n    {\n        key: \"integrity\",\n        converter: webidl.converters.DOMString\n    },\n    {\n        key: \"keepalive\",\n        converter: webidl.converters.boolean\n    },\n    {\n        key: \"signal\",\n        converter: webidl.nullableConverter((signal)=>webidl.converters.AbortSignal(signal, {\n                strict: false\n            }))\n    },\n    {\n        key: \"window\",\n        converter: webidl.converters.any\n    },\n    {\n        key: \"duplex\",\n        converter: webidl.converters.DOMString,\n        allowedValues: requestDuplex\n    }\n]);\nmodule.exports = {\n    Request,\n    makeRequest\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvcmVxdWVzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQSwyQkFBMkIsR0FFM0I7QUFFQSxNQUFNLEVBQUVBLFdBQVcsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDdEQsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLE1BQU1DLFdBQVcsRUFBRUMsV0FBVyxFQUFFLEdBQUdKLG1CQUFPQSxDQUFDO0FBQzVELE1BQU0sRUFBRUssb0JBQW9CLEVBQUUsR0FBR0wsbUJBQU9BLENBQUM7QUFDekMsTUFBTU0sT0FBT04sbUJBQU9BLENBQUM7QUFDckIsTUFBTSxFQUNKTyxnQkFBZ0IsRUFDaEJDLFVBQVUsRUFDVkMsZUFBZSxFQUNmQyxtQkFBbUIsRUFDbkJDLHFCQUFxQixFQUN0QixHQUFHWCxtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFDSlksbUJBQW1CLEVBQ25CQyx3QkFBd0IsRUFDeEJDLGNBQWMsRUFDZEMsZUFBZSxFQUNmQyxXQUFXLEVBQ1hDLGtCQUFrQixFQUNsQkMsWUFBWSxFQUNaQyxhQUFhLEVBQ2QsR0FBR25CLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFb0IsbUJBQW1CLEVBQUUsR0FBR2Q7QUFDaEMsTUFBTSxFQUFFZSxRQUFRLEVBQUVDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHekIsbUJBQU9BLENBQUM7QUFDOUQsTUFBTSxFQUFFMEIsTUFBTSxFQUFFLEdBQUcxQixtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUUyQixlQUFlLEVBQUUsR0FBRzNCLG1CQUFPQSxDQUFDO0FBQ3BDLE1BQU0sRUFBRTRCLGFBQWEsRUFBRSxHQUFHNUIsbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUFFNkIsWUFBWSxFQUFFQyxVQUFVLEVBQUUsR0FBRzlCLG1CQUFPQSxDQUFDO0FBQzdDLE1BQU0rQixTQUFTL0IsbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFZ0MsZUFBZSxFQUFFQyxlQUFlLEVBQUVDLGlCQUFpQixFQUFFQyxtQkFBbUIsRUFBRSxHQUFHbkMsbUJBQU9BLENBQUM7QUFFN0YsSUFBSW9DLGtCQUFrQkMsV0FBV0QsZUFBZTtBQUVoRCxNQUFNRSxtQkFBbUJDLE9BQU87QUFFaEMsTUFBTUMsbUJBQW1CLElBQUluQyxxQkFBcUIsQ0FBQyxFQUFFb0MsTUFBTSxFQUFFQyxLQUFLLEVBQUU7SUFDbEVELE9BQU9FLG1CQUFtQixDQUFDLFNBQVNEO0FBQ3RDO0FBRUEsK0NBQStDO0FBQy9DLE1BQU1FO0lBQ0osNkNBQTZDO0lBQzdDQyxZQUFhQyxLQUFLLEVBQUVDLE9BQU8sQ0FBQyxDQUFDLENBQUU7UUFDN0IsSUFBSUQsVUFBVWhCLFlBQVk7WUFDeEI7UUFDRjtRQUVBSixPQUFPc0IsbUJBQW1CLENBQUNDLFdBQVcsR0FBRztZQUFFQyxRQUFRO1FBQXNCO1FBRXpFSixRQUFRcEIsT0FBT3lCLFVBQVUsQ0FBQ0MsV0FBVyxDQUFDTjtRQUN0Q0MsT0FBT3JCLE9BQU95QixVQUFVLENBQUNFLFdBQVcsQ0FBQ047UUFFckMscUZBQXFGO1FBQ3JGLElBQUksQ0FBQ3RCLE9BQU8sR0FBRztZQUNiNkIsZ0JBQWdCO2dCQUNkQyxTQUFTNUI7Z0JBQ1QsSUFBSTZCLFVBQVU7b0JBQ1osT0FBTyxJQUFJLENBQUNELE9BQU8sRUFBRUM7Z0JBQ3ZCO2dCQUNBQyxpQkFBaUIvQztZQUNuQjtRQUNGO1FBRUEsMEJBQTBCO1FBQzFCLElBQUlnRCxVQUFVO1FBRWQsK0JBQStCO1FBQy9CLElBQUlDLGVBQWU7UUFFbkIsb0VBQW9FO1FBQ3BFLE1BQU1KLFVBQVUsSUFBSSxDQUFDOUIsT0FBTyxDQUFDNkIsY0FBYyxDQUFDQyxPQUFPO1FBRW5ELHlCQUF5QjtRQUN6QixJQUFJZCxTQUFTO1FBRWIsaUNBQWlDO1FBQ2pDLElBQUksT0FBT0ssVUFBVSxVQUFVO1lBQzdCLGdFQUFnRTtZQUNoRSxzREFBc0Q7WUFDdEQsSUFBSWM7WUFDSixJQUFJO2dCQUNGQSxZQUFZLElBQUlDLElBQUlmLE9BQU9TO1lBQzdCLEVBQUUsT0FBT08sS0FBSztnQkFDWixNQUFNLElBQUlDLFVBQVUsOEJBQThCakIsT0FBTztvQkFBRWtCLE9BQU9GO2dCQUFJO1lBQ3hFO1lBRUEsZ0VBQWdFO1lBQ2hFLElBQUlGLFVBQVVLLFFBQVEsSUFBSUwsVUFBVU0sUUFBUSxFQUFFO2dCQUM1QyxNQUFNLElBQUlILFVBQ1IseUVBQ0VqQjtZQUVOO1lBRUEsMERBQTBEO1lBQzFEWSxVQUFVUyxZQUFZO2dCQUFFQyxTQUFTO29CQUFDUjtpQkFBVTtZQUFDO1lBRTdDLGlDQUFpQztZQUNqQ0QsZUFBZTtRQUNqQixPQUFPO1lBQ0wsZ0JBQWdCO1lBRWhCLHdDQUF3QztZQUN4QzVCLE9BQU9lLGlCQUFpQkY7WUFFeEIscUNBQXFDO1lBQ3JDYyxVQUFVWixLQUFLLENBQUN2QixPQUFPO1lBRXZCLG1DQUFtQztZQUNuQ2tCLFNBQVNLLEtBQUssQ0FBQ3hCLFFBQVE7UUFDekI7UUFFQSw2REFBNkQ7UUFDN0QsTUFBTWtDLFNBQVMsSUFBSSxDQUFDL0IsT0FBTyxDQUFDNkIsY0FBYyxDQUFDRSxNQUFNO1FBRWpELDZCQUE2QjtRQUM3QixJQUFJYSxTQUFTO1FBRWIsMEVBQTBFO1FBQzFFLG1FQUFtRTtRQUNuRSxJQUNFWCxRQUFRVyxNQUFNLEVBQUV4QixhQUFheUIsU0FBUywrQkFDdEM5RCxXQUFXa0QsUUFBUVcsTUFBTSxFQUFFYixTQUMzQjtZQUNBYSxTQUFTWCxRQUFRVyxNQUFNO1FBQ3pCO1FBRUEsd0VBQXdFO1FBQ3hFLElBQUl0QixLQUFLc0IsTUFBTSxJQUFJLE1BQU07WUFDdkIsTUFBTSxJQUFJTixVQUFVLENBQUMsaUJBQWlCLEVBQUVNLE9BQU8sY0FBYyxDQUFDO1FBQ2hFO1FBRUEsZ0VBQWdFO1FBQ2hFLElBQUksWUFBWXRCLE1BQU07WUFDcEJzQixTQUFTO1FBQ1g7UUFFQSxrRUFBa0U7UUFDbEVYLFVBQVVTLFlBQVk7WUFDcEIscUJBQXFCO1lBQ3JCLGdHQUFnRztZQUNoRywyQkFBMkI7WUFDM0JJLFFBQVFiLFFBQVFhLE1BQU07WUFDdEIsK0NBQStDO1lBQy9DLG1FQUFtRTtZQUNuRUMsYUFBYWQsUUFBUWMsV0FBVztZQUNoQywyQkFBMkI7WUFDM0JDLGVBQWVmLFFBQVFlLGFBQWE7WUFDcEMsMENBQTBDO1lBQzFDQyxRQUFRLElBQUksQ0FBQ2pELE9BQU8sQ0FBQzZCLGNBQWM7WUFDbkMsaUJBQWlCO1lBQ2pCZTtZQUNBLCtCQUErQjtZQUMvQk0sVUFBVWpCLFFBQVFpQixRQUFRO1lBQzFCLHFHQUFxRztZQUNyRyxxR0FBcUc7WUFDckcsMkJBQTJCO1lBQzNCbkIsUUFBUUUsUUFBUUYsTUFBTTtZQUN0QiwrQkFBK0I7WUFDL0JvQixVQUFVbEIsUUFBUWtCLFFBQVE7WUFDMUIsNkNBQTZDO1lBQzdDOUQsZ0JBQWdCNEMsUUFBUTVDLGNBQWM7WUFDdEMsdUJBQXVCO1lBQ3ZCK0QsTUFBTW5CLFFBQVFtQixJQUFJO1lBQ2xCLCtDQUErQztZQUMvQ0MsYUFBYXBCLFFBQVFvQixXQUFXO1lBQ2hDLG1DQUFtQztZQUNuQ0MsT0FBT3JCLFFBQVFxQixLQUFLO1lBQ3BCLHlDQUF5QztZQUN6Q0MsVUFBVXRCLFFBQVFzQixRQUFRO1lBQzFCLG1EQUFtRDtZQUNuREMsV0FBV3ZCLFFBQVF1QixTQUFTO1lBQzVCLGlDQUFpQztZQUNqQ0MsV0FBV3hCLFFBQVF3QixTQUFTO1lBQzVCLDJEQUEyRDtZQUMzREMsa0JBQWtCekIsUUFBUXlCLGdCQUFnQjtZQUMxQyw2REFBNkQ7WUFDN0RDLG1CQUFtQjFCLFFBQVEwQixpQkFBaUI7WUFDNUMsMENBQTBDO1lBQzFDaEIsU0FBUzttQkFBSVYsUUFBUVUsT0FBTzthQUFDO1FBQy9CO1FBRUEsTUFBTWlCLGFBQWFDLE9BQU9DLElBQUksQ0FBQ3hDLE1BQU15QyxNQUFNLEtBQUs7UUFFaEQsa0NBQWtDO1FBQ2xDLElBQUlILFlBQVk7WUFDZCxvRUFBb0U7WUFDcEUsSUFBSTNCLFFBQVFtQixJQUFJLEtBQUssWUFBWTtnQkFDL0JuQixRQUFRbUIsSUFBSSxHQUFHO1lBQ2pCO1lBRUEsNkNBQTZDO1lBQzdDbkIsUUFBUXlCLGdCQUFnQixHQUFHO1lBRTNCLDhDQUE4QztZQUM5Q3pCLFFBQVEwQixpQkFBaUIsR0FBRztZQUU1Qix1Q0FBdUM7WUFDdkMxQixRQUFRRixNQUFNLEdBQUc7WUFFakIsd0NBQXdDO1lBQ3hDRSxRQUFRa0IsUUFBUSxHQUFHO1lBRW5CLHdEQUF3RDtZQUN4RGxCLFFBQVE1QyxjQUFjLEdBQUc7WUFFekIsaURBQWlEO1lBQ2pENEMsUUFBUStCLEdBQUcsR0FBRy9CLFFBQVFVLE9BQU8sQ0FBQ1YsUUFBUVUsT0FBTyxDQUFDb0IsTUFBTSxHQUFHLEVBQUU7WUFFekQsa0RBQWtEO1lBQ2xEOUIsUUFBUVUsT0FBTyxHQUFHO2dCQUFDVixRQUFRK0IsR0FBRzthQUFDO1FBQ2pDO1FBRUEsd0NBQXdDO1FBQ3hDLElBQUkxQyxLQUFLNkIsUUFBUSxLQUFLYyxXQUFXO1lBQy9CLHVDQUF1QztZQUN2QyxNQUFNZCxXQUFXN0IsS0FBSzZCLFFBQVE7WUFFOUIsb0ZBQW9GO1lBQ3BGLElBQUlBLGFBQWEsSUFBSTtnQkFDbkJsQixRQUFRa0IsUUFBUSxHQUFHO1lBQ3JCLE9BQU87Z0JBQ0wsK0RBQStEO2dCQUMvRCxXQUFXO2dCQUNYLDJEQUEyRDtnQkFDM0QsSUFBSWU7Z0JBQ0osSUFBSTtvQkFDRkEsaUJBQWlCLElBQUk5QixJQUFJZSxVQUFVckI7Z0JBQ3JDLEVBQUUsT0FBT08sS0FBSztvQkFDWixNQUFNLElBQUlDLFVBQVUsQ0FBQyxVQUFVLEVBQUVhLFNBQVMscUJBQXFCLENBQUMsRUFBRTt3QkFBRVosT0FBT0Y7b0JBQUk7Z0JBQ2pGO2dCQUVBLHFDQUFxQztnQkFDckMsdUVBQXVFO2dCQUN2RSwyREFBMkQ7Z0JBQzNELDJDQUEyQztnQkFDM0MsSUFDRSxlQUFnQjhCLFFBQVEsS0FBSyxZQUFZRCxlQUFlRSxRQUFRLEtBQUssWUFDcEVyQyxVQUFVLENBQUNoRCxXQUFXbUYsZ0JBQWdCLElBQUksQ0FBQ2xFLE9BQU8sQ0FBQzZCLGNBQWMsQ0FBQ0MsT0FBTyxHQUMxRTtvQkFDQUcsUUFBUWtCLFFBQVEsR0FBRztnQkFDckIsT0FBTztvQkFDTCwwREFBMEQ7b0JBQzFEbEIsUUFBUWtCLFFBQVEsR0FBR2U7Z0JBQ3JCO1lBQ0Y7UUFDRjtRQUVBLDJFQUEyRTtRQUMzRSxTQUFTO1FBQ1QsSUFBSTVDLEtBQUtqQyxjQUFjLEtBQUs0RSxXQUFXO1lBQ3JDaEMsUUFBUTVDLGNBQWMsR0FBR2lDLEtBQUtqQyxjQUFjO1FBQzlDO1FBRUEseUVBQXlFO1FBQ3pFLElBQUkrRDtRQUNKLElBQUk5QixLQUFLOEIsSUFBSSxLQUFLYSxXQUFXO1lBQzNCYixPQUFPOUIsS0FBSzhCLElBQUk7UUFDbEIsT0FBTztZQUNMQSxPQUFPbEI7UUFDVDtRQUVBLHFEQUFxRDtRQUNyRCxJQUFJa0IsU0FBUyxZQUFZO1lBQ3ZCLE1BQU1uRCxPQUFPb0UsTUFBTSxDQUFDQyxTQUFTLENBQUM7Z0JBQzVCN0MsUUFBUTtnQkFDUjhDLFNBQVM7WUFDWDtRQUNGO1FBRUEsdURBQXVEO1FBQ3ZELElBQUluQixRQUFRLE1BQU07WUFDaEJuQixRQUFRbUIsSUFBSSxHQUFHQTtRQUNqQjtRQUVBLHlFQUF5RTtRQUN6RSxTQUFTO1FBQ1QsSUFBSTlCLEtBQUsrQixXQUFXLEtBQUtZLFdBQVc7WUFDbENoQyxRQUFRb0IsV0FBVyxHQUFHL0IsS0FBSytCLFdBQVc7UUFDeEM7UUFFQSxvRUFBb0U7UUFDcEUsSUFBSS9CLEtBQUtnQyxLQUFLLEtBQUtXLFdBQVc7WUFDNUJoQyxRQUFRcUIsS0FBSyxHQUFHaEMsS0FBS2dDLEtBQUs7UUFDNUI7UUFFQSx3RUFBd0U7UUFDeEUsNkNBQTZDO1FBQzdDLElBQUlyQixRQUFRcUIsS0FBSyxLQUFLLG9CQUFvQnJCLFFBQVFtQixJQUFJLEtBQUssZUFBZTtZQUN4RSxNQUFNLElBQUlkLFVBQ1I7UUFFSjtRQUVBLDBFQUEwRTtRQUMxRSxJQUFJaEIsS0FBS2lDLFFBQVEsS0FBS1UsV0FBVztZQUMvQmhDLFFBQVFzQixRQUFRLEdBQUdqQyxLQUFLaUMsUUFBUTtRQUNsQztRQUVBLGdGQUFnRjtRQUNoRixJQUFJakMsS0FBS2tDLFNBQVMsSUFBSSxNQUFNO1lBQzFCdkIsUUFBUXVCLFNBQVMsR0FBR2dCLE9BQU9sRCxLQUFLa0MsU0FBUztRQUMzQztRQUVBLHVFQUF1RTtRQUN2RSxJQUFJbEMsS0FBS21DLFNBQVMsS0FBS1EsV0FBVztZQUNoQ2hDLFFBQVF3QixTQUFTLEdBQUdnQixRQUFRbkQsS0FBS21DLFNBQVM7UUFDNUM7UUFFQSxzQ0FBc0M7UUFDdEMsSUFBSW5DLEtBQUt3QixNQUFNLEtBQUttQixXQUFXO1lBQzdCLG1DQUFtQztZQUNuQyxJQUFJbkIsU0FBU3hCLEtBQUt3QixNQUFNO1lBRXhCLHFFQUFxRTtZQUNyRSxxQkFBcUI7WUFDckIsSUFBSSxDQUFDaEUsaUJBQWlCZ0UsU0FBUztnQkFDN0IsTUFBTSxJQUFJUixVQUFVLENBQUMsQ0FBQyxFQUFFUSxPQUFPLDZCQUE2QixDQUFDO1lBQy9EO1lBRUEsSUFBSTNELG9CQUFvQnVGLEdBQUcsQ0FBQzVCLE9BQU82QixXQUFXLEtBQUs7Z0JBQ2pELE1BQU0sSUFBSXJDLFVBQVUsQ0FBQyxDQUFDLEVBQUVRLE9BQU8sNkJBQTZCLENBQUM7WUFDL0Q7WUFFQSx1QkFBdUI7WUFDdkJBLFNBQVM1RCxxQkFBcUIsQ0FBQzRELE9BQU8sSUFBSTlELGdCQUFnQjhEO1lBRTFELHFDQUFxQztZQUNyQ2IsUUFBUWEsTUFBTSxHQUFHQTtRQUNuQjtRQUVBLHVEQUF1RDtRQUN2RCxJQUFJeEIsS0FBS04sTUFBTSxLQUFLaUQsV0FBVztZQUM3QmpELFNBQVNNLEtBQUtOLE1BQU07UUFDdEI7UUFFQSxxQ0FBcUM7UUFDckMsSUFBSSxDQUFDbEIsT0FBTyxHQUFHbUM7UUFFZix5RUFBeUU7UUFDekUsU0FBUztRQUNULHNEQUFzRDtRQUN0RCxxREFBcUQ7UUFDckQsTUFBTTJDLEtBQUssSUFBSUM7UUFDZixJQUFJLENBQUNoRixRQUFRLEdBQUcrRSxHQUFHNUQsTUFBTTtRQUN6QixJQUFJLENBQUNuQixRQUFRLENBQUNHLE9BQU8sR0FBRyxJQUFJLENBQUNBLE9BQU87UUFFcEMsb0VBQW9FO1FBQ3BFLElBQUlnQixVQUFVLE1BQU07WUFDbEIsSUFDRSxDQUFDQSxVQUNELE9BQU9BLE9BQU84RCxPQUFPLEtBQUssYUFDMUIsT0FBTzlELE9BQU8rRCxnQkFBZ0IsS0FBSyxZQUNuQztnQkFDQSxNQUFNLElBQUl6QyxVQUNSO1lBRUo7WUFFQSxJQUFJdEIsT0FBTzhELE9BQU8sRUFBRTtnQkFDbEJGLEdBQUczRCxLQUFLLENBQUNELE9BQU9nRSxNQUFNO1lBQ3hCLE9BQU87Z0JBQ0wsK0NBQStDO2dCQUMvQyxzREFBc0Q7Z0JBQ3RELDRDQUE0QztnQkFDNUMscURBQXFEO2dCQUNyRCxJQUFJLENBQUNuRSxpQkFBaUIsR0FBRytEO2dCQUV6QixNQUFNSyxRQUFRLElBQUlDLFFBQVFOO2dCQUMxQixNQUFNM0QsUUFBUTtvQkFDWixNQUFNMkQsS0FBS0ssTUFBTUUsS0FBSztvQkFDdEIsSUFBSVAsT0FBT1gsV0FBVzt3QkFDcEJXLEdBQUczRCxLQUFLLENBQUMsSUFBSSxDQUFDK0QsTUFBTTtvQkFDdEI7Z0JBQ0Y7Z0JBRUEsd0RBQXdEO2dCQUN4RCwyRUFBMkU7Z0JBQzNFLElBQUk7b0JBQ0Ysc0VBQXNFO29CQUN0RSw0Q0FBNEM7b0JBQzVDLElBQUksT0FBT3pFLG9CQUFvQixjQUFjQSxnQkFBZ0JTLFlBQVlOLHFCQUFxQjt3QkFDNUZGLGdCQUFnQixLQUFLUTtvQkFDdkIsT0FBTyxJQUFJUCxrQkFBa0JPLFFBQVEsU0FBUytDLE1BQU0sSUFBSXJELHFCQUFxQjt3QkFDM0VGLGdCQUFnQixLQUFLUTtvQkFDdkI7Z0JBQ0YsRUFBRSxPQUFNLENBQUM7Z0JBRVRuQyxLQUFLdUcsZ0JBQWdCLENBQUNwRSxRQUFRQztnQkFDOUJGLGlCQUFpQnNFLFFBQVEsQ0FBQ1QsSUFBSTtvQkFBRTVEO29CQUFRQztnQkFBTTtZQUNoRDtRQUNGO1FBRUEsc0VBQXNFO1FBQ3RFLGlFQUFpRTtRQUNqRSxhQUFhO1FBQ2IsSUFBSSxDQUFDckIsU0FBUyxHQUFHLElBQUlwQixRQUFRNkI7UUFDN0IsSUFBSSxDQUFDVCxTQUFTLENBQUNRLGFBQWEsR0FBRzZCLFFBQVFjLFdBQVc7UUFDbEQsSUFBSSxDQUFDbkQsU0FBUyxDQUFDRyxPQUFPLEdBQUc7UUFDekIsSUFBSSxDQUFDSCxTQUFTLENBQUNJLE9BQU8sR0FBRyxJQUFJLENBQUNBLE9BQU87UUFFckMsbURBQW1EO1FBQ25ELElBQUlvRCxTQUFTLFdBQVc7WUFDdEIsaUVBQWlFO1lBQ2pFLDBCQUEwQjtZQUMxQixJQUFJLENBQUNoRSx5QkFBeUJzRixHQUFHLENBQUN6QyxRQUFRYSxNQUFNLEdBQUc7Z0JBQ2pELE1BQU0sSUFBSVIsVUFDUixDQUFDLENBQUMsRUFBRUwsUUFBUWEsTUFBTSxDQUFDLGdDQUFnQyxDQUFDO1lBRXhEO1lBRUEsc0RBQXNEO1lBQ3RELElBQUksQ0FBQ2xELFNBQVMsQ0FBQ0csT0FBTyxHQUFHO1FBQzNCO1FBRUEsa0NBQWtDO1FBQ2xDLElBQUk2RCxZQUFZO1lBQ2Qsd0JBQXdCLEdBQ3hCLE1BQU1iLGNBQWMsSUFBSSxDQUFDbkQsU0FBUyxDQUFDUSxhQUFhO1lBQ2hELHVFQUF1RTtZQUN2RSxRQUFRO1lBQ1IscUVBQXFFO1lBQ3JFLE1BQU1rRixVQUFVaEUsS0FBS2dFLE9BQU8sS0FBS3JCLFlBQVkzQyxLQUFLZ0UsT0FBTyxHQUFHLElBQUkzRyxZQUFZb0U7WUFFNUUseUNBQXlDO1lBQ3pDQSxZQUFZd0MsS0FBSztZQUVqQix3RUFBd0U7WUFDeEUsK0RBQStEO1lBQy9ELElBQUlELG1CQUFtQjNHLGFBQWE7Z0JBQ2xDLEtBQUssTUFBTSxDQUFDNkcsS0FBS0MsSUFBSSxJQUFJSCxRQUFTO29CQUNoQ3ZDLFlBQVkyQyxNQUFNLENBQUNGLEtBQUtDO2dCQUMxQjtnQkFDQSx5Q0FBeUM7Z0JBQ3pDMUMsWUFBWTRDLE9BQU8sR0FBR0wsUUFBUUssT0FBTztZQUN2QyxPQUFPO2dCQUNMLGtEQUFrRDtnQkFDbERqSCxZQUFZLElBQUksQ0FBQ2tCLFNBQVMsRUFBRTBGO1lBQzlCO1FBQ0Y7UUFFQSxvRUFBb0U7UUFDcEUsMEJBQTBCO1FBQzFCLE1BQU1NLFlBQVl2RSxpQkFBaUJGLFVBQVVFLEtBQUssQ0FBQ3ZCLE9BQU8sQ0FBQytGLElBQUksR0FBRztRQUVsRSxvRUFBb0U7UUFDcEUsa0VBQWtFO1FBQ2xFLGFBQWE7UUFDYixJQUNFLENBQUN2RSxLQUFLdUUsSUFBSSxJQUFJLFFBQVFELGFBQWEsSUFBRyxLQUNyQzNELENBQUFBLFFBQVFhLE1BQU0sS0FBSyxTQUFTYixRQUFRYSxNQUFNLEtBQUssTUFBSyxHQUNyRDtZQUNBLE1BQU0sSUFBSVIsVUFBVTtRQUN0QjtRQUVBLDRCQUE0QjtRQUM1QixJQUFJd0QsV0FBVztRQUVmLG9EQUFvRDtRQUNwRCxJQUFJeEUsS0FBS3VFLElBQUksSUFBSSxNQUFNO1lBQ3JCLCtCQUErQjtZQUMvQiwrREFBK0Q7WUFDL0QsMkRBQTJEO1lBQzNELE1BQU0sQ0FBQ0UsZUFBZUMsWUFBWSxHQUFHNUgsWUFDbkNrRCxLQUFLdUUsSUFBSSxFQUNUNUQsUUFBUXdCLFNBQVM7WUFFbkJxQyxXQUFXQztZQUVYLHVFQUF1RTtZQUN2RSx5RUFBeUU7WUFDekUsa0JBQWtCO1lBQ2xCLElBQUlDLGVBQWUsQ0FBQyxJQUFJLENBQUNwRyxTQUFTLENBQUNRLGFBQWEsQ0FBQzZGLFFBQVEsQ0FBQyxpQkFBaUI7Z0JBQ3pFLElBQUksQ0FBQ3JHLFNBQVMsQ0FBQzhGLE1BQU0sQ0FBQyxnQkFBZ0JNO1lBQ3hDO1FBQ0Y7UUFFQSxtRUFBbUU7UUFDbkUsYUFBYTtRQUNiLE1BQU1FLGtCQUFrQkosWUFBWUY7UUFFcEMscUVBQXFFO1FBQ3JFLGNBQWM7UUFDZCxJQUFJTSxtQkFBbUIsUUFBUUEsZ0JBQWdCQyxNQUFNLElBQUksTUFBTTtZQUM3RCxnRUFBZ0U7WUFDaEUsNkJBQTZCO1lBQzdCLElBQUlMLFlBQVksUUFBUXhFLEtBQUs4RSxNQUFNLElBQUksTUFBTTtnQkFDM0MsTUFBTSxJQUFJOUQsVUFBVTtZQUN0QjtZQUVBLG1FQUFtRTtZQUNuRSwwQkFBMEI7WUFDMUIsSUFBSUwsUUFBUW1CLElBQUksS0FBSyxpQkFBaUJuQixRQUFRbUIsSUFBSSxLQUFLLFFBQVE7Z0JBQzdELE1BQU0sSUFBSWQsVUFDUjtZQUVKO1lBRUEsbURBQW1EO1lBQ25ETCxRQUFRb0Usb0JBQW9CLEdBQUc7UUFDakM7UUFFQSx3Q0FBd0M7UUFDeEMsSUFBSUMsWUFBWUo7UUFFaEIsMkRBQTJEO1FBQzNELElBQUlKLFlBQVksUUFBUUYsYUFBYSxNQUFNO1lBQ3pDLG1EQUFtRDtZQUNuRCxJQUFJL0csS0FBSzBILFdBQVcsQ0FBQ1gsVUFBVVksTUFBTSxLQUFLWixVQUFVWSxNQUFNLENBQUNDLE1BQU0sRUFBRTtnQkFDakUsTUFBTSxJQUFJbkUsVUFDUjtZQUVKO1lBRUEsb0VBQW9FO1lBQ3BFLElBQUksQ0FBQzNCLGlCQUFpQjtnQkFDcEJBLGtCQUFrQnBDLHFFQUFxQztZQUN6RDtZQUVBLGlFQUFpRTtZQUNqRSxNQUFNbUksb0JBQW9CLElBQUkvRjtZQUM5QmlGLFVBQVVZLE1BQU0sQ0FBQ0csV0FBVyxDQUFDRDtZQUM3QkosWUFBWTtnQkFDVkgsUUFBUVAsVUFBVU8sTUFBTTtnQkFDeEJwQyxRQUFRNkIsVUFBVTdCLE1BQU07Z0JBQ3hCeUMsUUFBUUUsa0JBQWtCRSxRQUFRO1lBQ3BDO1FBQ0Y7UUFFQSw4Q0FBOEM7UUFDOUMsSUFBSSxDQUFDOUcsT0FBTyxDQUFDK0YsSUFBSSxHQUFHUztJQUN0QjtJQUVBLDREQUE0RDtJQUM1RCxJQUFJeEQsU0FBVTtRQUNaN0MsT0FBTzRHLFVBQVUsQ0FBQyxJQUFJLEVBQUUxRjtRQUV4QixpRUFBaUU7UUFDakUsT0FBTyxJQUFJLENBQUNyQixPQUFPLENBQUNnRCxNQUFNO0lBQzVCO0lBRUEsMENBQTBDO0lBQzFDLElBQUlrQixNQUFPO1FBQ1QvRCxPQUFPNEcsVUFBVSxDQUFDLElBQUksRUFBRTFGO1FBRXhCLHVFQUF1RTtRQUN2RSxPQUFPaEIsY0FBYyxJQUFJLENBQUNMLE9BQU8sQ0FBQ2tFLEdBQUc7SUFDdkM7SUFFQSw4RUFBOEU7SUFDOUUsMEVBQTBFO0lBQzFFLDREQUE0RDtJQUM1RCxJQUFJc0IsVUFBVztRQUNickYsT0FBTzRHLFVBQVUsQ0FBQyxJQUFJLEVBQUUxRjtRQUV4Qix5REFBeUQ7UUFDekQsT0FBTyxJQUFJLENBQUN2QixTQUFTO0lBQ3ZCO0lBRUEsc0VBQXNFO0lBQ3RFLGVBQWU7SUFDZixJQUFJa0gsY0FBZTtRQUNqQjdHLE9BQU80RyxVQUFVLENBQUMsSUFBSSxFQUFFMUY7UUFFeEIscUVBQXFFO1FBQ3JFLE9BQU8sSUFBSSxDQUFDckIsT0FBTyxDQUFDZ0gsV0FBVztJQUNqQztJQUVBLHlFQUF5RTtJQUN6RSx3RUFBd0U7SUFDeEUsdUVBQXVFO0lBQ3ZFLHdFQUF3RTtJQUN4RSxzQkFBc0I7SUFDdEIsSUFBSTNELFdBQVk7UUFDZGxELE9BQU80RyxVQUFVLENBQUMsSUFBSSxFQUFFMUY7UUFFeEIsb0VBQW9FO1FBQ3BFLGdCQUFnQjtRQUNoQixJQUFJLElBQUksQ0FBQ3JCLE9BQU8sQ0FBQ3FELFFBQVEsS0FBSyxlQUFlO1lBQzNDLE9BQU87UUFDVDtRQUVBLDJEQUEyRDtRQUMzRCxrQkFBa0I7UUFDbEIsSUFBSSxJQUFJLENBQUNyRCxPQUFPLENBQUNxRCxRQUFRLEtBQUssVUFBVTtZQUN0QyxPQUFPO1FBQ1Q7UUFFQSxnREFBZ0Q7UUFDaEQsT0FBTyxJQUFJLENBQUNyRCxPQUFPLENBQUNxRCxRQUFRLENBQUM0RCxRQUFRO0lBQ3ZDO0lBRUEsdURBQXVEO0lBQ3ZELHFFQUFxRTtJQUNyRSxZQUFZO0lBQ1osSUFBSTFILGlCQUFrQjtRQUNwQlksT0FBTzRHLFVBQVUsQ0FBQyxJQUFJLEVBQUUxRjtRQUV4QixrRkFBa0Y7UUFDbEYsT0FBTyxJQUFJLENBQUNyQixPQUFPLENBQUNULGNBQWM7SUFDcEM7SUFFQSx5RUFBeUU7SUFDekUsMEVBQTBFO0lBQzFFLFFBQVE7SUFDUixJQUFJK0QsT0FBUTtRQUNWbkQsT0FBTzRHLFVBQVUsQ0FBQyxJQUFJLEVBQUUxRjtRQUV4Qiw2REFBNkQ7UUFDN0QsT0FBTyxJQUFJLENBQUNyQixPQUFPLENBQUNzRCxJQUFJO0lBQzFCO0lBRUEsd0RBQXdEO0lBQ3hELHlFQUF5RTtJQUN6RSxpRUFBaUU7SUFDakUsSUFBSUMsY0FBZTtRQUNqQixnRkFBZ0Y7UUFDaEYsT0FBTyxJQUFJLENBQUN2RCxPQUFPLENBQUN1RCxXQUFXO0lBQ2pDO0lBRUEsa0RBQWtEO0lBQ2xELG9EQUFvRDtJQUNwRCxtREFBbUQ7SUFDbkQsSUFBSUMsUUFBUztRQUNYckQsT0FBTzRHLFVBQVUsQ0FBQyxJQUFJLEVBQUUxRjtRQUV4QixvRUFBb0U7UUFDcEUsT0FBTyxJQUFJLENBQUNyQixPQUFPLENBQUN3RCxLQUFLO0lBQzNCO0lBRUEscURBQXFEO0lBQ3JELHFEQUFxRDtJQUNyRCxxREFBcUQ7SUFDckQsb0NBQW9DO0lBQ3BDLElBQUlDLFdBQVk7UUFDZHRELE9BQU80RyxVQUFVLENBQUMsSUFBSSxFQUFFMUY7UUFFeEIsMEVBQTBFO1FBQzFFLE9BQU8sSUFBSSxDQUFDckIsT0FBTyxDQUFDeUQsUUFBUTtJQUM5QjtJQUVBLCtEQUErRDtJQUMvRCw4REFBOEQ7SUFDOUQsNkRBQTZEO0lBQzdELElBQUlDLFlBQWE7UUFDZnZELE9BQU80RyxVQUFVLENBQUMsSUFBSSxFQUFFMUY7UUFFeEIsc0VBQXNFO1FBQ3RFLFlBQVk7UUFDWixPQUFPLElBQUksQ0FBQ3JCLE9BQU8sQ0FBQzBELFNBQVM7SUFDL0I7SUFFQSxzRUFBc0U7SUFDdEUsa0NBQWtDO0lBQ2xDLElBQUlDLFlBQWE7UUFDZnhELE9BQU80RyxVQUFVLENBQUMsSUFBSSxFQUFFMUY7UUFFeEIsdUVBQXVFO1FBQ3ZFLE9BQU8sSUFBSSxDQUFDckIsT0FBTyxDQUFDMkQsU0FBUztJQUMvQjtJQUVBLHNFQUFzRTtJQUN0RSxjQUFjO0lBQ2QsSUFBSXVELHFCQUFzQjtRQUN4Qi9HLE9BQU80RyxVQUFVLENBQUMsSUFBSSxFQUFFMUY7UUFFeEIsbUVBQW1FO1FBQ25FLDREQUE0RDtRQUM1RCxPQUFPLElBQUksQ0FBQ3JCLE9BQU8sQ0FBQzRELGdCQUFnQjtJQUN0QztJQUVBLHVFQUF1RTtJQUN2RSw4Q0FBOEM7SUFDOUMsSUFBSXVELHNCQUF1QjtRQUN6QmhILE9BQU80RyxVQUFVLENBQUMsSUFBSSxFQUFFMUY7UUFFeEIsOEVBQThFO1FBQzlFLG1EQUFtRDtRQUNuRCxPQUFPLElBQUksQ0FBQ3JCLE9BQU8sQ0FBQzZELGlCQUFpQjtJQUN2QztJQUVBLHNFQUFzRTtJQUN0RSxxRUFBcUU7SUFDckUsdUJBQXVCO0lBQ3ZCLElBQUkzQyxTQUFVO1FBQ1pmLE9BQU80RyxVQUFVLENBQUMsSUFBSSxFQUFFMUY7UUFFeEIsdURBQXVEO1FBQ3ZELE9BQU8sSUFBSSxDQUFDdEIsUUFBUTtJQUN0QjtJQUVBLElBQUlnRyxPQUFRO1FBQ1Y1RixPQUFPNEcsVUFBVSxDQUFDLElBQUksRUFBRTFGO1FBRXhCLE9BQU8sSUFBSSxDQUFDckIsT0FBTyxDQUFDK0YsSUFBSSxHQUFHLElBQUksQ0FBQy9GLE9BQU8sQ0FBQytGLElBQUksQ0FBQ1csTUFBTSxHQUFHO0lBQ3hEO0lBRUEsSUFBSVUsV0FBWTtRQUNkakgsT0FBTzRHLFVBQVUsQ0FBQyxJQUFJLEVBQUUxRjtRQUV4QixPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUNyQixPQUFPLENBQUMrRixJQUFJLElBQUloSCxLQUFLMEgsV0FBVyxDQUFDLElBQUksQ0FBQ3pHLE9BQU8sQ0FBQytGLElBQUksQ0FBQ1csTUFBTTtJQUN6RTtJQUVBLElBQUlKLFNBQVU7UUFDWm5HLE9BQU80RyxVQUFVLENBQUMsSUFBSSxFQUFFMUY7UUFFeEIsT0FBTztJQUNUO0lBRUEsOEJBQThCO0lBQzlCZ0csUUFBUztRQUNQbEgsT0FBTzRHLFVBQVUsQ0FBQyxJQUFJLEVBQUUxRjtRQUV4QixrREFBa0Q7UUFDbEQsSUFBSSxJQUFJLENBQUMrRixRQUFRLElBQUksSUFBSSxDQUFDckIsSUFBSSxFQUFFWSxRQUFRO1lBQ3RDLE1BQU0sSUFBSW5FLFVBQVU7UUFDdEI7UUFFQSxnRUFBZ0U7UUFDaEUsTUFBTThFLGdCQUFnQkMsYUFBYSxJQUFJLENBQUN2SCxPQUFPO1FBRS9DLHlFQUF5RTtRQUN6RSwwRUFBMEU7UUFDMUUsTUFBTXdILHNCQUFzQixJQUFJbkcsUUFBUWQ7UUFDeENpSCxtQkFBbUIsQ0FBQ3hILE9BQU8sR0FBR3NIO1FBQzlCRSxtQkFBbUIsQ0FBQ3RILE9BQU8sR0FBRyxJQUFJLENBQUNBLE9BQU87UUFDMUNzSCxtQkFBbUIsQ0FBQzFILFNBQVMsR0FBRyxJQUFJcEIsUUFBUTZCO1FBQzVDaUgsbUJBQW1CLENBQUMxSCxTQUFTLENBQUNRLGFBQWEsR0FBR2dILGNBQWNyRSxXQUFXO1FBQ3ZFdUUsbUJBQW1CLENBQUMxSCxTQUFTLENBQUNHLE9BQU8sR0FBRyxJQUFJLENBQUNILFNBQVMsQ0FBQ0csT0FBTztRQUM5RHVILG1CQUFtQixDQUFDMUgsU0FBUyxDQUFDSSxPQUFPLEdBQUcsSUFBSSxDQUFDSixTQUFTLENBQUNJLE9BQU87UUFFOUQsNkRBQTZEO1FBQzdELE1BQU00RSxLQUFLLElBQUlDO1FBQ2YsSUFBSSxJQUFJLENBQUM3RCxNQUFNLENBQUM4RCxPQUFPLEVBQUU7WUFDdkJGLEdBQUczRCxLQUFLLENBQUMsSUFBSSxDQUFDRCxNQUFNLENBQUNnRSxNQUFNO1FBQzdCLE9BQU87WUFDTG5HLEtBQUt1RyxnQkFBZ0IsQ0FDbkIsSUFBSSxDQUFDcEUsTUFBTSxFQUNYO2dCQUNFNEQsR0FBRzNELEtBQUssQ0FBQyxJQUFJLENBQUNELE1BQU0sQ0FBQ2dFLE1BQU07WUFDN0I7UUFFSjtRQUNBc0MsbUJBQW1CLENBQUN6SCxRQUFRLEdBQUcrRSxHQUFHNUQsTUFBTTtRQUV4QyxpQ0FBaUM7UUFDakMsT0FBT3NHO0lBQ1Q7QUFDRjtBQUVBakosVUFBVThDO0FBRVYsU0FBU3VCLFlBQWFwQixJQUFJO0lBQ3hCLDBDQUEwQztJQUMxQyxNQUFNVyxVQUFVO1FBQ2RhLFFBQVE7UUFDUnlFLGVBQWU7UUFDZnZFLGVBQWU7UUFDZjZDLE1BQU07UUFDTjVDLFFBQVE7UUFDUnVFLGdCQUFnQjtRQUNoQkMsa0JBQWtCO1FBQ2xCN0UsUUFBUTtRQUNSYSxXQUFXO1FBQ1hpRSxnQkFBZ0I7UUFDaEJDLFdBQVc7UUFDWGIsYUFBYTtRQUNiNUQsVUFBVTtRQUNWbkIsUUFBUTtRQUNSQyxpQkFBaUI7UUFDakJtQixVQUFVO1FBQ1Y5RCxnQkFBZ0I7UUFDaEIrRCxNQUFNO1FBQ05pRCxzQkFBc0I7UUFDdEJoRCxhQUFhO1FBQ2J1RSxnQkFBZ0I7UUFDaEJ0RSxPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsV0FBVztRQUNYcUUsNkJBQTZCO1FBQzdCQyxnQkFBZ0I7UUFDaEJwRSxrQkFBa0I7UUFDbEJDLG1CQUFtQjtRQUNuQm9FLGdCQUFnQjtRQUNoQkMsZUFBZTtRQUNmQyxlQUFlO1FBQ2ZDLGtCQUFrQjtRQUNsQkMsOENBQThDO1FBQzlDQyxNQUFNO1FBQ05DLG1CQUFtQjtRQUNuQixHQUFHL0csSUFBSTtRQUNQeUIsYUFBYXpCLEtBQUt5QixXQUFXLEdBQ3pCLElBQUlwRSxZQUFZMkMsS0FBS3lCLFdBQVcsSUFDaEMsSUFBSXBFO0lBQ1Y7SUFDQXNELFFBQVErQixHQUFHLEdBQUcvQixRQUFRVSxPQUFPLENBQUMsRUFBRTtJQUNoQyxPQUFPVjtBQUNUO0FBRUEsdURBQXVEO0FBQ3ZELFNBQVNvRixhQUFjcEYsT0FBTztJQUM1QiwrQ0FBK0M7SUFFL0MsK0RBQStEO0lBQy9ELE1BQU1xRyxhQUFhNUYsWUFBWTtRQUFFLEdBQUdULE9BQU87UUFBRTRELE1BQU07SUFBSztJQUV4RCxpRUFBaUU7SUFDakUsb0NBQW9DO0lBQ3BDLElBQUk1RCxRQUFRNEQsSUFBSSxJQUFJLE1BQU07UUFDeEJ5QyxXQUFXekMsSUFBSSxHQUFHdkgsVUFBVTJELFFBQVE0RCxJQUFJO0lBQzFDO0lBRUEsd0JBQXdCO0lBQ3hCLE9BQU95QztBQUNUO0FBRUF6RSxPQUFPMEUsZ0JBQWdCLENBQUNwSCxRQUFRcUgsU0FBUyxFQUFFO0lBQ3pDMUYsUUFBUW5EO0lBQ1JxRSxLQUFLckU7SUFDTDJGLFNBQVMzRjtJQUNUNEQsVUFBVTVEO0lBQ1Z3SCxPQUFPeEg7SUFDUHFCLFFBQVFyQjtJQUNSeUcsUUFBUXpHO0lBQ1JtSCxhQUFhbkg7SUFDYmtHLE1BQU1sRztJQUNOdUgsVUFBVXZIO0lBQ1ZzSCxxQkFBcUJ0SDtJQUNyQnFILG9CQUFvQnJIO0lBQ3BCOEQsV0FBVzlEO0lBQ1g2RCxXQUFXN0Q7SUFDWDJELE9BQU8zRDtJQUNQMEQsYUFBYTFEO0lBQ2I4SSxXQUFXOUk7SUFDWE4sZ0JBQWdCTTtJQUNoQndELFVBQVV4RDtJQUNWeUQsTUFBTXpEO0lBQ04sQ0FBQ21CLE9BQU80SCxXQUFXLENBQUMsRUFBRTtRQUNwQkMsT0FBTztRQUNQQyxjQUFjO0lBQ2hCO0FBQ0Y7QUFFQTNJLE9BQU95QixVQUFVLENBQUNQLE9BQU8sR0FBR2xCLE9BQU80SSxrQkFBa0IsQ0FDbkQxSDtBQUdGLDZDQUE2QztBQUM3Q2xCLE9BQU95QixVQUFVLENBQUNDLFdBQVcsR0FBRyxTQUFVbUgsQ0FBQztJQUN6QyxJQUFJLE9BQU9BLE1BQU0sVUFBVTtRQUN6QixPQUFPN0ksT0FBT3lCLFVBQVUsQ0FBQ3FILFNBQVMsQ0FBQ0Q7SUFDckM7SUFFQSxJQUFJQSxhQUFhM0gsU0FBUztRQUN4QixPQUFPbEIsT0FBT3lCLFVBQVUsQ0FBQ1AsT0FBTyxDQUFDMkg7SUFDbkM7SUFFQSxPQUFPN0ksT0FBT3lCLFVBQVUsQ0FBQ3FILFNBQVMsQ0FBQ0Q7QUFDckM7QUFFQTdJLE9BQU95QixVQUFVLENBQUNzSCxXQUFXLEdBQUcvSSxPQUFPNEksa0JBQWtCLENBQ3ZERztBQUdGLDZDQUE2QztBQUM3Qy9JLE9BQU95QixVQUFVLENBQUNFLFdBQVcsR0FBRzNCLE9BQU9nSixtQkFBbUIsQ0FBQztJQUN6RDtRQUNFekQsS0FBSztRQUNMMEQsV0FBV2pKLE9BQU95QixVQUFVLENBQUN5SCxVQUFVO0lBQ3pDO0lBQ0E7UUFDRTNELEtBQUs7UUFDTDBELFdBQVdqSixPQUFPeUIsVUFBVSxDQUFDMEgsV0FBVztJQUMxQztJQUNBO1FBQ0U1RCxLQUFLO1FBQ0wwRCxXQUFXakosT0FBT29KLGlCQUFpQixDQUNqQ3BKLE9BQU95QixVQUFVLENBQUM0SCxRQUFRO0lBRTlCO0lBQ0E7UUFDRTlELEtBQUs7UUFDTDBELFdBQVdqSixPQUFPeUIsVUFBVSxDQUFDcUgsU0FBUztJQUN4QztJQUNBO1FBQ0V2RCxLQUFLO1FBQ0wwRCxXQUFXakosT0FBT3lCLFVBQVUsQ0FBQzZILFNBQVM7UUFDdEMsbUVBQW1FO1FBQ25FQyxlQUFlbks7SUFDakI7SUFDQTtRQUNFbUcsS0FBSztRQUNMMEQsV0FBV2pKLE9BQU95QixVQUFVLENBQUM2SCxTQUFTO1FBQ3RDLHNEQUFzRDtRQUN0REMsZUFBZWpLO0lBQ2pCO0lBQ0E7UUFDRWlHLEtBQUs7UUFDTDBELFdBQVdqSixPQUFPeUIsVUFBVSxDQUFDNkgsU0FBUztRQUN0QyxvREFBb0Q7UUFDcERDLGVBQWVoSztJQUNqQjtJQUNBO1FBQ0VnRyxLQUFLO1FBQ0wwRCxXQUFXakosT0FBT3lCLFVBQVUsQ0FBQzZILFNBQVM7UUFDdEMsOENBQThDO1FBQzlDQyxlQUFlL0o7SUFDakI7SUFDQTtRQUNFK0YsS0FBSztRQUNMMEQsV0FBV2pKLE9BQU95QixVQUFVLENBQUM2SCxTQUFTO1FBQ3RDLGlEQUFpRDtRQUNqREMsZUFBZWxLO0lBQ2pCO0lBQ0E7UUFDRWtHLEtBQUs7UUFDTDBELFdBQVdqSixPQUFPeUIsVUFBVSxDQUFDNkgsU0FBUztJQUN4QztJQUNBO1FBQ0UvRCxLQUFLO1FBQ0wwRCxXQUFXakosT0FBT3lCLFVBQVUsQ0FBQytILE9BQU87SUFDdEM7SUFDQTtRQUNFakUsS0FBSztRQUNMMEQsV0FBV2pKLE9BQU9vSixpQkFBaUIsQ0FDakMsQ0FBQ3JJLFNBQVdmLE9BQU95QixVQUFVLENBQUNzSCxXQUFXLENBQ3ZDaEksUUFDQTtnQkFBRTBJLFFBQVE7WUFBTTtJQUd0QjtJQUNBO1FBQ0VsRSxLQUFLO1FBQ0wwRCxXQUFXakosT0FBT3lCLFVBQVUsQ0FBQ2lJLEdBQUc7SUFDbEM7SUFDQTtRQUNFbkUsS0FBSztRQUNMMEQsV0FBV2pKLE9BQU95QixVQUFVLENBQUM2SCxTQUFTO1FBQ3RDQyxlQUFlOUo7SUFDakI7Q0FDRDtBQUVEa0ssT0FBT0MsT0FBTyxHQUFHO0lBQUUxSTtJQUFTdUI7QUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL3JlcXVlc3QuanM/MWE2OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWxzIEFib3J0Q29udHJvbGxlciAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgeyBleHRyYWN0Qm9keSwgbWl4aW5Cb2R5LCBjbG9uZUJvZHkgfSA9IHJlcXVpcmUoJy4vYm9keScpXG5jb25zdCB7IEhlYWRlcnMsIGZpbGw6IGZpbGxIZWFkZXJzLCBIZWFkZXJzTGlzdCB9ID0gcmVxdWlyZSgnLi9oZWFkZXJzJylcbmNvbnN0IHsgRmluYWxpemF0aW9uUmVnaXN0cnkgfSA9IHJlcXVpcmUoJy4uL2NvbXBhdC9kaXNwYXRjaGVyLXdlYWtyZWYnKSgpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHtcbiAgaXNWYWxpZEhUVFBUb2tlbixcbiAgc2FtZU9yaWdpbixcbiAgbm9ybWFsaXplTWV0aG9kLFxuICBtYWtlUG9saWN5Q29udGFpbmVyLFxuICBub3JtYWxpemVNZXRob2RSZWNvcmRcbn0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3Qge1xuICBmb3JiaWRkZW5NZXRob2RzU2V0LFxuICBjb3JzU2FmZUxpc3RlZE1ldGhvZHNTZXQsXG4gIHJlZmVycmVyUG9saWN5LFxuICByZXF1ZXN0UmVkaXJlY3QsXG4gIHJlcXVlc3RNb2RlLFxuICByZXF1ZXN0Q3JlZGVudGlhbHMsXG4gIHJlcXVlc3RDYWNoZSxcbiAgcmVxdWVzdER1cGxleFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gdXRpbFxuY29uc3QgeyBrSGVhZGVycywga1NpZ25hbCwga1N0YXRlLCBrR3VhcmQsIGtSZWFsbSB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuL3dlYmlkbCcpXG5jb25zdCB7IGdldEdsb2JhbE9yaWdpbiB9ID0gcmVxdWlyZSgnLi9nbG9iYWwnKVxuY29uc3QgeyBVUkxTZXJpYWxpemVyIH0gPSByZXF1aXJlKCcuL2RhdGFVUkwnKVxuY29uc3QgeyBrSGVhZGVyc0xpc3QsIGtDb25zdHJ1Y3QgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgeyBnZXRNYXhMaXN0ZW5lcnMsIHNldE1heExpc3RlbmVycywgZ2V0RXZlbnRMaXN0ZW5lcnMsIGRlZmF1bHRNYXhMaXN0ZW5lcnMgfSA9IHJlcXVpcmUoJ2V2ZW50cycpXG5cbmxldCBUcmFuc2Zvcm1TdHJlYW0gPSBnbG9iYWxUaGlzLlRyYW5zZm9ybVN0cmVhbVxuXG5jb25zdCBrQWJvcnRDb250cm9sbGVyID0gU3ltYm9sKCdhYm9ydENvbnRyb2xsZXInKVxuXG5jb25zdCByZXF1ZXN0RmluYWxpemVyID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KCh7IHNpZ25hbCwgYWJvcnQgfSkgPT4ge1xuICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydClcbn0pXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0LWNsYXNzXG5jbGFzcyBSZXF1ZXN0IHtcbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXF1ZXN0XG4gIGNvbnN0cnVjdG9yIChpbnB1dCwgaW5pdCA9IHt9KSB7XG4gICAgaWYgKGlucHV0ID09PSBrQ29uc3RydWN0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnUmVxdWVzdCBjb25zdHJ1Y3RvcicgfSlcblxuICAgIGlucHV0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8oaW5wdXQpXG4gICAgaW5pdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbml0KGluaXQpXG5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS93ZWJhcHBhcGlzLmh0bWwjZW52aXJvbm1lbnQtc2V0dGluZ3Mtb2JqZWN0XG4gICAgdGhpc1trUmVhbG1dID0ge1xuICAgICAgc2V0dGluZ3NPYmplY3Q6IHtcbiAgICAgICAgYmFzZVVybDogZ2V0R2xvYmFsT3JpZ2luKCksXG4gICAgICAgIGdldCBvcmlnaW4gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJhc2VVcmw/Lm9yaWdpblxuICAgICAgICB9LFxuICAgICAgICBwb2xpY3lDb250YWluZXI6IG1ha2VQb2xpY3lDb250YWluZXIoKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDEuIExldCByZXF1ZXN0IGJlIG51bGwuXG4gICAgbGV0IHJlcXVlc3QgPSBudWxsXG5cbiAgICAvLyAyLiBMZXQgZmFsbGJhY2tNb2RlIGJlIG51bGwuXG4gICAgbGV0IGZhbGxiYWNrTW9kZSA9IG51bGxcblxuICAgIC8vIDMuIExldCBiYXNlVVJMIGJlIHRoaXPigJlzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdOKAmXMgQVBJIGJhc2UgVVJMLlxuICAgIGNvbnN0IGJhc2VVcmwgPSB0aGlzW2tSZWFsbV0uc2V0dGluZ3NPYmplY3QuYmFzZVVybFxuXG4gICAgLy8gNC4gTGV0IHNpZ25hbCBiZSBudWxsLlxuICAgIGxldCBzaWduYWwgPSBudWxsXG5cbiAgICAvLyA1LiBJZiBpbnB1dCBpcyBhIHN0cmluZywgdGhlbjpcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gMS4gTGV0IHBhcnNlZFVSTCBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgaW5wdXQgd2l0aCBiYXNlVVJMLlxuICAgICAgLy8gMi4gSWYgcGFyc2VkVVJMIGlzIGZhaWx1cmUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBsZXQgcGFyc2VkVVJMXG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWRVUkwgPSBuZXcgVVJMKGlucHV0LCBiYXNlVXJsKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBVUkwgZnJvbSAnICsgaW5wdXQsIHsgY2F1c2U6IGVyciB9KVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBJZiBwYXJzZWRVUkwgaW5jbHVkZXMgY3JlZGVudGlhbHMsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBpZiAocGFyc2VkVVJMLnVzZXJuYW1lIHx8IHBhcnNlZFVSTC5wYXNzd29yZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdSZXF1ZXN0IGNhbm5vdCBiZSBjb25zdHJ1Y3RlZCBmcm9tIGEgVVJMIHRoYXQgaW5jbHVkZXMgY3JlZGVudGlhbHM6ICcgK1xuICAgICAgICAgICAgaW5wdXRcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyA0LiBTZXQgcmVxdWVzdCB0byBhIG5ldyByZXF1ZXN0IHdob3NlIFVSTCBpcyBwYXJzZWRVUkwuXG4gICAgICByZXF1ZXN0ID0gbWFrZVJlcXVlc3QoeyB1cmxMaXN0OiBbcGFyc2VkVVJMXSB9KVxuXG4gICAgICAvLyA1LiBTZXQgZmFsbGJhY2tNb2RlIHRvIFwiY29yc1wiLlxuICAgICAgZmFsbGJhY2tNb2RlID0gJ2NvcnMnXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDYuIE90aGVyd2lzZTpcblxuICAgICAgLy8gNy4gQXNzZXJ0OiBpbnB1dCBpcyBhIFJlcXVlc3Qgb2JqZWN0LlxuICAgICAgYXNzZXJ0KGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdClcblxuICAgICAgLy8gOC4gU2V0IHJlcXVlc3QgdG8gaW5wdXTigJlzIHJlcXVlc3QuXG4gICAgICByZXF1ZXN0ID0gaW5wdXRba1N0YXRlXVxuXG4gICAgICAvLyA5LiBTZXQgc2lnbmFsIHRvIGlucHV04oCZcyBzaWduYWwuXG4gICAgICBzaWduYWwgPSBpbnB1dFtrU2lnbmFsXVxuICAgIH1cblxuICAgIC8vIDcuIExldCBvcmlnaW4gYmUgdGhpc+KAmXMgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN04oCZcyBvcmlnaW4uXG4gICAgY29uc3Qgb3JpZ2luID0gdGhpc1trUmVhbG1dLnNldHRpbmdzT2JqZWN0Lm9yaWdpblxuXG4gICAgLy8gOC4gTGV0IHdpbmRvdyBiZSBcImNsaWVudFwiLlxuICAgIGxldCB3aW5kb3cgPSAnY2xpZW50J1xuXG4gICAgLy8gOS4gSWYgcmVxdWVzdOKAmXMgd2luZG93IGlzIGFuIGVudmlyb25tZW50IHNldHRpbmdzIG9iamVjdCBhbmQgaXRzIG9yaWdpblxuICAgIC8vIGlzIHNhbWUgb3JpZ2luIHdpdGggb3JpZ2luLCB0aGVuIHNldCB3aW5kb3cgdG8gcmVxdWVzdOKAmXMgd2luZG93LlxuICAgIGlmIChcbiAgICAgIHJlcXVlc3Qud2luZG93Py5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ0Vudmlyb25tZW50U2V0dGluZ3NPYmplY3QnICYmXG4gICAgICBzYW1lT3JpZ2luKHJlcXVlc3Qud2luZG93LCBvcmlnaW4pXG4gICAgKSB7XG4gICAgICB3aW5kb3cgPSByZXF1ZXN0LndpbmRvd1xuICAgIH1cblxuICAgIC8vIDEwLiBJZiBpbml0W1wid2luZG93XCJdIGV4aXN0cyBhbmQgaXMgbm9uLW51bGwsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKGluaXQud2luZG93ICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCd3aW5kb3cnIG9wdGlvbiAnJHt3aW5kb3d9JyBtdXN0IGJlIG51bGxgKVxuICAgIH1cblxuICAgIC8vIDExLiBJZiBpbml0W1wid2luZG93XCJdIGV4aXN0cywgdGhlbiBzZXQgd2luZG93IHRvIFwibm8td2luZG93XCIuXG4gICAgaWYgKCd3aW5kb3cnIGluIGluaXQpIHtcbiAgICAgIHdpbmRvdyA9ICduby13aW5kb3cnXG4gICAgfVxuXG4gICAgLy8gMTIuIFNldCByZXF1ZXN0IHRvIGEgbmV3IHJlcXVlc3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0KHtcbiAgICAgIC8vIFVSTCByZXF1ZXN04oCZcyBVUkwuXG4gICAgICAvLyB1bmRpY2kgaW1wbGVtZW50YXRpb24gbm90ZTogdGhpcyBpcyBzZXQgYXMgdGhlIGZpcnN0IGl0ZW0gaW4gcmVxdWVzdCdzIHVybExpc3QgaW4gbWFrZVJlcXVlc3RcbiAgICAgIC8vIG1ldGhvZCByZXF1ZXN04oCZcyBtZXRob2QuXG4gICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgLy8gaGVhZGVyIGxpc3QgQSBjb3B5IG9mIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAgICAgLy8gdW5kaWNpIGltcGxlbWVudGF0aW9uIG5vdGU6IGhlYWRlcnNMaXN0IGlzIGNsb25lZCBpbiBtYWtlUmVxdWVzdFxuICAgICAgaGVhZGVyc0xpc3Q6IHJlcXVlc3QuaGVhZGVyc0xpc3QsXG4gICAgICAvLyB1bnNhZmUtcmVxdWVzdCBmbGFnIFNldC5cbiAgICAgIHVuc2FmZVJlcXVlc3Q6IHJlcXVlc3QudW5zYWZlUmVxdWVzdCxcbiAgICAgIC8vIGNsaWVudCBUaGlz4oCZcyByZWxldmFudCBzZXR0aW5ncyBvYmplY3QuXG4gICAgICBjbGllbnQ6IHRoaXNba1JlYWxtXS5zZXR0aW5nc09iamVjdCxcbiAgICAgIC8vIHdpbmRvdyB3aW5kb3cuXG4gICAgICB3aW5kb3csXG4gICAgICAvLyBwcmlvcml0eSByZXF1ZXN04oCZcyBwcmlvcml0eS5cbiAgICAgIHByaW9yaXR5OiByZXF1ZXN0LnByaW9yaXR5LFxuICAgICAgLy8gb3JpZ2luIHJlcXVlc3TigJlzIG9yaWdpbi4gVGhlIHByb3BhZ2F0aW9uIG9mIHRoZSBvcmlnaW4gaXMgb25seSBzaWduaWZpY2FudCBmb3IgbmF2aWdhdGlvbiByZXF1ZXN0c1xuICAgICAgLy8gYmVpbmcgaGFuZGxlZCBieSBhIHNlcnZpY2Ugd29ya2VyLiBJbiB0aGlzIHNjZW5hcmlvIGEgcmVxdWVzdCBjYW4gaGF2ZSBhbiBvcmlnaW4gdGhhdCBpcyBkaWZmZXJlbnRcbiAgICAgIC8vIGZyb20gdGhlIGN1cnJlbnQgY2xpZW50LlxuICAgICAgb3JpZ2luOiByZXF1ZXN0Lm9yaWdpbixcbiAgICAgIC8vIHJlZmVycmVyIHJlcXVlc3TigJlzIHJlZmVycmVyLlxuICAgICAgcmVmZXJyZXI6IHJlcXVlc3QucmVmZXJyZXIsXG4gICAgICAvLyByZWZlcnJlciBwb2xpY3kgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5LlxuICAgICAgcmVmZXJyZXJQb2xpY3k6IHJlcXVlc3QucmVmZXJyZXJQb2xpY3ksXG4gICAgICAvLyBtb2RlIHJlcXVlc3TigJlzIG1vZGUuXG4gICAgICBtb2RlOiByZXF1ZXN0Lm1vZGUsXG4gICAgICAvLyBjcmVkZW50aWFscyBtb2RlIHJlcXVlc3TigJlzIGNyZWRlbnRpYWxzIG1vZGUuXG4gICAgICBjcmVkZW50aWFsczogcmVxdWVzdC5jcmVkZW50aWFscyxcbiAgICAgIC8vIGNhY2hlIG1vZGUgcmVxdWVzdOKAmXMgY2FjaGUgbW9kZS5cbiAgICAgIGNhY2hlOiByZXF1ZXN0LmNhY2hlLFxuICAgICAgLy8gcmVkaXJlY3QgbW9kZSByZXF1ZXN04oCZcyByZWRpcmVjdCBtb2RlLlxuICAgICAgcmVkaXJlY3Q6IHJlcXVlc3QucmVkaXJlY3QsXG4gICAgICAvLyBpbnRlZ3JpdHkgbWV0YWRhdGEgcmVxdWVzdOKAmXMgaW50ZWdyaXR5IG1ldGFkYXRhLlxuICAgICAgaW50ZWdyaXR5OiByZXF1ZXN0LmludGVncml0eSxcbiAgICAgIC8vIGtlZXBhbGl2ZSByZXF1ZXN04oCZcyBrZWVwYWxpdmUuXG4gICAgICBrZWVwYWxpdmU6IHJlcXVlc3Qua2VlcGFsaXZlLFxuICAgICAgLy8gcmVsb2FkLW5hdmlnYXRpb24gZmxhZyByZXF1ZXN04oCZcyByZWxvYWQtbmF2aWdhdGlvbiBmbGFnLlxuICAgICAgcmVsb2FkTmF2aWdhdGlvbjogcmVxdWVzdC5yZWxvYWROYXZpZ2F0aW9uLFxuICAgICAgLy8gaGlzdG9yeS1uYXZpZ2F0aW9uIGZsYWcgcmVxdWVzdOKAmXMgaGlzdG9yeS1uYXZpZ2F0aW9uIGZsYWcuXG4gICAgICBoaXN0b3J5TmF2aWdhdGlvbjogcmVxdWVzdC5oaXN0b3J5TmF2aWdhdGlvbixcbiAgICAgIC8vIFVSTCBsaXN0IEEgY2xvbmUgb2YgcmVxdWVzdOKAmXMgVVJMIGxpc3QuXG4gICAgICB1cmxMaXN0OiBbLi4ucmVxdWVzdC51cmxMaXN0XVxuICAgIH0pXG5cbiAgICBjb25zdCBpbml0SGFzS2V5ID0gT2JqZWN0LmtleXMoaW5pdCkubGVuZ3RoICE9PSAwXG5cbiAgICAvLyAxMy4gSWYgaW5pdCBpcyBub3QgZW1wdHksIHRoZW46XG4gICAgaWYgKGluaXRIYXNLZXkpIHtcbiAgICAgIC8vIDEuIElmIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJuYXZpZ2F0ZVwiLCB0aGVuIHNldCBpdCB0byBcInNhbWUtb3JpZ2luXCIuXG4gICAgICBpZiAocmVxdWVzdC5tb2RlID09PSAnbmF2aWdhdGUnKSB7XG4gICAgICAgIHJlcXVlc3QubW9kZSA9ICdzYW1lLW9yaWdpbidcbiAgICAgIH1cblxuICAgICAgLy8gMi4gVW5zZXQgcmVxdWVzdOKAmXMgcmVsb2FkLW5hdmlnYXRpb24gZmxhZy5cbiAgICAgIHJlcXVlc3QucmVsb2FkTmF2aWdhdGlvbiA9IGZhbHNlXG5cbiAgICAgIC8vIDMuIFVuc2V0IHJlcXVlc3TigJlzIGhpc3RvcnktbmF2aWdhdGlvbiBmbGFnLlxuICAgICAgcmVxdWVzdC5oaXN0b3J5TmF2aWdhdGlvbiA9IGZhbHNlXG5cbiAgICAgIC8vIDQuIFNldCByZXF1ZXN04oCZcyBvcmlnaW4gdG8gXCJjbGllbnRcIi5cbiAgICAgIHJlcXVlc3Qub3JpZ2luID0gJ2NsaWVudCdcblxuICAgICAgLy8gNS4gU2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHRvIFwiY2xpZW50XCJcbiAgICAgIHJlcXVlc3QucmVmZXJyZXIgPSAnY2xpZW50J1xuXG4gICAgICAvLyA2LiBTZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5IHRvIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICByZXF1ZXN0LnJlZmVycmVyUG9saWN5ID0gJydcblxuICAgICAgLy8gNy4gU2V0IHJlcXVlc3TigJlzIFVSTCB0byByZXF1ZXN04oCZcyBjdXJyZW50IFVSTC5cbiAgICAgIHJlcXVlc3QudXJsID0gcmVxdWVzdC51cmxMaXN0W3JlcXVlc3QudXJsTGlzdC5sZW5ndGggLSAxXVxuXG4gICAgICAvLyA4LiBTZXQgcmVxdWVzdOKAmXMgVVJMIGxpc3QgdG8gwqsgcmVxdWVzdOKAmXMgVVJMIMK7LlxuICAgICAgcmVxdWVzdC51cmxMaXN0ID0gW3JlcXVlc3QudXJsXVxuICAgIH1cblxuICAgIC8vIDE0LiBJZiBpbml0W1wicmVmZXJyZXJcIl0gZXhpc3RzLCB0aGVuOlxuICAgIGlmIChpbml0LnJlZmVycmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIDEuIExldCByZWZlcnJlciBiZSBpbml0W1wicmVmZXJyZXJcIl0uXG4gICAgICBjb25zdCByZWZlcnJlciA9IGluaXQucmVmZXJyZXJcblxuICAgICAgLy8gMi4gSWYgcmVmZXJyZXIgaXMgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBzZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgdG8gXCJuby1yZWZlcnJlclwiLlxuICAgICAgaWYgKHJlZmVycmVyID09PSAnJykge1xuICAgICAgICByZXF1ZXN0LnJlZmVycmVyID0gJ25vLXJlZmVycmVyJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gMS4gTGV0IHBhcnNlZFJlZmVycmVyIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZyByZWZlcnJlciB3aXRoXG4gICAgICAgIC8vIGJhc2VVUkwuXG4gICAgICAgIC8vIDIuIElmIHBhcnNlZFJlZmVycmVyIGlzIGZhaWx1cmUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICAgIGxldCBwYXJzZWRSZWZlcnJlclxuICAgICAgICB0cnkge1xuICAgICAgICAgIHBhcnNlZFJlZmVycmVyID0gbmV3IFVSTChyZWZlcnJlciwgYmFzZVVybClcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUmVmZXJyZXIgXCIke3JlZmVycmVyfVwiIGlzIG5vdCBhIHZhbGlkIFVSTC5gLCB7IGNhdXNlOiBlcnIgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuIElmIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWVcbiAgICAgICAgLy8gLSBwYXJzZWRSZWZlcnJlcuKAmXMgc2NoZW1lIGlzIFwiYWJvdXRcIiBhbmQgcGF0aCBpcyB0aGUgc3RyaW5nIFwiY2xpZW50XCJcbiAgICAgICAgLy8gLSBwYXJzZWRSZWZlcnJlcuKAmXMgb3JpZ2luIGlzIG5vdCBzYW1lIG9yaWdpbiB3aXRoIG9yaWdpblxuICAgICAgICAvLyB0aGVuIHNldCByZXF1ZXN04oCZcyByZWZlcnJlciB0byBcImNsaWVudFwiLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgKHBhcnNlZFJlZmVycmVyLnByb3RvY29sID09PSAnYWJvdXQ6JyAmJiBwYXJzZWRSZWZlcnJlci5ob3N0bmFtZSA9PT0gJ2NsaWVudCcpIHx8XG4gICAgICAgICAgKG9yaWdpbiAmJiAhc2FtZU9yaWdpbihwYXJzZWRSZWZlcnJlciwgdGhpc1trUmVhbG1dLnNldHRpbmdzT2JqZWN0LmJhc2VVcmwpKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXF1ZXN0LnJlZmVycmVyID0gJ2NsaWVudCdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyA0LiBPdGhlcndpc2UsIHNldCByZXF1ZXN04oCZcyByZWZlcnJlciB0byBwYXJzZWRSZWZlcnJlci5cbiAgICAgICAgICByZXF1ZXN0LnJlZmVycmVyID0gcGFyc2VkUmVmZXJyZXJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDE1LiBJZiBpbml0W1wicmVmZXJyZXJQb2xpY3lcIl0gZXhpc3RzLCB0aGVuIHNldCByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3lcbiAgICAvLyB0byBpdC5cbiAgICBpZiAoaW5pdC5yZWZlcnJlclBvbGljeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0LnJlZmVycmVyUG9saWN5ID0gaW5pdC5yZWZlcnJlclBvbGljeVxuICAgIH1cblxuICAgIC8vIDE2LiBMZXQgbW9kZSBiZSBpbml0W1wibW9kZVwiXSBpZiBpdCBleGlzdHMsIGFuZCBmYWxsYmFja01vZGUgb3RoZXJ3aXNlLlxuICAgIGxldCBtb2RlXG4gICAgaWYgKGluaXQubW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBtb2RlID0gaW5pdC5tb2RlXG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGUgPSBmYWxsYmFja01vZGVcbiAgICB9XG5cbiAgICAvLyAxNy4gSWYgbW9kZSBpcyBcIm5hdmlnYXRlXCIsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKG1vZGUgPT09ICduYXZpZ2F0ZScpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnUmVxdWVzdCBjb25zdHJ1Y3RvcicsXG4gICAgICAgIG1lc3NhZ2U6ICdpbnZhbGlkIHJlcXVlc3QgbW9kZSBuYXZpZ2F0ZS4nXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDE4LiBJZiBtb2RlIGlzIG5vbi1udWxsLCBzZXQgcmVxdWVzdOKAmXMgbW9kZSB0byBtb2RlLlxuICAgIGlmIChtb2RlICE9IG51bGwpIHtcbiAgICAgIHJlcXVlc3QubW9kZSA9IG1vZGVcbiAgICB9XG5cbiAgICAvLyAxOS4gSWYgaW5pdFtcImNyZWRlbnRpYWxzXCJdIGV4aXN0cywgdGhlbiBzZXQgcmVxdWVzdOKAmXMgY3JlZGVudGlhbHMgbW9kZVxuICAgIC8vIHRvIGl0LlxuICAgIGlmIChpbml0LmNyZWRlbnRpYWxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3QuY3JlZGVudGlhbHMgPSBpbml0LmNyZWRlbnRpYWxzXG4gICAgfVxuXG4gICAgLy8gMTguIElmIGluaXRbXCJjYWNoZVwiXSBleGlzdHMsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGNhY2hlIG1vZGUgdG8gaXQuXG4gICAgaWYgKGluaXQuY2FjaGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdC5jYWNoZSA9IGluaXQuY2FjaGVcbiAgICB9XG5cbiAgICAvLyAyMS4gSWYgcmVxdWVzdOKAmXMgY2FjaGUgbW9kZSBpcyBcIm9ubHktaWYtY2FjaGVkXCIgYW5kIHJlcXVlc3TigJlzIG1vZGUgaXNcbiAgICAvLyBub3QgXCJzYW1lLW9yaWdpblwiLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmIChyZXF1ZXN0LmNhY2hlID09PSAnb25seS1pZi1jYWNoZWQnICYmIHJlcXVlc3QubW9kZSAhPT0gJ3NhbWUtb3JpZ2luJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCInb25seS1pZi1jYWNoZWQnIGNhbiBiZSBzZXQgb25seSB3aXRoICdzYW1lLW9yaWdpbicgbW9kZVwiXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gMjIuIElmIGluaXRbXCJyZWRpcmVjdFwiXSBleGlzdHMsIHRoZW4gc2V0IHJlcXVlc3TigJlzIHJlZGlyZWN0IG1vZGUgdG8gaXQuXG4gICAgaWYgKGluaXQucmVkaXJlY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdC5yZWRpcmVjdCA9IGluaXQucmVkaXJlY3RcbiAgICB9XG5cbiAgICAvLyAyMy4gSWYgaW5pdFtcImludGVncml0eVwiXSBleGlzdHMsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGludGVncml0eSBtZXRhZGF0YSB0byBpdC5cbiAgICBpZiAoaW5pdC5pbnRlZ3JpdHkgIT0gbnVsbCkge1xuICAgICAgcmVxdWVzdC5pbnRlZ3JpdHkgPSBTdHJpbmcoaW5pdC5pbnRlZ3JpdHkpXG4gICAgfVxuXG4gICAgLy8gMjQuIElmIGluaXRbXCJrZWVwYWxpdmVcIl0gZXhpc3RzLCB0aGVuIHNldCByZXF1ZXN04oCZcyBrZWVwYWxpdmUgdG8gaXQuXG4gICAgaWYgKGluaXQua2VlcGFsaXZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3Qua2VlcGFsaXZlID0gQm9vbGVhbihpbml0LmtlZXBhbGl2ZSlcbiAgICB9XG5cbiAgICAvLyAyNS4gSWYgaW5pdFtcIm1ldGhvZFwiXSBleGlzdHMsIHRoZW46XG4gICAgaWYgKGluaXQubWV0aG9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIDEuIExldCBtZXRob2QgYmUgaW5pdFtcIm1ldGhvZFwiXS5cbiAgICAgIGxldCBtZXRob2QgPSBpbml0Lm1ldGhvZFxuXG4gICAgICAvLyAyLiBJZiBtZXRob2QgaXMgbm90IGEgbWV0aG9kIG9yIG1ldGhvZCBpcyBhIGZvcmJpZGRlbiBtZXRob2QsIHRoZW5cbiAgICAgIC8vIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKCFpc1ZhbGlkSFRUUFRva2VuKG1ldGhvZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJyR7bWV0aG9kfScgaXMgbm90IGEgdmFsaWQgSFRUUCBtZXRob2QuYClcbiAgICAgIH1cblxuICAgICAgaWYgKGZvcmJpZGRlbk1ldGhvZHNTZXQuaGFzKG1ldGhvZC50b1VwcGVyQ2FzZSgpKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAnJHttZXRob2R9JyBIVFRQIG1ldGhvZCBpcyB1bnN1cHBvcnRlZC5gKVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBOb3JtYWxpemUgbWV0aG9kLlxuICAgICAgbWV0aG9kID0gbm9ybWFsaXplTWV0aG9kUmVjb3JkW21ldGhvZF0gPz8gbm9ybWFsaXplTWV0aG9kKG1ldGhvZClcblxuICAgICAgLy8gNC4gU2V0IHJlcXVlc3TigJlzIG1ldGhvZCB0byBtZXRob2QuXG4gICAgICByZXF1ZXN0Lm1ldGhvZCA9IG1ldGhvZFxuICAgIH1cblxuICAgIC8vIDI2LiBJZiBpbml0W1wic2lnbmFsXCJdIGV4aXN0cywgdGhlbiBzZXQgc2lnbmFsIHRvIGl0LlxuICAgIGlmIChpbml0LnNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzaWduYWwgPSBpbml0LnNpZ25hbFxuICAgIH1cblxuICAgIC8vIDI3LiBTZXQgdGhpc+KAmXMgcmVxdWVzdCB0byByZXF1ZXN0LlxuICAgIHRoaXNba1N0YXRlXSA9IHJlcXVlc3RcblxuICAgIC8vIDI4LiBTZXQgdGhpc+KAmXMgc2lnbmFsIHRvIGEgbmV3IEFib3J0U2lnbmFsIG9iamVjdCB3aXRoIHRoaXPigJlzIHJlbGV2YW50XG4gICAgLy8gUmVhbG0uXG4gICAgLy8gVE9ETzogY291bGQgdGhpcyBiZSBzaW1wbGlmaWVkIHdpdGggQWJvcnRTaWduYWwuYW55XG4gICAgLy8gKGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWFib3J0c2lnbmFsLWFueSlcbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgIHRoaXNba1NpZ25hbF0gPSBhYy5zaWduYWxcbiAgICB0aGlzW2tTaWduYWxdW2tSZWFsbV0gPSB0aGlzW2tSZWFsbV1cblxuICAgIC8vIDI5LiBJZiBzaWduYWwgaXMgbm90IG51bGwsIHRoZW4gbWFrZSB0aGlz4oCZcyBzaWduYWwgZm9sbG93IHNpZ25hbC5cbiAgICBpZiAoc2lnbmFsICE9IG51bGwpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIXNpZ25hbCB8fFxuICAgICAgICB0eXBlb2Ygc2lnbmFsLmFib3J0ZWQgIT09ICdib29sZWFuJyB8fFxuICAgICAgICB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICdmdW5jdGlvbidcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVxdWVzdCc6IG1lbWJlciBzaWduYWwgaXMgbm90IG9mIHR5cGUgQWJvcnRTaWduYWwuXCJcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgYWMuYWJvcnQoc2lnbmFsLnJlYXNvbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEtlZXAgYSBzdHJvbmcgcmVmIHRvIGFjIHdoaWxlIHJlcXVlc3Qgb2JqZWN0XG4gICAgICAgIC8vIGlzIGFsaXZlLiBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50IEFib3J0Q29udHJvbGxlclxuICAgICAgICAvLyBmcm9tIGJlaW5nIHByZW1hdHVyZWx5IGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgICAgICAvLyBTZWUsIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xOTI2LlxuICAgICAgICB0aGlzW2tBYm9ydENvbnRyb2xsZXJdID0gYWNcblxuICAgICAgICBjb25zdCBhY1JlZiA9IG5ldyBXZWFrUmVmKGFjKVxuICAgICAgICBjb25zdCBhYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zdCBhYyA9IGFjUmVmLmRlcmVmKClcbiAgICAgICAgICBpZiAoYWMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYWMuYWJvcnQodGhpcy5yZWFzb24pXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcmQtcGFydHkgQWJvcnRDb250cm9sbGVycyBtYXkgbm90IHdvcmsgd2l0aCB0aGVzZS5cbiAgICAgICAgLy8gU2VlLCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9wdWxsLzE5MTAjaXNzdWVjb21tZW50LTE0NjQ0OTU2MTkuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gSWYgdGhlIG1heCBhbW91bnQgb2YgbGlzdGVuZXJzIGlzIGVxdWFsIHRvIHRoZSBkZWZhdWx0LCBpbmNyZWFzZSBpdFxuICAgICAgICAgIC8vIFRoaXMgaXMgb25seSBhdmFpbGFibGUgaW4gbm9kZSA+PSB2MTkuOS4wXG4gICAgICAgICAgaWYgKHR5cGVvZiBnZXRNYXhMaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicgJiYgZ2V0TWF4TGlzdGVuZXJzKHNpZ25hbCkgPT09IGRlZmF1bHRNYXhMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHNldE1heExpc3RlbmVycygxMDAsIHNpZ25hbClcbiAgICAgICAgICB9IGVsc2UgaWYgKGdldEV2ZW50TGlzdGVuZXJzKHNpZ25hbCwgJ2Fib3J0JykubGVuZ3RoID49IGRlZmF1bHRNYXhMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHNldE1heExpc3RlbmVycygxMDAsIHNpZ25hbClcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge31cblxuICAgICAgICB1dGlsLmFkZEFib3J0TGlzdGVuZXIoc2lnbmFsLCBhYm9ydClcbiAgICAgICAgcmVxdWVzdEZpbmFsaXplci5yZWdpc3RlcihhYywgeyBzaWduYWwsIGFib3J0IH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMzAuIFNldCB0aGlz4oCZcyBoZWFkZXJzIHRvIGEgbmV3IEhlYWRlcnMgb2JqZWN0IHdpdGggdGhpc+KAmXMgcmVsZXZhbnRcbiAgICAvLyBSZWFsbSwgd2hvc2UgaGVhZGVyIGxpc3QgaXMgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgYW5kIGd1YXJkIGlzXG4gICAgLy8gXCJyZXF1ZXN0XCIuXG4gICAgdGhpc1trSGVhZGVyc10gPSBuZXcgSGVhZGVycyhrQ29uc3RydWN0KVxuICAgIHRoaXNba0hlYWRlcnNdW2tIZWFkZXJzTGlzdF0gPSByZXF1ZXN0LmhlYWRlcnNMaXN0XG4gICAgdGhpc1trSGVhZGVyc11ba0d1YXJkXSA9ICdyZXF1ZXN0J1xuICAgIHRoaXNba0hlYWRlcnNdW2tSZWFsbV0gPSB0aGlzW2tSZWFsbV1cblxuICAgIC8vIDMxLiBJZiB0aGlz4oCZcyByZXF1ZXN04oCZcyBtb2RlIGlzIFwibm8tY29yc1wiLCB0aGVuOlxuICAgIGlmIChtb2RlID09PSAnbm8tY29ycycpIHtcbiAgICAgIC8vIDEuIElmIHRoaXPigJlzIHJlcXVlc3TigJlzIG1ldGhvZCBpcyBub3QgYSBDT1JTLXNhZmVsaXN0ZWQgbWV0aG9kLFxuICAgICAgLy8gdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGlmICghY29yc1NhZmVMaXN0ZWRNZXRob2RzU2V0LmhhcyhyZXF1ZXN0Lm1ldGhvZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBgJyR7cmVxdWVzdC5tZXRob2R9IGlzIHVuc3VwcG9ydGVkIGluIG5vLWNvcnMgbW9kZS5gXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gMi4gU2V0IHRoaXPigJlzIGhlYWRlcnPigJlzIGd1YXJkIHRvIFwicmVxdWVzdC1uby1jb3JzXCIuXG4gICAgICB0aGlzW2tIZWFkZXJzXVtrR3VhcmRdID0gJ3JlcXVlc3Qtbm8tY29ycydcbiAgICB9XG5cbiAgICAvLyAzMi4gSWYgaW5pdCBpcyBub3QgZW1wdHksIHRoZW46XG4gICAgaWYgKGluaXRIYXNLZXkpIHtcbiAgICAgIC8qKiBAdHlwZSB7SGVhZGVyc0xpc3R9ICovXG4gICAgICBjb25zdCBoZWFkZXJzTGlzdCA9IHRoaXNba0hlYWRlcnNdW2tIZWFkZXJzTGlzdF1cbiAgICAgIC8vIDEuIExldCBoZWFkZXJzIGJlIGEgY29weSBvZiB0aGlz4oCZcyBoZWFkZXJzIGFuZCBpdHMgYXNzb2NpYXRlZCBoZWFkZXJcbiAgICAgIC8vIGxpc3QuXG4gICAgICAvLyAyLiBJZiBpbml0W1wiaGVhZGVyc1wiXSBleGlzdHMsIHRoZW4gc2V0IGhlYWRlcnMgdG8gaW5pdFtcImhlYWRlcnNcIl0uXG4gICAgICBjb25zdCBoZWFkZXJzID0gaW5pdC5oZWFkZXJzICE9PSB1bmRlZmluZWQgPyBpbml0LmhlYWRlcnMgOiBuZXcgSGVhZGVyc0xpc3QoaGVhZGVyc0xpc3QpXG5cbiAgICAgIC8vIDMuIEVtcHR5IHRoaXPigJlzIGhlYWRlcnPigJlzIGhlYWRlciBsaXN0LlxuICAgICAgaGVhZGVyc0xpc3QuY2xlYXIoKVxuXG4gICAgICAvLyA0LiBJZiBoZWFkZXJzIGlzIGEgSGVhZGVycyBvYmplY3QsIHRoZW4gZm9yIGVhY2ggaGVhZGVyIGluIGl0cyBoZWFkZXJcbiAgICAgIC8vIGxpc3QsIGFwcGVuZCBoZWFkZXLigJlzIG5hbWUvaGVhZGVy4oCZcyB2YWx1ZSB0byB0aGlz4oCZcyBoZWFkZXJzLlxuICAgICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzTGlzdCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgaGVhZGVycykge1xuICAgICAgICAgIGhlYWRlcnNMaXN0LmFwcGVuZChrZXksIHZhbClcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBDb3B5IHRoZSBgc2V0LWNvb2tpZWAgbWV0YS1kYXRhLlxuICAgICAgICBoZWFkZXJzTGlzdC5jb29raWVzID0gaGVhZGVycy5jb29raWVzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyA1LiBPdGhlcndpc2UsIGZpbGwgdGhpc+KAmXMgaGVhZGVycyB3aXRoIGhlYWRlcnMuXG4gICAgICAgIGZpbGxIZWFkZXJzKHRoaXNba0hlYWRlcnNdLCBoZWFkZXJzKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDMzLiBMZXQgaW5wdXRCb2R5IGJlIGlucHV04oCZcyByZXF1ZXN04oCZcyBib2R5IGlmIGlucHV0IGlzIGEgUmVxdWVzdFxuICAgIC8vIG9iamVjdDsgb3RoZXJ3aXNlIG51bGwuXG4gICAgY29uc3QgaW5wdXRCb2R5ID0gaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0ID8gaW5wdXRba1N0YXRlXS5ib2R5IDogbnVsbFxuXG4gICAgLy8gMzQuIElmIGVpdGhlciBpbml0W1wiYm9keVwiXSBleGlzdHMgYW5kIGlzIG5vbi1udWxsIG9yIGlucHV0Qm9keSBpc1xuICAgIC8vIG5vbi1udWxsLCBhbmQgcmVxdWVzdOKAmXMgbWV0aG9kIGlzIGBHRVRgIG9yIGBIRUFEYCwgdGhlbiB0aHJvdyBhXG4gICAgLy8gVHlwZUVycm9yLlxuICAgIGlmIChcbiAgICAgIChpbml0LmJvZHkgIT0gbnVsbCB8fCBpbnB1dEJvZHkgIT0gbnVsbCkgJiZcbiAgICAgIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0dFVCcgfHwgcmVxdWVzdC5tZXRob2QgPT09ICdIRUFEJylcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlcXVlc3Qgd2l0aCBHRVQvSEVBRCBtZXRob2QgY2Fubm90IGhhdmUgYm9keS4nKVxuICAgIH1cblxuICAgIC8vIDM1LiBMZXQgaW5pdEJvZHkgYmUgbnVsbC5cbiAgICBsZXQgaW5pdEJvZHkgPSBudWxsXG5cbiAgICAvLyAzNi4gSWYgaW5pdFtcImJvZHlcIl0gZXhpc3RzIGFuZCBpcyBub24tbnVsbCwgdGhlbjpcbiAgICBpZiAoaW5pdC5ib2R5ICE9IG51bGwpIHtcbiAgICAgIC8vIDEuIExldCBDb250ZW50LVR5cGUgYmUgbnVsbC5cbiAgICAgIC8vIDIuIFNldCBpbml0Qm9keSBhbmQgQ29udGVudC1UeXBlIHRvIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZ1xuICAgICAgLy8gaW5pdFtcImJvZHlcIl0sIHdpdGgga2VlcGFsaXZlIHNldCB0byByZXF1ZXN04oCZcyBrZWVwYWxpdmUuXG4gICAgICBjb25zdCBbZXh0cmFjdGVkQm9keSwgY29udGVudFR5cGVdID0gZXh0cmFjdEJvZHkoXG4gICAgICAgIGluaXQuYm9keSxcbiAgICAgICAgcmVxdWVzdC5rZWVwYWxpdmVcbiAgICAgIClcbiAgICAgIGluaXRCb2R5ID0gZXh0cmFjdGVkQm9keVxuXG4gICAgICAvLyAzLCBJZiBDb250ZW50LVR5cGUgaXMgbm9uLW51bGwgYW5kIHRoaXPigJlzIGhlYWRlcnPigJlzIGhlYWRlciBsaXN0IGRvZXNcbiAgICAgIC8vIG5vdCBjb250YWluIGBDb250ZW50LVR5cGVgLCB0aGVuIGFwcGVuZCBgQ29udGVudC1UeXBlYC9Db250ZW50LVR5cGUgdG9cbiAgICAgIC8vIHRoaXPigJlzIGhlYWRlcnMuXG4gICAgICBpZiAoY29udGVudFR5cGUgJiYgIXRoaXNba0hlYWRlcnNdW2tIZWFkZXJzTGlzdF0uY29udGFpbnMoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICAgIHRoaXNba0hlYWRlcnNdLmFwcGVuZCgnY29udGVudC10eXBlJywgY29udGVudFR5cGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMzcuIExldCBpbnB1dE9ySW5pdEJvZHkgYmUgaW5pdEJvZHkgaWYgaXQgaXMgbm9uLW51bGw7IG90aGVyd2lzZVxuICAgIC8vIGlucHV0Qm9keS5cbiAgICBjb25zdCBpbnB1dE9ySW5pdEJvZHkgPSBpbml0Qm9keSA/PyBpbnB1dEJvZHlcblxuICAgIC8vIDM4LiBJZiBpbnB1dE9ySW5pdEJvZHkgaXMgbm9uLW51bGwgYW5kIGlucHV0T3JJbml0Qm9keeKAmXMgc291cmNlIGlzXG4gICAgLy8gbnVsbCwgdGhlbjpcbiAgICBpZiAoaW5wdXRPckluaXRCb2R5ICE9IG51bGwgJiYgaW5wdXRPckluaXRCb2R5LnNvdXJjZSA9PSBudWxsKSB7XG4gICAgICAvLyAxLiBJZiBpbml0Qm9keSBpcyBub24tbnVsbCBhbmQgaW5pdFtcImR1cGxleFwiXSBkb2VzIG5vdCBleGlzdCxcbiAgICAgIC8vICAgIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBpZiAoaW5pdEJvZHkgIT0gbnVsbCAmJiBpbml0LmR1cGxleCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlcXVlc3RJbml0OiBkdXBsZXggb3B0aW9uIGlzIHJlcXVpcmVkIHdoZW4gc2VuZGluZyBhIGJvZHkuJylcbiAgICAgIH1cblxuICAgICAgLy8gMi4gSWYgdGhpc+KAmXMgcmVxdWVzdOKAmXMgbW9kZSBpcyBuZWl0aGVyIFwic2FtZS1vcmlnaW5cIiBub3IgXCJjb3JzXCIsXG4gICAgICAvLyB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKHJlcXVlc3QubW9kZSAhPT0gJ3NhbWUtb3JpZ2luJyAmJiByZXF1ZXN0Lm1vZGUgIT09ICdjb3JzJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdJZiByZXF1ZXN0IGlzIG1hZGUgZnJvbSBSZWFkYWJsZVN0cmVhbSwgbW9kZSBzaG91bGQgYmUgXCJzYW1lLW9yaWdpblwiIG9yIFwiY29yc1wiJ1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIFNldCB0aGlz4oCZcyByZXF1ZXN04oCZcyB1c2UtQ09SUy1wcmVmbGlnaHQgZmxhZy5cbiAgICAgIHJlcXVlc3QudXNlQ09SU1ByZWZsaWdodEZsYWcgPSB0cnVlXG4gICAgfVxuXG4gICAgLy8gMzkuIExldCBmaW5hbEJvZHkgYmUgaW5wdXRPckluaXRCb2R5LlxuICAgIGxldCBmaW5hbEJvZHkgPSBpbnB1dE9ySW5pdEJvZHlcblxuICAgIC8vIDQwLiBJZiBpbml0Qm9keSBpcyBudWxsIGFuZCBpbnB1dEJvZHkgaXMgbm9uLW51bGwsIHRoZW46XG4gICAgaWYgKGluaXRCb2R5ID09IG51bGwgJiYgaW5wdXRCb2R5ICE9IG51bGwpIHtcbiAgICAgIC8vIDEuIElmIGlucHV0IGlzIHVudXNhYmxlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKHV0aWwuaXNEaXN0dXJiZWQoaW5wdXRCb2R5LnN0cmVhbSkgfHwgaW5wdXRCb2R5LnN0cmVhbS5sb2NrZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnQ2Fubm90IGNvbnN0cnVjdCBhIFJlcXVlc3Qgd2l0aCBhIFJlcXVlc3Qgb2JqZWN0IHRoYXQgaGFzIGFscmVhZHkgYmVlbiB1c2VkLidcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBTZXQgZmluYWxCb2R5IHRvIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYSBwcm94eSBmb3IgaW5wdXRCb2R5LlxuICAgICAgaWYgKCFUcmFuc2Zvcm1TdHJlYW0pIHtcbiAgICAgICAgVHJhbnNmb3JtU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtL3dlYicpLlRyYW5zZm9ybVN0cmVhbVxuICAgICAgfVxuXG4gICAgICAvLyBodHRwczovL3N0cmVhbXMuc3BlYy53aGF0d2cub3JnLyNyZWFkYWJsZXN0cmVhbS1jcmVhdGUtYS1wcm94eVxuICAgICAgY29uc3QgaWRlbnRpdHlUcmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKClcbiAgICAgIGlucHV0Qm9keS5zdHJlYW0ucGlwZVRocm91Z2goaWRlbnRpdHlUcmFuc2Zvcm0pXG4gICAgICBmaW5hbEJvZHkgPSB7XG4gICAgICAgIHNvdXJjZTogaW5wdXRCb2R5LnNvdXJjZSxcbiAgICAgICAgbGVuZ3RoOiBpbnB1dEJvZHkubGVuZ3RoLFxuICAgICAgICBzdHJlYW06IGlkZW50aXR5VHJhbnNmb3JtLnJlYWRhYmxlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNDEuIFNldCB0aGlz4oCZcyByZXF1ZXN04oCZcyBib2R5IHRvIGZpbmFsQm9keS5cbiAgICB0aGlzW2tTdGF0ZV0uYm9keSA9IGZpbmFsQm9keVxuICB9XG5cbiAgLy8gUmV0dXJucyByZXF1ZXN04oCZcyBIVFRQIG1ldGhvZCwgd2hpY2ggaXMgXCJHRVRcIiBieSBkZWZhdWx0LlxuICBnZXQgbWV0aG9kICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIG1ldGhvZCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBtZXRob2QuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5tZXRob2RcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIFVSTCBvZiByZXF1ZXN0IGFzIGEgc3RyaW5nLlxuICBnZXQgdXJsICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIHVybCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBVUkwsIHNlcmlhbGl6ZWQuXG4gICAgcmV0dXJuIFVSTFNlcmlhbGl6ZXIodGhpc1trU3RhdGVdLnVybClcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBIZWFkZXJzIG9iamVjdCBjb25zaXN0aW5nIG9mIHRoZSBoZWFkZXJzIGFzc29jaWF0ZWQgd2l0aCByZXF1ZXN0LlxuICAvLyBOb3RlIHRoYXQgaGVhZGVycyBhZGRlZCBpbiB0aGUgbmV0d29yayBsYXllciBieSB0aGUgdXNlciBhZ2VudCB3aWxsIG5vdFxuICAvLyBiZSBhY2NvdW50ZWQgZm9yIGluIHRoaXMgb2JqZWN0LCBlLmcuLCB0aGUgXCJIb3N0XCIgaGVhZGVyLlxuICBnZXQgaGVhZGVycyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBoZWFkZXJzIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIGhlYWRlcnMuXG4gICAgcmV0dXJuIHRoaXNba0hlYWRlcnNdXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBraW5kIG9mIHJlc291cmNlIHJlcXVlc3RlZCBieSByZXF1ZXN0LCBlLmcuLCBcImRvY3VtZW50XCJcbiAgLy8gb3IgXCJzY3JpcHRcIi5cbiAgZ2V0IGRlc3RpbmF0aW9uICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIGRlc3RpbmF0aW9uIGdldHRlciBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIGRlc3RpbmF0aW9uLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uZGVzdGluYXRpb25cbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIHJlZmVycmVyIG9mIHJlcXVlc3QuIEl0cyB2YWx1ZSBjYW4gYmUgYSBzYW1lLW9yaWdpbiBVUkwgaWZcbiAgLy8gZXhwbGljaXRseSBzZXQgaW4gaW5pdCwgdGhlIGVtcHR5IHN0cmluZyB0byBpbmRpY2F0ZSBubyByZWZlcnJlciwgYW5kXG4gIC8vIFwiYWJvdXQ6Y2xpZW50XCIgd2hlbiBkZWZhdWx0aW5nIHRvIHRoZSBnbG9iYWzigJlzIGRlZmF1bHQuIFRoaXMgaXMgdXNlZFxuICAvLyBkdXJpbmcgZmV0Y2hpbmcgdG8gZGV0ZXJtaW5lIHRoZSB2YWx1ZSBvZiB0aGUgYFJlZmVyZXJgIGhlYWRlciBvZiB0aGVcbiAgLy8gcmVxdWVzdCBiZWluZyBtYWRlLlxuICBnZXQgcmVmZXJyZXIgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyAxLiBJZiB0aGlz4oCZcyByZXF1ZXN04oCZcyByZWZlcnJlciBpcyBcIm5vLXJlZmVycmVyXCIsIHRoZW4gcmV0dXJuIHRoZVxuICAgIC8vIGVtcHR5IHN0cmluZy5cbiAgICBpZiAodGhpc1trU3RhdGVdLnJlZmVycmVyID09PSAnbm8tcmVmZXJyZXInKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG5cbiAgICAvLyAyLiBJZiB0aGlz4oCZcyByZXF1ZXN04oCZcyByZWZlcnJlciBpcyBcImNsaWVudFwiLCB0aGVuIHJldHVyblxuICAgIC8vIFwiYWJvdXQ6Y2xpZW50XCIuXG4gICAgaWYgKHRoaXNba1N0YXRlXS5yZWZlcnJlciA9PT0gJ2NsaWVudCcpIHtcbiAgICAgIHJldHVybiAnYWJvdXQ6Y2xpZW50J1xuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyByZWZlcnJlciwgc2VyaWFsaXplZC5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnJlZmVycmVyLnRvU3RyaW5nKClcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIHJlZmVycmVyIHBvbGljeSBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdC5cbiAgLy8gVGhpcyBpcyB1c2VkIGR1cmluZyBmZXRjaGluZyB0byBjb21wdXRlIHRoZSB2YWx1ZSBvZiB0aGUgcmVxdWVzdOKAmXNcbiAgLy8gcmVmZXJyZXIuXG4gIGdldCByZWZlcnJlclBvbGljeSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSByZWZlcnJlclBvbGljeSBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3kuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5yZWZlcnJlclBvbGljeVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgbW9kZSBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdCwgd2hpY2ggaXMgYSBzdHJpbmcgaW5kaWNhdGluZ1xuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IHdpbGwgdXNlIENPUlMsIG9yIHdpbGwgYmUgcmVzdHJpY3RlZCB0byBzYW1lLW9yaWdpblxuICAvLyBVUkxzLlxuICBnZXQgbW9kZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBtb2RlIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIG1vZGUuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5tb2RlXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBjcmVkZW50aWFscyBtb2RlIGFzc29jaWF0ZWQgd2l0aCByZXF1ZXN0LFxuICAvLyB3aGljaCBpcyBhIHN0cmluZyBpbmRpY2F0aW5nIHdoZXRoZXIgY3JlZGVudGlhbHMgd2lsbCBiZSBzZW50IHdpdGggdGhlXG4gIC8vIHJlcXVlc3QgYWx3YXlzLCBuZXZlciwgb3Igb25seSB3aGVuIHNlbnQgdG8gYSBzYW1lLW9yaWdpbiBVUkwuXG4gIGdldCBjcmVkZW50aWFscyAoKSB7XG4gICAgLy8gVGhlIGNyZWRlbnRpYWxzIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIGNyZWRlbnRpYWxzIG1vZGUuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5jcmVkZW50aWFsc1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgY2FjaGUgbW9kZSBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdCxcbiAgLy8gd2hpY2ggaXMgYSBzdHJpbmcgaW5kaWNhdGluZyBob3cgdGhlIHJlcXVlc3Qgd2lsbFxuICAvLyBpbnRlcmFjdCB3aXRoIHRoZSBicm93c2Vy4oCZcyBjYWNoZSB3aGVuIGZldGNoaW5nLlxuICBnZXQgY2FjaGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgY2FjaGUgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgY2FjaGUgbW9kZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmNhY2hlXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSByZWRpcmVjdCBtb2RlIGFzc29jaWF0ZWQgd2l0aCByZXF1ZXN0LFxuICAvLyB3aGljaCBpcyBhIHN0cmluZyBpbmRpY2F0aW5nIGhvdyByZWRpcmVjdHMgZm9yIHRoZVxuICAvLyByZXF1ZXN0IHdpbGwgYmUgaGFuZGxlZCBkdXJpbmcgZmV0Y2hpbmcuIEEgcmVxdWVzdFxuICAvLyB3aWxsIGZvbGxvdyByZWRpcmVjdHMgYnkgZGVmYXVsdC5cbiAgZ2V0IHJlZGlyZWN0ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIHJlZGlyZWN0IGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIHJlZGlyZWN0IG1vZGUuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5yZWRpcmVjdFxuICB9XG5cbiAgLy8gUmV0dXJucyByZXF1ZXN04oCZcyBzdWJyZXNvdXJjZSBpbnRlZ3JpdHkgbWV0YWRhdGEsIHdoaWNoIGlzIGFcbiAgLy8gY3J5cHRvZ3JhcGhpYyBoYXNoIG9mIHRoZSByZXNvdXJjZSBiZWluZyBmZXRjaGVkLiBJdHMgdmFsdWVcbiAgLy8gY29uc2lzdHMgb2YgbXVsdGlwbGUgaGFzaGVzIHNlcGFyYXRlZCBieSB3aGl0ZXNwYWNlLiBbU1JJXVxuICBnZXQgaW50ZWdyaXR5ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIGludGVncml0eSBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBpbnRlZ3JpdHlcbiAgICAvLyBtZXRhZGF0YS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmludGVncml0eVxuICB9XG5cbiAgLy8gUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCByZXF1ZXN0IGNhbiBvdXRsaXZlIHRoZVxuICAvLyBnbG9iYWwgaW4gd2hpY2ggaXQgd2FzIGNyZWF0ZWQuXG4gIGdldCBrZWVwYWxpdmUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUga2VlcGFsaXZlIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIGtlZXBhbGl2ZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmtlZXBhbGl2ZVxuICB9XG5cbiAgLy8gUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCByZXF1ZXN0IGlzIGZvciBhIHJlbG9hZFxuICAvLyBuYXZpZ2F0aW9uLlxuICBnZXQgaXNSZWxvYWROYXZpZ2F0aW9uICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIGlzUmVsb2FkTmF2aWdhdGlvbiBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0cnVlIGlmIHRoaXPigJlzXG4gICAgLy8gcmVxdWVzdOKAmXMgcmVsb2FkLW5hdmlnYXRpb24gZmxhZyBpcyBzZXQ7IG90aGVyd2lzZSBmYWxzZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnJlbG9hZE5hdmlnYXRpb25cbiAgfVxuXG4gIC8vIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgcmVxdWVzdCBpcyBmb3IgYSBoaXN0b3J5XG4gIC8vIG5hdmlnYXRpb24gKGEuay5hLiBiYWNrLWZvd2FyZCBuYXZpZ2F0aW9uKS5cbiAgZ2V0IGlzSGlzdG9yeU5hdmlnYXRpb24gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgaXNIaXN0b3J5TmF2aWdhdGlvbiBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0cnVlIGlmIHRoaXPigJlzIHJlcXVlc3TigJlzXG4gICAgLy8gaGlzdG9yeS1uYXZpZ2F0aW9uIGZsYWcgaXMgc2V0OyBvdGhlcndpc2UgZmFsc2UuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5oaXN0b3J5TmF2aWdhdGlvblxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgc2lnbmFsIGFzc29jaWF0ZWQgd2l0aCByZXF1ZXN0LCB3aGljaCBpcyBhbiBBYm9ydFNpZ25hbFxuICAvLyBvYmplY3QgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCByZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWQsIGFuZCBpdHNcbiAgLy8gYWJvcnQgZXZlbnQgaGFuZGxlci5cbiAgZ2V0IHNpZ25hbCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBzaWduYWwgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgc2lnbmFsLlxuICAgIHJldHVybiB0aGlzW2tTaWduYWxdXG4gIH1cblxuICBnZXQgYm9keSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYm9keSA/IHRoaXNba1N0YXRlXS5ib2R5LnN0cmVhbSA6IG51bGxcbiAgfVxuXG4gIGdldCBib2R5VXNlZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIHJldHVybiAhIXRoaXNba1N0YXRlXS5ib2R5ICYmIHV0aWwuaXNEaXN0dXJiZWQodGhpc1trU3RhdGVdLmJvZHkuc3RyZWFtKVxuICB9XG5cbiAgZ2V0IGR1cGxleCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIHJldHVybiAnaGFsZidcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBjbG9uZSBvZiByZXF1ZXN0LlxuICBjbG9uZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIDEuIElmIHRoaXMgaXMgdW51c2FibGUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKHRoaXMuYm9keVVzZWQgfHwgdGhpcy5ib2R5Py5sb2NrZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VudXNhYmxlJylcbiAgICB9XG5cbiAgICAvLyAyLiBMZXQgY2xvbmVkUmVxdWVzdCBiZSB0aGUgcmVzdWx0IG9mIGNsb25pbmcgdGhpc+KAmXMgcmVxdWVzdC5cbiAgICBjb25zdCBjbG9uZWRSZXF1ZXN0ID0gY2xvbmVSZXF1ZXN0KHRoaXNba1N0YXRlXSlcblxuICAgIC8vIDMuIExldCBjbG9uZWRSZXF1ZXN0T2JqZWN0IGJlIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYSBSZXF1ZXN0IG9iamVjdCxcbiAgICAvLyBnaXZlbiBjbG9uZWRSZXF1ZXN0LCB0aGlz4oCZcyBoZWFkZXJz4oCZcyBndWFyZCwgYW5kIHRoaXPigJlzIHJlbGV2YW50IFJlYWxtLlxuICAgIGNvbnN0IGNsb25lZFJlcXVlc3RPYmplY3QgPSBuZXcgUmVxdWVzdChrQ29uc3RydWN0KVxuICAgIGNsb25lZFJlcXVlc3RPYmplY3Rba1N0YXRlXSA9IGNsb25lZFJlcXVlc3RcbiAgICBjbG9uZWRSZXF1ZXN0T2JqZWN0W2tSZWFsbV0gPSB0aGlzW2tSZWFsbV1cbiAgICBjbG9uZWRSZXF1ZXN0T2JqZWN0W2tIZWFkZXJzXSA9IG5ldyBIZWFkZXJzKGtDb25zdHJ1Y3QpXG4gICAgY2xvbmVkUmVxdWVzdE9iamVjdFtrSGVhZGVyc11ba0hlYWRlcnNMaXN0XSA9IGNsb25lZFJlcXVlc3QuaGVhZGVyc0xpc3RcbiAgICBjbG9uZWRSZXF1ZXN0T2JqZWN0W2tIZWFkZXJzXVtrR3VhcmRdID0gdGhpc1trSGVhZGVyc11ba0d1YXJkXVxuICAgIGNsb25lZFJlcXVlc3RPYmplY3Rba0hlYWRlcnNdW2tSZWFsbV0gPSB0aGlzW2tIZWFkZXJzXVtrUmVhbG1dXG5cbiAgICAvLyA0LiBNYWtlIGNsb25lZFJlcXVlc3RPYmplY3TigJlzIHNpZ25hbCBmb2xsb3cgdGhpc+KAmXMgc2lnbmFsLlxuICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgaWYgKHRoaXMuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGFjLmFib3J0KHRoaXMuc2lnbmFsLnJlYXNvbilcbiAgICB9IGVsc2Uge1xuICAgICAgdXRpbC5hZGRBYm9ydExpc3RlbmVyKFxuICAgICAgICB0aGlzLnNpZ25hbCxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGFjLmFib3J0KHRoaXMuc2lnbmFsLnJlYXNvbilcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH1cbiAgICBjbG9uZWRSZXF1ZXN0T2JqZWN0W2tTaWduYWxdID0gYWMuc2lnbmFsXG5cbiAgICAvLyA0LiBSZXR1cm4gY2xvbmVkUmVxdWVzdE9iamVjdC5cbiAgICByZXR1cm4gY2xvbmVkUmVxdWVzdE9iamVjdFxuICB9XG59XG5cbm1peGluQm9keShSZXF1ZXN0KVxuXG5mdW5jdGlvbiBtYWtlUmVxdWVzdCAoaW5pdCkge1xuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdHNcbiAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIGxvY2FsVVJMc09ubHk6IGZhbHNlLFxuICAgIHVuc2FmZVJlcXVlc3Q6IGZhbHNlLFxuICAgIGJvZHk6IG51bGwsXG4gICAgY2xpZW50OiBudWxsLFxuICAgIHJlc2VydmVkQ2xpZW50OiBudWxsLFxuICAgIHJlcGxhY2VzQ2xpZW50SWQ6ICcnLFxuICAgIHdpbmRvdzogJ2NsaWVudCcsXG4gICAga2VlcGFsaXZlOiBmYWxzZSxcbiAgICBzZXJ2aWNlV29ya2VyczogJ2FsbCcsXG4gICAgaW5pdGlhdG9yOiAnJyxcbiAgICBkZXN0aW5hdGlvbjogJycsXG4gICAgcHJpb3JpdHk6IG51bGwsXG4gICAgb3JpZ2luOiAnY2xpZW50JyxcbiAgICBwb2xpY3lDb250YWluZXI6ICdjbGllbnQnLFxuICAgIHJlZmVycmVyOiAnY2xpZW50JyxcbiAgICByZWZlcnJlclBvbGljeTogJycsXG4gICAgbW9kZTogJ25vLWNvcnMnLFxuICAgIHVzZUNPUlNQcmVmbGlnaHRGbGFnOiBmYWxzZSxcbiAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgICB1c2VDcmVkZW50aWFsczogZmFsc2UsXG4gICAgY2FjaGU6ICdkZWZhdWx0JyxcbiAgICByZWRpcmVjdDogJ2ZvbGxvdycsXG4gICAgaW50ZWdyaXR5OiAnJyxcbiAgICBjcnlwdG9HcmFwaGljc05vbmNlTWV0YWRhdGE6ICcnLFxuICAgIHBhcnNlck1ldGFkYXRhOiAnJyxcbiAgICByZWxvYWROYXZpZ2F0aW9uOiBmYWxzZSxcbiAgICBoaXN0b3J5TmF2aWdhdGlvbjogZmFsc2UsXG4gICAgdXNlckFjdGl2YXRpb246IGZhbHNlLFxuICAgIHRhaW50ZWRPcmlnaW46IGZhbHNlLFxuICAgIHJlZGlyZWN0Q291bnQ6IDAsXG4gICAgcmVzcG9uc2VUYWludGluZzogJ2Jhc2ljJyxcbiAgICBwcmV2ZW50Tm9DYWNoZUNhY2hlQ29udHJvbEhlYWRlck1vZGlmaWNhdGlvbjogZmFsc2UsXG4gICAgZG9uZTogZmFsc2UsXG4gICAgdGltaW5nQWxsb3dGYWlsZWQ6IGZhbHNlLFxuICAgIC4uLmluaXQsXG4gICAgaGVhZGVyc0xpc3Q6IGluaXQuaGVhZGVyc0xpc3RcbiAgICAgID8gbmV3IEhlYWRlcnNMaXN0KGluaXQuaGVhZGVyc0xpc3QpXG4gICAgICA6IG5ldyBIZWFkZXJzTGlzdCgpXG4gIH1cbiAgcmVxdWVzdC51cmwgPSByZXF1ZXN0LnVybExpc3RbMF1cbiAgcmV0dXJuIHJlcXVlc3Rcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtcmVxdWVzdC1jbG9uZVxuZnVuY3Rpb24gY2xvbmVSZXF1ZXN0IChyZXF1ZXN0KSB7XG4gIC8vIFRvIGNsb25lIGEgcmVxdWVzdCByZXF1ZXN0LCBydW4gdGhlc2Ugc3RlcHM6XG5cbiAgLy8gMS4gTGV0IG5ld1JlcXVlc3QgYmUgYSBjb3B5IG9mIHJlcXVlc3QsIGV4Y2VwdCBmb3IgaXRzIGJvZHkuXG4gIGNvbnN0IG5ld1JlcXVlc3QgPSBtYWtlUmVxdWVzdCh7IC4uLnJlcXVlc3QsIGJvZHk6IG51bGwgfSlcblxuICAvLyAyLiBJZiByZXF1ZXN04oCZcyBib2R5IGlzIG5vbi1udWxsLCBzZXQgbmV3UmVxdWVzdOKAmXMgYm9keSB0byB0aGVcbiAgLy8gcmVzdWx0IG9mIGNsb25pbmcgcmVxdWVzdOKAmXMgYm9keS5cbiAgaWYgKHJlcXVlc3QuYm9keSAhPSBudWxsKSB7XG4gICAgbmV3UmVxdWVzdC5ib2R5ID0gY2xvbmVCb2R5KHJlcXVlc3QuYm9keSlcbiAgfVxuXG4gIC8vIDMuIFJldHVybiBuZXdSZXF1ZXN0LlxuICByZXR1cm4gbmV3UmVxdWVzdFxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZXF1ZXN0LnByb3RvdHlwZSwge1xuICBtZXRob2Q6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHVybDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaGVhZGVyczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVkaXJlY3Q6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGNsb25lOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBzaWduYWw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGR1cGxleDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZGVzdGluYXRpb246IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGJvZHk6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGJvZHlVc2VkOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBpc0hpc3RvcnlOYXZpZ2F0aW9uOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBpc1JlbG9hZE5hdmlnYXRpb246IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGtlZXBhbGl2ZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaW50ZWdyaXR5OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjYWNoZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY3JlZGVudGlhbHM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGF0dHJpYnV0ZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVmZXJyZXJQb2xpY3k6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlZmVycmVyOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBtb2RlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnUmVxdWVzdCcsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3QgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKFxuICBSZXF1ZXN0XG4pXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0aW5mb1xud2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8gPSBmdW5jdGlvbiAoVikge1xuICBpZiAodHlwZW9mIFYgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhWKVxuICB9XG5cbiAgaWYgKFYgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3QoVilcbiAgfVxuXG4gIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoVilcbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuQWJvcnRTaWduYWwgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKFxuICBBYm9ydFNpZ25hbFxuKVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdGluaXRcbndlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbml0ID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICB7XG4gICAga2V5OiAnbWV0aG9kJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmdcbiAgfSxcbiAge1xuICAgIGtleTogJ2hlYWRlcnMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuSGVhZGVyc0luaXRcbiAgfSxcbiAge1xuICAgIGtleTogJ2JvZHknLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKFxuICAgICAgd2ViaWRsLmNvbnZlcnRlcnMuQm9keUluaXRcbiAgICApXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdyZWZlcnJlcicsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmdcbiAgfSxcbiAge1xuICAgIGtleTogJ3JlZmVycmVyUG9saWN5JyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jcmVmZXJyZXItcG9saWN5XG4gICAgYWxsb3dlZFZhbHVlczogcmVmZXJyZXJQb2xpY3lcbiAgfSxcbiAge1xuICAgIGtleTogJ21vZGUnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXJlcXVlc3QtbW9kZVxuICAgIGFsbG93ZWRWYWx1ZXM6IHJlcXVlc3RNb2RlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjcmVkZW50aWFscycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3RjcmVkZW50aWFsc1xuICAgIGFsbG93ZWRWYWx1ZXM6IHJlcXVlc3RDcmVkZW50aWFsc1xuICB9LFxuICB7XG4gICAga2V5OiAnY2FjaGUnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0Y2FjaGVcbiAgICBhbGxvd2VkVmFsdWVzOiByZXF1ZXN0Q2FjaGVcbiAgfSxcbiAge1xuICAgIGtleTogJ3JlZGlyZWN0JyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdHJlZGlyZWN0XG4gICAgYWxsb3dlZFZhbHVlczogcmVxdWVzdFJlZGlyZWN0XG4gIH0sXG4gIHtcbiAgICBrZXk6ICdpbnRlZ3JpdHknLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdrZWVwYWxpdmUnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhblxuICB9LFxuICB7XG4gICAga2V5OiAnc2lnbmFsJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcihcbiAgICAgIChzaWduYWwpID0+IHdlYmlkbC5jb252ZXJ0ZXJzLkFib3J0U2lnbmFsKFxuICAgICAgICBzaWduYWwsXG4gICAgICAgIHsgc3RyaWN0OiBmYWxzZSB9XG4gICAgICApXG4gICAgKVxuICB9LFxuICB7XG4gICAga2V5OiAnd2luZG93JyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmFueVxuICB9LFxuICB7XG4gICAga2V5OiAnZHVwbGV4JyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICBhbGxvd2VkVmFsdWVzOiByZXF1ZXN0RHVwbGV4XG4gIH1cbl0pXG5cbm1vZHVsZS5leHBvcnRzID0geyBSZXF1ZXN0LCBtYWtlUmVxdWVzdCB9XG4iXSwibmFtZXMiOlsiZXh0cmFjdEJvZHkiLCJtaXhpbkJvZHkiLCJjbG9uZUJvZHkiLCJyZXF1aXJlIiwiSGVhZGVycyIsImZpbGwiLCJmaWxsSGVhZGVycyIsIkhlYWRlcnNMaXN0IiwiRmluYWxpemF0aW9uUmVnaXN0cnkiLCJ1dGlsIiwiaXNWYWxpZEhUVFBUb2tlbiIsInNhbWVPcmlnaW4iLCJub3JtYWxpemVNZXRob2QiLCJtYWtlUG9saWN5Q29udGFpbmVyIiwibm9ybWFsaXplTWV0aG9kUmVjb3JkIiwiZm9yYmlkZGVuTWV0aG9kc1NldCIsImNvcnNTYWZlTGlzdGVkTWV0aG9kc1NldCIsInJlZmVycmVyUG9saWN5IiwicmVxdWVzdFJlZGlyZWN0IiwicmVxdWVzdE1vZGUiLCJyZXF1ZXN0Q3JlZGVudGlhbHMiLCJyZXF1ZXN0Q2FjaGUiLCJyZXF1ZXN0RHVwbGV4Iiwia0VudW1lcmFibGVQcm9wZXJ0eSIsImtIZWFkZXJzIiwia1NpZ25hbCIsImtTdGF0ZSIsImtHdWFyZCIsImtSZWFsbSIsIndlYmlkbCIsImdldEdsb2JhbE9yaWdpbiIsIlVSTFNlcmlhbGl6ZXIiLCJrSGVhZGVyc0xpc3QiLCJrQ29uc3RydWN0IiwiYXNzZXJ0IiwiZ2V0TWF4TGlzdGVuZXJzIiwic2V0TWF4TGlzdGVuZXJzIiwiZ2V0RXZlbnRMaXN0ZW5lcnMiLCJkZWZhdWx0TWF4TGlzdGVuZXJzIiwiVHJhbnNmb3JtU3RyZWFtIiwiZ2xvYmFsVGhpcyIsImtBYm9ydENvbnRyb2xsZXIiLCJTeW1ib2wiLCJyZXF1ZXN0RmluYWxpemVyIiwic2lnbmFsIiwiYWJvcnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiUmVxdWVzdCIsImNvbnN0cnVjdG9yIiwiaW5wdXQiLCJpbml0IiwiYXJndW1lbnRMZW5ndGhDaGVjayIsImFyZ3VtZW50cyIsImhlYWRlciIsImNvbnZlcnRlcnMiLCJSZXF1ZXN0SW5mbyIsIlJlcXVlc3RJbml0Iiwic2V0dGluZ3NPYmplY3QiLCJiYXNlVXJsIiwib3JpZ2luIiwicG9saWN5Q29udGFpbmVyIiwicmVxdWVzdCIsImZhbGxiYWNrTW9kZSIsInBhcnNlZFVSTCIsIlVSTCIsImVyciIsIlR5cGVFcnJvciIsImNhdXNlIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsIm1ha2VSZXF1ZXN0IiwidXJsTGlzdCIsIndpbmRvdyIsIm5hbWUiLCJtZXRob2QiLCJoZWFkZXJzTGlzdCIsInVuc2FmZVJlcXVlc3QiLCJjbGllbnQiLCJwcmlvcml0eSIsInJlZmVycmVyIiwibW9kZSIsImNyZWRlbnRpYWxzIiwiY2FjaGUiLCJyZWRpcmVjdCIsImludGVncml0eSIsImtlZXBhbGl2ZSIsInJlbG9hZE5hdmlnYXRpb24iLCJoaXN0b3J5TmF2aWdhdGlvbiIsImluaXRIYXNLZXkiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwidXJsIiwidW5kZWZpbmVkIiwicGFyc2VkUmVmZXJyZXIiLCJwcm90b2NvbCIsImhvc3RuYW1lIiwiZXJyb3JzIiwiZXhjZXB0aW9uIiwibWVzc2FnZSIsIlN0cmluZyIsIkJvb2xlYW4iLCJoYXMiLCJ0b1VwcGVyQ2FzZSIsImFjIiwiQWJvcnRDb250cm9sbGVyIiwiYWJvcnRlZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZWFzb24iLCJhY1JlZiIsIldlYWtSZWYiLCJkZXJlZiIsImFkZEFib3J0TGlzdGVuZXIiLCJyZWdpc3RlciIsImhlYWRlcnMiLCJjbGVhciIsImtleSIsInZhbCIsImFwcGVuZCIsImNvb2tpZXMiLCJpbnB1dEJvZHkiLCJib2R5IiwiaW5pdEJvZHkiLCJleHRyYWN0ZWRCb2R5IiwiY29udGVudFR5cGUiLCJjb250YWlucyIsImlucHV0T3JJbml0Qm9keSIsInNvdXJjZSIsImR1cGxleCIsInVzZUNPUlNQcmVmbGlnaHRGbGFnIiwiZmluYWxCb2R5IiwiaXNEaXN0dXJiZWQiLCJzdHJlYW0iLCJsb2NrZWQiLCJpZGVudGl0eVRyYW5zZm9ybSIsInBpcGVUaHJvdWdoIiwicmVhZGFibGUiLCJicmFuZENoZWNrIiwiZGVzdGluYXRpb24iLCJ0b1N0cmluZyIsImlzUmVsb2FkTmF2aWdhdGlvbiIsImlzSGlzdG9yeU5hdmlnYXRpb24iLCJib2R5VXNlZCIsImNsb25lIiwiY2xvbmVkUmVxdWVzdCIsImNsb25lUmVxdWVzdCIsImNsb25lZFJlcXVlc3RPYmplY3QiLCJsb2NhbFVSTHNPbmx5IiwicmVzZXJ2ZWRDbGllbnQiLCJyZXBsYWNlc0NsaWVudElkIiwic2VydmljZVdvcmtlcnMiLCJpbml0aWF0b3IiLCJ1c2VDcmVkZW50aWFscyIsImNyeXB0b0dyYXBoaWNzTm9uY2VNZXRhZGF0YSIsInBhcnNlck1ldGFkYXRhIiwidXNlckFjdGl2YXRpb24iLCJ0YWludGVkT3JpZ2luIiwicmVkaXJlY3RDb3VudCIsInJlc3BvbnNlVGFpbnRpbmciLCJwcmV2ZW50Tm9DYWNoZUNhY2hlQ29udHJvbEhlYWRlck1vZGlmaWNhdGlvbiIsImRvbmUiLCJ0aW1pbmdBbGxvd0ZhaWxlZCIsIm5ld1JlcXVlc3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJvdG90eXBlIiwiYXR0cmlidXRlIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsImNvbmZpZ3VyYWJsZSIsImludGVyZmFjZUNvbnZlcnRlciIsIlYiLCJVU1ZTdHJpbmciLCJBYm9ydFNpZ25hbCIsImRpY3Rpb25hcnlDb252ZXJ0ZXIiLCJjb252ZXJ0ZXIiLCJCeXRlU3RyaW5nIiwiSGVhZGVyc0luaXQiLCJudWxsYWJsZUNvbnZlcnRlciIsIkJvZHlJbml0IiwiRE9NU3RyaW5nIiwiYWxsb3dlZFZhbHVlcyIsImJvb2xlYW4iLCJzdHJpY3QiLCJhbnkiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/request.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/response.js":
/*!*************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/fetch/response.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Headers, HeadersList, fill } = __webpack_require__(/*! ./headers */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/headers.js\");\nconst { extractBody, cloneBody, mixinBody } = __webpack_require__(/*! ./body */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/body.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst { kEnumerableProperty } = util;\nconst { isValidReasonPhrase, isCancelled, isAborted, isBlobLike, serializeJavascriptValueToJSONString, isErrorLike, isomorphicEncode } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/util.js\");\nconst { redirectStatusSet, nullBodyStatus, DOMException } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/constants.js\");\nconst { kState, kHeaders, kGuard, kRealm } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/webidl.js\");\nconst { FormData } = __webpack_require__(/*! ./formdata */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/formdata.js\");\nconst { getGlobalOrigin } = __webpack_require__(/*! ./global */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/global.js\");\nconst { URLSerializer } = __webpack_require__(/*! ./dataURL */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/dataURL.js\");\nconst { kHeadersList, kConstruct } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { types } = __webpack_require__(/*! util */ \"util\");\nconst ReadableStream = globalThis.ReadableStream || (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\nconst textEncoder = new TextEncoder(\"utf-8\");\n// https://fetch.spec.whatwg.org/#response-class\nclass Response {\n    // Creates network error Response.\n    static error() {\n        // TODO\n        const relevantRealm = {\n            settingsObject: {}\n        };\n        // The static error() method steps are to return the result of creating a\n        // Response object, given a new network error, \"immutable\", and thiss\n        // relevant Realm.\n        const responseObject = new Response();\n        responseObject[kState] = makeNetworkError();\n        responseObject[kRealm] = relevantRealm;\n        responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;\n        responseObject[kHeaders][kGuard] = \"immutable\";\n        responseObject[kHeaders][kRealm] = relevantRealm;\n        return responseObject;\n    }\n    // https://fetch.spec.whatwg.org/#dom-response-json\n    static json(data, init = {}) {\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Response.json\"\n        });\n        if (init !== null) {\n            init = webidl.converters.ResponseInit(init);\n        }\n        // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.\n        const bytes = textEncoder.encode(serializeJavascriptValueToJSONString(data));\n        // 2. Let body be the result of extracting bytes.\n        const body = extractBody(bytes);\n        // 3. Let responseObject be the result of creating a Response object, given a new response,\n        //    \"response\", and thiss relevant Realm.\n        const relevantRealm = {\n            settingsObject: {}\n        };\n        const responseObject = new Response();\n        responseObject[kRealm] = relevantRealm;\n        responseObject[kHeaders][kGuard] = \"response\";\n        responseObject[kHeaders][kRealm] = relevantRealm;\n        // 4. Perform initialize a response given responseObject, init, and (body, \"application/json\").\n        initializeResponse(responseObject, init, {\n            body: body[0],\n            type: \"application/json\"\n        });\n        // 5. Return responseObject.\n        return responseObject;\n    }\n    // Creates a redirect Response that redirects to url with status status.\n    static redirect(url, status = 302) {\n        const relevantRealm = {\n            settingsObject: {}\n        };\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Response.redirect\"\n        });\n        url = webidl.converters.USVString(url);\n        status = webidl.converters[\"unsigned short\"](status);\n        // 1. Let parsedURL be the result of parsing url with current settings\n        // objects API base URL.\n        // 2. If parsedURL is failure, then throw a TypeError.\n        // TODO: base-URL?\n        let parsedURL;\n        try {\n            parsedURL = new URL(url, getGlobalOrigin());\n        } catch (err) {\n            throw Object.assign(new TypeError(\"Failed to parse URL from \" + url), {\n                cause: err\n            });\n        }\n        // 3. If status is not a redirect status, then throw a RangeError.\n        if (!redirectStatusSet.has(status)) {\n            throw new RangeError(\"Invalid status code \" + status);\n        }\n        // 4. Let responseObject be the result of creating a Response object,\n        // given a new response, \"immutable\", and thiss relevant Realm.\n        const responseObject = new Response();\n        responseObject[kRealm] = relevantRealm;\n        responseObject[kHeaders][kGuard] = \"immutable\";\n        responseObject[kHeaders][kRealm] = relevantRealm;\n        // 5. Set responseObjects responses status to status.\n        responseObject[kState].status = status;\n        // 6. Let value be parsedURL, serialized and isomorphic encoded.\n        const value = isomorphicEncode(URLSerializer(parsedURL));\n        // 7. Append `Location`/value to responseObjects responses header list.\n        responseObject[kState].headersList.append(\"location\", value);\n        // 8. Return responseObject.\n        return responseObject;\n    }\n    // https://fetch.spec.whatwg.org/#dom-response\n    constructor(body = null, init = {}){\n        if (body !== null) {\n            body = webidl.converters.BodyInit(body);\n        }\n        init = webidl.converters.ResponseInit(init);\n        // TODO\n        this[kRealm] = {\n            settingsObject: {}\n        };\n        // 1. Set thiss response to a new response.\n        this[kState] = makeResponse({});\n        // 2. Set thiss headers to a new Headers object with thiss relevant\n        // Realm, whose header list is thiss responses header list and guard\n        // is \"response\".\n        this[kHeaders] = new Headers(kConstruct);\n        this[kHeaders][kGuard] = \"response\";\n        this[kHeaders][kHeadersList] = this[kState].headersList;\n        this[kHeaders][kRealm] = this[kRealm];\n        // 3. Let bodyWithType be null.\n        let bodyWithType = null;\n        // 4. If body is non-null, then set bodyWithType to the result of extracting body.\n        if (body != null) {\n            const [extractedBody, type] = extractBody(body);\n            bodyWithType = {\n                body: extractedBody,\n                type\n            };\n        }\n        // 5. Perform initialize a response given this, init, and bodyWithType.\n        initializeResponse(this, init, bodyWithType);\n    }\n    // Returns responses type, e.g., \"cors\".\n    get type() {\n        webidl.brandCheck(this, Response);\n        // The type getter steps are to return thiss responses type.\n        return this[kState].type;\n    }\n    // Returns responses URL, if it has one; otherwise the empty string.\n    get url() {\n        webidl.brandCheck(this, Response);\n        const urlList = this[kState].urlList;\n        // The url getter steps are to return the empty string if thiss\n        // responses URL is null; otherwise thiss responses URL,\n        // serialized with exclude fragment set to true.\n        const url = urlList[urlList.length - 1] ?? null;\n        if (url === null) {\n            return \"\";\n        }\n        return URLSerializer(url, true);\n    }\n    // Returns whether response was obtained through a redirect.\n    get redirected() {\n        webidl.brandCheck(this, Response);\n        // The redirected getter steps are to return true if thiss responses URL\n        // list has more than one item; otherwise false.\n        return this[kState].urlList.length > 1;\n    }\n    // Returns responses status.\n    get status() {\n        webidl.brandCheck(this, Response);\n        // The status getter steps are to return thiss responses status.\n        return this[kState].status;\n    }\n    // Returns whether responses status is an ok status.\n    get ok() {\n        webidl.brandCheck(this, Response);\n        // The ok getter steps are to return true if thiss responses status is an\n        // ok status; otherwise false.\n        return this[kState].status >= 200 && this[kState].status <= 299;\n    }\n    // Returns responses status message.\n    get statusText() {\n        webidl.brandCheck(this, Response);\n        // The statusText getter steps are to return thiss responses status\n        // message.\n        return this[kState].statusText;\n    }\n    // Returns responses headers as Headers.\n    get headers() {\n        webidl.brandCheck(this, Response);\n        // The headers getter steps are to return thiss headers.\n        return this[kHeaders];\n    }\n    get body() {\n        webidl.brandCheck(this, Response);\n        return this[kState].body ? this[kState].body.stream : null;\n    }\n    get bodyUsed() {\n        webidl.brandCheck(this, Response);\n        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);\n    }\n    // Returns a clone of response.\n    clone() {\n        webidl.brandCheck(this, Response);\n        // 1. If this is unusable, then throw a TypeError.\n        if (this.bodyUsed || this.body && this.body.locked) {\n            throw webidl.errors.exception({\n                header: \"Response.clone\",\n                message: \"Body has already been consumed.\"\n            });\n        }\n        // 2. Let clonedResponse be the result of cloning thiss response.\n        const clonedResponse = cloneResponse(this[kState]);\n        // 3. Return the result of creating a Response object, given\n        // clonedResponse, thiss headerss guard, and thiss relevant Realm.\n        const clonedResponseObject = new Response();\n        clonedResponseObject[kState] = clonedResponse;\n        clonedResponseObject[kRealm] = this[kRealm];\n        clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;\n        clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];\n        clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];\n        return clonedResponseObject;\n    }\n}\nmixinBody(Response);\nObject.defineProperties(Response.prototype, {\n    type: kEnumerableProperty,\n    url: kEnumerableProperty,\n    status: kEnumerableProperty,\n    ok: kEnumerableProperty,\n    redirected: kEnumerableProperty,\n    statusText: kEnumerableProperty,\n    headers: kEnumerableProperty,\n    clone: kEnumerableProperty,\n    body: kEnumerableProperty,\n    bodyUsed: kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: \"Response\",\n        configurable: true\n    }\n});\nObject.defineProperties(Response, {\n    json: kEnumerableProperty,\n    redirect: kEnumerableProperty,\n    error: kEnumerableProperty\n});\n// https://fetch.spec.whatwg.org/#concept-response-clone\nfunction cloneResponse(response) {\n    // To clone a response response, run these steps:\n    // 1. If response is a filtered response, then return a new identical\n    // filtered response whose internal response is a clone of responses\n    // internal response.\n    if (response.internalResponse) {\n        return filterResponse(cloneResponse(response.internalResponse), response.type);\n    }\n    // 2. Let newResponse be a copy of response, except for its body.\n    const newResponse = makeResponse({\n        ...response,\n        body: null\n    });\n    // 3. If responses body is non-null, then set newResponses body to the\n    // result of cloning responses body.\n    if (response.body != null) {\n        newResponse.body = cloneBody(response.body);\n    }\n    // 4. Return newResponse.\n    return newResponse;\n}\nfunction makeResponse(init) {\n    return {\n        aborted: false,\n        rangeRequested: false,\n        timingAllowPassed: false,\n        requestIncludesCredentials: false,\n        type: \"default\",\n        status: 200,\n        timingInfo: null,\n        cacheState: \"\",\n        statusText: \"\",\n        ...init,\n        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),\n        urlList: init.urlList ? [\n            ...init.urlList\n        ] : []\n    };\n}\nfunction makeNetworkError(reason) {\n    const isError = isErrorLike(reason);\n    return makeResponse({\n        type: \"error\",\n        status: 0,\n        error: isError ? reason : new Error(reason ? String(reason) : reason),\n        aborted: reason && reason.name === \"AbortError\"\n    });\n}\nfunction makeFilteredResponse(response, state) {\n    state = {\n        internalResponse: response,\n        ...state\n    };\n    return new Proxy(response, {\n        get (target, p) {\n            return p in state ? state[p] : target[p];\n        },\n        set (target, p, value) {\n            assert(!(p in state));\n            target[p] = value;\n            return true;\n        }\n    });\n}\n// https://fetch.spec.whatwg.org/#concept-filtered-response\nfunction filterResponse(response, type) {\n    // Set response to the following filtered response with response as its\n    // internal response, depending on requests response tainting:\n    if (type === \"basic\") {\n        // A basic filtered response is a filtered response whose type is \"basic\"\n        // and header list excludes any headers in internal responses header list\n        // whose name is a forbidden response-header name.\n        // Note: undici does not implement forbidden response-header names\n        return makeFilteredResponse(response, {\n            type: \"basic\",\n            headersList: response.headersList\n        });\n    } else if (type === \"cors\") {\n        // A CORS filtered response is a filtered response whose type is \"cors\"\n        // and header list excludes any headers in internal responses header\n        // list whose name is not a CORS-safelisted response-header name, given\n        // internal responses CORS-exposed header-name list.\n        // Note: undici does not implement CORS-safelisted response-header names\n        return makeFilteredResponse(response, {\n            type: \"cors\",\n            headersList: response.headersList\n        });\n    } else if (type === \"opaque\") {\n        // An opaque filtered response is a filtered response whose type is\n        // \"opaque\", URL list is the empty list, status is 0, status message\n        // is the empty byte sequence, header list is empty, and body is null.\n        return makeFilteredResponse(response, {\n            type: \"opaque\",\n            urlList: Object.freeze([]),\n            status: 0,\n            statusText: \"\",\n            body: null\n        });\n    } else if (type === \"opaqueredirect\") {\n        // An opaque-redirect filtered response is a filtered response whose type\n        // is \"opaqueredirect\", status is 0, status message is the empty byte\n        // sequence, header list is empty, and body is null.\n        return makeFilteredResponse(response, {\n            type: \"opaqueredirect\",\n            status: 0,\n            statusText: \"\",\n            headersList: [],\n            body: null\n        });\n    } else {\n        assert(false);\n    }\n}\n// https://fetch.spec.whatwg.org/#appropriate-network-error\nfunction makeAppropriateNetworkError(fetchParams, err = null) {\n    // 1. Assert: fetchParams is canceled.\n    assert(isCancelled(fetchParams));\n    // 2. Return an aborted network error if fetchParams is aborted;\n    // otherwise return a network error.\n    return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException(\"The operation was aborted.\", \"AbortError\"), {\n        cause: err\n    })) : makeNetworkError(Object.assign(new DOMException(\"Request was cancelled.\"), {\n        cause: err\n    }));\n}\n// https://whatpr.org/fetch/1392.html#initialize-a-response\nfunction initializeResponse(response, init, body) {\n    // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n    //    throw a RangeError.\n    if (init.status !== null && (init.status < 200 || init.status > 599)) {\n        throw new RangeError('init[\"status\"] must be in the range of 200 to 599, inclusive.');\n    }\n    // 2. If init[\"statusText\"] does not match the reason-phrase token production,\n    //    then throw a TypeError.\n    if (\"statusText\" in init && init.statusText != null) {\n        // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n        //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n        if (!isValidReasonPhrase(String(init.statusText))) {\n            throw new TypeError(\"Invalid statusText\");\n        }\n    }\n    // 3. Set responses responses status to init[\"status\"].\n    if (\"status\" in init && init.status != null) {\n        response[kState].status = init.status;\n    }\n    // 4. Set responses responses status message to init[\"statusText\"].\n    if (\"statusText\" in init && init.statusText != null) {\n        response[kState].statusText = init.statusText;\n    }\n    // 5. If init[\"headers\"] exists, then fill responses headers with init[\"headers\"].\n    if (\"headers\" in init && init.headers != null) {\n        fill(response[kHeaders], init.headers);\n    }\n    // 6. If body was given, then:\n    if (body) {\n        // 1. If response's status is a null body status, then throw a TypeError.\n        if (nullBodyStatus.includes(response.status)) {\n            throw webidl.errors.exception({\n                header: \"Response constructor\",\n                message: \"Invalid response status code \" + response.status\n            });\n        }\n        // 2. Set response's body to body's body.\n        response[kState].body = body.body;\n        // 3. If body's type is non-null and response's header list does not contain\n        //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.\n        if (body.type != null && !response[kState].headersList.contains(\"Content-Type\")) {\n            response[kState].headersList.append(\"content-type\", body.type);\n        }\n    }\n}\nwebidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream);\nwebidl.converters.FormData = webidl.interfaceConverter(FormData);\nwebidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams);\n// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit\nwebidl.converters.XMLHttpRequestBodyInit = function(V) {\n    if (typeof V === \"string\") {\n        return webidl.converters.USVString(V);\n    }\n    if (isBlobLike(V)) {\n        return webidl.converters.Blob(V, {\n            strict: false\n        });\n    }\n    if (types.isArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {\n        return webidl.converters.BufferSource(V);\n    }\n    if (util.isFormDataLike(V)) {\n        return webidl.converters.FormData(V, {\n            strict: false\n        });\n    }\n    if (V instanceof URLSearchParams) {\n        return webidl.converters.URLSearchParams(V);\n    }\n    return webidl.converters.DOMString(V);\n};\n// https://fetch.spec.whatwg.org/#bodyinit\nwebidl.converters.BodyInit = function(V) {\n    if (V instanceof ReadableStream) {\n        return webidl.converters.ReadableStream(V);\n    }\n    // Note: the spec doesn't include async iterables,\n    // this is an undici extension.\n    if (V?.[Symbol.asyncIterator]) {\n        return V;\n    }\n    return webidl.converters.XMLHttpRequestBodyInit(V);\n};\nwebidl.converters.ResponseInit = webidl.dictionaryConverter([\n    {\n        key: \"status\",\n        converter: webidl.converters[\"unsigned short\"],\n        defaultValue: 200\n    },\n    {\n        key: \"statusText\",\n        converter: webidl.converters.ByteString,\n        defaultValue: \"\"\n    },\n    {\n        key: \"headers\",\n        converter: webidl.converters.HeadersInit\n    }\n]);\nmodule.exports = {\n    makeNetworkError,\n    makeResponse,\n    makeAppropriateNetworkError,\n    filterResponse,\n    Response,\n    cloneResponse\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvcmVzcG9uc2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLE9BQU8sRUFBRUMsV0FBVyxFQUFFQyxJQUFJLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDL0MsTUFBTSxFQUFFQyxXQUFXLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFLEdBQUdILG1CQUFPQSxDQUFDO0FBQ3RELE1BQU1JLE9BQU9KLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRUssbUJBQW1CLEVBQUUsR0FBR0Q7QUFDaEMsTUFBTSxFQUNKRSxtQkFBbUIsRUFDbkJDLFdBQVcsRUFDWEMsU0FBUyxFQUNUQyxVQUFVLEVBQ1ZDLG9DQUFvQyxFQUNwQ0MsV0FBVyxFQUNYQyxnQkFBZ0IsRUFDakIsR0FBR1osbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQ0phLGlCQUFpQixFQUNqQkMsY0FBYyxFQUNkQyxZQUFZLEVBQ2IsR0FBR2YsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQUVnQixNQUFNLEVBQUVDLFFBQVEsRUFBRUMsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR25CLG1CQUFPQSxDQUFDO0FBQ3JELE1BQU0sRUFBRW9CLE1BQU0sRUFBRSxHQUFHcEIsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFcUIsUUFBUSxFQUFFLEdBQUdyQixtQkFBT0EsQ0FBQztBQUM3QixNQUFNLEVBQUVzQixlQUFlLEVBQUUsR0FBR3RCLG1CQUFPQSxDQUFDO0FBQ3BDLE1BQU0sRUFBRXVCLGFBQWEsRUFBRSxHQUFHdkIsbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUFFd0IsWUFBWSxFQUFFQyxVQUFVLEVBQUUsR0FBR3pCLG1CQUFPQSxDQUFDO0FBQzdDLE1BQU0wQixTQUFTMUIsbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFMkIsS0FBSyxFQUFFLEdBQUczQixtQkFBT0EsQ0FB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QUNMQyxXQUFXckgsT0FBT3lCLFVBQVUsQ0FBQytGLFdBQVc7SUFDMUM7Q0FDRDtBQUVEQyxPQUFPQyxPQUFPLEdBQUc7SUFDZnpHO0lBQ0FnQztJQUNBaUQ7SUFDQXJCO0lBQ0FqRTtJQUNBd0Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL3Jlc3BvbnNlLmpzP2I5ZDgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgSGVhZGVycywgSGVhZGVyc0xpc3QsIGZpbGwgfSA9IHJlcXVpcmUoJy4vaGVhZGVycycpXG5jb25zdCB7IGV4dHJhY3RCb2R5LCBjbG9uZUJvZHksIG1peGluQm9keSB9ID0gcmVxdWlyZSgnLi9ib2R5JylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSB1dGlsXG5jb25zdCB7XG4gIGlzVmFsaWRSZWFzb25QaHJhc2UsXG4gIGlzQ2FuY2VsbGVkLFxuICBpc0Fib3J0ZWQsXG4gIGlzQmxvYkxpa2UsXG4gIHNlcmlhbGl6ZUphdmFzY3JpcHRWYWx1ZVRvSlNPTlN0cmluZyxcbiAgaXNFcnJvckxpa2UsXG4gIGlzb21vcnBoaWNFbmNvZGVcbn0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3Qge1xuICByZWRpcmVjdFN0YXR1c1NldCxcbiAgbnVsbEJvZHlTdGF0dXMsXG4gIERPTUV4Y2VwdGlvblxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsga1N0YXRlLCBrSGVhZGVycywga0d1YXJkLCBrUmVhbG0gfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi93ZWJpZGwnKVxuY29uc3QgeyBGb3JtRGF0YSB9ID0gcmVxdWlyZSgnLi9mb3JtZGF0YScpXG5jb25zdCB7IGdldEdsb2JhbE9yaWdpbiB9ID0gcmVxdWlyZSgnLi9nbG9iYWwnKVxuY29uc3QgeyBVUkxTZXJpYWxpemVyIH0gPSByZXF1aXJlKCcuL2RhdGFVUkwnKVxuY29uc3QgeyBrSGVhZGVyc0xpc3QsIGtDb25zdHJ1Y3QgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgeyB0eXBlcyB9ID0gcmVxdWlyZSgndXRpbCcpXG5cbmNvbnN0IFJlYWRhYmxlU3RyZWFtID0gZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSB8fCByZXF1aXJlKCdzdHJlYW0vd2ViJykuUmVhZGFibGVTdHJlYW1cbmNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCd1dGYtOCcpXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXNwb25zZS1jbGFzc1xuY2xhc3MgUmVzcG9uc2Uge1xuICAvLyBDcmVhdGVzIG5ldHdvcmsgZXJyb3IgUmVzcG9uc2UuXG4gIHN0YXRpYyBlcnJvciAoKSB7XG4gICAgLy8gVE9ET1xuICAgIGNvbnN0IHJlbGV2YW50UmVhbG0gPSB7IHNldHRpbmdzT2JqZWN0OiB7fSB9XG5cbiAgICAvLyBUaGUgc3RhdGljIGVycm9yKCkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhXG4gICAgLy8gUmVzcG9uc2Ugb2JqZWN0LCBnaXZlbiBhIG5ldyBuZXR3b3JrIGVycm9yLCBcImltbXV0YWJsZVwiLCBhbmQgdGhpc+KAmXNcbiAgICAvLyByZWxldmFudCBSZWFsbS5cbiAgICBjb25zdCByZXNwb25zZU9iamVjdCA9IG5ldyBSZXNwb25zZSgpXG4gICAgcmVzcG9uc2VPYmplY3Rba1N0YXRlXSA9IG1ha2VOZXR3b3JrRXJyb3IoKVxuICAgIHJlc3BvbnNlT2JqZWN0W2tSZWFsbV0gPSByZWxldmFudFJlYWxtXG4gICAgcmVzcG9uc2VPYmplY3Rba0hlYWRlcnNdW2tIZWFkZXJzTGlzdF0gPSByZXNwb25zZU9iamVjdFtrU3RhdGVdLmhlYWRlcnNMaXN0XG4gICAgcmVzcG9uc2VPYmplY3Rba0hlYWRlcnNdW2tHdWFyZF0gPSAnaW1tdXRhYmxlJ1xuICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrUmVhbG1dID0gcmVsZXZhbnRSZWFsbVxuICAgIHJldHVybiByZXNwb25zZU9iamVjdFxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXNwb25zZS1qc29uXG4gIHN0YXRpYyBqc29uIChkYXRhLCBpbml0ID0ge30pIHtcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnUmVzcG9uc2UuanNvbicgfSlcblxuICAgIGlmIChpbml0ICE9PSBudWxsKSB7XG4gICAgICBpbml0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVzcG9uc2VJbml0KGluaXQpXG4gICAgfVxuXG4gICAgLy8gMS4gTGV0IGJ5dGVzIHRoZSByZXN1bHQgb2YgcnVubmluZyBzZXJpYWxpemUgYSBKYXZhU2NyaXB0IHZhbHVlIHRvIEpTT04gYnl0ZXMgb24gZGF0YS5cbiAgICBjb25zdCBieXRlcyA9IHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgIHNlcmlhbGl6ZUphdmFzY3JpcHRWYWx1ZVRvSlNPTlN0cmluZyhkYXRhKVxuICAgIClcblxuICAgIC8vIDIuIExldCBib2R5IGJlIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBieXRlcy5cbiAgICBjb25zdCBib2R5ID0gZXh0cmFjdEJvZHkoYnl0ZXMpXG5cbiAgICAvLyAzLiBMZXQgcmVzcG9uc2VPYmplY3QgYmUgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhIFJlc3BvbnNlIG9iamVjdCwgZ2l2ZW4gYSBuZXcgcmVzcG9uc2UsXG4gICAgLy8gICAgXCJyZXNwb25zZVwiLCBhbmQgdGhpc+KAmXMgcmVsZXZhbnQgUmVhbG0uXG4gICAgY29uc3QgcmVsZXZhbnRSZWFsbSA9IHsgc2V0dGluZ3NPYmplY3Q6IHt9IH1cbiAgICBjb25zdCByZXNwb25zZU9iamVjdCA9IG5ldyBSZXNwb25zZSgpXG4gICAgcmVzcG9uc2VPYmplY3Rba1JlYWxtXSA9IHJlbGV2YW50UmVhbG1cbiAgICByZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba0d1YXJkXSA9ICdyZXNwb25zZSdcbiAgICByZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba1JlYWxtXSA9IHJlbGV2YW50UmVhbG1cblxuICAgIC8vIDQuIFBlcmZvcm0gaW5pdGlhbGl6ZSBhIHJlc3BvbnNlIGdpdmVuIHJlc3BvbnNlT2JqZWN0LCBpbml0LCBhbmQgKGJvZHksIFwiYXBwbGljYXRpb24vanNvblwiKS5cbiAgICBpbml0aWFsaXplUmVzcG9uc2UocmVzcG9uc2VPYmplY3QsIGluaXQsIHsgYm9keTogYm9keVswXSwgdHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nIH0pXG5cbiAgICAvLyA1LiBSZXR1cm4gcmVzcG9uc2VPYmplY3QuXG4gICAgcmV0dXJuIHJlc3BvbnNlT2JqZWN0XG4gIH1cblxuICAvLyBDcmVhdGVzIGEgcmVkaXJlY3QgUmVzcG9uc2UgdGhhdCByZWRpcmVjdHMgdG8gdXJsIHdpdGggc3RhdHVzIHN0YXR1cy5cbiAgc3RhdGljIHJlZGlyZWN0ICh1cmwsIHN0YXR1cyA9IDMwMikge1xuICAgIGNvbnN0IHJlbGV2YW50UmVhbG0gPSB7IHNldHRpbmdzT2JqZWN0OiB7fSB9XG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnUmVzcG9uc2UucmVkaXJlY3QnIH0pXG5cbiAgICB1cmwgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcodXJsKVxuICAgIHN0YXR1cyA9IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBzaG9ydCddKHN0YXR1cylcblxuICAgIC8vIDEuIExldCBwYXJzZWRVUkwgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIHVybCB3aXRoIGN1cnJlbnQgc2V0dGluZ3NcbiAgICAvLyBvYmplY3TigJlzIEFQSSBiYXNlIFVSTC5cbiAgICAvLyAyLiBJZiBwYXJzZWRVUkwgaXMgZmFpbHVyZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAvLyBUT0RPOiBiYXNlLVVSTD9cbiAgICBsZXQgcGFyc2VkVVJMXG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZFVSTCA9IG5ldyBVUkwodXJsLCBnZXRHbG9iYWxPcmlnaW4oKSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IE9iamVjdC5hc3NpZ24obmV3IFR5cGVFcnJvcignRmFpbGVkIHRvIHBhcnNlIFVSTCBmcm9tICcgKyB1cmwpLCB7XG4gICAgICAgIGNhdXNlOiBlcnJcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMy4gSWYgc3RhdHVzIGlzIG5vdCBhIHJlZGlyZWN0IHN0YXR1cywgdGhlbiB0aHJvdyBhIFJhbmdlRXJyb3IuXG4gICAgaWYgKCFyZWRpcmVjdFN0YXR1c1NldC5oYXMoc3RhdHVzKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUgJyArIHN0YXR1cylcbiAgICB9XG5cbiAgICAvLyA0LiBMZXQgcmVzcG9uc2VPYmplY3QgYmUgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhIFJlc3BvbnNlIG9iamVjdCxcbiAgICAvLyBnaXZlbiBhIG5ldyByZXNwb25zZSwgXCJpbW11dGFibGVcIiwgYW5kIHRoaXPigJlzIHJlbGV2YW50IFJlYWxtLlxuICAgIGNvbnN0IHJlc3BvbnNlT2JqZWN0ID0gbmV3IFJlc3BvbnNlKClcbiAgICByZXNwb25zZU9iamVjdFtrUmVhbG1dID0gcmVsZXZhbnRSZWFsbVxuICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrR3VhcmRdID0gJ2ltbXV0YWJsZSdcbiAgICByZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba1JlYWxtXSA9IHJlbGV2YW50UmVhbG1cblxuICAgIC8vIDUuIFNldCByZXNwb25zZU9iamVjdOKAmXMgcmVzcG9uc2XigJlzIHN0YXR1cyB0byBzdGF0dXMuXG4gICAgcmVzcG9uc2VPYmplY3Rba1N0YXRlXS5zdGF0dXMgPSBzdGF0dXNcblxuICAgIC8vIDYuIExldCB2YWx1ZSBiZSBwYXJzZWRVUkwsIHNlcmlhbGl6ZWQgYW5kIGlzb21vcnBoaWMgZW5jb2RlZC5cbiAgICBjb25zdCB2YWx1ZSA9IGlzb21vcnBoaWNFbmNvZGUoVVJMU2VyaWFsaXplcihwYXJzZWRVUkwpKVxuXG4gICAgLy8gNy4gQXBwZW5kIGBMb2NhdGlvbmAvdmFsdWUgdG8gcmVzcG9uc2VPYmplY3TigJlzIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cbiAgICByZXNwb25zZU9iamVjdFtrU3RhdGVdLmhlYWRlcnNMaXN0LmFwcGVuZCgnbG9jYXRpb24nLCB2YWx1ZSlcblxuICAgIC8vIDguIFJldHVybiByZXNwb25zZU9iamVjdC5cbiAgICByZXR1cm4gcmVzcG9uc2VPYmplY3RcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tcmVzcG9uc2VcbiAgY29uc3RydWN0b3IgKGJvZHkgPSBudWxsLCBpbml0ID0ge30pIHtcbiAgICBpZiAoYm9keSAhPT0gbnVsbCkge1xuICAgICAgYm9keSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJvZHlJbml0KGJvZHkpXG4gICAgfVxuXG4gICAgaW5pdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlc3BvbnNlSW5pdChpbml0KVxuXG4gICAgLy8gVE9ET1xuICAgIHRoaXNba1JlYWxtXSA9IHsgc2V0dGluZ3NPYmplY3Q6IHt9IH1cblxuICAgIC8vIDEuIFNldCB0aGlz4oCZcyByZXNwb25zZSB0byBhIG5ldyByZXNwb25zZS5cbiAgICB0aGlzW2tTdGF0ZV0gPSBtYWtlUmVzcG9uc2Uoe30pXG5cbiAgICAvLyAyLiBTZXQgdGhpc+KAmXMgaGVhZGVycyB0byBhIG5ldyBIZWFkZXJzIG9iamVjdCB3aXRoIHRoaXPigJlzIHJlbGV2YW50XG4gICAgLy8gUmVhbG0sIHdob3NlIGhlYWRlciBsaXN0IGlzIHRoaXPigJlzIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdCBhbmQgZ3VhcmRcbiAgICAvLyBpcyBcInJlc3BvbnNlXCIuXG4gICAgdGhpc1trSGVhZGVyc10gPSBuZXcgSGVhZGVycyhrQ29uc3RydWN0KVxuICAgIHRoaXNba0hlYWRlcnNdW2tHdWFyZF0gPSAncmVzcG9uc2UnXG4gICAgdGhpc1trSGVhZGVyc11ba0hlYWRlcnNMaXN0XSA9IHRoaXNba1N0YXRlXS5oZWFkZXJzTGlzdFxuICAgIHRoaXNba0hlYWRlcnNdW2tSZWFsbV0gPSB0aGlzW2tSZWFsbV1cblxuICAgIC8vIDMuIExldCBib2R5V2l0aFR5cGUgYmUgbnVsbC5cbiAgICBsZXQgYm9keVdpdGhUeXBlID0gbnVsbFxuXG4gICAgLy8gNC4gSWYgYm9keSBpcyBub24tbnVsbCwgdGhlbiBzZXQgYm9keVdpdGhUeXBlIHRvIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBib2R5LlxuICAgIGlmIChib2R5ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IFtleHRyYWN0ZWRCb2R5LCB0eXBlXSA9IGV4dHJhY3RCb2R5KGJvZHkpXG4gICAgICBib2R5V2l0aFR5cGUgPSB7IGJvZHk6IGV4dHJhY3RlZEJvZHksIHR5cGUgfVxuICAgIH1cblxuICAgIC8vIDUuIFBlcmZvcm0gaW5pdGlhbGl6ZSBhIHJlc3BvbnNlIGdpdmVuIHRoaXMsIGluaXQsIGFuZCBib2R5V2l0aFR5cGUuXG4gICAgaW5pdGlhbGl6ZVJlc3BvbnNlKHRoaXMsIGluaXQsIGJvZHlXaXRoVHlwZSlcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVzcG9uc2XigJlzIHR5cGUsIGUuZy4sIFwiY29yc1wiLlxuICBnZXQgdHlwZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyBUaGUgdHlwZSBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXNwb25zZeKAmXMgdHlwZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnR5cGVcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVzcG9uc2XigJlzIFVSTCwgaWYgaXQgaGFzIG9uZTsgb3RoZXJ3aXNlIHRoZSBlbXB0eSBzdHJpbmcuXG4gIGdldCB1cmwgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgY29uc3QgdXJsTGlzdCA9IHRoaXNba1N0YXRlXS51cmxMaXN0XG5cbiAgICAvLyBUaGUgdXJsIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcgaWYgdGhpc+KAmXNcbiAgICAvLyByZXNwb25zZeKAmXMgVVJMIGlzIG51bGw7IG90aGVyd2lzZSB0aGlz4oCZcyByZXNwb25zZeKAmXMgVVJMLFxuICAgIC8vIHNlcmlhbGl6ZWQgd2l0aCBleGNsdWRlIGZyYWdtZW50IHNldCB0byB0cnVlLlxuICAgIGNvbnN0IHVybCA9IHVybExpc3RbdXJsTGlzdC5sZW5ndGggLSAxXSA/PyBudWxsXG5cbiAgICBpZiAodXJsID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG5cbiAgICByZXR1cm4gVVJMU2VyaWFsaXplcih1cmwsIHRydWUpXG4gIH1cblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgcmVzcG9uc2Ugd2FzIG9idGFpbmVkIHRocm91Z2ggYSByZWRpcmVjdC5cbiAgZ2V0IHJlZGlyZWN0ZWQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgLy8gVGhlIHJlZGlyZWN0ZWQgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdHJ1ZSBpZiB0aGlz4oCZcyByZXNwb25zZeKAmXMgVVJMXG4gICAgLy8gbGlzdCBoYXMgbW9yZSB0aGFuIG9uZSBpdGVtOyBvdGhlcndpc2UgZmFsc2UuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS51cmxMaXN0Lmxlbmd0aCA+IDFcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVzcG9uc2XigJlzIHN0YXR1cy5cbiAgZ2V0IHN0YXR1cyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyBUaGUgc3RhdHVzIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXMuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5zdGF0dXNcbiAgfVxuXG4gIC8vIFJldHVybnMgd2hldGhlciByZXNwb25zZeKAmXMgc3RhdHVzIGlzIGFuIG9rIHN0YXR1cy5cbiAgZ2V0IG9rICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIC8vIFRoZSBvayBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0cnVlIGlmIHRoaXPigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgYW5cbiAgICAvLyBvayBzdGF0dXM7IG90aGVyd2lzZSBmYWxzZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnN0YXR1cyA+PSAyMDAgJiYgdGhpc1trU3RhdGVdLnN0YXR1cyA8PSAyOTlcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVzcG9uc2XigJlzIHN0YXR1cyBtZXNzYWdlLlxuICBnZXQgc3RhdHVzVGV4dCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyBUaGUgc3RhdHVzVGV4dCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXNwb25zZeKAmXMgc3RhdHVzXG4gICAgLy8gbWVzc2FnZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnN0YXR1c1RleHRcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVzcG9uc2XigJlzIGhlYWRlcnMgYXMgSGVhZGVycy5cbiAgZ2V0IGhlYWRlcnMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgLy8gVGhlIGhlYWRlcnMgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgaGVhZGVycy5cbiAgICByZXR1cm4gdGhpc1trSGVhZGVyc11cbiAgfVxuXG4gIGdldCBib2R5ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYm9keSA/IHRoaXNba1N0YXRlXS5ib2R5LnN0cmVhbSA6IG51bGxcbiAgfVxuXG4gIGdldCBib2R5VXNlZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICByZXR1cm4gISF0aGlzW2tTdGF0ZV0uYm9keSAmJiB1dGlsLmlzRGlzdHVyYmVkKHRoaXNba1N0YXRlXS5ib2R5LnN0cmVhbSlcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBjbG9uZSBvZiByZXNwb25zZS5cbiAgY2xvbmUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgLy8gMS4gSWYgdGhpcyBpcyB1bnVzYWJsZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAodGhpcy5ib2R5VXNlZCB8fCAodGhpcy5ib2R5ICYmIHRoaXMuYm9keS5sb2NrZWQpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ1Jlc3BvbnNlLmNsb25lJyxcbiAgICAgICAgbWVzc2FnZTogJ0JvZHkgaGFzIGFscmVhZHkgYmVlbiBjb25zdW1lZC4nXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIExldCBjbG9uZWRSZXNwb25zZSBiZSB0aGUgcmVzdWx0IG9mIGNsb25pbmcgdGhpc+KAmXMgcmVzcG9uc2UuXG4gICAgY29uc3QgY2xvbmVkUmVzcG9uc2UgPSBjbG9uZVJlc3BvbnNlKHRoaXNba1N0YXRlXSlcblxuICAgIC8vIDMuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgUmVzcG9uc2Ugb2JqZWN0LCBnaXZlblxuICAgIC8vIGNsb25lZFJlc3BvbnNlLCB0aGlz4oCZcyBoZWFkZXJz4oCZcyBndWFyZCwgYW5kIHRoaXPigJlzIHJlbGV2YW50IFJlYWxtLlxuICAgIGNvbnN0IGNsb25lZFJlc3BvbnNlT2JqZWN0ID0gbmV3IFJlc3BvbnNlKClcbiAgICBjbG9uZWRSZXNwb25zZU9iamVjdFtrU3RhdGVdID0gY2xvbmVkUmVzcG9uc2VcbiAgICBjbG9uZWRSZXNwb25zZU9iamVjdFtrUmVhbG1dID0gdGhpc1trUmVhbG1dXG4gICAgY2xvbmVkUmVzcG9uc2VPYmplY3Rba0hlYWRlcnNdW2tIZWFkZXJzTGlzdF0gPSBjbG9uZWRSZXNwb25zZS5oZWFkZXJzTGlzdFxuICAgIGNsb25lZFJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrR3VhcmRdID0gdGhpc1trSGVhZGVyc11ba0d1YXJkXVxuICAgIGNsb25lZFJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrUmVhbG1dID0gdGhpc1trSGVhZGVyc11ba1JlYWxtXVxuXG4gICAgcmV0dXJuIGNsb25lZFJlc3BvbnNlT2JqZWN0XG4gIH1cbn1cblxubWl4aW5Cb2R5KFJlc3BvbnNlKVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZXNwb25zZS5wcm90b3R5cGUsIHtcbiAgdHlwZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgdXJsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBzdGF0dXM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9rOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWRpcmVjdGVkOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBzdGF0dXNUZXh0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBoZWFkZXJzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjbG9uZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYm9keToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYm9keVVzZWQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdSZXNwb25zZScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlc3BvbnNlLCB7XG4gIGpzb246IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlZGlyZWN0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBlcnJvcjoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtcmVzcG9uc2UtY2xvbmVcbmZ1bmN0aW9uIGNsb25lUmVzcG9uc2UgKHJlc3BvbnNlKSB7XG4gIC8vIFRvIGNsb25lIGEgcmVzcG9uc2UgcmVzcG9uc2UsIHJ1biB0aGVzZSBzdGVwczpcblxuICAvLyAxLiBJZiByZXNwb25zZSBpcyBhIGZpbHRlcmVkIHJlc3BvbnNlLCB0aGVuIHJldHVybiBhIG5ldyBpZGVudGljYWxcbiAgLy8gZmlsdGVyZWQgcmVzcG9uc2Ugd2hvc2UgaW50ZXJuYWwgcmVzcG9uc2UgaXMgYSBjbG9uZSBvZiByZXNwb25zZeKAmXNcbiAgLy8gaW50ZXJuYWwgcmVzcG9uc2UuXG4gIGlmIChyZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIGZpbHRlclJlc3BvbnNlKFxuICAgICAgY2xvbmVSZXNwb25zZShyZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlKSxcbiAgICAgIHJlc3BvbnNlLnR5cGVcbiAgICApXG4gIH1cblxuICAvLyAyLiBMZXQgbmV3UmVzcG9uc2UgYmUgYSBjb3B5IG9mIHJlc3BvbnNlLCBleGNlcHQgZm9yIGl0cyBib2R5LlxuICBjb25zdCBuZXdSZXNwb25zZSA9IG1ha2VSZXNwb25zZSh7IC4uLnJlc3BvbnNlLCBib2R5OiBudWxsIH0pXG5cbiAgLy8gMy4gSWYgcmVzcG9uc2XigJlzIGJvZHkgaXMgbm9uLW51bGwsIHRoZW4gc2V0IG5ld1Jlc3BvbnNl4oCZcyBib2R5IHRvIHRoZVxuICAvLyByZXN1bHQgb2YgY2xvbmluZyByZXNwb25zZeKAmXMgYm9keS5cbiAgaWYgKHJlc3BvbnNlLmJvZHkgIT0gbnVsbCkge1xuICAgIG5ld1Jlc3BvbnNlLmJvZHkgPSBjbG9uZUJvZHkocmVzcG9uc2UuYm9keSlcbiAgfVxuXG4gIC8vIDQuIFJldHVybiBuZXdSZXNwb25zZS5cbiAgcmV0dXJuIG5ld1Jlc3BvbnNlXG59XG5cbmZ1bmN0aW9uIG1ha2VSZXNwb25zZSAoaW5pdCkge1xuICByZXR1cm4ge1xuICAgIGFib3J0ZWQ6IGZhbHNlLFxuICAgIHJhbmdlUmVxdWVzdGVkOiBmYWxzZSxcbiAgICB0aW1pbmdBbGxvd1Bhc3NlZDogZmFsc2UsXG4gICAgcmVxdWVzdEluY2x1ZGVzQ3JlZGVudGlhbHM6IGZhbHNlLFxuICAgIHR5cGU6ICdkZWZhdWx0JyxcbiAgICBzdGF0dXM6IDIwMCxcbiAgICB0aW1pbmdJbmZvOiBudWxsLFxuICAgIGNhY2hlU3RhdGU6ICcnLFxuICAgIHN0YXR1c1RleHQ6ICcnLFxuICAgIC4uLmluaXQsXG4gICAgaGVhZGVyc0xpc3Q6IGluaXQuaGVhZGVyc0xpc3RcbiAgICAgID8gbmV3IEhlYWRlcnNMaXN0KGluaXQuaGVhZGVyc0xpc3QpXG4gICAgICA6IG5ldyBIZWFkZXJzTGlzdCgpLFxuICAgIHVybExpc3Q6IGluaXQudXJsTGlzdCA/IFsuLi5pbml0LnVybExpc3RdIDogW11cbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlTmV0d29ya0Vycm9yIChyZWFzb24pIHtcbiAgY29uc3QgaXNFcnJvciA9IGlzRXJyb3JMaWtlKHJlYXNvbilcbiAgcmV0dXJuIG1ha2VSZXNwb25zZSh7XG4gICAgdHlwZTogJ2Vycm9yJyxcbiAgICBzdGF0dXM6IDAsXG4gICAgZXJyb3I6IGlzRXJyb3JcbiAgICAgID8gcmVhc29uXG4gICAgICA6IG5ldyBFcnJvcihyZWFzb24gPyBTdHJpbmcocmVhc29uKSA6IHJlYXNvbiksXG4gICAgYWJvcnRlZDogcmVhc29uICYmIHJlYXNvbi5uYW1lID09PSAnQWJvcnRFcnJvcidcbiAgfSlcbn1cblxuZnVuY3Rpb24gbWFrZUZpbHRlcmVkUmVzcG9uc2UgKHJlc3BvbnNlLCBzdGF0ZSkge1xuICBzdGF0ZSA9IHtcbiAgICBpbnRlcm5hbFJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAuLi5zdGF0ZVxuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm94eShyZXNwb25zZSwge1xuICAgIGdldCAodGFyZ2V0LCBwKSB7XG4gICAgICByZXR1cm4gcCBpbiBzdGF0ZSA/IHN0YXRlW3BdIDogdGFyZ2V0W3BdXG4gICAgfSxcbiAgICBzZXQgKHRhcmdldCwgcCwgdmFsdWUpIHtcbiAgICAgIGFzc2VydCghKHAgaW4gc3RhdGUpKVxuICAgICAgdGFyZ2V0W3BdID0gdmFsdWVcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9KVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1maWx0ZXJlZC1yZXNwb25zZVxuZnVuY3Rpb24gZmlsdGVyUmVzcG9uc2UgKHJlc3BvbnNlLCB0eXBlKSB7XG4gIC8vIFNldCByZXNwb25zZSB0byB0aGUgZm9sbG93aW5nIGZpbHRlcmVkIHJlc3BvbnNlIHdpdGggcmVzcG9uc2UgYXMgaXRzXG4gIC8vIGludGVybmFsIHJlc3BvbnNlLCBkZXBlbmRpbmcgb24gcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmc6XG4gIGlmICh0eXBlID09PSAnYmFzaWMnKSB7XG4gICAgLy8gQSBiYXNpYyBmaWx0ZXJlZCByZXNwb25zZSBpcyBhIGZpbHRlcmVkIHJlc3BvbnNlIHdob3NlIHR5cGUgaXMgXCJiYXNpY1wiXG4gICAgLy8gYW5kIGhlYWRlciBsaXN0IGV4Y2x1ZGVzIGFueSBoZWFkZXJzIGluIGludGVybmFsIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdFxuICAgIC8vIHdob3NlIG5hbWUgaXMgYSBmb3JiaWRkZW4gcmVzcG9uc2UtaGVhZGVyIG5hbWUuXG5cbiAgICAvLyBOb3RlOiB1bmRpY2kgZG9lcyBub3QgaW1wbGVtZW50IGZvcmJpZGRlbiByZXNwb25zZS1oZWFkZXIgbmFtZXNcbiAgICByZXR1cm4gbWFrZUZpbHRlcmVkUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICAgIHR5cGU6ICdiYXNpYycsXG4gICAgICBoZWFkZXJzTGlzdDogcmVzcG9uc2UuaGVhZGVyc0xpc3RcbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjb3JzJykge1xuICAgIC8vIEEgQ09SUyBmaWx0ZXJlZCByZXNwb25zZSBpcyBhIGZpbHRlcmVkIHJlc3BvbnNlIHdob3NlIHR5cGUgaXMgXCJjb3JzXCJcbiAgICAvLyBhbmQgaGVhZGVyIGxpc3QgZXhjbHVkZXMgYW55IGhlYWRlcnMgaW4gaW50ZXJuYWwgcmVzcG9uc2XigJlzIGhlYWRlclxuICAgIC8vIGxpc3Qgd2hvc2UgbmFtZSBpcyBub3QgYSBDT1JTLXNhZmVsaXN0ZWQgcmVzcG9uc2UtaGVhZGVyIG5hbWUsIGdpdmVuXG4gICAgLy8gaW50ZXJuYWwgcmVzcG9uc2XigJlzIENPUlMtZXhwb3NlZCBoZWFkZXItbmFtZSBsaXN0LlxuXG4gICAgLy8gTm90ZTogdW5kaWNpIGRvZXMgbm90IGltcGxlbWVudCBDT1JTLXNhZmVsaXN0ZWQgcmVzcG9uc2UtaGVhZGVyIG5hbWVzXG4gICAgcmV0dXJuIG1ha2VGaWx0ZXJlZFJlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgICB0eXBlOiAnY29ycycsXG4gICAgICBoZWFkZXJzTGlzdDogcmVzcG9uc2UuaGVhZGVyc0xpc3RcbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGFxdWUnKSB7XG4gICAgLy8gQW4gb3BhcXVlIGZpbHRlcmVkIHJlc3BvbnNlIGlzIGEgZmlsdGVyZWQgcmVzcG9uc2Ugd2hvc2UgdHlwZSBpc1xuICAgIC8vIFwib3BhcXVlXCIsIFVSTCBsaXN0IGlzIHRoZSBlbXB0eSBsaXN0LCBzdGF0dXMgaXMgMCwgc3RhdHVzIG1lc3NhZ2VcbiAgICAvLyBpcyB0aGUgZW1wdHkgYnl0ZSBzZXF1ZW5jZSwgaGVhZGVyIGxpc3QgaXMgZW1wdHksIGFuZCBib2R5IGlzIG51bGwuXG5cbiAgICByZXR1cm4gbWFrZUZpbHRlcmVkUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICAgIHR5cGU6ICdvcGFxdWUnLFxuICAgICAgdXJsTGlzdDogT2JqZWN0LmZyZWV6ZShbXSksXG4gICAgICBzdGF0dXM6IDAsXG4gICAgICBzdGF0dXNUZXh0OiAnJyxcbiAgICAgIGJvZHk6IG51bGxcbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGFxdWVyZWRpcmVjdCcpIHtcbiAgICAvLyBBbiBvcGFxdWUtcmVkaXJlY3QgZmlsdGVyZWQgcmVzcG9uc2UgaXMgYSBmaWx0ZXJlZCByZXNwb25zZSB3aG9zZSB0eXBlXG4gICAgLy8gaXMgXCJvcGFxdWVyZWRpcmVjdFwiLCBzdGF0dXMgaXMgMCwgc3RhdHVzIG1lc3NhZ2UgaXMgdGhlIGVtcHR5IGJ5dGVcbiAgICAvLyBzZXF1ZW5jZSwgaGVhZGVyIGxpc3QgaXMgZW1wdHksIGFuZCBib2R5IGlzIG51bGwuXG5cbiAgICByZXR1cm4gbWFrZUZpbHRlcmVkUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICAgIHR5cGU6ICdvcGFxdWVyZWRpcmVjdCcsXG4gICAgICBzdGF0dXM6IDAsXG4gICAgICBzdGF0dXNUZXh0OiAnJyxcbiAgICAgIGhlYWRlcnNMaXN0OiBbXSxcbiAgICAgIGJvZHk6IG51bGxcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGFzc2VydChmYWxzZSlcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYXBwcm9wcmlhdGUtbmV0d29yay1lcnJvclxuZnVuY3Rpb24gbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yIChmZXRjaFBhcmFtcywgZXJyID0gbnVsbCkge1xuICAvLyAxLiBBc3NlcnQ6IGZldGNoUGFyYW1zIGlzIGNhbmNlbGVkLlxuICBhc3NlcnQoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKVxuXG4gIC8vIDIuIFJldHVybiBhbiBhYm9ydGVkIG5ldHdvcmsgZXJyb3IgaWYgZmV0Y2hQYXJhbXMgaXMgYWJvcnRlZDtcbiAgLy8gb3RoZXJ3aXNlIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gIHJldHVybiBpc0Fib3J0ZWQoZmV0Y2hQYXJhbXMpXG4gICAgPyBtYWtlTmV0d29ya0Vycm9yKE9iamVjdC5hc3NpZ24obmV3IERPTUV4Y2VwdGlvbignVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC4nLCAnQWJvcnRFcnJvcicpLCB7IGNhdXNlOiBlcnIgfSkpXG4gICAgOiBtYWtlTmV0d29ya0Vycm9yKE9iamVjdC5hc3NpZ24obmV3IERPTUV4Y2VwdGlvbignUmVxdWVzdCB3YXMgY2FuY2VsbGVkLicpLCB7IGNhdXNlOiBlcnIgfSkpXG59XG5cbi8vIGh0dHBzOi8vd2hhdHByLm9yZy9mZXRjaC8xMzkyLmh0bWwjaW5pdGlhbGl6ZS1hLXJlc3BvbnNlXG5mdW5jdGlvbiBpbml0aWFsaXplUmVzcG9uc2UgKHJlc3BvbnNlLCBpbml0LCBib2R5KSB7XG4gIC8vIDEuIElmIGluaXRbXCJzdGF0dXNcIl0gaXMgbm90IGluIHRoZSByYW5nZSAyMDAgdG8gNTk5LCBpbmNsdXNpdmUsIHRoZW5cbiAgLy8gICAgdGhyb3cgYSBSYW5nZUVycm9yLlxuICBpZiAoaW5pdC5zdGF0dXMgIT09IG51bGwgJiYgKGluaXQuc3RhdHVzIDwgMjAwIHx8IGluaXQuc3RhdHVzID4gNTk5KSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbml0W1wic3RhdHVzXCJdIG11c3QgYmUgaW4gdGhlIHJhbmdlIG9mIDIwMCB0byA1OTksIGluY2x1c2l2ZS4nKVxuICB9XG5cbiAgLy8gMi4gSWYgaW5pdFtcInN0YXR1c1RleHRcIl0gZG9lcyBub3QgbWF0Y2ggdGhlIHJlYXNvbi1waHJhc2UgdG9rZW4gcHJvZHVjdGlvbixcbiAgLy8gICAgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKCdzdGF0dXNUZXh0JyBpbiBpbml0ICYmIGluaXQuc3RhdHVzVGV4dCAhPSBudWxsKSB7XG4gICAgLy8gU2VlLCBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjEuMjpcbiAgICAvLyAgIHJlYXNvbi1waHJhc2UgID0gKiggSFRBQiAvIFNQIC8gVkNIQVIgLyBvYnMtdGV4dCApXG4gICAgaWYgKCFpc1ZhbGlkUmVhc29uUGhyYXNlKFN0cmluZyhpbml0LnN0YXR1c1RleHQpKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzdGF0dXNUZXh0JylcbiAgICB9XG4gIH1cblxuICAvLyAzLiBTZXQgcmVzcG9uc2XigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXMgdG8gaW5pdFtcInN0YXR1c1wiXS5cbiAgaWYgKCdzdGF0dXMnIGluIGluaXQgJiYgaW5pdC5zdGF0dXMgIT0gbnVsbCkge1xuICAgIHJlc3BvbnNlW2tTdGF0ZV0uc3RhdHVzID0gaW5pdC5zdGF0dXNcbiAgfVxuXG4gIC8vIDQuIFNldCByZXNwb25zZeKAmXMgcmVzcG9uc2XigJlzIHN0YXR1cyBtZXNzYWdlIHRvIGluaXRbXCJzdGF0dXNUZXh0XCJdLlxuICBpZiAoJ3N0YXR1c1RleHQnIGluIGluaXQgJiYgaW5pdC5zdGF0dXNUZXh0ICE9IG51bGwpIHtcbiAgICByZXNwb25zZVtrU3RhdGVdLnN0YXR1c1RleHQgPSBpbml0LnN0YXR1c1RleHRcbiAgfVxuXG4gIC8vIDUuIElmIGluaXRbXCJoZWFkZXJzXCJdIGV4aXN0cywgdGhlbiBmaWxsIHJlc3BvbnNl4oCZcyBoZWFkZXJzIHdpdGggaW5pdFtcImhlYWRlcnNcIl0uXG4gIGlmICgnaGVhZGVycycgaW4gaW5pdCAmJiBpbml0LmhlYWRlcnMgIT0gbnVsbCkge1xuICAgIGZpbGwocmVzcG9uc2Vba0hlYWRlcnNdLCBpbml0LmhlYWRlcnMpXG4gIH1cblxuICAvLyA2LiBJZiBib2R5IHdhcyBnaXZlbiwgdGhlbjpcbiAgaWYgKGJvZHkpIHtcbiAgICAvLyAxLiBJZiByZXNwb25zZSdzIHN0YXR1cyBpcyBhIG51bGwgYm9keSBzdGF0dXMsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKG51bGxCb2R5U3RhdHVzLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnUmVzcG9uc2UgY29uc3RydWN0b3InLFxuICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCByZXNwb25zZSBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIFNldCByZXNwb25zZSdzIGJvZHkgdG8gYm9keSdzIGJvZHkuXG4gICAgcmVzcG9uc2Vba1N0YXRlXS5ib2R5ID0gYm9keS5ib2R5XG5cbiAgICAvLyAzLiBJZiBib2R5J3MgdHlwZSBpcyBub24tbnVsbCBhbmQgcmVzcG9uc2UncyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluXG4gICAgLy8gICAgYENvbnRlbnQtVHlwZWAsIHRoZW4gYXBwZW5kIChgQ29udGVudC1UeXBlYCwgYm9keSdzIHR5cGUpIHRvIHJlc3BvbnNlJ3MgaGVhZGVyIGxpc3QuXG4gICAgaWYgKGJvZHkudHlwZSAhPSBudWxsICYmICFyZXNwb25zZVtrU3RhdGVdLmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdDb250ZW50LVR5cGUnKSkge1xuICAgICAgcmVzcG9uc2Vba1N0YXRlXS5oZWFkZXJzTGlzdC5hcHBlbmQoJ2NvbnRlbnQtdHlwZScsIGJvZHkudHlwZSlcbiAgICB9XG4gIH1cbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuUmVhZGFibGVTdHJlYW0gPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKFxuICBSZWFkYWJsZVN0cmVhbVxuKVxuXG53ZWJpZGwuY29udmVydGVycy5Gb3JtRGF0YSA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoXG4gIEZvcm1EYXRhXG4pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLlVSTFNlYXJjaFBhcmFtcyA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoXG4gIFVSTFNlYXJjaFBhcmFtc1xuKVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jdHlwZWRlZmRlZi14bWxodHRwcmVxdWVzdGJvZHlpbml0XG53ZWJpZGwuY29udmVydGVycy5YTUxIdHRwUmVxdWVzdEJvZHlJbml0ID0gZnVuY3Rpb24gKFYpIHtcbiAgaWYgKHR5cGVvZiBWID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoVilcbiAgfVxuXG4gIGlmIChpc0Jsb2JMaWtlKFYpKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IoViwgeyBzdHJpY3Q6IGZhbHNlIH0pXG4gIH1cblxuICBpZiAodHlwZXMuaXNBcnJheUJ1ZmZlcihWKSB8fCB0eXBlcy5pc1R5cGVkQXJyYXkoVikgfHwgdHlwZXMuaXNEYXRhVmlldyhWKSkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5CdWZmZXJTb3VyY2UoVilcbiAgfVxuXG4gIGlmICh1dGlsLmlzRm9ybURhdGFMaWtlKFYpKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkZvcm1EYXRhKFYsIHsgc3RyaWN0OiBmYWxzZSB9KVxuICB9XG5cbiAgaWYgKFYgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVVJMU2VhcmNoUGFyYW1zKFYpXG4gIH1cblxuICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKFYpXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5aW5pdFxud2ViaWRsLmNvbnZlcnRlcnMuQm9keUluaXQgPSBmdW5jdGlvbiAoVikge1xuICBpZiAoViBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlJlYWRhYmxlU3RyZWFtKFYpXG4gIH1cblxuICAvLyBOb3RlOiB0aGUgc3BlYyBkb2Vzbid0IGluY2x1ZGUgYXN5bmMgaXRlcmFibGVzLFxuICAvLyB0aGlzIGlzIGFuIHVuZGljaSBleHRlbnNpb24uXG4gIGlmIChWPy5bU3ltYm9sLmFzeW5jSXRlcmF0b3JdKSB7XG4gICAgcmV0dXJuIFZcbiAgfVxuXG4gIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5YTUxIdHRwUmVxdWVzdEJvZHlJbml0KFYpXG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLlJlc3BvbnNlSW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGtleTogJ3N0YXR1cycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgc2hvcnQnXSxcbiAgICBkZWZhdWx0VmFsdWU6IDIwMFxuICB9LFxuICB7XG4gICAga2V5OiAnc3RhdHVzVGV4dCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogJydcbiAgfSxcbiAge1xuICAgIGtleTogJ2hlYWRlcnMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuSGVhZGVyc0luaXRcbiAgfVxuXSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1ha2VOZXR3b3JrRXJyb3IsXG4gIG1ha2VSZXNwb25zZSxcbiAgbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yLFxuICBmaWx0ZXJSZXNwb25zZSxcbiAgUmVzcG9uc2UsXG4gIGNsb25lUmVzcG9uc2Vcbn1cbiJdLCJuYW1lcyI6WyJIZWFkZXJzIiwiSGVhZGVyc0xpc3QiLCJmaWxsIiwicmVxdWlyZSIsImV4dHJhY3RCb2R5IiwiY2xvbmVCb2R5IiwibWl4aW5Cb2R5IiwidXRpbCIsImtFbnVtZXJhYmxlUHJvcGVydHkiLCJpc1ZhbGlkUmVhc29uUGhyYXNlIiwiaXNDYW5jZWxsZWQiLCJpc0Fib3J0ZWQiLCJpc0Jsb2JMaWtlIiwic2VyaWFsaXplSmF2YXNjcmlwdFZhbHVlVG9KU09OU3RyaW5nIiwiaXNFcnJvckxpa2UiLCJpc29tb3JwaGljRW5jb2RlIiwicmVkaXJlY3RTdGF0dXNTZXQiLCJudWxsQm9keVN0YXR1cyIsIkRPTUV4Y2VwdGlvbiIsImtTdGF0ZSIsImtIZWFkZXJzIiwia0d1YXJkIiwia1JlYWxtIiwid2ViaWRsIiwiRm9ybURhdGEiLCJnZXRHbG9iYWxPcmlnaW4iLCJVUkxTZXJpYWxpemVyIiwia0hlYWRlcnNMaXN0Iiwia0NvbnN0cnVjdCIsImFzc2VydCIsInR5cGVzIiwiUmVhZGFibGVTdHJlYW0iLCJnbG9iYWxUaGlzIiwidGV4dEVuY29kZXIiLCJUZXh0RW5jb2RlciIsIlJlc3BvbnNlIiwiZXJyb3IiLCJyZWxldmFudFJlYWxtIiwic2V0dGluZ3NPYmplY3QiLCJyZXNwb25zZU9iamVjdCIsIm1ha2VOZXR3b3JrRXJyb3IiLCJoZWFkZXJzTGlzdCIsImpzb24iLCJkYXRhIiwiaW5pdCIsImFyZ3VtZW50TGVuZ3RoQ2hlY2siLCJhcmd1bWVudHMiLCJoZWFkZXIiLCJjb252ZXJ0ZXJzIiwiUmVzcG9uc2VJbml0IiwiYnl0ZXMiLCJlbmNvZGUiLCJib2R5IiwiaW5pdGlhbGl6ZVJlc3BvbnNlIiwidHlwZSIsInJlZGlyZWN0IiwidXJsIiwic3RhdHVzIiwiVVNWU3RyaW5nIiwicGFyc2VkVVJMIiwiVVJMIiwiZXJyIiwiT2JqZWN0IiwiYXNzaWduIiwiVHlwZUVycm9yIiwiY2F1c2UiLCJoYXMiLCJSYW5nZUVycm9yIiwidmFsdWUiLCJhcHBlbmQiLCJjb25zdHJ1Y3RvciIsIkJvZHlJbml0IiwibWFrZVJlc3BvbnNlIiwiYm9keVdpdGhUeXBlIiwiZXh0cmFjdGVkQm9keSIsImJyYW5kQ2hlY2siLCJ1cmxMaXN0IiwibGVuZ3RoIiwicmVkaXJlY3RlZCIsIm9rIiwic3RhdHVzVGV4dCIsImhlYWRlcnMiLCJzdHJlYW0iLCJib2R5VXNlZCIsImlzRGlzdHVyYmVkIiwiY2xvbmUiLCJsb2NrZWQiLCJlcnJvcnMiLCJleGNlcHRpb24iLCJtZXNzYWdlIiwiY2xvbmVkUmVzcG9uc2UiLCJjbG9uZVJlc3BvbnNlIiwiY2xvbmVkUmVzcG9uc2VPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJvdG90eXBlIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJjb25maWd1cmFibGUiLCJyZXNwb25zZSIsImludGVybmFsUmVzcG9uc2UiLCJmaWx0ZXJSZXNwb25zZSIsIm5ld1Jlc3BvbnNlIiwiYWJvcnRlZCIsInJhbmdlUmVxdWVzdGVkIiwidGltaW5nQWxsb3dQYXNzZWQiLCJyZXF1ZXN0SW5jbHVkZXNDcmVkZW50aWFscyIsInRpbWluZ0luZm8iLCJjYWNoZVN0YXRlIiwicmVhc29uIiwiaXNFcnJvciIsIkVycm9yIiwiU3RyaW5nIiwibmFtZSIsIm1ha2VGaWx0ZXJlZFJlc3BvbnNlIiwic3RhdGUiLCJQcm94eSIsImdldCIsInRhcmdldCIsInAiLCJzZXQiLCJmcmVlemUiLCJtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IiLCJmZXRjaFBhcmFtcyIsImluY2x1ZGVzIiwiY29udGFpbnMiLCJpbnRlcmZhY2VDb252ZXJ0ZXIiLCJVUkxTZWFyY2hQYXJhbXMiLCJYTUxIdHRwUmVxdWVzdEJvZHlJbml0IiwiViIsIkJsb2IiLCJzdHJpY3QiLCJpc0FycmF5QnVmZmVyIiwiaXNUeXBlZEFycmF5IiwiaXNEYXRhVmlldyIsIkJ1ZmZlclNvdXJjZSIsImlzRm9ybURhdGFMaWtlIiwiRE9NU3RyaW5nIiwiYXN5bmNJdGVyYXRvciIsImRpY3Rpb25hcnlDb252ZXJ0ZXIiLCJrZXkiLCJjb252ZXJ0ZXIiLCJkZWZhdWx0VmFsdWUiLCJCeXRlU3RyaW5nIiwiSGVhZGVyc0luaXQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/response.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/symbols.js":
/*!************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/fetch/symbols.js ***!
  \************************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    kUrl: Symbol(\"url\"),\n    kHeaders: Symbol(\"headers\"),\n    kSignal: Symbol(\"signal\"),\n    kState: Symbol(\"state\"),\n    kGuard: Symbol(\"guard\"),\n    kRealm: Symbol(\"realm\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSxPQUFPQyxPQUFPLEdBQUc7SUFDZkMsTUFBTUMsT0FBTztJQUNiQyxVQUFVRCxPQUFPO0lBQ2pCRSxTQUFTRixPQUFPO0lBQ2hCRyxRQUFRSCxPQUFPO0lBQ2ZJLFFBQVFKLE9BQU87SUFDZkssUUFBUUwsT0FBTztBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL3N5bWJvbHMuanM/ZDJiNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtVcmw6IFN5bWJvbCgndXJsJyksXG4gIGtIZWFkZXJzOiBTeW1ib2woJ2hlYWRlcnMnKSxcbiAga1NpZ25hbDogU3ltYm9sKCdzaWduYWwnKSxcbiAga1N0YXRlOiBTeW1ib2woJ3N0YXRlJyksXG4gIGtHdWFyZDogU3ltYm9sKCdndWFyZCcpLFxuICBrUmVhbG06IFN5bWJvbCgncmVhbG0nKVxufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJrVXJsIiwiU3ltYm9sIiwia0hlYWRlcnMiLCJrU2lnbmFsIiwia1N0YXRlIiwia0d1YXJkIiwia1JlYWxtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/util.js":
/*!*********************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/fetch/util.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/constants.js\");\nconst { getGlobalOrigin } = __webpack_require__(/*! ./global */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/global.js\");\nconst { performance } = __webpack_require__(/*! perf_hooks */ \"perf_hooks\");\nconst { isBlobLike, toUSVString, ReadableStreamFrom } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { isUint8Array } = __webpack_require__(/*! util/types */ \"util/types\");\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('crypto')|undefined} */ let crypto;\ntry {\n    crypto = __webpack_require__(/*! crypto */ \"crypto\");\n} catch  {}\nfunction responseURL(response) {\n    // https://fetch.spec.whatwg.org/#responses\n    // A response has an associated URL. It is a pointer to the last URL\n    // in responses URL list and null if responses URL list is empty.\n    const urlList = response.urlList;\n    const length = urlList.length;\n    return length === 0 ? null : urlList[length - 1].toString();\n}\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL(response, requestFragment) {\n    // 1. If responses status is not a redirect status, then return null.\n    if (!redirectStatusSet.has(response.status)) {\n        return null;\n    }\n    // 2. Let location be the result of extracting header list values given\n    // `Location` and responses header list.\n    let location = response.headersList.get(\"location\");\n    // 3. If location is a header value, then set location to the result of\n    //    parsing location with responses URL.\n    if (location !== null && isValidHeaderValue(location)) {\n        location = new URL(location, responseURL(response));\n    }\n    // 4. If location is a URL whose fragment is null, then set locations\n    // fragment to requestFragment.\n    if (location && !location.hash) {\n        location.hash = requestFragment;\n    }\n    // 5. Return location.\n    return location;\n}\n/** @returns {URL} */ function requestCurrentURL(request) {\n    return request.urlList[request.urlList.length - 1];\n}\nfunction requestBadPort(request) {\n    // 1. Let url be requests current URL.\n    const url = requestCurrentURL(request);\n    // 2. If urls scheme is an HTTP(S) scheme and urls port is a bad port,\n    // then return blocked.\n    if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {\n        return \"blocked\";\n    }\n    // 3. Return allowed.\n    return \"allowed\";\n}\nfunction isErrorLike(object) {\n    return object instanceof Error || object?.constructor?.name === \"Error\" || object?.constructor?.name === \"DOMException\";\n}\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase(statusText) {\n    for(let i = 0; i < statusText.length; ++i){\n        const c = statusText.charCodeAt(i);\n        if (!(c === 0x09 || // HTAB\n        c >= 0x20 && c <= 0x7e || // SP / VCHAR\n        c >= 0x80 && c <= 0xff // obs-text\n        )) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n * @param {number} c\n */ function isTokenCharCode(c) {\n    switch(c){\n        case 0x22:\n        case 0x28:\n        case 0x29:\n        case 0x2c:\n        case 0x2f:\n        case 0x3a:\n        case 0x3b:\n        case 0x3c:\n        case 0x3d:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x5b:\n        case 0x5c:\n        case 0x5d:\n        case 0x7b:\n        case 0x7d:\n            // DQUOTE and \"(),/:;<=>?@[\\]{}\"\n            return false;\n        default:\n            // VCHAR %x21-7E\n            return c >= 0x21 && c <= 0x7e;\n    }\n}\n/**\n * @param {string} characters\n */ function isValidHTTPToken(characters) {\n    if (characters.length === 0) {\n        return false;\n    }\n    for(let i = 0; i < characters.length; ++i){\n        if (!isTokenCharCode(characters.charCodeAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * @see https://fetch.spec.whatwg.org/#header-name\n * @param {string} potentialValue\n */ function isValidHeaderName(potentialValue) {\n    return isValidHTTPToken(potentialValue);\n}\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */ function isValidHeaderValue(potentialValue) {\n    // - Has no leading or trailing HTTP tab or space bytes.\n    // - Contains no 0x00 (NUL) or HTTP newline bytes.\n    if (potentialValue.startsWith(\"\t\") || potentialValue.startsWith(\" \") || potentialValue.endsWith(\"\t\") || potentialValue.endsWith(\" \")) {\n        return false;\n    }\n    if (potentialValue.includes(\"\\x00\") || potentialValue.includes(\"\\r\") || potentialValue.includes(\"\\n\")) {\n        return false;\n    }\n    return true;\n}\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction setRequestReferrerPolicyOnRedirect(request, actualResponse) {\n    //  Given a request request and a response actualResponse, this algorithm\n    //  updates requests referrer policy according to the Referrer-Policy\n    //  header (if any) in actualResponse.\n    // 1. Let policy be the result of executing  8.1 Parse a referrer policy\n    // from a Referrer-Policy header on actualResponse.\n    // 8.1 Parse a referrer policy from a Referrer-Policy header\n    // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and responses header list.\n    const { headersList } = actualResponse;\n    // 2. Let policy be the empty string.\n    // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.\n    // 4. Return policy.\n    const policyHeader = (headersList.get(\"referrer-policy\") ?? \"\").split(\",\");\n    // Note: As the referrer-policy can contain multiple policies\n    // separated by comma, we need to loop through all of them\n    // and pick the first valid one.\n    // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy\n    let policy = \"\";\n    if (policyHeader.length > 0) {\n        // The right-most policy takes precedence.\n        // The left-most policy is the fallback.\n        for(let i = policyHeader.length; i !== 0; i--){\n            const token = policyHeader[i - 1].trim();\n            if (referrerPolicyTokens.has(token)) {\n                policy = token;\n                break;\n            }\n        }\n    }\n    // 2. If policy is not the empty string, then set requests referrer policy to policy.\n    if (policy !== \"\") {\n        request.referrerPolicy = policy;\n    }\n}\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck() {\n    // TODO\n    return \"allowed\";\n}\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck() {\n    // TODO\n    return \"success\";\n}\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck() {\n    // TODO\n    return \"success\";\n}\nfunction appendFetchMetadata(httpRequest) {\n    //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n    //  TODO\n    //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n    //  1. Assert: rs url is a potentially trustworthy URL.\n    //  TODO\n    //  2. Let header be a Structured Header whose value is a token.\n    let header = null;\n    //  3. Set headers value to rs mode.\n    header = httpRequest.mode;\n    //  4. Set a structured field value `Sec-Fetch-Mode`/header in rs header list.\n    httpRequest.headersList.set(\"sec-fetch-mode\", header);\n//  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n//  TODO\n//  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n//  TODO\n}\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader(request) {\n    // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.\n    let serializedOrigin = request.origin;\n    // 2. If requests response tainting is \"cors\" or requests mode is \"websocket\", then append (`Origin`, serializedOrigin) to requests header list.\n    if (request.responseTainting === \"cors\" || request.mode === \"websocket\") {\n        if (serializedOrigin) {\n            request.headersList.append(\"origin\", serializedOrigin);\n        }\n    // 3. Otherwise, if requests method is neither `GET` nor `HEAD`, then:\n    } else if (request.method !== \"GET\" && request.method !== \"HEAD\") {\n        // 1. Switch on requests referrer policy:\n        switch(request.referrerPolicy){\n            case \"no-referrer\":\n                // Set serializedOrigin to `null`.\n                serializedOrigin = null;\n                break;\n            case \"no-referrer-when-downgrade\":\n            case \"strict-origin\":\n            case \"strict-origin-when-cross-origin\":\n                // If requests origin is a tuple origin, its scheme is \"https\", and requests current URLs scheme is not \"https\", then set serializedOrigin to `null`.\n                if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {\n                    serializedOrigin = null;\n                }\n                break;\n            case \"same-origin\":\n                // If requests origin is not same origin with requests current URLs origin, then set serializedOrigin to `null`.\n                if (!sameOrigin(request, requestCurrentURL(request))) {\n                    serializedOrigin = null;\n                }\n                break;\n            default:\n        }\n        if (serializedOrigin) {\n            // 2. Append (`Origin`, serializedOrigin) to requests header list.\n            request.headersList.append(\"origin\", serializedOrigin);\n        }\n    }\n}\nfunction coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {\n    // TODO\n    return performance.now();\n}\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo(timingInfo) {\n    return {\n        startTime: timingInfo.startTime ?? 0,\n        redirectStartTime: 0,\n        redirectEndTime: 0,\n        postRedirectStartTime: timingInfo.startTime ?? 0,\n        finalServiceWorkerStartTime: 0,\n        finalNetworkResponseStartTime: 0,\n        finalNetworkRequestStartTime: 0,\n        endTime: 0,\n        encodedBodySize: 0,\n        decodedBodySize: 0,\n        finalConnectionTimingInfo: null\n    };\n}\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer() {\n    // Note: the fetch spec doesn't make use of embedder policy or CSP list\n    return {\n        referrerPolicy: \"strict-origin-when-cross-origin\"\n    };\n}\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer(policyContainer) {\n    return {\n        referrerPolicy: policyContainer.referrerPolicy\n    };\n}\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction determineRequestsReferrer(request) {\n    // 1. Let policy be request's referrer policy.\n    const policy = request.referrerPolicy;\n    // Note: policy cannot (shouldn't) be null or an empty string.\n    assert(policy);\n    // 2. Let environment be requests client.\n    let referrerSource = null;\n    // 3. Switch on requests referrer:\n    if (request.referrer === \"client\") {\n        // Note: node isn't a browser and doesn't implement document/iframes,\n        // so we bypass this step and replace it with our own.\n        const globalOrigin = getGlobalOrigin();\n        if (!globalOrigin || globalOrigin.origin === \"null\") {\n            return \"no-referrer\";\n        }\n        // note: we need to clone it as it's mutated\n        referrerSource = new URL(globalOrigin);\n    } else if (request.referrer instanceof URL) {\n        // Let referrerSource be requests referrer.\n        referrerSource = request.referrer;\n    }\n    // 4. Let requests referrerURL be the result of stripping referrerSource for\n    //    use as a referrer.\n    let referrerURL = stripURLForReferrer(referrerSource);\n    // 5. Let referrerOrigin be the result of stripping referrerSource for use as\n    //    a referrer, with the origin-only flag set to true.\n    const referrerOrigin = stripURLForReferrer(referrerSource, true);\n    // 6. If the result of serializing referrerURL is a string whose length is\n    //    greater than 4096, set referrerURL to referrerOrigin.\n    if (referrerURL.toString().length > 4096) {\n        referrerURL = referrerOrigin;\n    }\n    const areSameOrigin = sameOrigin(request, referrerURL);\n    const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);\n    // 8. Execute the switch statements corresponding to the value of policy:\n    switch(policy){\n        case \"origin\":\n            return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);\n        case \"unsafe-url\":\n            return referrerURL;\n        case \"same-origin\":\n            return areSameOrigin ? referrerOrigin : \"no-referrer\";\n        case \"origin-when-cross-origin\":\n            return areSameOrigin ? referrerURL : referrerOrigin;\n        case \"strict-origin-when-cross-origin\":\n            {\n                const currentURL = requestCurrentURL(request);\n                // 1. If the origin of referrerURL and the origin of requests current\n                //    URL are the same, then return referrerURL.\n                if (sameOrigin(referrerURL, currentURL)) {\n                    return referrerURL;\n                }\n                // 2. If referrerURL is a potentially trustworthy URL and requests\n                //    current URL is not a potentially trustworthy URL, then return no\n                //    referrer.\n                if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n                    return \"no-referrer\";\n                }\n                // 3. Return referrerOrigin.\n                return referrerOrigin;\n            }\n        case \"strict-origin\":\n        /**\n         * 1. If referrerURL is a potentially trustworthy URL and\n         * requests current URL is not a potentially trustworthy URL,\n         * then return no referrer.\n         * 2. Return referrerOrigin\n        */ case \"no-referrer-when-downgrade\":\n        /**\n       * 1. If referrerURL is a potentially trustworthy URL and\n       * requests current URL is not a potentially trustworthy URL,\n       * then return no referrer.\n       * 2. Return referrerOrigin\n      */ default:\n            return isNonPotentiallyTrustWorthy ? \"no-referrer\" : referrerOrigin;\n    }\n}\n/**\n * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url\n * @param {URL} url\n * @param {boolean|undefined} originOnly\n */ function stripURLForReferrer(url, originOnly) {\n    // 1. Assert: url is a URL.\n    assert(url instanceof URL);\n    // 2. If urls scheme is a local scheme, then return no referrer.\n    if (url.protocol === \"file:\" || url.protocol === \"about:\" || url.protocol === \"blank:\") {\n        return \"no-referrer\";\n    }\n    // 3. Set urls username to the empty string.\n    url.username = \"\";\n    // 4. Set urls password to the empty string.\n    url.password = \"\";\n    // 5. Set urls fragment to null.\n    url.hash = \"\";\n    // 6. If the origin-only flag is true, then:\n    if (originOnly) {\n        // 1. Set urls path to  the empty string .\n        url.pathname = \"\";\n        // 2. Set urls query to null.\n        url.search = \"\";\n    }\n    // 7. Return url.\n    return url;\n}\nfunction isURLPotentiallyTrustworthy(url) {\n    if (!(url instanceof URL)) {\n        return false;\n    }\n    // If child of about, return true\n    if (url.href === \"about:blank\" || url.href === \"about:srcdoc\") {\n        return true;\n    }\n    // If scheme is data, return true\n    if (url.protocol === \"data:\") return true;\n    // If file, return true\n    if (url.protocol === \"file:\") return true;\n    return isOriginPotentiallyTrustworthy(url.origin);\n    function isOriginPotentiallyTrustworthy(origin) {\n        // If origin is explicitly null, return false\n        if (origin == null || origin === \"null\") return false;\n        const originAsURL = new URL(origin);\n        // If secure, return true\n        if (originAsURL.protocol === \"https:\" || originAsURL.protocol === \"wss:\") {\n            return true;\n        }\n        // If localhost or variants, return true\n        if (/^127(?:\\.[0-9]+){0,2}\\.[0-9]+$|^\\[(?:0*:)*?:?0*1\\]$/.test(originAsURL.hostname) || originAsURL.hostname === \"localhost\" || originAsURL.hostname.includes(\"localhost.\") || originAsURL.hostname.endsWith(\".localhost\")) {\n            return true;\n        }\n        // If any other, return false\n        return false;\n    }\n}\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n */ function bytesMatch(bytes, metadataList) {\n    // If node is not built with OpenSSL support, we cannot check\n    // a request's integrity, so allow it by default (the spec will\n    // allow requests if an invalid hash is given, as precedence).\n    /* istanbul ignore if: only if node is built with --without-ssl */ if (crypto === undefined) {\n        return true;\n    }\n    // 1. Let parsedMetadata be the result of parsing metadataList.\n    const parsedMetadata = parseMetadata(metadataList);\n    // 2. If parsedMetadata is no metadata, return true.\n    if (parsedMetadata === \"no metadata\") {\n        return true;\n    }\n    // 3. If parsedMetadata is the empty set, return true.\n    if (parsedMetadata.length === 0) {\n        return true;\n    }\n    // 4. Let metadata be the result of getting the strongest\n    //    metadata from parsedMetadata.\n    const list = parsedMetadata.sort((c, d)=>d.algo.localeCompare(c.algo));\n    // get the strongest algorithm\n    const strongest = list[0].algo;\n    // get all entries that use the strongest algorithm; ignore weaker\n    const metadata = list.filter((item)=>item.algo === strongest);\n    // 5. For each item in metadata:\n    for (const item of metadata){\n        // 1. Let algorithm be the alg component of item.\n        const algorithm = item.algo;\n        // 2. Let expectedValue be the val component of item.\n        let expectedValue = item.hash;\n        // See https://github.com/web-platform-tests/wpt/commit/e4c5cc7a5e48093220528dfdd1c4012dc3837a0e\n        // \"be liberal with padding\". This is annoying, and it's not even in the spec.\n        if (expectedValue.endsWith(\"==\")) {\n            expectedValue = expectedValue.slice(0, -2);\n        }\n        // 3. Let actualValue be the result of applying algorithm to bytes.\n        let actualValue = crypto.createHash(algorithm).update(bytes).digest(\"base64\");\n        if (actualValue.endsWith(\"==\")) {\n            actualValue = actualValue.slice(0, -2);\n        }\n        // 4. If actualValue is a case-sensitive match for expectedValue,\n        //    return true.\n        if (actualValue === expectedValue) {\n            return true;\n        }\n        let actualBase64URL = crypto.createHash(algorithm).update(bytes).digest(\"base64url\");\n        if (actualBase64URL.endsWith(\"==\")) {\n            actualBase64URL = actualBase64URL.slice(0, -2);\n        }\n        if (actualBase64URL === expectedValue) {\n            return true;\n        }\n    }\n    // 6. Return false.\n    return false;\n}\n// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options\n// https://www.w3.org/TR/CSP2/#source-list-syntax\n// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\nconst parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={0,2}))( +[\\x21-\\x7e]?)?/i;\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n * @param {string} metadata\n */ function parseMetadata(metadata) {\n    // 1. Let result be the empty set.\n    /** @type {{ algo: string, hash: string }[]} */ const result = [];\n    // 2. Let empty be equal to true.\n    let empty = true;\n    const supportedHashes = crypto.getHashes();\n    // 3. For each token returned by splitting metadata on spaces:\n    for (const token of metadata.split(\" \")){\n        // 1. Set empty to false.\n        empty = false;\n        // 2. Parse token as a hash-with-options.\n        const parsedToken = parseHashWithOptions.exec(token);\n        // 3. If token does not parse, continue to the next token.\n        if (parsedToken === null || parsedToken.groups === undefined) {\n            continue;\n        }\n        // 4. Let algorithm be the hash-algo component of token.\n        const algorithm = parsedToken.groups.algo;\n        // 5. If algorithm is a hash function recognized by the user\n        //    agent, add the parsed token to result.\n        if (supportedHashes.includes(algorithm.toLowerCase())) {\n            result.push(parsedToken.groups);\n        }\n    }\n    // 4. Return no metadata if empty is true, otherwise return result.\n    if (empty === true) {\n        return \"no metadata\";\n    }\n    return result;\n}\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {\n// TODO\n}\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */ function sameOrigin(A, B) {\n    // 1. If A and B are the same opaque origin, then return true.\n    if (A.origin === B.origin && A.origin === \"null\") {\n        return true;\n    }\n    // 2. If A and B are both tuple origins and their schemes,\n    //    hosts, and port are identical, then return true.\n    if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n        return true;\n    }\n    // 3. Return false.\n    return false;\n}\nfunction createDeferredPromise() {\n    let res;\n    let rej;\n    const promise = new Promise((resolve, reject)=>{\n        res = resolve;\n        rej = reject;\n    });\n    return {\n        promise,\n        resolve: res,\n        reject: rej\n    };\n}\nfunction isAborted(fetchParams) {\n    return fetchParams.controller.state === \"aborted\";\n}\nfunction isCancelled(fetchParams) {\n    return fetchParams.controller.state === \"aborted\" || fetchParams.controller.state === \"terminated\";\n}\nconst normalizeMethodRecord = {\n    delete: \"DELETE\",\n    DELETE: \"DELETE\",\n    get: \"GET\",\n    GET: \"GET\",\n    head: \"HEAD\",\n    HEAD: \"HEAD\",\n    options: \"OPTIONS\",\n    OPTIONS: \"OPTIONS\",\n    post: \"POST\",\n    POST: \"POST\",\n    put: \"PUT\",\n    PUT: \"PUT\"\n};\n// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.\nObject.setPrototypeOf(normalizeMethodRecord, null);\n/**\n * @see https://fetch.spec.whatwg.org/#concept-method-normalize\n * @param {string} method\n */ function normalizeMethod(method) {\n    return normalizeMethodRecord[method.toLowerCase()] ?? method;\n}\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction serializeJavascriptValueToJSONString(value) {\n    // 1. Let result be ? Call(%JSON.stringify%, undefined,  value ).\n    const result = JSON.stringify(value);\n    // 2. If result is undefined, then throw a TypeError.\n    if (result === undefined) {\n        throw new TypeError(\"Value is not JSON serializable\");\n    }\n    // 3. Assert: result is a string.\n    assert(typeof result === \"string\");\n    // 4. Return result.\n    return result;\n}\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {() => unknown[]} iterator\n * @param {string} name name of the instance\n * @param {'key'|'value'|'key+value'} kind\n */ function makeIterator(iterator, name, kind) {\n    const object = {\n        index: 0,\n        kind,\n        target: iterator\n    };\n    const i = {\n        next () {\n            // 1. Let interface be the interface for which the iterator prototype object exists.\n            // 2. Let thisValue be the this value.\n            // 3. Let object be ? ToObject(thisValue).\n            // 4. If object is a platform object, then perform a security\n            //    check, passing:\n            // 5. If object is not a default iterator object for interface,\n            //    then throw a TypeError.\n            if (Object.getPrototypeOf(this) !== i) {\n                throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);\n            }\n            // 6. Let index be objects index.\n            // 7. Let kind be objects kind.\n            // 8. Let values be objects target's value pairs to iterate over.\n            const { index, kind, target } = object;\n            const values = target();\n            // 9. Let len be the length of values.\n            const len = values.length;\n            // 10. If index is greater than or equal to len, then return\n            //     CreateIterResultObject(undefined, true).\n            if (index >= len) {\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n            // 11. Let pair be the entry in values at index index.\n            const pair = values[index];\n            // 12. Set objects index to index + 1.\n            object.index = index + 1;\n            // 13. Return the iterator result for pair and kind.\n            return iteratorResult(pair, kind);\n        },\n        // The class string of an iterator prototype object for a given interface is the\n        // result of concatenating the identifier of the interface and the string \" Iterator\".\n        [Symbol.toStringTag]: `${name} Iterator`\n    };\n    // The [[Prototype]] internal slot of an iterator prototype object must be %IteratorPrototype%.\n    Object.setPrototypeOf(i, esIteratorPrototype);\n    // esIteratorPrototype needs to be the prototype of i\n    // which is the prototype of an empty object. Yes, it's confusing.\n    return Object.setPrototypeOf({}, i);\n}\n// https://webidl.spec.whatwg.org/#iterator-result\nfunction iteratorResult(pair, kind) {\n    let result;\n    // 1. Let result be a value determined by the value of kind:\n    switch(kind){\n        case \"key\":\n            {\n                // 1. Let idlKey be pairs key.\n                // 2. Let key be the result of converting idlKey to an\n                //    ECMAScript value.\n                // 3. result is key.\n                result = pair[0];\n                break;\n            }\n        case \"value\":\n            {\n                // 1. Let idlValue be pairs value.\n                // 2. Let value be the result of converting idlValue to\n                //    an ECMAScript value.\n                // 3. result is value.\n                result = pair[1];\n                break;\n            }\n        case \"key+value\":\n            {\n                // 1. Let idlKey be pairs key.\n                // 2. Let idlValue be pairs value.\n                // 3. Let key be the result of converting idlKey to an\n                //    ECMAScript value.\n                // 4. Let value be the result of converting idlValue to\n                //    an ECMAScript value.\n                // 5. Let array be ! ArrayCreate(2).\n                // 6. Call ! CreateDataProperty(array, \"0\", key).\n                // 7. Call ! CreateDataProperty(array, \"1\", value).\n                // 8. result is array.\n                result = pair;\n                break;\n            }\n    }\n    // 2. Return CreateIterResultObject(result, false).\n    return {\n        value: result,\n        done: false\n    };\n}\n/**\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */ async function fullyReadBody(body, processBody, processBodyError) {\n    // 1. If taskDestination is null, then set taskDestination to\n    //    the result of starting a new parallel queue.\n    // 2. Let successSteps given a byte sequence bytes be to queue a\n    //    fetch task to run processBody given bytes, with taskDestination.\n    const successSteps = processBody;\n    // 3. Let errorSteps be to queue a fetch task to run processBodyError,\n    //    with taskDestination.\n    const errorSteps = processBodyError;\n    // 4. Let reader be the result of getting a reader for bodys stream.\n    //    If that threw an exception, then run errorSteps with that\n    //    exception and return.\n    let reader;\n    try {\n        reader = body.stream.getReader();\n    } catch (e) {\n        errorSteps(e);\n        return;\n    }\n    // 5. Read all bytes from reader, given successSteps and errorSteps.\n    try {\n        const result = await readAllBytes(reader);\n        successSteps(result);\n    } catch (e) {\n        errorSteps(e);\n    }\n}\n/** @type {ReadableStream} */ let ReadableStream = globalThis.ReadableStream;\nfunction isReadableStreamLike(stream) {\n    if (!ReadableStream) {\n        ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n    }\n    return stream instanceof ReadableStream || stream[Symbol.toStringTag] === \"ReadableStream\" && typeof stream.tee === \"function\";\n}\nconst MAXIMUM_ARGUMENT_LENGTH = 65535;\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-decode\n * @param {number[]|Uint8Array} input\n */ function isomorphicDecode(input) {\n    // 1. To isomorphic decode a byte sequence input, return a string whose code point\n    //    length is equal to inputs length and whose code points have the same values\n    //    as the values of inputs bytes, in the same order.\n    if (input.length < MAXIMUM_ARGUMENT_LENGTH) {\n        return String.fromCharCode(...input);\n    }\n    return input.reduce((previous, current)=>previous + String.fromCharCode(current), \"\");\n}\n/**\n * @param {ReadableStreamController<Uint8Array>} controller\n */ function readableStreamClose(controller) {\n    try {\n        controller.close();\n    } catch (err) {\n        // TODO: add comment explaining why this error occurs.\n        if (!err.message.includes(\"Controller is already closed\")) {\n            throw err;\n        }\n    }\n}\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-encode\n * @param {string} input\n */ function isomorphicEncode(input) {\n    // 1. Assert: input contains no code points greater than U+00FF.\n    for(let i = 0; i < input.length; i++){\n        assert(input.charCodeAt(i) <= 0xFF);\n    }\n    // 2. Return a byte sequence whose length is equal to inputs code\n    //    point length and whose bytes have the same values as the\n    //    values of inputs code points, in the same order\n    return input;\n}\n/**\n * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes\n * @see https://streams.spec.whatwg.org/#read-loop\n * @param {ReadableStreamDefaultReader} reader\n */ async function readAllBytes(reader) {\n    const bytes = [];\n    let byteLength = 0;\n    while(true){\n        const { done, value: chunk } = await reader.read();\n        if (done) {\n            // 1. Call successSteps with bytes.\n            return Buffer.concat(bytes, byteLength);\n        }\n        // 1. If chunk is not a Uint8Array object, call failureSteps\n        //    with a TypeError and abort these steps.\n        if (!isUint8Array(chunk)) {\n            throw new TypeError(\"Received non-Uint8Array chunk\");\n        }\n        // 2. Append the bytes represented by chunk to bytes.\n        bytes.push(chunk);\n        byteLength += chunk.length;\n    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.\n    }\n}\n/**\n * @see https://fetch.spec.whatwg.org/#is-local\n * @param {URL} url\n */ function urlIsLocal(url) {\n    assert(\"protocol\" in url) // ensure it's a url object\n    ;\n    const protocol = url.protocol;\n    return protocol === \"about:\" || protocol === \"blob:\" || protocol === \"data:\";\n}\n/**\n * @param {string|URL} url\n */ function urlHasHttpsScheme(url) {\n    if (typeof url === \"string\") {\n        return url.startsWith(\"https:\");\n    }\n    return url.protocol === \"https:\";\n}\n/**\n * @see https://fetch.spec.whatwg.org/#http-scheme\n * @param {URL} url\n */ function urlIsHttpHttpsScheme(url) {\n    assert(\"protocol\" in url) // ensure it's a url object\n    ;\n    const protocol = url.protocol;\n    return protocol === \"http:\" || protocol === \"https:\";\n}\n/**\n * Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.\n */ const hasOwn = Object.hasOwn || ((dict, key)=>Object.prototype.hasOwnProperty.call(dict, key));\nmodule.exports = {\n    isAborted,\n    isCancelled,\n    createDeferredPromise,\n    ReadableStreamFrom,\n    toUSVString,\n    tryUpgradeRequestToAPotentiallyTrustworthyURL,\n    coarsenedSharedCurrentTime,\n    determineRequestsReferrer,\n    makePolicyContainer,\n    clonePolicyContainer,\n    appendFetchMetadata,\n    appendRequestOriginHeader,\n    TAOCheck,\n    corsCheck,\n    crossOriginResourcePolicyCheck,\n    createOpaqueTimingInfo,\n    setRequestReferrerPolicyOnRedirect,\n    isValidHTTPToken,\n    requestBadPort,\n    requestCurrentURL,\n    responseURL,\n    responseLocationURL,\n    isBlobLike,\n    isURLPotentiallyTrustworthy,\n    isValidReasonPhrase,\n    sameOrigin,\n    normalizeMethod,\n    serializeJavascriptValueToJSONString,\n    makeIterator,\n    isValidHeaderName,\n    isValidHeaderValue,\n    hasOwn,\n    isErrorLike,\n    fullyReadBody,\n    bytesMatch,\n    isReadableStreamLike,\n    readableStreamClose,\n    isomorphicEncode,\n    isomorphicDecode,\n    urlIsLocal,\n    urlHasHttpsScheme,\n    urlIsHttpHttpsScheme,\n    readAllBytes,\n    normalizeMethodRecord\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsaUJBQWlCLEVBQUVDLG1CQUFtQkMsb0JBQW9CLEVBQUVDLFdBQVcsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUM1RixNQUFNLEVBQUVDLGVBQWUsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUNwQyxNQUFNLEVBQUVFLFdBQVcsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUNoQyxNQUFNLEVBQUVHLFVBQVUsRUFBRUMsV0FBVyxFQUFFQyxrQkFBa0IsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUNoRSxNQUFNTSxTQUFTTixtQkFBT0EsQ0FBQztBQUN2QixNQUFNLEVBQUVPLFlBQVksRUFBRSxHQUFHUCxtQkFBT0EsQ0FBQztBQUVqQyxrRkFBa0Y7QUFDbEYsdUNBQXVDLEdBQ3ZDLElBQUlRO0FBRUosSUFBSTtJQUNGQSxTQUFTUixtQkFBT0EsQ0FBQztBQUNuQixFQUFFLE9BQU0sQ0FFUjtBQUVBLFNBQVNTLFlBQWFDLFFBQVE7SUFDNUIsMkNBQTJDO0lBQzNDLG9FQUFvRTtJQUNwRSxtRUFBbUU7SUFDbkUsTUFBTUMsVUFBVUQsU0FBU0MsT0FBTztJQUNoQyxNQUFNQyxTQUFTRCxRQUFRQyxNQUFNO0lBQzdCLE9BQU9BLFdBQVcsSUFBSSxPQUFPRCxPQUFPLENBQUNDLFNBQVMsRUFBRSxDQUFDQyxRQUFRO0FBQzNEO0FBRUEsK0RBQStEO0FBQy9ELFNBQVNDLG9CQUFxQkosUUFBUSxFQUFFSyxlQUFlO0lBQ3JELHNFQUFzRTtJQUN0RSxJQUFJLENBQUNuQixrQkFBa0JvQixHQUFHLENBQUNOLFNBQVNPLE1BQU0sR0FBRztRQUMzQyxPQUFPO0lBQ1Q7SUFFQSx1RUFBdUU7SUFDdkUseUNBQXlDO0lBQ3pDLElBQUlDLFdBQVdSLFNBQVNTLFdBQVcsQ0FBQ0MsR0FBRyxDQUFDO0lB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Q2ZqRjtJQUNBSTtJQUNBWDtJQUNBaEo7SUFDQUQ7SUFDQThJO0lBQ0ExRTtJQUNBbUI7SUFDQUg7SUFDQUM7SUFDQTlCO0lBQ0FLO0lBQ0FOO0lBQ0FEO0lBQ0FEO0lBQ0FtQjtJQUNBM0I7SUFDQVA7SUFDQWY7SUFDQUY7SUFDQWY7SUFDQUs7SUFDQVg7SUFDQWlHO0lBQ0FqRTtJQUNBb0M7SUFDQXdHO0lBQ0FDO0lBQ0FTO0lBQ0E5STtJQUNBdEI7SUFDQWlOO0lBQ0F4TTtJQUNBc0s7SUFDQW5GO0lBQ0FnRztJQUNBVTtJQUNBSTtJQUNBWDtJQUNBaUI7SUFDQS9KO0lBQ0ExQztJQUNBa0w7SUFDQTdDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC91dGlsLmpzP2E5NmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgcmVkaXJlY3RTdGF0dXNTZXQsIHJlZmVycmVyUG9saWN5U2V0OiByZWZlcnJlclBvbGljeVRva2VucywgYmFkUG9ydHNTZXQgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsgZ2V0R2xvYmFsT3JpZ2luIH0gPSByZXF1aXJlKCcuL2dsb2JhbCcpXG5jb25zdCB7IHBlcmZvcm1hbmNlIH0gPSByZXF1aXJlKCdwZXJmX2hvb2tzJylcbmNvbnN0IHsgaXNCbG9iTGlrZSwgdG9VU1ZTdHJpbmcsIFJlYWRhYmxlU3RyZWFtRnJvbSB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCB7IGlzVWludDhBcnJheSB9ID0gcmVxdWlyZSgndXRpbC90eXBlcycpXG5cbi8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvY3J5cHRvLmh0bWwjZGV0ZXJtaW5pbmctaWYtY3J5cHRvLXN1cHBvcnQtaXMtdW5hdmFpbGFibGVcbi8qKiBAdHlwZSB7aW1wb3J0KCdjcnlwdG8nKXx1bmRlZmluZWR9ICovXG5sZXQgY3J5cHRvXG5cbnRyeSB7XG4gIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpXG59IGNhdGNoIHtcblxufVxuXG5mdW5jdGlvbiByZXNwb25zZVVSTCAocmVzcG9uc2UpIHtcbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3Jlc3BvbnNlc1xuICAvLyBBIHJlc3BvbnNlIGhhcyBhbiBhc3NvY2lhdGVkIFVSTC4gSXQgaXMgYSBwb2ludGVyIHRvIHRoZSBsYXN0IFVSTFxuICAvLyBpbiByZXNwb25zZeKAmXMgVVJMIGxpc3QgYW5kIG51bGwgaWYgcmVzcG9uc2XigJlzIFVSTCBsaXN0IGlzIGVtcHR5LlxuICBjb25zdCB1cmxMaXN0ID0gcmVzcG9uc2UudXJsTGlzdFxuICBjb25zdCBsZW5ndGggPSB1cmxMaXN0Lmxlbmd0aFxuICByZXR1cm4gbGVuZ3RoID09PSAwID8gbnVsbCA6IHVybExpc3RbbGVuZ3RoIC0gMV0udG9TdHJpbmcoKVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1yZXNwb25zZS1sb2NhdGlvbi11cmxcbmZ1bmN0aW9uIHJlc3BvbnNlTG9jYXRpb25VUkwgKHJlc3BvbnNlLCByZXF1ZXN0RnJhZ21lbnQpIHtcbiAgLy8gMS4gSWYgcmVzcG9uc2XigJlzIHN0YXR1cyBpcyBub3QgYSByZWRpcmVjdCBzdGF0dXMsIHRoZW4gcmV0dXJuIG51bGwuXG4gIGlmICghcmVkaXJlY3RTdGF0dXNTZXQuaGFzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gMi4gTGV0IGxvY2F0aW9uIGJlIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBoZWFkZXIgbGlzdCB2YWx1ZXMgZ2l2ZW5cbiAgLy8gYExvY2F0aW9uYCBhbmQgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICBsZXQgbG9jYXRpb24gPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ2xvY2F0aW9uJylcblxuICAvLyAzLiBJZiBsb2NhdGlvbiBpcyBhIGhlYWRlciB2YWx1ZSwgdGhlbiBzZXQgbG9jYXRpb24gdG8gdGhlIHJlc3VsdCBvZlxuICAvLyAgICBwYXJzaW5nIGxvY2F0aW9uIHdpdGggcmVzcG9uc2XigJlzIFVSTC5cbiAgaWYgKGxvY2F0aW9uICE9PSBudWxsICYmIGlzVmFsaWRIZWFkZXJWYWx1ZShsb2NhdGlvbikpIHtcbiAgICBsb2NhdGlvbiA9IG5ldyBVUkwobG9jYXRpb24sIHJlc3BvbnNlVVJMKHJlc3BvbnNlKSlcbiAgfVxuXG4gIC8vIDQuIElmIGxvY2F0aW9uIGlzIGEgVVJMIHdob3NlIGZyYWdtZW50IGlzIG51bGwsIHRoZW4gc2V0IGxvY2F0aW9u4oCZc1xuICAvLyBmcmFnbWVudCB0byByZXF1ZXN0RnJhZ21lbnQuXG4gIGlmIChsb2NhdGlvbiAmJiAhbG9jYXRpb24uaGFzaCkge1xuICAgIGxvY2F0aW9uLmhhc2ggPSByZXF1ZXN0RnJhZ21lbnRcbiAgfVxuXG4gIC8vIDUuIFJldHVybiBsb2NhdGlvbi5cbiAgcmV0dXJuIGxvY2F0aW9uXG59XG5cbi8qKiBAcmV0dXJucyB7VVJMfSAqL1xuZnVuY3Rpb24gcmVxdWVzdEN1cnJlbnRVUkwgKHJlcXVlc3QpIHtcbiAgcmV0dXJuIHJlcXVlc3QudXJsTGlzdFtyZXF1ZXN0LnVybExpc3QubGVuZ3RoIC0gMV1cbn1cblxuZnVuY3Rpb24gcmVxdWVzdEJhZFBvcnQgKHJlcXVlc3QpIHtcbiAgLy8gMS4gTGV0IHVybCBiZSByZXF1ZXN04oCZcyBjdXJyZW50IFVSTC5cbiAgY29uc3QgdXJsID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcblxuICAvLyAyLiBJZiB1cmzigJlzIHNjaGVtZSBpcyBhbiBIVFRQKFMpIHNjaGVtZSBhbmQgdXJs4oCZcyBwb3J0IGlzIGEgYmFkIHBvcnQsXG4gIC8vIHRoZW4gcmV0dXJuIGJsb2NrZWQuXG4gIGlmICh1cmxJc0h0dHBIdHRwc1NjaGVtZSh1cmwpICYmIGJhZFBvcnRzU2V0Lmhhcyh1cmwucG9ydCkpIHtcbiAgICByZXR1cm4gJ2Jsb2NrZWQnXG4gIH1cblxuICAvLyAzLiBSZXR1cm4gYWxsb3dlZC5cbiAgcmV0dXJuICdhbGxvd2VkJ1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yTGlrZSAob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBFcnJvciB8fCAoXG4gICAgb2JqZWN0Py5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ0Vycm9yJyB8fFxuICAgIG9iamVjdD8uY29uc3RydWN0b3I/Lm5hbWUgPT09ICdET01FeGNlcHRpb24nXG4gIClcbn1cblxuLy8gQ2hlY2sgd2hldGhlciB8c3RhdHVzVGV4dHwgaXMgYSBCeXRlU3RyaW5nIGFuZFxuLy8gbWF0Y2hlcyB0aGUgUmVhc29uLVBocmFzZSB0b2tlbiBwcm9kdWN0aW9uLlxuLy8gUkZDIDI2MTY6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyNjE2XG4vLyBSRkMgNzIzMDogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzBcbi8vIFwicmVhc29uLXBocmFzZSA9ICooIEhUQUIgLyBTUCAvIFZDSEFSIC8gb2JzLXRleHQgKVwiXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY2hyb21pdW0vY2hyb21pdW0vYmxvYi85NC4wLjQ2MDQuMS90aGlyZF9wYXJ0eS9ibGluay9yZW5kZXJlci9jb3JlL2ZldGNoL3Jlc3BvbnNlLmNjI0wxMTZcbmZ1bmN0aW9uIGlzVmFsaWRSZWFzb25QaHJhc2UgKHN0YXR1c1RleHQpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0dXNUZXh0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgYyA9IHN0YXR1c1RleHQuY2hhckNvZGVBdChpKVxuICAgIGlmIChcbiAgICAgICEoXG4gICAgICAgIChcbiAgICAgICAgICBjID09PSAweDA5IHx8IC8vIEhUQUJcbiAgICAgICAgICAoYyA+PSAweDIwICYmIGMgPD0gMHg3ZSkgfHwgLy8gU1AgLyBWQ0hBUlxuICAgICAgICAgIChjID49IDB4ODAgJiYgYyA8PSAweGZmKVxuICAgICAgICApIC8vIG9icy10ZXh0XG4gICAgICApXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4yLjZcbiAqIEBwYXJhbSB7bnVtYmVyfSBjXG4gKi9cbmZ1bmN0aW9uIGlzVG9rZW5DaGFyQ29kZSAoYykge1xuICBzd2l0Y2ggKGMpIHtcbiAgICBjYXNlIDB4MjI6XG4gICAgY2FzZSAweDI4OlxuICAgIGNhc2UgMHgyOTpcbiAgICBjYXNlIDB4MmM6XG4gICAgY2FzZSAweDJmOlxuICAgIGNhc2UgMHgzYTpcbiAgICBjYXNlIDB4M2I6XG4gICAgY2FzZSAweDNjOlxuICAgIGNhc2UgMHgzZDpcbiAgICBjYXNlIDB4M2U6XG4gICAgY2FzZSAweDNmOlxuICAgIGNhc2UgMHg0MDpcbiAgICBjYXNlIDB4NWI6XG4gICAgY2FzZSAweDVjOlxuICAgIGNhc2UgMHg1ZDpcbiAgICBjYXNlIDB4N2I6XG4gICAgY2FzZSAweDdkOlxuICAgICAgLy8gRFFVT1RFIGFuZCBcIigpLC86Ozw9Pj9AW1xcXXt9XCJcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBWQ0hBUiAleDIxLTdFXG4gICAgICByZXR1cm4gYyA+PSAweDIxICYmIGMgPD0gMHg3ZVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNoYXJhY3RlcnNcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEhUVFBUb2tlbiAoY2hhcmFjdGVycykge1xuICBpZiAoY2hhcmFjdGVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJhY3RlcnMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoIWlzVG9rZW5DaGFyQ29kZShjaGFyYWN0ZXJzLmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNoZWFkZXItbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHBvdGVudGlhbFZhbHVlXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRIZWFkZXJOYW1lIChwb3RlbnRpYWxWYWx1ZSkge1xuICByZXR1cm4gaXNWYWxpZEhUVFBUb2tlbihwb3RlbnRpYWxWYWx1ZSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNoZWFkZXItdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwb3RlbnRpYWxWYWx1ZVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkSGVhZGVyVmFsdWUgKHBvdGVudGlhbFZhbHVlKSB7XG4gIC8vIC0gSGFzIG5vIGxlYWRpbmcgb3IgdHJhaWxpbmcgSFRUUCB0YWIgb3Igc3BhY2UgYnl0ZXMuXG4gIC8vIC0gQ29udGFpbnMgbm8gMHgwMCAoTlVMKSBvciBIVFRQIG5ld2xpbmUgYnl0ZXMuXG4gIGlmIChcbiAgICBwb3RlbnRpYWxWYWx1ZS5zdGFydHNXaXRoKCdcXHQnKSB8fFxuICAgIHBvdGVudGlhbFZhbHVlLnN0YXJ0c1dpdGgoJyAnKSB8fFxuICAgIHBvdGVudGlhbFZhbHVlLmVuZHNXaXRoKCdcXHQnKSB8fFxuICAgIHBvdGVudGlhbFZhbHVlLmVuZHNXaXRoKCcgJylcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoXG4gICAgcG90ZW50aWFsVmFsdWUuaW5jbHVkZXMoJ1xcMCcpIHx8XG4gICAgcG90ZW50aWFsVmFsdWUuaW5jbHVkZXMoJ1xccicpIHx8XG4gICAgcG90ZW50aWFsVmFsdWUuaW5jbHVkZXMoJ1xcbicpXG4gICkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI3NldC1yZXF1ZXN0cy1yZWZlcnJlci1wb2xpY3ktb24tcmVkaXJlY3RcbmZ1bmN0aW9uIHNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3QgKHJlcXVlc3QsIGFjdHVhbFJlc3BvbnNlKSB7XG4gIC8vICBHaXZlbiBhIHJlcXVlc3QgcmVxdWVzdCBhbmQgYSByZXNwb25zZSBhY3R1YWxSZXNwb25zZSwgdGhpcyBhbGdvcml0aG1cbiAgLy8gIHVwZGF0ZXMgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5IGFjY29yZGluZyB0byB0aGUgUmVmZXJyZXItUG9saWN5XG4gIC8vICBoZWFkZXIgKGlmIGFueSkgaW4gYWN0dWFsUmVzcG9uc2UuXG5cbiAgLy8gMS4gTGV0IHBvbGljeSBiZSB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyDCpyA4LjEgUGFyc2UgYSByZWZlcnJlciBwb2xpY3lcbiAgLy8gZnJvbSBhIFJlZmVycmVyLVBvbGljeSBoZWFkZXIgb24gYWN0dWFsUmVzcG9uc2UuXG5cbiAgLy8gOC4xIFBhcnNlIGEgcmVmZXJyZXIgcG9saWN5IGZyb20gYSBSZWZlcnJlci1Qb2xpY3kgaGVhZGVyXG4gIC8vIDEuIExldCBwb2xpY3ktdG9rZW5zIGJlIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBoZWFkZXIgbGlzdCB2YWx1ZXMgZ2l2ZW4gYFJlZmVycmVyLVBvbGljeWAgYW5kIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cbiAgY29uc3QgeyBoZWFkZXJzTGlzdCB9ID0gYWN0dWFsUmVzcG9uc2VcbiAgLy8gMi4gTGV0IHBvbGljeSBiZSB0aGUgZW1wdHkgc3RyaW5nLlxuICAvLyAzLiBGb3IgZWFjaCB0b2tlbiBpbiBwb2xpY3ktdG9rZW5zLCBpZiB0b2tlbiBpcyBhIHJlZmVycmVyIHBvbGljeSBhbmQgdG9rZW4gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gc2V0IHBvbGljeSB0byB0b2tlbi5cbiAgLy8gNC4gUmV0dXJuIHBvbGljeS5cbiAgY29uc3QgcG9saWN5SGVhZGVyID0gKGhlYWRlcnNMaXN0LmdldCgncmVmZXJyZXItcG9saWN5JykgPz8gJycpLnNwbGl0KCcsJylcblxuICAvLyBOb3RlOiBBcyB0aGUgcmVmZXJyZXItcG9saWN5IGNhbiBjb250YWluIG11bHRpcGxlIHBvbGljaWVzXG4gIC8vIHNlcGFyYXRlZCBieSBjb21tYSwgd2UgbmVlZCB0byBsb29wIHRocm91Z2ggYWxsIG9mIHRoZW1cbiAgLy8gYW5kIHBpY2sgdGhlIGZpcnN0IHZhbGlkIG9uZS5cbiAgLy8gUmVmOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvUmVmZXJyZXItUG9saWN5I3NwZWNpZnlfYV9mYWxsYmFja19wb2xpY3lcbiAgbGV0IHBvbGljeSA9ICcnXG4gIGlmIChwb2xpY3lIZWFkZXIubGVuZ3RoID4gMCkge1xuICAgIC8vIFRoZSByaWdodC1tb3N0IHBvbGljeSB0YWtlcyBwcmVjZWRlbmNlLlxuICAgIC8vIFRoZSBsZWZ0LW1vc3QgcG9saWN5IGlzIHRoZSBmYWxsYmFjay5cbiAgICBmb3IgKGxldCBpID0gcG9saWN5SGVhZGVyLmxlbmd0aDsgaSAhPT0gMDsgaS0tKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHBvbGljeUhlYWRlcltpIC0gMV0udHJpbSgpXG4gICAgICBpZiAocmVmZXJyZXJQb2xpY3lUb2tlbnMuaGFzKHRva2VuKSkge1xuICAgICAgICBwb2xpY3kgPSB0b2tlblxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIDIuIElmIHBvbGljeSBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBzZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5IHRvIHBvbGljeS5cbiAgaWYgKHBvbGljeSAhPT0gJycpIHtcbiAgICByZXF1ZXN0LnJlZmVycmVyUG9saWN5ID0gcG9saWN5XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2Nyb3NzLW9yaWdpbi1yZXNvdXJjZS1wb2xpY3ktY2hlY2tcbmZ1bmN0aW9uIGNyb3NzT3JpZ2luUmVzb3VyY2VQb2xpY3lDaGVjayAoKSB7XG4gIC8vIFRPRE9cbiAgcmV0dXJuICdhbGxvd2VkJ1xufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1jb3JzLWNoZWNrXG5mdW5jdGlvbiBjb3JzQ2hlY2sgKCkge1xuICAvLyBUT0RPXG4gIHJldHVybiAnc3VjY2Vzcydcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtdGFvLWNoZWNrXG5mdW5jdGlvbiBUQU9DaGVjayAoKSB7XG4gIC8vIFRPRE9cbiAgcmV0dXJuICdzdWNjZXNzJ1xufVxuXG5mdW5jdGlvbiBhcHBlbmRGZXRjaE1ldGFkYXRhIChodHRwUmVxdWVzdCkge1xuICAvLyAgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1mZXRjaC1tZXRhZGF0YS8jc2VjLWZldGNoLWRlc3QtaGVhZGVyXG4gIC8vICBUT0RPXG5cbiAgLy8gIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtZmV0Y2gtbWV0YWRhdGEvI3NlYy1mZXRjaC1tb2RlLWhlYWRlclxuXG4gIC8vICAxLiBBc3NlcnQ6IHLigJlzIHVybCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTC5cbiAgLy8gIFRPRE9cblxuICAvLyAgMi4gTGV0IGhlYWRlciBiZSBhIFN0cnVjdHVyZWQgSGVhZGVyIHdob3NlIHZhbHVlIGlzIGEgdG9rZW4uXG4gIGxldCBoZWFkZXIgPSBudWxsXG5cbiAgLy8gIDMuIFNldCBoZWFkZXLigJlzIHZhbHVlIHRvIHLigJlzIG1vZGUuXG4gIGhlYWRlciA9IGh0dHBSZXF1ZXN0Lm1vZGVcblxuICAvLyAgNC4gU2V0IGEgc3RydWN0dXJlZCBmaWVsZCB2YWx1ZSBgU2VjLUZldGNoLU1vZGVgL2hlYWRlciBpbiBy4oCZcyBoZWFkZXIgbGlzdC5cbiAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3Quc2V0KCdzZWMtZmV0Y2gtbW9kZScsIGhlYWRlcilcblxuICAvLyAgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1mZXRjaC1tZXRhZGF0YS8jc2VjLWZldGNoLXNpdGUtaGVhZGVyXG4gIC8vICBUT0RPXG5cbiAgLy8gIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtZmV0Y2gtbWV0YWRhdGEvI3NlYy1mZXRjaC11c2VyLWhlYWRlclxuICAvLyAgVE9ET1xufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYXBwZW5kLWEtcmVxdWVzdC1vcmlnaW4taGVhZGVyXG5mdW5jdGlvbiBhcHBlbmRSZXF1ZXN0T3JpZ2luSGVhZGVyIChyZXF1ZXN0KSB7XG4gIC8vIDEuIExldCBzZXJpYWxpemVkT3JpZ2luIGJlIHRoZSByZXN1bHQgb2YgYnl0ZS1zZXJpYWxpemluZyBhIHJlcXVlc3Qgb3JpZ2luIHdpdGggcmVxdWVzdC5cbiAgbGV0IHNlcmlhbGl6ZWRPcmlnaW4gPSByZXF1ZXN0Lm9yaWdpblxuXG4gIC8vIDIuIElmIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIFwiY29yc1wiIG9yIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJ3ZWJzb2NrZXRcIiwgdGhlbiBhcHBlbmQgKGBPcmlnaW5gLCBzZXJpYWxpemVkT3JpZ2luKSB0byByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgaWYgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2NvcnMnIHx8IHJlcXVlc3QubW9kZSA9PT0gJ3dlYnNvY2tldCcpIHtcbiAgICBpZiAoc2VyaWFsaXplZE9yaWdpbikge1xuICAgICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ29yaWdpbicsIHNlcmlhbGl6ZWRPcmlnaW4pXG4gICAgfVxuXG4gIC8vIDMuIE90aGVyd2lzZSwgaWYgcmVxdWVzdOKAmXMgbWV0aG9kIGlzIG5laXRoZXIgYEdFVGAgbm9yIGBIRUFEYCwgdGhlbjpcbiAgfSBlbHNlIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gJ0dFVCcgJiYgcmVxdWVzdC5tZXRob2QgIT09ICdIRUFEJykge1xuICAgIC8vIDEuIFN3aXRjaCBvbiByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3k6XG4gICAgc3dpdGNoIChyZXF1ZXN0LnJlZmVycmVyUG9saWN5KSB7XG4gICAgICBjYXNlICduby1yZWZlcnJlcic6XG4gICAgICAgIC8vIFNldCBzZXJpYWxpemVkT3JpZ2luIHRvIGBudWxsYC5cbiAgICAgICAgc2VyaWFsaXplZE9yaWdpbiA9IG51bGxcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ25vLXJlZmVycmVyLXdoZW4tZG93bmdyYWRlJzpcbiAgICAgIGNhc2UgJ3N0cmljdC1vcmlnaW4nOlxuICAgICAgY2FzZSAnc3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpbic6XG4gICAgICAgIC8vIElmIHJlcXVlc3TigJlzIG9yaWdpbiBpcyBhIHR1cGxlIG9yaWdpbiwgaXRzIHNjaGVtZSBpcyBcImh0dHBzXCIsIGFuZCByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgc2NoZW1lIGlzIG5vdCBcImh0dHBzXCIsIHRoZW4gc2V0IHNlcmlhbGl6ZWRPcmlnaW4gdG8gYG51bGxgLlxuICAgICAgICBpZiAocmVxdWVzdC5vcmlnaW4gJiYgdXJsSGFzSHR0cHNTY2hlbWUocmVxdWVzdC5vcmlnaW4pICYmICF1cmxIYXNIdHRwc1NjaGVtZShyZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KSkpIHtcbiAgICAgICAgICBzZXJpYWxpemVkT3JpZ2luID0gbnVsbFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzYW1lLW9yaWdpbic6XG4gICAgICAgIC8vIElmIHJlcXVlc3TigJlzIG9yaWdpbiBpcyBub3Qgc2FtZSBvcmlnaW4gd2l0aCByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgb3JpZ2luLCB0aGVuIHNldCBzZXJpYWxpemVkT3JpZ2luIHRvIGBudWxsYC5cbiAgICAgICAgaWYgKCFzYW1lT3JpZ2luKHJlcXVlc3QsIHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpKSkge1xuICAgICAgICAgIHNlcmlhbGl6ZWRPcmlnaW4gPSBudWxsXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgfVxuXG4gICAgaWYgKHNlcmlhbGl6ZWRPcmlnaW4pIHtcbiAgICAgIC8vIDIuIEFwcGVuZCAoYE9yaWdpbmAsIHNlcmlhbGl6ZWRPcmlnaW4pIHRvIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAgICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ29yaWdpbicsIHNlcmlhbGl6ZWRPcmlnaW4pXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lIChjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSkge1xuICAvLyBUT0RPXG4gIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY3JlYXRlLWFuLW9wYXF1ZS10aW1pbmctaW5mb1xuZnVuY3Rpb24gY3JlYXRlT3BhcXVlVGltaW5nSW5mbyAodGltaW5nSW5mbykge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0VGltZTogdGltaW5nSW5mby5zdGFydFRpbWUgPz8gMCxcbiAgICByZWRpcmVjdFN0YXJ0VGltZTogMCxcbiAgICByZWRpcmVjdEVuZFRpbWU6IDAsXG4gICAgcG9zdFJlZGlyZWN0U3RhcnRUaW1lOiB0aW1pbmdJbmZvLnN0YXJ0VGltZSA/PyAwLFxuICAgIGZpbmFsU2VydmljZVdvcmtlclN0YXJ0VGltZTogMCxcbiAgICBmaW5hbE5ldHdvcmtSZXNwb25zZVN0YXJ0VGltZTogMCxcbiAgICBmaW5hbE5ldHdvcmtSZXF1ZXN0U3RhcnRUaW1lOiAwLFxuICAgIGVuZFRpbWU6IDAsXG4gICAgZW5jb2RlZEJvZHlTaXplOiAwLFxuICAgIGRlY29kZWRCb2R5U2l6ZTogMCxcbiAgICBmaW5hbENvbm5lY3Rpb25UaW1pbmdJbmZvOiBudWxsXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvb3JpZ2luLmh0bWwjcG9saWN5LWNvbnRhaW5lclxuZnVuY3Rpb24gbWFrZVBvbGljeUNvbnRhaW5lciAoKSB7XG4gIC8vIE5vdGU6IHRoZSBmZXRjaCBzcGVjIGRvZXNuJ3QgbWFrZSB1c2Ugb2YgZW1iZWRkZXIgcG9saWN5IG9yIENTUCBsaXN0XG4gIHJldHVybiB7XG4gICAgcmVmZXJyZXJQb2xpY3k6ICdzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJ1xuICB9XG59XG5cbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL29yaWdpbi5odG1sI2Nsb25lLWEtcG9saWN5LWNvbnRhaW5lclxuZnVuY3Rpb24gY2xvbmVQb2xpY3lDb250YWluZXIgKHBvbGljeUNvbnRhaW5lcikge1xuICByZXR1cm4ge1xuICAgIHJlZmVycmVyUG9saWN5OiBwb2xpY3lDb250YWluZXIucmVmZXJyZXJQb2xpY3lcbiAgfVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jZGV0ZXJtaW5lLXJlcXVlc3RzLXJlZmVycmVyXG5mdW5jdGlvbiBkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyIChyZXF1ZXN0KSB7XG4gIC8vIDEuIExldCBwb2xpY3kgYmUgcmVxdWVzdCdzIHJlZmVycmVyIHBvbGljeS5cbiAgY29uc3QgcG9saWN5ID0gcmVxdWVzdC5yZWZlcnJlclBvbGljeVxuXG4gIC8vIE5vdGU6IHBvbGljeSBjYW5ub3QgKHNob3VsZG4ndCkgYmUgbnVsbCBvciBhbiBlbXB0eSBzdHJpbmcuXG4gIGFzc2VydChwb2xpY3kpXG5cbiAgLy8gMi4gTGV0IGVudmlyb25tZW50IGJlIHJlcXVlc3TigJlzIGNsaWVudC5cblxuICBsZXQgcmVmZXJyZXJTb3VyY2UgPSBudWxsXG5cbiAgLy8gMy4gU3dpdGNoIG9uIHJlcXVlc3TigJlzIHJlZmVycmVyOlxuICBpZiAocmVxdWVzdC5yZWZlcnJlciA9PT0gJ2NsaWVudCcpIHtcbiAgICAvLyBOb3RlOiBub2RlIGlzbid0IGEgYnJvd3NlciBhbmQgZG9lc24ndCBpbXBsZW1lbnQgZG9jdW1lbnQvaWZyYW1lcyxcbiAgICAvLyBzbyB3ZSBieXBhc3MgdGhpcyBzdGVwIGFuZCByZXBsYWNlIGl0IHdpdGggb3VyIG93bi5cblxuICAgIGNvbnN0IGdsb2JhbE9yaWdpbiA9IGdldEdsb2JhbE9yaWdpbigpXG5cbiAgICBpZiAoIWdsb2JhbE9yaWdpbiB8fCBnbG9iYWxPcmlnaW4ub3JpZ2luID09PSAnbnVsbCcpIHtcbiAgICAgIHJldHVybiAnbm8tcmVmZXJyZXInXG4gICAgfVxuXG4gICAgLy8gbm90ZTogd2UgbmVlZCB0byBjbG9uZSBpdCBhcyBpdCdzIG11dGF0ZWRcbiAgICByZWZlcnJlclNvdXJjZSA9IG5ldyBVUkwoZ2xvYmFsT3JpZ2luKVxuICB9IGVsc2UgaWYgKHJlcXVlc3QucmVmZXJyZXIgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAvLyBMZXQgcmVmZXJyZXJTb3VyY2UgYmUgcmVxdWVzdOKAmXMgcmVmZXJyZXIuXG4gICAgcmVmZXJyZXJTb3VyY2UgPSByZXF1ZXN0LnJlZmVycmVyXG4gIH1cblxuICAvLyA0LiBMZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXJVUkwgYmUgdGhlIHJlc3VsdCBvZiBzdHJpcHBpbmcgcmVmZXJyZXJTb3VyY2UgZm9yXG4gIC8vICAgIHVzZSBhcyBhIHJlZmVycmVyLlxuICBsZXQgcmVmZXJyZXJVUkwgPSBzdHJpcFVSTEZvclJlZmVycmVyKHJlZmVycmVyU291cmNlKVxuXG4gIC8vIDUuIExldCByZWZlcnJlck9yaWdpbiBiZSB0aGUgcmVzdWx0IG9mIHN0cmlwcGluZyByZWZlcnJlclNvdXJjZSBmb3IgdXNlIGFzXG4gIC8vICAgIGEgcmVmZXJyZXIsIHdpdGggdGhlIG9yaWdpbi1vbmx5IGZsYWcgc2V0IHRvIHRydWUuXG4gIGNvbnN0IHJlZmVycmVyT3JpZ2luID0gc3RyaXBVUkxGb3JSZWZlcnJlcihyZWZlcnJlclNvdXJjZSwgdHJ1ZSlcblxuICAvLyA2LiBJZiB0aGUgcmVzdWx0IG9mIHNlcmlhbGl6aW5nIHJlZmVycmVyVVJMIGlzIGEgc3RyaW5nIHdob3NlIGxlbmd0aCBpc1xuICAvLyAgICBncmVhdGVyIHRoYW4gNDA5Niwgc2V0IHJlZmVycmVyVVJMIHRvIHJlZmVycmVyT3JpZ2luLlxuICBpZiAocmVmZXJyZXJVUkwudG9TdHJpbmcoKS5sZW5ndGggPiA0MDk2KSB7XG4gICAgcmVmZXJyZXJVUkwgPSByZWZlcnJlck9yaWdpblxuICB9XG5cbiAgY29uc3QgYXJlU2FtZU9yaWdpbiA9IHNhbWVPcmlnaW4ocmVxdWVzdCwgcmVmZXJyZXJVUkwpXG4gIGNvbnN0IGlzTm9uUG90ZW50aWFsbHlUcnVzdFdvcnRoeSA9IGlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZWZlcnJlclVSTCkgJiZcbiAgICAhaXNVUkxQb3RlbnRpYWxseVRydXN0d29ydGh5KHJlcXVlc3QudXJsKVxuXG4gIC8vIDguIEV4ZWN1dGUgdGhlIHN3aXRjaCBzdGF0ZW1lbnRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHZhbHVlIG9mIHBvbGljeTpcbiAgc3dpdGNoIChwb2xpY3kpIHtcbiAgICBjYXNlICdvcmlnaW4nOiByZXR1cm4gcmVmZXJyZXJPcmlnaW4gIT0gbnVsbCA/IHJlZmVycmVyT3JpZ2luIDogc3RyaXBVUkxGb3JSZWZlcnJlcihyZWZlcnJlclNvdXJjZSwgdHJ1ZSlcbiAgICBjYXNlICd1bnNhZmUtdXJsJzogcmV0dXJuIHJlZmVycmVyVVJMXG4gICAgY2FzZSAnc2FtZS1vcmlnaW4nOlxuICAgICAgcmV0dXJuIGFyZVNhbWVPcmlnaW4gPyByZWZlcnJlck9yaWdpbiA6ICduby1yZWZlcnJlcidcbiAgICBjYXNlICdvcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nOlxuICAgICAgcmV0dXJuIGFyZVNhbWVPcmlnaW4gPyByZWZlcnJlclVSTCA6IHJlZmVycmVyT3JpZ2luXG4gICAgY2FzZSAnc3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpbic6IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRVUkwgPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuXG4gICAgICAvLyAxLiBJZiB0aGUgb3JpZ2luIG9mIHJlZmVycmVyVVJMIGFuZCB0aGUgb3JpZ2luIG9mIHJlcXVlc3TigJlzIGN1cnJlbnRcbiAgICAgIC8vICAgIFVSTCBhcmUgdGhlIHNhbWUsIHRoZW4gcmV0dXJuIHJlZmVycmVyVVJMLlxuICAgICAgaWYgKHNhbWVPcmlnaW4ocmVmZXJyZXJVUkwsIGN1cnJlbnRVUkwpKSB7XG4gICAgICAgIHJldHVybiByZWZlcnJlclVSTFxuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmQgcmVxdWVzdOKAmXNcbiAgICAgIC8vICAgIGN1cnJlbnQgVVJMIGlzIG5vdCBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCwgdGhlbiByZXR1cm4gbm9cbiAgICAgIC8vICAgIHJlZmVycmVyLlxuICAgICAgaWYgKGlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZWZlcnJlclVSTCkgJiYgIWlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeShjdXJyZW50VVJMKSkge1xuICAgICAgICByZXR1cm4gJ25vLXJlZmVycmVyJ1xuICAgICAgfVxuXG4gICAgICAvLyAzLiBSZXR1cm4gcmVmZXJyZXJPcmlnaW4uXG4gICAgICByZXR1cm4gcmVmZXJyZXJPcmlnaW5cbiAgICB9XG4gICAgY2FzZSAnc3RyaWN0LW9yaWdpbic6IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIC8qKlxuICAgICAgICAgKiAxLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmRcbiAgICAgICAgICogcmVxdWVzdOKAmXMgY3VycmVudCBVUkwgaXMgbm90IGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLFxuICAgICAgICAgKiB0aGVuIHJldHVybiBubyByZWZlcnJlci5cbiAgICAgICAgICogMi4gUmV0dXJuIHJlZmVycmVyT3JpZ2luXG4gICAgICAgICovXG4gICAgY2FzZSAnbm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGUnOiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAvKipcbiAgICAgICAqIDEuIElmIHJlZmVycmVyVVJMIGlzIGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMIGFuZFxuICAgICAgICogcmVxdWVzdOKAmXMgY3VycmVudCBVUkwgaXMgbm90IGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLFxuICAgICAgICogdGhlbiByZXR1cm4gbm8gcmVmZXJyZXIuXG4gICAgICAgKiAyLiBSZXR1cm4gcmVmZXJyZXJPcmlnaW5cbiAgICAgICovXG5cbiAgICBkZWZhdWx0OiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICByZXR1cm4gaXNOb25Qb3RlbnRpYWxseVRydXN0V29ydGh5ID8gJ25vLXJlZmVycmVyJyA6IHJlZmVycmVyT3JpZ2luXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNzdHJpcC11cmxcbiAqIEBwYXJhbSB7VVJMfSB1cmxcbiAqIEBwYXJhbSB7Ym9vbGVhbnx1bmRlZmluZWR9IG9yaWdpbk9ubHlcbiAqL1xuZnVuY3Rpb24gc3RyaXBVUkxGb3JSZWZlcnJlciAodXJsLCBvcmlnaW5Pbmx5KSB7XG4gIC8vIDEuIEFzc2VydDogdXJsIGlzIGEgVVJMLlxuICBhc3NlcnQodXJsIGluc3RhbmNlb2YgVVJMKVxuXG4gIC8vIDIuIElmIHVybOKAmXMgc2NoZW1lIGlzIGEgbG9jYWwgc2NoZW1lLCB0aGVuIHJldHVybiBubyByZWZlcnJlci5cbiAgaWYgKHVybC5wcm90b2NvbCA9PT0gJ2ZpbGU6JyB8fCB1cmwucHJvdG9jb2wgPT09ICdhYm91dDonIHx8IHVybC5wcm90b2NvbCA9PT0gJ2JsYW5rOicpIHtcbiAgICByZXR1cm4gJ25vLXJlZmVycmVyJ1xuICB9XG5cbiAgLy8gMy4gU2V0IHVybOKAmXMgdXNlcm5hbWUgdG8gdGhlIGVtcHR5IHN0cmluZy5cbiAgdXJsLnVzZXJuYW1lID0gJydcblxuICAvLyA0LiBTZXQgdXJs4oCZcyBwYXNzd29yZCB0byB0aGUgZW1wdHkgc3RyaW5nLlxuICB1cmwucGFzc3dvcmQgPSAnJ1xuXG4gIC8vIDUuIFNldCB1cmzigJlzIGZyYWdtZW50IHRvIG51bGwuXG4gIHVybC5oYXNoID0gJydcblxuICAvLyA2LiBJZiB0aGUgb3JpZ2luLW9ubHkgZmxhZyBpcyB0cnVlLCB0aGVuOlxuICBpZiAob3JpZ2luT25seSkge1xuICAgIC8vIDEuIFNldCB1cmzigJlzIHBhdGggdG8gwqsgdGhlIGVtcHR5IHN0cmluZyDCuy5cbiAgICB1cmwucGF0aG5hbWUgPSAnJ1xuXG4gICAgLy8gMi4gU2V0IHVybOKAmXMgcXVlcnkgdG8gbnVsbC5cbiAgICB1cmwuc2VhcmNoID0gJydcbiAgfVxuXG4gIC8vIDcuIFJldHVybiB1cmwuXG4gIHJldHVybiB1cmxcbn1cblxuZnVuY3Rpb24gaXNVUkxQb3RlbnRpYWxseVRydXN0d29ydGh5ICh1cmwpIHtcbiAgaWYgKCEodXJsIGluc3RhbmNlb2YgVVJMKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gSWYgY2hpbGQgb2YgYWJvdXQsIHJldHVybiB0cnVlXG4gIGlmICh1cmwuaHJlZiA9PT0gJ2Fib3V0OmJsYW5rJyB8fCB1cmwuaHJlZiA9PT0gJ2Fib3V0OnNyY2RvYycpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gSWYgc2NoZW1lIGlzIGRhdGEsIHJldHVybiB0cnVlXG4gIGlmICh1cmwucHJvdG9jb2wgPT09ICdkYXRhOicpIHJldHVybiB0cnVlXG5cbiAgLy8gSWYgZmlsZSwgcmV0dXJuIHRydWVcbiAgaWYgKHVybC5wcm90b2NvbCA9PT0gJ2ZpbGU6JykgcmV0dXJuIHRydWVcblxuICByZXR1cm4gaXNPcmlnaW5Qb3RlbnRpYWxseVRydXN0d29ydGh5KHVybC5vcmlnaW4pXG5cbiAgZnVuY3Rpb24gaXNPcmlnaW5Qb3RlbnRpYWxseVRydXN0d29ydGh5IChvcmlnaW4pIHtcbiAgICAvLyBJZiBvcmlnaW4gaXMgZXhwbGljaXRseSBudWxsLCByZXR1cm4gZmFsc2VcbiAgICBpZiAob3JpZ2luID09IG51bGwgfHwgb3JpZ2luID09PSAnbnVsbCcpIHJldHVybiBmYWxzZVxuXG4gICAgY29uc3Qgb3JpZ2luQXNVUkwgPSBuZXcgVVJMKG9yaWdpbilcblxuICAgIC8vIElmIHNlY3VyZSwgcmV0dXJuIHRydWVcbiAgICBpZiAob3JpZ2luQXNVUkwucHJvdG9jb2wgPT09ICdodHRwczonIHx8IG9yaWdpbkFzVVJMLnByb3RvY29sID09PSAnd3NzOicpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gSWYgbG9jYWxob3N0IG9yIHZhcmlhbnRzLCByZXR1cm4gdHJ1ZVxuICAgIGlmICgvXjEyNyg/OlxcLlswLTldKyl7MCwyfVxcLlswLTldKyR8XlxcWyg/OjAqOikqPzo/MCoxXFxdJC8udGVzdChvcmlnaW5Bc1VSTC5ob3N0bmFtZSkgfHxcbiAgICAgKG9yaWdpbkFzVVJMLmhvc3RuYW1lID09PSAnbG9jYWxob3N0JyB8fCBvcmlnaW5Bc1VSTC5ob3N0bmFtZS5pbmNsdWRlcygnbG9jYWxob3N0LicpKSB8fFxuICAgICAob3JpZ2luQXNVUkwuaG9zdG5hbWUuZW5kc1dpdGgoJy5sb2NhbGhvc3QnKSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gSWYgYW55IG90aGVyLCByZXR1cm4gZmFsc2VcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1zdWJyZXNvdXJjZS1pbnRlZ3JpdHkvI2RvZXMtcmVzcG9uc2UtbWF0Y2gtbWV0YWRhdGFsaXN0XG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0YWRhdGFMaXN0XG4gKi9cbmZ1bmN0aW9uIGJ5dGVzTWF0Y2ggKGJ5dGVzLCBtZXRhZGF0YUxpc3QpIHtcbiAgLy8gSWYgbm9kZSBpcyBub3QgYnVpbHQgd2l0aCBPcGVuU1NMIHN1cHBvcnQsIHdlIGNhbm5vdCBjaGVja1xuICAvLyBhIHJlcXVlc3QncyBpbnRlZ3JpdHksIHNvIGFsbG93IGl0IGJ5IGRlZmF1bHQgKHRoZSBzcGVjIHdpbGxcbiAgLy8gYWxsb3cgcmVxdWVzdHMgaWYgYW4gaW52YWxpZCBoYXNoIGlzIGdpdmVuLCBhcyBwcmVjZWRlbmNlKS5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmOiBvbmx5IGlmIG5vZGUgaXMgYnVpbHQgd2l0aCAtLXdpdGhvdXQtc3NsICovXG4gIGlmIChjcnlwdG8gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyAxLiBMZXQgcGFyc2VkTWV0YWRhdGEgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIG1ldGFkYXRhTGlzdC5cbiAgY29uc3QgcGFyc2VkTWV0YWRhdGEgPSBwYXJzZU1ldGFkYXRhKG1ldGFkYXRhTGlzdClcblxuICAvLyAyLiBJZiBwYXJzZWRNZXRhZGF0YSBpcyBubyBtZXRhZGF0YSwgcmV0dXJuIHRydWUuXG4gIGlmIChwYXJzZWRNZXRhZGF0YSA9PT0gJ25vIG1ldGFkYXRhJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyAzLiBJZiBwYXJzZWRNZXRhZGF0YSBpcyB0aGUgZW1wdHkgc2V0LCByZXR1cm4gdHJ1ZS5cbiAgaWYgKHBhcnNlZE1ldGFkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyA0LiBMZXQgbWV0YWRhdGEgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nIHRoZSBzdHJvbmdlc3RcbiAgLy8gICAgbWV0YWRhdGEgZnJvbSBwYXJzZWRNZXRhZGF0YS5cbiAgY29uc3QgbGlzdCA9IHBhcnNlZE1ldGFkYXRhLnNvcnQoKGMsIGQpID0+IGQuYWxnby5sb2NhbGVDb21wYXJlKGMuYWxnbykpXG4gIC8vIGdldCB0aGUgc3Ryb25nZXN0IGFsZ29yaXRobVxuICBjb25zdCBzdHJvbmdlc3QgPSBsaXN0WzBdLmFsZ29cbiAgLy8gZ2V0IGFsbCBlbnRyaWVzIHRoYXQgdXNlIHRoZSBzdHJvbmdlc3QgYWxnb3JpdGhtOyBpZ25vcmUgd2Vha2VyXG4gIGNvbnN0IG1ldGFkYXRhID0gbGlzdC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uYWxnbyA9PT0gc3Ryb25nZXN0KVxuXG4gIC8vIDUuIEZvciBlYWNoIGl0ZW0gaW4gbWV0YWRhdGE6XG4gIGZvciAoY29uc3QgaXRlbSBvZiBtZXRhZGF0YSkge1xuICAgIC8vIDEuIExldCBhbGdvcml0aG0gYmUgdGhlIGFsZyBjb21wb25lbnQgb2YgaXRlbS5cbiAgICBjb25zdCBhbGdvcml0aG0gPSBpdGVtLmFsZ29cblxuICAgIC8vIDIuIExldCBleHBlY3RlZFZhbHVlIGJlIHRoZSB2YWwgY29tcG9uZW50IG9mIGl0ZW0uXG4gICAgbGV0IGV4cGVjdGVkVmFsdWUgPSBpdGVtLmhhc2hcblxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2ViLXBsYXRmb3JtLXRlc3RzL3dwdC9jb21taXQvZTRjNWNjN2E1ZTQ4MDkzMjIwNTI4ZGZkZDFjNDAxMmRjMzgzN2EwZVxuICAgIC8vIFwiYmUgbGliZXJhbCB3aXRoIHBhZGRpbmdcIi4gVGhpcyBpcyBhbm5veWluZywgYW5kIGl0J3Mgbm90IGV2ZW4gaW4gdGhlIHNwZWMuXG5cbiAgICBpZiAoZXhwZWN0ZWRWYWx1ZS5lbmRzV2l0aCgnPT0nKSkge1xuICAgICAgZXhwZWN0ZWRWYWx1ZSA9IGV4cGVjdGVkVmFsdWUuc2xpY2UoMCwgLTIpXG4gICAgfVxuXG4gICAgLy8gMy4gTGV0IGFjdHVhbFZhbHVlIGJlIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYWxnb3JpdGhtIHRvIGJ5dGVzLlxuICAgIGxldCBhY3R1YWxWYWx1ZSA9IGNyeXB0by5jcmVhdGVIYXNoKGFsZ29yaXRobSkudXBkYXRlKGJ5dGVzKS5kaWdlc3QoJ2Jhc2U2NCcpXG5cbiAgICBpZiAoYWN0dWFsVmFsdWUuZW5kc1dpdGgoJz09JykpIHtcbiAgICAgIGFjdHVhbFZhbHVlID0gYWN0dWFsVmFsdWUuc2xpY2UoMCwgLTIpXG4gICAgfVxuXG4gICAgLy8gNC4gSWYgYWN0dWFsVmFsdWUgaXMgYSBjYXNlLXNlbnNpdGl2ZSBtYXRjaCBmb3IgZXhwZWN0ZWRWYWx1ZSxcbiAgICAvLyAgICByZXR1cm4gdHJ1ZS5cbiAgICBpZiAoYWN0dWFsVmFsdWUgPT09IGV4cGVjdGVkVmFsdWUpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgbGV0IGFjdHVhbEJhc2U2NFVSTCA9IGNyeXB0by5jcmVhdGVIYXNoKGFsZ29yaXRobSkudXBkYXRlKGJ5dGVzKS5kaWdlc3QoJ2Jhc2U2NHVybCcpXG5cbiAgICBpZiAoYWN0dWFsQmFzZTY0VVJMLmVuZHNXaXRoKCc9PScpKSB7XG4gICAgICBhY3R1YWxCYXNlNjRVUkwgPSBhY3R1YWxCYXNlNjRVUkwuc2xpY2UoMCwgLTIpXG4gICAgfVxuXG4gICAgaWYgKGFjdHVhbEJhc2U2NFVSTCA9PT0gZXhwZWN0ZWRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICAvLyA2LiBSZXR1cm4gZmFsc2UuXG4gIHJldHVybiBmYWxzZVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXN1YnJlc291cmNlLWludGVncml0eS8jZ3JhbW1hcmRlZi1oYXNoLXdpdGgtb3B0aW9uc1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0NTUDIvI3NvdXJjZS1saXN0LXN5bnRheFxuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzUyMzQjYXBwZW5kaXgtQi4xXG5jb25zdCBwYXJzZUhhc2hXaXRoT3B0aW9ucyA9IC8oKD88YWxnbz5zaGEyNTZ8c2hhMzg0fHNoYTUxMiktKD88aGFzaD5bQS16MC05Ky9dezF9Lio9ezAsMn0pKSggK1tcXHgyMS1cXHg3ZV0/KT8vaVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1zdWJyZXNvdXJjZS1pbnRlZ3JpdHkvI3BhcnNlLW1ldGFkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0YWRhdGFcbiAqL1xuZnVuY3Rpb24gcGFyc2VNZXRhZGF0YSAobWV0YWRhdGEpIHtcbiAgLy8gMS4gTGV0IHJlc3VsdCBiZSB0aGUgZW1wdHkgc2V0LlxuICAvKiogQHR5cGUge3sgYWxnbzogc3RyaW5nLCBoYXNoOiBzdHJpbmcgfVtdfSAqL1xuICBjb25zdCByZXN1bHQgPSBbXVxuXG4gIC8vIDIuIExldCBlbXB0eSBiZSBlcXVhbCB0byB0cnVlLlxuICBsZXQgZW1wdHkgPSB0cnVlXG5cbiAgY29uc3Qgc3VwcG9ydGVkSGFzaGVzID0gY3J5cHRvLmdldEhhc2hlcygpXG5cbiAgLy8gMy4gRm9yIGVhY2ggdG9rZW4gcmV0dXJuZWQgYnkgc3BsaXR0aW5nIG1ldGFkYXRhIG9uIHNwYWNlczpcbiAgZm9yIChjb25zdCB0b2tlbiBvZiBtZXRhZGF0YS5zcGxpdCgnICcpKSB7XG4gICAgLy8gMS4gU2V0IGVtcHR5IHRvIGZhbHNlLlxuICAgIGVtcHR5ID0gZmFsc2VcblxuICAgIC8vIDIuIFBhcnNlIHRva2VuIGFzIGEgaGFzaC13aXRoLW9wdGlvbnMuXG4gICAgY29uc3QgcGFyc2VkVG9rZW4gPSBwYXJzZUhhc2hXaXRoT3B0aW9ucy5leGVjKHRva2VuKVxuXG4gICAgLy8gMy4gSWYgdG9rZW4gZG9lcyBub3QgcGFyc2UsIGNvbnRpbnVlIHRvIHRoZSBuZXh0IHRva2VuLlxuICAgIGlmIChwYXJzZWRUb2tlbiA9PT0gbnVsbCB8fCBwYXJzZWRUb2tlbi5ncm91cHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gTm90ZTogQ2hyb21pdW0gYmxvY2tzIHRoZSByZXF1ZXN0IGF0IHRoaXMgcG9pbnQsIGJ1dCBGaXJlZm94XG4gICAgICAvLyBnaXZlcyBhIHdhcm5pbmcgdGhhdCBhbiBpbnZhbGlkIGludGVncml0eSB3YXMgZ2l2ZW4uIFRoZVxuICAgICAgLy8gY29ycmVjdCBiZWhhdmlvciBpcyB0byBpZ25vcmUgdGhlc2UsIGFuZCBzdWJzZXF1ZW50bHkgbm90XG4gICAgICAvLyBjaGVjayB0aGUgaW50ZWdyaXR5IG9mIHRoZSByZXNvdXJjZS5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgLy8gNC4gTGV0IGFsZ29yaXRobSBiZSB0aGUgaGFzaC1hbGdvIGNvbXBvbmVudCBvZiB0b2tlbi5cbiAgICBjb25zdCBhbGdvcml0aG0gPSBwYXJzZWRUb2tlbi5ncm91cHMuYWxnb1xuXG4gICAgLy8gNS4gSWYgYWxnb3JpdGhtIGlzIGEgaGFzaCBmdW5jdGlvbiByZWNvZ25pemVkIGJ5IHRoZSB1c2VyXG4gICAgLy8gICAgYWdlbnQsIGFkZCB0aGUgcGFyc2VkIHRva2VuIHRvIHJlc3VsdC5cbiAgICBpZiAoc3VwcG9ydGVkSGFzaGVzLmluY2x1ZGVzKGFsZ29yaXRobS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgcmVzdWx0LnB1c2gocGFyc2VkVG9rZW4uZ3JvdXBzKVxuICAgIH1cbiAgfVxuXG4gIC8vIDQuIFJldHVybiBubyBtZXRhZGF0YSBpZiBlbXB0eSBpcyB0cnVlLCBvdGhlcndpc2UgcmV0dXJuIHJlc3VsdC5cbiAgaWYgKGVtcHR5ID09PSB0cnVlKSB7XG4gICAgcmV0dXJuICdubyBtZXRhZGF0YSdcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy11cGdyYWRlLWluc2VjdXJlLXJlcXVlc3RzLyN1cGdyYWRlLXJlcXVlc3RcbmZ1bmN0aW9uIHRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTCAocmVxdWVzdCkge1xuICAvLyBUT0RPXG59XG5cbi8qKlxuICogQGxpbmsge2h0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL29yaWdpbi5odG1sI3NhbWUtb3JpZ2lufVxuICogQHBhcmFtIHtVUkx9IEFcbiAqIEBwYXJhbSB7VVJMfSBCXG4gKi9cbmZ1bmN0aW9uIHNhbWVPcmlnaW4gKEEsIEIpIHtcbiAgLy8gMS4gSWYgQSBhbmQgQiBhcmUgdGhlIHNhbWUgb3BhcXVlIG9yaWdpbiwgdGhlbiByZXR1cm4gdHJ1ZS5cbiAgaWYgKEEub3JpZ2luID09PSBCLm9yaWdpbiAmJiBBLm9yaWdpbiA9PT0gJ251bGwnKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIDIuIElmIEEgYW5kIEIgYXJlIGJvdGggdHVwbGUgb3JpZ2lucyBhbmQgdGhlaXIgc2NoZW1lcyxcbiAgLy8gICAgaG9zdHMsIGFuZCBwb3J0IGFyZSBpZGVudGljYWwsIHRoZW4gcmV0dXJuIHRydWUuXG4gIGlmIChBLnByb3RvY29sID09PSBCLnByb3RvY29sICYmIEEuaG9zdG5hbWUgPT09IEIuaG9zdG5hbWUgJiYgQS5wb3J0ID09PSBCLnBvcnQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIGZhbHNlLlxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVmZXJyZWRQcm9taXNlICgpIHtcbiAgbGV0IHJlc1xuICBsZXQgcmVqXG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVzID0gcmVzb2x2ZVxuICAgIHJlaiA9IHJlamVjdFxuICB9KVxuXG4gIHJldHVybiB7IHByb21pc2UsIHJlc29sdmU6IHJlcywgcmVqZWN0OiByZWogfVxufVxuXG5mdW5jdGlvbiBpc0Fib3J0ZWQgKGZldGNoUGFyYW1zKSB7XG4gIHJldHVybiBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnN0YXRlID09PSAnYWJvcnRlZCdcbn1cblxuZnVuY3Rpb24gaXNDYW5jZWxsZWQgKGZldGNoUGFyYW1zKSB7XG4gIHJldHVybiBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnN0YXRlID09PSAnYWJvcnRlZCcgfHxcbiAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnN0YXRlID09PSAndGVybWluYXRlZCdcbn1cblxuY29uc3Qgbm9ybWFsaXplTWV0aG9kUmVjb3JkID0ge1xuICBkZWxldGU6ICdERUxFVEUnLFxuICBERUxFVEU6ICdERUxFVEUnLFxuICBnZXQ6ICdHRVQnLFxuICBHRVQ6ICdHRVQnLFxuICBoZWFkOiAnSEVBRCcsXG4gIEhFQUQ6ICdIRUFEJyxcbiAgb3B0aW9uczogJ09QVElPTlMnLFxuICBPUFRJT05TOiAnT1BUSU9OUycsXG4gIHBvc3Q6ICdQT1NUJyxcbiAgUE9TVDogJ1BPU1QnLFxuICBwdXQ6ICdQVVQnLFxuICBQVVQ6ICdQVVQnXG59XG5cbi8vIE5vdGU6IG9iamVjdCBwcm90b3R5cGVzIHNob3VsZCBub3QgYmUgYWJsZSB0byBiZSByZWZlcmVuY2VkLiBlLmcuIGBPYmplY3QjaGFzT3duUHJvcGVydHlgLlxuT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vcm1hbGl6ZU1ldGhvZFJlY29yZCwgbnVsbClcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LW1ldGhvZC1ub3JtYWxpemVcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kIChtZXRob2QpIHtcbiAgcmV0dXJuIG5vcm1hbGl6ZU1ldGhvZFJlY29yZFttZXRob2QudG9Mb3dlckNhc2UoKV0gPz8gbWV0aG9kXG59XG5cbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzZXJpYWxpemUtYS1qYXZhc2NyaXB0LXZhbHVlLXRvLWEtanNvbi1zdHJpbmdcbmZ1bmN0aW9uIHNlcmlhbGl6ZUphdmFzY3JpcHRWYWx1ZVRvSlNPTlN0cmluZyAodmFsdWUpIHtcbiAgLy8gMS4gTGV0IHJlc3VsdCBiZSA/IENhbGwoJUpTT04uc3RyaW5naWZ5JSwgdW5kZWZpbmVkLCDCqyB2YWx1ZSDCuykuXG4gIGNvbnN0IHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKVxuXG4gIC8vIDIuIElmIHJlc3VsdCBpcyB1bmRlZmluZWQsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1ZhbHVlIGlzIG5vdCBKU09OIHNlcmlhbGl6YWJsZScpXG4gIH1cblxuICAvLyAzLiBBc3NlcnQ6IHJlc3VsdCBpcyBhIHN0cmluZy5cbiAgYXNzZXJ0KHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKVxuXG4gIC8vIDQuIFJldHVybiByZXN1bHQuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lMjVpdGVyYXRvcnByb3RvdHlwZSUyNS1vYmplY3RcbmNvbnN0IGVzSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkpXG5cbi8qKlxuICogQHNlZSBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2Rmbi1pdGVyYXRvci1wcm90b3R5cGUtb2JqZWN0XG4gKiBAcGFyYW0geygpID0+IHVua25vd25bXX0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIGluc3RhbmNlXG4gKiBAcGFyYW0geydrZXknfCd2YWx1ZSd8J2tleSt2YWx1ZSd9IGtpbmRcbiAqL1xuZnVuY3Rpb24gbWFrZUl0ZXJhdG9yIChpdGVyYXRvciwgbmFtZSwga2luZCkge1xuICBjb25zdCBvYmplY3QgPSB7XG4gICAgaW5kZXg6IDAsXG4gICAga2luZCxcbiAgICB0YXJnZXQ6IGl0ZXJhdG9yXG4gIH1cblxuICBjb25zdCBpID0ge1xuICAgIG5leHQgKCkge1xuICAgICAgLy8gMS4gTGV0IGludGVyZmFjZSBiZSB0aGUgaW50ZXJmYWNlIGZvciB3aGljaCB0aGUgaXRlcmF0b3IgcHJvdG90eXBlIG9iamVjdCBleGlzdHMuXG5cbiAgICAgIC8vIDIuIExldCB0aGlzVmFsdWUgYmUgdGhlIHRoaXMgdmFsdWUuXG5cbiAgICAgIC8vIDMuIExldCBvYmplY3QgYmUgPyBUb09iamVjdCh0aGlzVmFsdWUpLlxuXG4gICAgICAvLyA0LiBJZiBvYmplY3QgaXMgYSBwbGF0Zm9ybSBvYmplY3QsIHRoZW4gcGVyZm9ybSBhIHNlY3VyaXR5XG4gICAgICAvLyAgICBjaGVjaywgcGFzc2luZzpcblxuICAgICAgLy8gNS4gSWYgb2JqZWN0IGlzIG5vdCBhIGRlZmF1bHQgaXRlcmF0b3Igb2JqZWN0IGZvciBpbnRlcmZhY2UsXG4gICAgICAvLyAgICB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSAhPT0gaSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGAnbmV4dCcgY2FsbGVkIG9uIGFuIG9iamVjdCB0aGF0IGRvZXMgbm90IGltcGxlbWVudCBpbnRlcmZhY2UgJHtuYW1lfSBJdGVyYXRvci5gXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gNi4gTGV0IGluZGV4IGJlIG9iamVjdOKAmXMgaW5kZXguXG4gICAgICAvLyA3LiBMZXQga2luZCBiZSBvYmplY3TigJlzIGtpbmQuXG4gICAgICAvLyA4LiBMZXQgdmFsdWVzIGJlIG9iamVjdOKAmXMgdGFyZ2V0J3MgdmFsdWUgcGFpcnMgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAgY29uc3QgeyBpbmRleCwga2luZCwgdGFyZ2V0IH0gPSBvYmplY3RcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHRhcmdldCgpXG5cbiAgICAgIC8vIDkuIExldCBsZW4gYmUgdGhlIGxlbmd0aCBvZiB2YWx1ZXMuXG4gICAgICBjb25zdCBsZW4gPSB2YWx1ZXMubGVuZ3RoXG5cbiAgICAgIC8vIDEwLiBJZiBpbmRleCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gbGVuLCB0aGVuIHJldHVyblxuICAgICAgLy8gICAgIENyZWF0ZUl0ZXJSZXN1bHRPYmplY3QodW5kZWZpbmVkLCB0cnVlKS5cbiAgICAgIGlmIChpbmRleCA+PSBsZW4pIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9XG4gICAgICB9XG5cbiAgICAgIC8vIDExLiBMZXQgcGFpciBiZSB0aGUgZW50cnkgaW4gdmFsdWVzIGF0IGluZGV4IGluZGV4LlxuICAgICAgY29uc3QgcGFpciA9IHZhbHVlc1tpbmRleF1cblxuICAgICAgLy8gMTIuIFNldCBvYmplY3TigJlzIGluZGV4IHRvIGluZGV4ICsgMS5cbiAgICAgIG9iamVjdC5pbmRleCA9IGluZGV4ICsgMVxuXG4gICAgICAvLyAxMy4gUmV0dXJuIHRoZSBpdGVyYXRvciByZXN1bHQgZm9yIHBhaXIgYW5kIGtpbmQuXG4gICAgICByZXR1cm4gaXRlcmF0b3JSZXN1bHQocGFpciwga2luZClcbiAgICB9LFxuICAgIC8vIFRoZSBjbGFzcyBzdHJpbmcgb2YgYW4gaXRlcmF0b3IgcHJvdG90eXBlIG9iamVjdCBmb3IgYSBnaXZlbiBpbnRlcmZhY2UgaXMgdGhlXG4gICAgLy8gcmVzdWx0IG9mIGNvbmNhdGVuYXRpbmcgdGhlIGlkZW50aWZpZXIgb2YgdGhlIGludGVyZmFjZSBhbmQgdGhlIHN0cmluZyBcIiBJdGVyYXRvclwiLlxuICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiBgJHtuYW1lfSBJdGVyYXRvcmBcbiAgfVxuXG4gIC8vIFRoZSBbW1Byb3RvdHlwZV1dIGludGVybmFsIHNsb3Qgb2YgYW4gaXRlcmF0b3IgcHJvdG90eXBlIG9iamVjdCBtdXN0IGJlICVJdGVyYXRvclByb3RvdHlwZSUuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihpLCBlc0l0ZXJhdG9yUHJvdG90eXBlKVxuICAvLyBlc0l0ZXJhdG9yUHJvdG90eXBlIG5lZWRzIHRvIGJlIHRoZSBwcm90b3R5cGUgb2YgaVxuICAvLyB3aGljaCBpcyB0aGUgcHJvdG90eXBlIG9mIGFuIGVtcHR5IG9iamVjdC4gWWVzLCBpdCdzIGNvbmZ1c2luZy5cbiAgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZih7fSwgaSlcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNpdGVyYXRvci1yZXN1bHRcbmZ1bmN0aW9uIGl0ZXJhdG9yUmVzdWx0IChwYWlyLCBraW5kKSB7XG4gIGxldCByZXN1bHRcblxuICAvLyAxLiBMZXQgcmVzdWx0IGJlIGEgdmFsdWUgZGV0ZXJtaW5lZCBieSB0aGUgdmFsdWUgb2Yga2luZDpcbiAgc3dpdGNoIChraW5kKSB7XG4gICAgY2FzZSAna2V5Jzoge1xuICAgICAgLy8gMS4gTGV0IGlkbEtleSBiZSBwYWly4oCZcyBrZXkuXG4gICAgICAvLyAyLiBMZXQga2V5IGJlIHRoZSByZXN1bHQgb2YgY29udmVydGluZyBpZGxLZXkgdG8gYW5cbiAgICAgIC8vICAgIEVDTUFTY3JpcHQgdmFsdWUuXG4gICAgICAvLyAzLiByZXN1bHQgaXMga2V5LlxuICAgICAgcmVzdWx0ID0gcGFpclswXVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAndmFsdWUnOiB7XG4gICAgICAvLyAxLiBMZXQgaWRsVmFsdWUgYmUgcGFpcuKAmXMgdmFsdWUuXG4gICAgICAvLyAyLiBMZXQgdmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIGlkbFZhbHVlIHRvXG4gICAgICAvLyAgICBhbiBFQ01BU2NyaXB0IHZhbHVlLlxuICAgICAgLy8gMy4gcmVzdWx0IGlzIHZhbHVlLlxuICAgICAgcmVzdWx0ID0gcGFpclsxXVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAna2V5K3ZhbHVlJzoge1xuICAgICAgLy8gMS4gTGV0IGlkbEtleSBiZSBwYWly4oCZcyBrZXkuXG4gICAgICAvLyAyLiBMZXQgaWRsVmFsdWUgYmUgcGFpcuKAmXMgdmFsdWUuXG4gICAgICAvLyAzLiBMZXQga2V5IGJlIHRoZSByZXN1bHQgb2YgY29udmVydGluZyBpZGxLZXkgdG8gYW5cbiAgICAgIC8vICAgIEVDTUFTY3JpcHQgdmFsdWUuXG4gICAgICAvLyA0LiBMZXQgdmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIGlkbFZhbHVlIHRvXG4gICAgICAvLyAgICBhbiBFQ01BU2NyaXB0IHZhbHVlLlxuICAgICAgLy8gNS4gTGV0IGFycmF5IGJlICEgQXJyYXlDcmVhdGUoMikuXG4gICAgICAvLyA2LiBDYWxsICEgQ3JlYXRlRGF0YVByb3BlcnR5KGFycmF5LCBcIjBcIiwga2V5KS5cbiAgICAgIC8vIDcuIENhbGwgISBDcmVhdGVEYXRhUHJvcGVydHkoYXJyYXksIFwiMVwiLCB2YWx1ZSkuXG4gICAgICAvLyA4LiByZXN1bHQgaXMgYXJyYXkuXG4gICAgICByZXN1bHQgPSBwYWlyXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIDIuIFJldHVybiBDcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHJlc3VsdCwgZmFsc2UpLlxuICByZXR1cm4geyB2YWx1ZTogcmVzdWx0LCBkb25lOiBmYWxzZSB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYm9keS1mdWxseS1yZWFkXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZ1bGx5UmVhZEJvZHkgKGJvZHksIHByb2Nlc3NCb2R5LCBwcm9jZXNzQm9keUVycm9yKSB7XG4gIC8vIDEuIElmIHRhc2tEZXN0aW5hdGlvbiBpcyBudWxsLCB0aGVuIHNldCB0YXNrRGVzdGluYXRpb24gdG9cbiAgLy8gICAgdGhlIHJlc3VsdCBvZiBzdGFydGluZyBhIG5ldyBwYXJhbGxlbCBxdWV1ZS5cblxuICAvLyAyLiBMZXQgc3VjY2Vzc1N0ZXBzIGdpdmVuIGEgYnl0ZSBzZXF1ZW5jZSBieXRlcyBiZSB0byBxdWV1ZSBhXG4gIC8vICAgIGZldGNoIHRhc2sgdG8gcnVuIHByb2Nlc3NCb2R5IGdpdmVuIGJ5dGVzLCB3aXRoIHRhc2tEZXN0aW5hdGlvbi5cbiAgY29uc3Qgc3VjY2Vzc1N0ZXBzID0gcHJvY2Vzc0JvZHlcblxuICAvLyAzLiBMZXQgZXJyb3JTdGVwcyBiZSB0byBxdWV1ZSBhIGZldGNoIHRhc2sgdG8gcnVuIHByb2Nlc3NCb2R5RXJyb3IsXG4gIC8vICAgIHdpdGggdGFza0Rlc3RpbmF0aW9uLlxuICBjb25zdCBlcnJvclN0ZXBzID0gcHJvY2Vzc0JvZHlFcnJvclxuXG4gIC8vIDQuIExldCByZWFkZXIgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nIGEgcmVhZGVyIGZvciBib2R54oCZcyBzdHJlYW0uXG4gIC8vICAgIElmIHRoYXQgdGhyZXcgYW4gZXhjZXB0aW9uLCB0aGVuIHJ1biBlcnJvclN0ZXBzIHdpdGggdGhhdFxuICAvLyAgICBleGNlcHRpb24gYW5kIHJldHVybi5cbiAgbGV0IHJlYWRlclxuXG4gIHRyeSB7XG4gICAgcmVhZGVyID0gYm9keS5zdHJlYW0uZ2V0UmVhZGVyKClcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9yU3RlcHMoZSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDUuIFJlYWQgYWxsIGJ5dGVzIGZyb20gcmVhZGVyLCBnaXZlbiBzdWNjZXNzU3RlcHMgYW5kIGVycm9yU3RlcHMuXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVhZEFsbEJ5dGVzKHJlYWRlcilcbiAgICBzdWNjZXNzU3RlcHMocmVzdWx0KVxuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3JTdGVwcyhlKVxuICB9XG59XG5cbi8qKiBAdHlwZSB7UmVhZGFibGVTdHJlYW19ICovXG5sZXQgUmVhZGFibGVTdHJlYW0gPSBnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtXG5cbmZ1bmN0aW9uIGlzUmVhZGFibGVTdHJlYW1MaWtlIChzdHJlYW0pIHtcbiAgaWYgKCFSZWFkYWJsZVN0cmVhbSkge1xuICAgIFJlYWRhYmxlU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtL3dlYicpLlJlYWRhYmxlU3RyZWFtXG4gIH1cblxuICByZXR1cm4gc3RyZWFtIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0gfHwgKFxuICAgIHN0cmVhbVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnUmVhZGFibGVTdHJlYW0nICYmXG4gICAgdHlwZW9mIHN0cmVhbS50ZWUgPT09ICdmdW5jdGlvbidcbiAgKVxufVxuXG5jb25zdCBNQVhJTVVNX0FSR1VNRU5UX0xFTkdUSCA9IDY1NTM1XG5cbi8qKlxuICogQHNlZSBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jaXNvbW9ycGhpYy1kZWNvZGVcbiAqIEBwYXJhbSB7bnVtYmVyW118VWludDhBcnJheX0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gaXNvbW9ycGhpY0RlY29kZSAoaW5wdXQpIHtcbiAgLy8gMS4gVG8gaXNvbW9ycGhpYyBkZWNvZGUgYSBieXRlIHNlcXVlbmNlIGlucHV0LCByZXR1cm4gYSBzdHJpbmcgd2hvc2UgY29kZSBwb2ludFxuICAvLyAgICBsZW5ndGggaXMgZXF1YWwgdG8gaW5wdXTigJlzIGxlbmd0aCBhbmQgd2hvc2UgY29kZSBwb2ludHMgaGF2ZSB0aGUgc2FtZSB2YWx1ZXNcbiAgLy8gICAgYXMgdGhlIHZhbHVlcyBvZiBpbnB1dOKAmXMgYnl0ZXMsIGluIHRoZSBzYW1lIG9yZGVyLlxuXG4gIGlmIChpbnB1dC5sZW5ndGggPCBNQVhJTVVNX0FSR1VNRU5UX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmlucHV0KVxuICB9XG5cbiAgcmV0dXJuIGlucHV0LnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHByZXZpb3VzICsgU3RyaW5nLmZyb21DaGFyQ29kZShjdXJyZW50KSwgJycpXG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXI8VWludDhBcnJheT59IGNvbnRyb2xsZXJcbiAqL1xuZnVuY3Rpb24gcmVhZGFibGVTdHJlYW1DbG9zZSAoY29udHJvbGxlcikge1xuICB0cnkge1xuICAgIGNvbnRyb2xsZXIuY2xvc2UoKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBUT0RPOiBhZGQgY29tbWVudCBleHBsYWluaW5nIHdoeSB0aGlzIGVycm9yIG9jY3Vycy5cbiAgICBpZiAoIWVyci5tZXNzYWdlLmluY2x1ZGVzKCdDb250cm9sbGVyIGlzIGFscmVhZHkgY2xvc2VkJykpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2lzb21vcnBoaWMtZW5jb2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqL1xuZnVuY3Rpb24gaXNvbW9ycGhpY0VuY29kZSAoaW5wdXQpIHtcbiAgLy8gMS4gQXNzZXJ0OiBpbnB1dCBjb250YWlucyBubyBjb2RlIHBvaW50cyBncmVhdGVyIHRoYW4gVSswMEZGLlxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgYXNzZXJ0KGlucHV0LmNoYXJDb2RlQXQoaSkgPD0gMHhGRilcbiAgfVxuXG4gIC8vIDIuIFJldHVybiBhIGJ5dGUgc2VxdWVuY2Ugd2hvc2UgbGVuZ3RoIGlzIGVxdWFsIHRvIGlucHV04oCZcyBjb2RlXG4gIC8vICAgIHBvaW50IGxlbmd0aCBhbmQgd2hvc2UgYnl0ZXMgaGF2ZSB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gIC8vICAgIHZhbHVlcyBvZiBpbnB1dOKAmXMgY29kZSBwb2ludHMsIGluIHRoZSBzYW1lIG9yZGVyXG4gIHJldHVybiBpbnB1dFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9zdHJlYW1zLnNwZWMud2hhdHdnLm9yZy8jcmVhZGFibGVzdHJlYW1kZWZhdWx0cmVhZGVyLXJlYWQtYWxsLWJ5dGVzXG4gKiBAc2VlIGh0dHBzOi8vc3RyZWFtcy5zcGVjLndoYXR3Zy5vcmcvI3JlYWQtbG9vcFxuICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJ9IHJlYWRlclxuICovXG5hc3luYyBmdW5jdGlvbiByZWFkQWxsQnl0ZXMgKHJlYWRlcikge1xuICBjb25zdCBieXRlcyA9IFtdXG4gIGxldCBieXRlTGVuZ3RoID0gMFxuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyBkb25lLCB2YWx1ZTogY2h1bmsgfSA9IGF3YWl0IHJlYWRlci5yZWFkKClcblxuICAgIGlmIChkb25lKSB7XG4gICAgICAvLyAxLiBDYWxsIHN1Y2Nlc3NTdGVwcyB3aXRoIGJ5dGVzLlxuICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoYnl0ZXMsIGJ5dGVMZW5ndGgpXG4gICAgfVxuXG4gICAgLy8gMS4gSWYgY2h1bmsgaXMgbm90IGEgVWludDhBcnJheSBvYmplY3QsIGNhbGwgZmFpbHVyZVN0ZXBzXG4gICAgLy8gICAgd2l0aCBhIFR5cGVFcnJvciBhbmQgYWJvcnQgdGhlc2Ugc3RlcHMuXG4gICAgaWYgKCFpc1VpbnQ4QXJyYXkoY2h1bmspKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWNlaXZlZCBub24tVWludDhBcnJheSBjaHVuaycpXG4gICAgfVxuXG4gICAgLy8gMi4gQXBwZW5kIHRoZSBieXRlcyByZXByZXNlbnRlZCBieSBjaHVuayB0byBieXRlcy5cbiAgICBieXRlcy5wdXNoKGNodW5rKVxuICAgIGJ5dGVMZW5ndGggKz0gY2h1bmsubGVuZ3RoXG5cbiAgICAvLyAzLiBSZWFkLWxvb3AgZ2l2ZW4gcmVhZGVyLCBieXRlcywgc3VjY2Vzc1N0ZXBzLCBhbmQgZmFpbHVyZVN0ZXBzLlxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaXMtbG9jYWxcbiAqIEBwYXJhbSB7VVJMfSB1cmxcbiAqL1xuZnVuY3Rpb24gdXJsSXNMb2NhbCAodXJsKSB7XG4gIGFzc2VydCgncHJvdG9jb2wnIGluIHVybCkgLy8gZW5zdXJlIGl0J3MgYSB1cmwgb2JqZWN0XG5cbiAgY29uc3QgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2xcblxuICByZXR1cm4gcHJvdG9jb2wgPT09ICdhYm91dDonIHx8IHByb3RvY29sID09PSAnYmxvYjonIHx8IHByb3RvY29sID09PSAnZGF0YTonXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8VVJMfSB1cmxcbiAqL1xuZnVuY3Rpb24gdXJsSGFzSHR0cHNTY2hlbWUgKHVybCkge1xuICBpZiAodHlwZW9mIHVybCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOicpXG4gIH1cblxuICByZXR1cm4gdXJsLnByb3RvY29sID09PSAnaHR0cHM6J1xufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtc2NoZW1lXG4gKiBAcGFyYW0ge1VSTH0gdXJsXG4gKi9cbmZ1bmN0aW9uIHVybElzSHR0cEh0dHBzU2NoZW1lICh1cmwpIHtcbiAgYXNzZXJ0KCdwcm90b2NvbCcgaW4gdXJsKSAvLyBlbnN1cmUgaXQncyBhIHVybCBvYmplY3RcblxuICBjb25zdCBwcm90b2NvbCA9IHVybC5wcm90b2NvbFxuXG4gIHJldHVybiBwcm90b2NvbCA9PT0gJ2h0dHA6JyB8fCBwcm90b2NvbCA9PT0gJ2h0dHBzOidcbn1cblxuLyoqXG4gKiBGZXRjaCBzdXBwb3J0cyBub2RlID49IDE2LjguMCwgYnV0IE9iamVjdC5oYXNPd24gd2FzIGFkZGVkIGluIHYxNi45LjAuXG4gKi9cbmNvbnN0IGhhc093biA9IE9iamVjdC5oYXNPd24gfHwgKChkaWN0LCBrZXkpID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkaWN0LCBrZXkpKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBYm9ydGVkLFxuICBpc0NhbmNlbGxlZCxcbiAgY3JlYXRlRGVmZXJyZWRQcm9taXNlLFxuICBSZWFkYWJsZVN0cmVhbUZyb20sXG4gIHRvVVNWU3RyaW5nLFxuICB0cnlVcGdyYWRlUmVxdWVzdFRvQVBvdGVudGlhbGx5VHJ1c3R3b3J0aHlVUkwsXG4gIGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lLFxuICBkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyLFxuICBtYWtlUG9saWN5Q29udGFpbmVyLFxuICBjbG9uZVBvbGljeUNvbnRhaW5lcixcbiAgYXBwZW5kRmV0Y2hNZXRhZGF0YSxcbiAgYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlcixcbiAgVEFPQ2hlY2ssXG4gIGNvcnNDaGVjayxcbiAgY3Jvc3NPcmlnaW5SZXNvdXJjZVBvbGljeUNoZWNrLFxuICBjcmVhdGVPcGFxdWVUaW1pbmdJbmZvLFxuICBzZXRSZXF1ZXN0UmVmZXJyZXJQb2xpY3lPblJlZGlyZWN0LFxuICBpc1ZhbGlkSFRUUFRva2VuLFxuICByZXF1ZXN0QmFkUG9ydCxcbiAgcmVxdWVzdEN1cnJlbnRVUkwsXG4gIHJlc3BvbnNlVVJMLFxuICByZXNwb25zZUxvY2F0aW9uVVJMLFxuICBpc0Jsb2JMaWtlLFxuICBpc1VSTFBvdGVudGlhbGx5VHJ1c3R3b3J0aHksXG4gIGlzVmFsaWRSZWFzb25QaHJhc2UsXG4gIHNhbWVPcmlnaW4sXG4gIG5vcm1hbGl6ZU1ldGhvZCxcbiAgc2VyaWFsaXplSmF2YXNjcmlwdFZhbHVlVG9KU09OU3RyaW5nLFxuICBtYWtlSXRlcmF0b3IsXG4gIGlzVmFsaWRIZWFkZXJOYW1lLFxuICBpc1ZhbGlkSGVhZGVyVmFsdWUsXG4gIGhhc093bixcbiAgaXNFcnJvckxpa2UsXG4gIGZ1bGx5UmVhZEJvZHksXG4gIGJ5dGVzTWF0Y2gsXG4gIGlzUmVhZGFibGVTdHJlYW1MaWtlLFxuICByZWFkYWJsZVN0cmVhbUNsb3NlLFxuICBpc29tb3JwaGljRW5jb2RlLFxuICBpc29tb3JwaGljRGVjb2RlLFxuICB1cmxJc0xvY2FsLFxuICB1cmxIYXNIdHRwc1NjaGVtZSxcbiAgdXJsSXNIdHRwSHR0cHNTY2hlbWUsXG4gIHJlYWRBbGxCeXRlcyxcbiAgbm9ybWFsaXplTWV0aG9kUmVjb3JkXG59XG4iXSwibmFtZXMiOlsicmVkaXJlY3RTdGF0dXNTZXQiLCJyZWZlcnJlclBvbGljeVNldCIsInJlZmVycmVyUG9saWN5VG9rZW5zIiwiYmFkUG9ydHNTZXQiLCJyZXF1aXJlIiwiZ2V0R2xvYmFsT3JpZ2luIiwicGVyZm9ybWFuY2UiLCJpc0Jsb2JMaWtlIiwidG9VU1ZTdHJpbmciLCJSZWFkYWJsZVN0cmVhbUZyb20iLCJhc3NlcnQiLCJpc1VpbnQ4QXJyYXkiLCJjcnlwdG8iLCJyZXNwb25zZVVSTCIsInJlc3BvbnNlIiwidXJsTGlzdCIsImxlbmd0aCIsInRvU3RyaW5nIiwicmVzcG9uc2VMb2NhdGlvblVSTCIsInJlcXVlc3RGcmFnbWVudCIsImhhcyIsInN0YXR1cyIsImxvY2F0aW9uIiwiaGVhZGVyc0xpc3QiLCJnZXQiLCJpc1ZhbGlkSGVhZGVyVmFsdWUiLCJVUkwiLCJoYXNoIiwicmVxdWVzdEN1cnJlbnRVUkwiLCJyZXF1ZXN0IiwicmVxdWVzdEJhZFBvcnQiLCJ1cmwiLCJ1cmxJc0h0dHBIdHRwc1NjaGVtZSIsInBvcnQiLCJpc0Vycm9yTGlrZSIsIm9iamVjdCIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiaXNWYWxpZFJlYXNvblBocmFzZSIsInN0YXR1c1RleHQiLCJpIiwiYyIsImNoYXJDb2RlQXQiLCJpc1Rva2VuQ2hhckNvZGUiLCJpc1ZhbGlkSFRUUFRva2VuIiwiY2hhcmFjdGVycyIsImlzVmFsaWRIZWFkZXJOYW1lIiwicG90ZW50aWFsVmFsdWUiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJpbmNsdWRlcyIsInNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3QiLCJhY3R1YWxSZXNwb25zZSIsInBvbGljeUhlYWRlciIsInNwbGl0IiwicG9saWN5IiwidG9rZW4iLCJ0cmltIiwicmVmZXJyZXJQb2xpY3kiLCJjcm9zc09yaWdpblJlc291cmNlUG9saWN5Q2hlY2siLCJjb3JzQ2hlY2siLCJUQU9DaGVjayIsImFwcGVuZEZldGNoTWV0YWRhdGEiLCJodHRwUmVxdWVzdCIsImhlYWRlciIsIm1vZGUiLCJzZXQiLCJhcHBlbmRSZXF1ZXN0T3JpZ2luSGVhZGVyIiwic2VyaWFsaXplZE9yaWdpbiIsIm9yaWdpbiIsInJlc3BvbnNlVGFpbnRpbmciLCJhcHBlbmQiLCJtZXRob2QiLCJ1cmxIYXNIdHRwc1NjaGVtZSIsInNhbWVPcmlnaW4iLCJjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZSIsImNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5Iiwibm93IiwiY3JlYXRlT3BhcXVlVGltaW5nSW5mbyIsInRpbWluZ0luZm8iLCJzdGFydFRpbWUiLCJyZWRpcmVjdFN0YXJ0VGltZSIsInJlZGlyZWN0RW5kVGltZSIsInBvc3RSZWRpcmVjdFN0YXJ0VGltZSIsImZpbmFsU2VydmljZVdvcmtlclN0YXJ0VGltZSIsImZpbmFsTmV0d29ya1Jlc3BvbnNlU3RhcnRUaW1lIiwiZmluYWxOZXR3b3JrUmVxdWVzdFN0YXJ0VGltZSIsImVuZFRpbWUiLCJlbmNvZGVkQm9keVNpemUiLCJkZWNvZGVkQm9keVNpemUiLCJmaW5hbENvbm5lY3Rpb25UaW1pbmdJbmZvIiwibWFrZVBvbGljeUNvbnRhaW5lciIsImNsb25lUG9saWN5Q29udGFpbmVyIiwicG9saWN5Q29udGFpbmVyIiwiZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlciIsInJlZmVycmVyU291cmNlIiwicmVmZXJyZXIiLCJnbG9iYWxPcmlnaW4iLCJyZWZlcnJlclVSTCIsInN0cmlwVVJMRm9yUmVmZXJyZXIiLCJyZWZlcnJlck9yaWdpbiIsImFyZVNhbWVPcmlnaW4iLCJpc05vblBvdGVudGlhbGx5VHJ1c3RXb3J0aHkiLCJpc1VSTFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkiLCJjdXJyZW50VVJMIiwib3JpZ2luT25seSIsInByb3RvY29sIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsInBhdGhuYW1lIiwic2VhcmNoIiwiaHJlZiIsImlzT3JpZ2luUG90ZW50aWFsbHlUcnVzdHdvcnRoeSIsIm9yaWdpbkFzVVJMIiwidGVzdCIsImhvc3RuYW1lIiwiYnl0ZXNNYXRjaCIsImJ5dGVzIiwibWV0YWRhdGFMaXN0IiwidW5kZWZpbmVkIiwicGFyc2VkTWV0YWRhdGEiLCJwYXJzZU1ldGFkYXRhIiwibGlzdCIsInNvcnQiLCJkIiwiYWxnbyIsImxvY2FsZUNvbXBhcmUiLCJzdHJvbmdlc3QiLCJtZXRhZGF0YSIsImZpbHRlciIsIml0ZW0iLCJhbGdvcml0aG0iLCJleHBlY3RlZFZhbHVlIiwic2xpY2UiLCJhY3R1YWxWYWx1ZSIsImNyZWF0ZUhhc2giLCJ1cGRhdGUiLCJkaWdlc3QiLCJhY3R1YWxCYXNlNjRVUkwiLCJwYXJzZUhhc2hXaXRoT3B0aW9ucyIsInJlc3VsdCIsImVtcHR5Iiwic3VwcG9ydGVkSGFzaGVzIiwiZ2V0SGFzaGVzIiwicGFyc2VkVG9rZW4iLCJleGVjIiwiZ3JvdXBzIiwidG9Mb3dlckNhc2UiLCJwdXNoIiwidHJ5VXBncmFkZVJlcXVlc3RUb0FQb3RlbnRpYWxseVRydXN0d29ydGh5VVJMIiwiQSIsIkIiLCJjcmVhdGVEZWZlcnJlZFByb21pc2UiLCJyZXMiLCJyZWoiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJpc0Fib3J0ZWQiLCJmZXRjaFBhcmFtcyIsImNvbnRyb2xsZXIiLCJzdGF0ZSIsImlzQ2FuY2VsbGVkIiwibm9ybWFsaXplTWV0aG9kUmVjb3JkIiwiZGVsZXRlIiwiREVMRVRFIiwiR0VUIiwiaGVhZCIsIkhFQUQiLCJvcHRpb25zIiwiT1BUSU9OUyIsInBvc3QiLCJQT1NUIiwicHV0IiwiUFVUIiwiT2JqZWN0Iiwic2V0UHJvdG90eXBlT2YiLCJub3JtYWxpemVNZXRob2QiLCJzZXJpYWxpemVKYXZhc2NyaXB0VmFsdWVUb0pTT05TdHJpbmciLCJ2YWx1ZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJUeXBlRXJyb3IiLCJlc0l0ZXJhdG9yUHJvdG90eXBlIiwiZ2V0UHJvdG90eXBlT2YiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm1ha2VJdGVyYXRvciIsImtpbmQiLCJpbmRleCIsInRhcmdldCIsIm5leHQiLCJ2YWx1ZXMiLCJsZW4iLCJkb25lIiwicGFpciIsIml0ZXJhdG9yUmVzdWx0IiwidG9TdHJpbmdUYWciLCJmdWxseVJlYWRCb2R5IiwiYm9keSIsInByb2Nlc3NCb2R5IiwicHJvY2Vzc0JvZHlFcnJvciIsInN1Y2Nlc3NTdGVwcyIsImVycm9yU3RlcHMiLCJyZWFkZXIiLCJzdHJlYW0iLCJnZXRSZWFkZXIiLCJlIiwicmVhZEFsbEJ5dGVzIiwiUmVhZGFibGVTdHJlYW0iLCJnbG9iYWxUaGlzIiwiaXNSZWFkYWJsZVN0cmVhbUxpa2UiLCJ0ZWUiLCJNQVhJTVVNX0FSR1VNRU5UX0xFTkdUSCIsImlzb21vcnBoaWNEZWNvZGUiLCJpbnB1dCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInJlZHVjZSIsInByZXZpb3VzIiwiY3VycmVudCIsInJlYWRhYmxlU3RyZWFtQ2xvc2UiLCJjbG9zZSIsImVyciIsIm1lc3NhZ2UiLCJpc29tb3JwaGljRW5jb2RlIiwiYnl0ZUxlbmd0aCIsImNodW5rIiwicmVhZCIsIkJ1ZmZlciIsImNvbmNhdCIsInVybElzTG9jYWwiLCJoYXNPd24iLCJkaWN0Iiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/webidl.js":
/*!***********************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/fetch/webidl.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { types } = __webpack_require__(/*! util */ \"util\");\nconst { hasOwn, toUSVString } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/util.js\");\n/** @type {import('../../types/webidl').Webidl} */ const webidl = {};\nwebidl.converters = {};\nwebidl.util = {};\nwebidl.errors = {};\nwebidl.errors.exception = function(message) {\n    return new TypeError(`${message.header}: ${message.message}`);\n};\nwebidl.errors.conversionFailed = function(context) {\n    const plural = context.types.length === 1 ? \"\" : \" one of\";\n    const message = `${context.argument} could not be converted to` + `${plural}: ${context.types.join(\", \")}.`;\n    return webidl.errors.exception({\n        header: context.prefix,\n        message\n    });\n};\nwebidl.errors.invalidArgument = function(context) {\n    return webidl.errors.exception({\n        header: context.prefix,\n        message: `\"${context.value}\" is an invalid ${context.type}.`\n    });\n};\n// https://webidl.spec.whatwg.org/#implements\nwebidl.brandCheck = function(V, I, opts = undefined) {\n    if (opts?.strict !== false && !(V instanceof I)) {\n        throw new TypeError(\"Illegal invocation\");\n    } else {\n        return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];\n    }\n};\nwebidl.argumentLengthCheck = function({ length }, min, ctx) {\n    if (length < min) {\n        throw webidl.errors.exception({\n            message: `${min} argument${min !== 1 ? \"s\" : \"\"} required, ` + `but${length ? \" only\" : \"\"} ${length} found.`,\n            ...ctx\n        });\n    }\n};\nwebidl.illegalConstructor = function() {\n    throw webidl.errors.exception({\n        header: \"TypeError\",\n        message: \"Illegal constructor\"\n    });\n};\n// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values\nwebidl.util.Type = function(V) {\n    switch(typeof V){\n        case \"undefined\":\n            return \"Undefined\";\n        case \"boolean\":\n            return \"Boolean\";\n        case \"string\":\n            return \"String\";\n        case \"symbol\":\n            return \"Symbol\";\n        case \"number\":\n            return \"Number\";\n        case \"bigint\":\n            return \"BigInt\";\n        case \"function\":\n        case \"object\":\n            {\n                if (V === null) {\n                    return \"Null\";\n                }\n                return \"Object\";\n            }\n    }\n};\n// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint\nwebidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {\n    let upperBound;\n    let lowerBound;\n    // 1. If bitLength is 64, then:\n    if (bitLength === 64) {\n        // 1. Let upperBound be 2^53  1.\n        upperBound = Math.pow(2, 53) - 1;\n        // 2. If signedness is \"unsigned\", then let lowerBound be 0.\n        if (signedness === \"unsigned\") {\n            lowerBound = 0;\n        } else {\n            // 3. Otherwise let lowerBound be 2^53 + 1.\n            lowerBound = Math.pow(-2, 53) + 1;\n        }\n    } else if (signedness === \"unsigned\") {\n        // 2. Otherwise, if signedness is \"unsigned\", then:\n        // 1. Let lowerBound be 0.\n        lowerBound = 0;\n        // 2. Let upperBound be 2^bitLength  1.\n        upperBound = Math.pow(2, bitLength) - 1;\n    } else {\n        // 3. Otherwise:\n        // 1. Let lowerBound be -2^bitLength  1.\n        lowerBound = Math.pow(-2, bitLength) - 1;\n        // 2. Let upperBound be 2^bitLength  1  1.\n        upperBound = Math.pow(2, bitLength - 1) - 1;\n    }\n    // 4. Let x be ? ToNumber(V).\n    let x = Number(V);\n    // 5. If x is 0, then set x to +0.\n    if (x === 0) {\n        x = 0;\n    }\n    // 6. If the conversion is to an IDL type associated\n    //    with the [EnforceRange] extended attribute, then:\n    if (opts.enforceRange === true) {\n        // 1. If x is NaN, +, or , then throw a TypeError.\n        if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {\n            throw webidl.errors.exception({\n                header: \"Integer conversion\",\n                message: `Could not convert ${V} to an integer.`\n            });\n        }\n        // 2. Set x to IntegerPart(x).\n        x = webidl.util.IntegerPart(x);\n        // 3. If x < lowerBound or x > upperBound, then\n        //    throw a TypeError.\n        if (x < lowerBound || x > upperBound) {\n            throw webidl.errors.exception({\n                header: \"Integer conversion\",\n                message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n            });\n        }\n        // 4. Return x.\n        return x;\n    }\n    // 7. If x is not NaN and the conversion is to an IDL\n    //    type associated with the [Clamp] extended\n    //    attribute, then:\n    if (!Number.isNaN(x) && opts.clamp === true) {\n        // 1. Set x to min(max(x, lowerBound), upperBound).\n        x = Math.min(Math.max(x, lowerBound), upperBound);\n        // 2. Round x to the nearest integer, choosing the\n        //    even integer if it lies halfway between two,\n        //    and choosing +0 rather than 0.\n        if (Math.floor(x) % 2 === 0) {\n            x = Math.floor(x);\n        } else {\n            x = Math.ceil(x);\n        }\n        // 3. Return x.\n        return x;\n    }\n    // 8. If x is NaN, +0, +, or , then return +0.\n    if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {\n        return 0;\n    }\n    // 9. Set x to IntegerPart(x).\n    x = webidl.util.IntegerPart(x);\n    // 10. Set x to x modulo 2^bitLength.\n    x = x % Math.pow(2, bitLength);\n    // 11. If signedness is \"signed\" and x  2^bitLength  1,\n    //    then return x  2^bitLength.\n    if (signedness === \"signed\" && x >= Math.pow(2, bitLength) - 1) {\n        return x - Math.pow(2, bitLength);\n    }\n    // 12. Otherwise, return x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart\nwebidl.util.IntegerPart = function(n) {\n    // 1. Let r be floor(abs(n)).\n    const r = Math.floor(Math.abs(n));\n    // 2. If n < 0, then return -1  r.\n    if (n < 0) {\n        return -1 * r;\n    }\n    // 3. Otherwise, return r.\n    return r;\n};\n// https://webidl.spec.whatwg.org/#es-sequence\nwebidl.sequenceConverter = function(converter) {\n    return (V)=>{\n        // 1. If Type(V) is not Object, throw a TypeError.\n        if (webidl.util.Type(V) !== \"Object\") {\n            throw webidl.errors.exception({\n                header: \"Sequence\",\n                message: `Value of type ${webidl.util.Type(V)} is not an Object.`\n            });\n        }\n        // 2. Let method be ? GetMethod(V, @@iterator).\n        /** @type {Generator} */ const method = V?.[Symbol.iterator]?.();\n        const seq = [];\n        // 3. If method is undefined, throw a TypeError.\n        if (method === undefined || typeof method.next !== \"function\") {\n            throw webidl.errors.exception({\n                header: \"Sequence\",\n                message: \"Object is not an iterator.\"\n            });\n        }\n        // https://webidl.spec.whatwg.org/#create-sequence-from-iterable\n        while(true){\n            const { done, value } = method.next();\n            if (done) {\n                break;\n            }\n            seq.push(converter(value));\n        }\n        return seq;\n    };\n};\n// https://webidl.spec.whatwg.org/#es-to-record\nwebidl.recordConverter = function(keyConverter, valueConverter) {\n    return (O)=>{\n        // 1. If Type(O) is not Object, throw a TypeError.\n        if (webidl.util.Type(O) !== \"Object\") {\n            throw webidl.errors.exception({\n                header: \"Record\",\n                message: `Value of type ${webidl.util.Type(O)} is not an Object.`\n            });\n        }\n        // 2. Let result be a new empty instance of record<K, V>.\n        const result = {};\n        if (!types.isProxy(O)) {\n            // Object.keys only returns enumerable properties\n            const keys = Object.keys(O);\n            for (const key of keys){\n                // 1. Let typedKey be key converted to an IDL value of type K.\n                const typedKey = keyConverter(key);\n                // 2. Let value be ? Get(O, key).\n                // 3. Let typedValue be value converted to an IDL value of type V.\n                const typedValue = valueConverter(O[key]);\n                // 4. Set result[typedKey] to typedValue.\n                result[typedKey] = typedValue;\n            }\n            // 5. Return result.\n            return result;\n        }\n        // 3. Let keys be ? O.[[OwnPropertyKeys]]().\n        const keys = Reflect.ownKeys(O);\n        // 4. For each key of keys.\n        for (const key of keys){\n            // 1. Let desc be ? O.[[GetOwnProperty]](key).\n            const desc = Reflect.getOwnPropertyDescriptor(O, key);\n            // 2. If desc is not undefined and desc.[[Enumerable]] is true:\n            if (desc?.enumerable) {\n                // 1. Let typedKey be key converted to an IDL value of type K.\n                const typedKey = keyConverter(key);\n                // 2. Let value be ? Get(O, key).\n                // 3. Let typedValue be value converted to an IDL value of type V.\n                const typedValue = valueConverter(O[key]);\n                // 4. Set result[typedKey] to typedValue.\n                result[typedKey] = typedValue;\n            }\n        }\n        // 5. Return result.\n        return result;\n    };\n};\nwebidl.interfaceConverter = function(i) {\n    return (V, opts = {})=>{\n        if (opts.strict !== false && !(V instanceof i)) {\n            throw webidl.errors.exception({\n                header: i.name,\n                message: `Expected ${V} to be an instance of ${i.name}.`\n            });\n        }\n        return V;\n    };\n};\nwebidl.dictionaryConverter = function(converters) {\n    return (dictionary)=>{\n        const type = webidl.util.Type(dictionary);\n        const dict = {};\n        if (type === \"Null\" || type === \"Undefined\") {\n            return dict;\n        } else if (type !== \"Object\") {\n            throw webidl.errors.exception({\n                header: \"Dictionary\",\n                message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n            });\n        }\n        for (const options of converters){\n            const { key, defaultValue, required, converter } = options;\n            if (required === true) {\n                if (!hasOwn(dictionary, key)) {\n                    throw webidl.errors.exception({\n                        header: \"Dictionary\",\n                        message: `Missing required key \"${key}\".`\n                    });\n                }\n            }\n            let value = dictionary[key];\n            const hasDefault = hasOwn(options, \"defaultValue\");\n            // Only use defaultValue if value is undefined and\n            // a defaultValue options was provided.\n            if (hasDefault && value !== null) {\n                value = value ?? defaultValue;\n            }\n            // A key can be optional and have no default value.\n            // When this happens, do not perform a conversion,\n            // and do not assign the key a value.\n            if (required || hasDefault || value !== undefined) {\n                value = converter(value);\n                if (options.allowedValues && !options.allowedValues.includes(value)) {\n                    throw webidl.errors.exception({\n                        header: \"Dictionary\",\n                        message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(\", \")}.`\n                    });\n                }\n                dict[key] = value;\n            }\n        }\n        return dict;\n    };\n};\nwebidl.nullableConverter = function(converter) {\n    return (V)=>{\n        if (V === null) {\n            return V;\n        }\n        return converter(V);\n    };\n};\n// https://webidl.spec.whatwg.org/#es-DOMString\nwebidl.converters.DOMString = function(V, opts = {}) {\n    // 1. If V is null and the conversion is to an IDL type\n    //    associated with the [LegacyNullToEmptyString]\n    //    extended attribute, then return the DOMString value\n    //    that represents the empty string.\n    if (V === null && opts.legacyNullToEmptyString) {\n        return \"\";\n    }\n    // 2. Let x be ? ToString(V).\n    if (typeof V === \"symbol\") {\n        throw new TypeError(\"Could not convert argument of type symbol to string.\");\n    }\n    // 3. Return the IDL DOMString value that represents the\n    //    same sequence of code units as the one the\n    //    ECMAScript String value x represents.\n    return String(V);\n};\n// https://webidl.spec.whatwg.org/#es-ByteString\nwebidl.converters.ByteString = function(V) {\n    // 1. Let x be ? ToString(V).\n    // Note: DOMString converter perform ? ToString(V)\n    const x = webidl.converters.DOMString(V);\n    // 2. If the value of any element of x is greater than\n    //    255, then throw a TypeError.\n    for(let index = 0; index < x.length; index++){\n        if (x.charCodeAt(index) > 255) {\n            throw new TypeError(\"Cannot convert argument to a ByteString because the character at \" + `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`);\n        }\n    }\n    // 3. Return an IDL ByteString value whose length is the\n    //    length of x, and where the value of each element is\n    //    the value of the corresponding element of x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-USVString\nwebidl.converters.USVString = toUSVString;\n// https://webidl.spec.whatwg.org/#es-boolean\nwebidl.converters.boolean = function(V) {\n    // 1. Let x be the result of computing ToBoolean(V).\n    const x = Boolean(V);\n    // 2. Return the IDL boolean value that is the one that represents\n    //    the same truth value as the ECMAScript Boolean value x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-any\nwebidl.converters.any = function(V) {\n    return V;\n};\n// https://webidl.spec.whatwg.org/#es-long-long\nwebidl.converters[\"long long\"] = function(V) {\n    // 1. Let x be ? ConvertToInt(V, 64, \"signed\").\n    const x = webidl.util.ConvertToInt(V, 64, \"signed\");\n    // 2. Return the IDL long long value that represents\n    //    the same numeric value as x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-unsigned-long-long\nwebidl.converters[\"unsigned long long\"] = function(V) {\n    // 1. Let x be ? ConvertToInt(V, 64, \"unsigned\").\n    const x = webidl.util.ConvertToInt(V, 64, \"unsigned\");\n    // 2. Return the IDL unsigned long long value that\n    //    represents the same numeric value as x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-unsigned-long\nwebidl.converters[\"unsigned long\"] = function(V) {\n    // 1. Let x be ? ConvertToInt(V, 32, \"unsigned\").\n    const x = webidl.util.ConvertToInt(V, 32, \"unsigned\");\n    // 2. Return the IDL unsigned long value that\n    //    represents the same numeric value as x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-unsigned-short\nwebidl.converters[\"unsigned short\"] = function(V, opts) {\n    // 1. Let x be ? ConvertToInt(V, 16, \"unsigned\").\n    const x = webidl.util.ConvertToInt(V, 16, \"unsigned\", opts);\n    // 2. Return the IDL unsigned short value that represents\n    //    the same numeric value as x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#idl-ArrayBuffer\nwebidl.converters.ArrayBuffer = function(V, opts = {}) {\n    // 1. If Type(V) is not Object, or V does not have an\n    //    [[ArrayBufferData]] internal slot, then throw a\n    //    TypeError.\n    // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances\n    // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances\n    if (webidl.util.Type(V) !== \"Object\" || !types.isAnyArrayBuffer(V)) {\n        throw webidl.errors.conversionFailed({\n            prefix: `${V}`,\n            argument: `${V}`,\n            types: [\n                \"ArrayBuffer\"\n            ]\n        });\n    }\n    // 2. If the conversion is not to an IDL type associated\n    //    with the [AllowShared] extended attribute, and\n    //    IsSharedArrayBuffer(V) is true, then throw a\n    //    TypeError.\n    if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {\n        throw webidl.errors.exception({\n            header: \"ArrayBuffer\",\n            message: \"SharedArrayBuffer is not allowed.\"\n        });\n    }\n    // 3. If the conversion is not to an IDL type associated\n    //    with the [AllowResizable] extended attribute, and\n    //    IsResizableArrayBuffer(V) is true, then throw a\n    //    TypeError.\n    // Note: resizable ArrayBuffers are currently a proposal.\n    // 4. Return the IDL ArrayBuffer value that is a\n    //    reference to the same object as V.\n    return V;\n};\nwebidl.converters.TypedArray = function(V, T, opts = {}) {\n    // 1. Let T be the IDL type V is being converted to.\n    // 2. If Type(V) is not Object, or V does not have a\n    //    [[TypedArrayName]] internal slot with a value\n    //    equal to Ts name, then throw a TypeError.\n    if (webidl.util.Type(V) !== \"Object\" || !types.isTypedArray(V) || V.constructor.name !== T.name) {\n        throw webidl.errors.conversionFailed({\n            prefix: `${T.name}`,\n            argument: `${V}`,\n            types: [\n                T.name\n            ]\n        });\n    }\n    // 3. If the conversion is not to an IDL type associated\n    //    with the [AllowShared] extended attribute, and\n    //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is\n    //    true, then throw a TypeError.\n    if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n        throw webidl.errors.exception({\n            header: \"ArrayBuffer\",\n            message: \"SharedArrayBuffer is not allowed.\"\n        });\n    }\n    // 4. If the conversion is not to an IDL type associated\n    //    with the [AllowResizable] extended attribute, and\n    //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n    //    true, then throw a TypeError.\n    // Note: resizable array buffers are currently a proposal\n    // 5. Return the IDL value of type T that is a reference\n    //    to the same object as V.\n    return V;\n};\nwebidl.converters.DataView = function(V, opts = {}) {\n    // 1. If Type(V) is not Object, or V does not have a\n    //    [[DataView]] internal slot, then throw a TypeError.\n    if (webidl.util.Type(V) !== \"Object\" || !types.isDataView(V)) {\n        throw webidl.errors.exception({\n            header: \"DataView\",\n            message: \"Object is not a DataView.\"\n        });\n    }\n    // 2. If the conversion is not to an IDL type associated\n    //    with the [AllowShared] extended attribute, and\n    //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,\n    //    then throw a TypeError.\n    if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n        throw webidl.errors.exception({\n            header: \"ArrayBuffer\",\n            message: \"SharedArrayBuffer is not allowed.\"\n        });\n    }\n    // 3. If the conversion is not to an IDL type associated\n    //    with the [AllowResizable] extended attribute, and\n    //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n    //    true, then throw a TypeError.\n    // Note: resizable ArrayBuffers are currently a proposal\n    // 4. Return the IDL DataView value that is a reference\n    //    to the same object as V.\n    return V;\n};\n// https://webidl.spec.whatwg.org/#BufferSource\nwebidl.converters.BufferSource = function(V, opts = {}) {\n    if (types.isAnyArrayBuffer(V)) {\n        return webidl.converters.ArrayBuffer(V, opts);\n    }\n    if (types.isTypedArray(V)) {\n        return webidl.converters.TypedArray(V, V.constructor);\n    }\n    if (types.isDataView(V)) {\n        return webidl.converters.DataView(V, opts);\n    }\n    throw new TypeError(`Could not convert ${V} to a BufferSource.`);\n};\nwebidl.converters[\"sequence<ByteString>\"] = webidl.sequenceConverter(webidl.converters.ByteString);\nwebidl.converters[\"sequence<sequence<ByteString>>\"] = webidl.sequenceConverter(webidl.converters[\"sequence<ByteString>\"]);\nwebidl.converters[\"record<ByteString, ByteString>\"] = webidl.recordConverter(webidl.converters.ByteString, webidl.converters.ByteString);\nmodule.exports = {\n    webidl\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvd2ViaWRsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxLQUFLLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDMUIsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLFdBQVcsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUV4QyxnREFBZ0QsR0FDaEQsTUFBTUcsU0FBUyxDQUFDO0FBQ2hCQSxPQUFPQyxVQUFVLEdBQUcsQ0FBQztBQUNyQkQsT0FBT0UsSUFBSSxHQUFHLENBQUM7QUFDZkYsT0FBT0csTUFBTSxHQUFHLENBQUM7QUFFakJILE9BQU9HLE1BQU0sQ0FBQ0MsU0FBUyxHQUFHLFNBQVVDLE9BQU87SUFDekMsT0FBTyxJQUFJQyxVQUFVLENBQUMsRUFBRUQsUUFBUUUsTUFBTSxDQUFDLEVBQUUsRUFBRUYsUUFBUUEsT0FBTyxDQUFDLENBQUM7QUFDOUQ7QUFFQUwsT0FBT0csTUFBTSxDQUFDSyxnQkFBZ0IsR0FBRyxTQUFVQyxPQUFPO0lBQ2hELE1BQU1DLFNBQVNELFFBQVFiLEtBQUssQ0FBQ2UsTUFBTSxLQUFLLElBQUksS0FBSztJQUNqRCxNQUFNTixVQUNKLENBQUMsRUFBRUksUUFBUUcsUUFBUSxDQUFDLDBCQUEwQixDQUFDLEdBQy9DLENBQUMsRUFBRUYsT0FBTyxFQUFFLEVBQUVELFFBQVFiLEtBQUssQ0FBQ2lCLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUUzQyxPQUFPYixPQUFPRyxNQUFNLENBQUNDLFNBQVMsQ0FBQztRQUM3QkcsUUFBUUUsUUFBUUssTUFBTTtRQUN0QlQ7SUFDRjtBQUNGO0FBRUFMLE9BQU9HLE1BQU0sQ0FBQ1ksZUFBZSxHQUFHLFNBQVVOLE9BQU87SUFDL0MsT0FBT1QsT0FBT0csTUFBTSxDQUFDQyxTQUFTLENBQUM7UUFDN0JHLFFBQVFFLFFBQVFLLE1BQU07UUFDdEJULFNBQVMsQ0FBQyxDQUFD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Q0FBaUMsR0FBR0QsT0FBTytELGVBQWUsQ0FDMUUvRCxPQUFPQyxVQUFVLENBQUM2RixVQUFVLEVBQzVCOUYsT0FBT0MsVUFBVSxDQUFDNkYsVUFBVTtBQUc5Qm1CLE9BQU9DLE9BQU8sR0FBRztJQUNmbEg7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL3dlYmlkbC5qcz9jZDVjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHR5cGVzIH0gPSByZXF1aXJlKCd1dGlsJylcbmNvbnN0IHsgaGFzT3duLCB0b1VTVlN0cmluZyB9ID0gcmVxdWlyZSgnLi91dGlsJylcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4uLy4uL3R5cGVzL3dlYmlkbCcpLldlYmlkbH0gKi9cbmNvbnN0IHdlYmlkbCA9IHt9XG53ZWJpZGwuY29udmVydGVycyA9IHt9XG53ZWJpZGwudXRpbCA9IHt9XG53ZWJpZGwuZXJyb3JzID0ge31cblxud2ViaWRsLmVycm9ycy5leGNlcHRpb24gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihgJHttZXNzYWdlLmhlYWRlcn06ICR7bWVzc2FnZS5tZXNzYWdlfWApXG59XG5cbndlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIGNvbnN0IHBsdXJhbCA9IGNvbnRleHQudHlwZXMubGVuZ3RoID09PSAxID8gJycgOiAnIG9uZSBvZidcbiAgY29uc3QgbWVzc2FnZSA9XG4gICAgYCR7Y29udGV4dC5hcmd1bWVudH0gY291bGQgbm90IGJlIGNvbnZlcnRlZCB0b2AgK1xuICAgIGAke3BsdXJhbH06ICR7Y29udGV4dC50eXBlcy5qb2luKCcsICcpfS5gXG5cbiAgcmV0dXJuIHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICBoZWFkZXI6IGNvbnRleHQucHJlZml4LFxuICAgIG1lc3NhZ2VcbiAgfSlcbn1cblxud2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICByZXR1cm4gd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgIGhlYWRlcjogY29udGV4dC5wcmVmaXgsXG4gICAgbWVzc2FnZTogYFwiJHtjb250ZXh0LnZhbHVlfVwiIGlzIGFuIGludmFsaWQgJHtjb250ZXh0LnR5cGV9LmBcbiAgfSlcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNpbXBsZW1lbnRzXG53ZWJpZGwuYnJhbmRDaGVjayA9IGZ1bmN0aW9uIChWLCBJLCBvcHRzID0gdW5kZWZpbmVkKSB7XG4gIGlmIChvcHRzPy5zdHJpY3QgIT09IGZhbHNlICYmICEoViBpbnN0YW5jZW9mIEkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBpbnZvY2F0aW9uJylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gVj8uW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09IEkucHJvdG90eXBlW1N5bWJvbC50b1N0cmluZ1RhZ11cbiAgfVxufVxuXG53ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayA9IGZ1bmN0aW9uICh7IGxlbmd0aCB9LCBtaW4sIGN0eCkge1xuICBpZiAobGVuZ3RoIDwgbWluKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgbWVzc2FnZTogYCR7bWlufSBhcmd1bWVudCR7bWluICE9PSAxID8gJ3MnIDogJyd9IHJlcXVpcmVkLCBgICtcbiAgICAgICAgICAgICAgIGBidXQke2xlbmd0aCA/ICcgb25seScgOiAnJ30gJHtsZW5ndGh9IGZvdW5kLmAsXG4gICAgICAuLi5jdHhcbiAgICB9KVxuICB9XG59XG5cbndlYmlkbC5pbGxlZ2FsQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICBoZWFkZXI6ICdUeXBlRXJyb3InLFxuICAgIG1lc3NhZ2U6ICdJbGxlZ2FsIGNvbnN0cnVjdG9yJ1xuICB9KVxufVxuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWVjbWFzY3JpcHQtZGF0YS10eXBlcy1hbmQtdmFsdWVzXG53ZWJpZGwudXRpbC5UeXBlID0gZnVuY3Rpb24gKFYpIHtcbiAgc3dpdGNoICh0eXBlb2YgVikge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6IHJldHVybiAnVW5kZWZpbmVkJ1xuICAgIGNhc2UgJ2Jvb2xlYW4nOiByZXR1cm4gJ0Jvb2xlYW4nXG4gICAgY2FzZSAnc3RyaW5nJzogcmV0dXJuICdTdHJpbmcnXG4gICAgY2FzZSAnc3ltYm9sJzogcmV0dXJuICdTeW1ib2wnXG4gICAgY2FzZSAnbnVtYmVyJzogcmV0dXJuICdOdW1iZXInXG4gICAgY2FzZSAnYmlnaW50JzogcmV0dXJuICdCaWdJbnQnXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgIGNhc2UgJ29iamVjdCc6IHtcbiAgICAgIGlmIChWID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnTnVsbCdcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdPYmplY3QnXG4gICAgfVxuICB9XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jYWJzdHJhY3Qtb3BkZWYtY29udmVydHRvaW50XG53ZWJpZGwudXRpbC5Db252ZXJ0VG9JbnQgPSBmdW5jdGlvbiAoViwgYml0TGVuZ3RoLCBzaWduZWRuZXNzLCBvcHRzID0ge30pIHtcbiAgbGV0IHVwcGVyQm91bmRcbiAgbGV0IGxvd2VyQm91bmRcblxuICAvLyAxLiBJZiBiaXRMZW5ndGggaXMgNjQsIHRoZW46XG4gIGlmIChiaXRMZW5ndGggPT09IDY0KSB7XG4gICAgLy8gMS4gTGV0IHVwcGVyQm91bmQgYmUgMl41MyDiiJIgMS5cbiAgICB1cHBlckJvdW5kID0gTWF0aC5wb3coMiwgNTMpIC0gMVxuXG4gICAgLy8gMi4gSWYgc2lnbmVkbmVzcyBpcyBcInVuc2lnbmVkXCIsIHRoZW4gbGV0IGxvd2VyQm91bmQgYmUgMC5cbiAgICBpZiAoc2lnbmVkbmVzcyA9PT0gJ3Vuc2lnbmVkJykge1xuICAgICAgbG93ZXJCb3VuZCA9IDBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMy4gT3RoZXJ3aXNlIGxldCBsb3dlckJvdW5kIGJlIOKIkjJeNTMgKyAxLlxuICAgICAgbG93ZXJCb3VuZCA9IE1hdGgucG93KC0yLCA1MykgKyAxXG4gICAgfVxuICB9IGVsc2UgaWYgKHNpZ25lZG5lc3MgPT09ICd1bnNpZ25lZCcpIHtcbiAgICAvLyAyLiBPdGhlcndpc2UsIGlmIHNpZ25lZG5lc3MgaXMgXCJ1bnNpZ25lZFwiLCB0aGVuOlxuXG4gICAgLy8gMS4gTGV0IGxvd2VyQm91bmQgYmUgMC5cbiAgICBsb3dlckJvdW5kID0gMFxuXG4gICAgLy8gMi4gTGV0IHVwcGVyQm91bmQgYmUgMl5iaXRMZW5ndGgg4oiSIDEuXG4gICAgdXBwZXJCb3VuZCA9IE1hdGgucG93KDIsIGJpdExlbmd0aCkgLSAxXG4gIH0gZWxzZSB7XG4gICAgLy8gMy4gT3RoZXJ3aXNlOlxuXG4gICAgLy8gMS4gTGV0IGxvd2VyQm91bmQgYmUgLTJeYml0TGVuZ3RoIOKIkiAxLlxuICAgIGxvd2VyQm91bmQgPSBNYXRoLnBvdygtMiwgYml0TGVuZ3RoKSAtIDFcblxuICAgIC8vIDIuIExldCB1cHBlckJvdW5kIGJlIDJeYml0TGVuZ3RoIOKIkiAxIOKIkiAxLlxuICAgIHVwcGVyQm91bmQgPSBNYXRoLnBvdygyLCBiaXRMZW5ndGggLSAxKSAtIDFcbiAgfVxuXG4gIC8vIDQuIExldCB4IGJlID8gVG9OdW1iZXIoVikuXG4gIGxldCB4ID0gTnVtYmVyKFYpXG5cbiAgLy8gNS4gSWYgeCBpcyDiiJIwLCB0aGVuIHNldCB4IHRvICswLlxuICBpZiAoeCA9PT0gMCkge1xuICAgIHggPSAwXG4gIH1cblxuICAvLyA2LiBJZiB0aGUgY29udmVyc2lvbiBpcyB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtFbmZvcmNlUmFuZ2VdIGV4dGVuZGVkIGF0dHJpYnV0ZSwgdGhlbjpcbiAgaWYgKG9wdHMuZW5mb3JjZVJhbmdlID09PSB0cnVlKSB7XG4gICAgLy8gMS4gSWYgeCBpcyBOYU4sICviiJ4sIG9yIOKIkuKIniwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoXG4gICAgICBOdW1iZXIuaXNOYU4oeCkgfHxcbiAgICAgIHggPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB8fFxuICAgICAgeCA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4gICAgKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ0ludGVnZXIgY29udmVyc2lvbicsXG4gICAgICAgIG1lc3NhZ2U6IGBDb3VsZCBub3QgY29udmVydCAke1Z9IHRvIGFuIGludGVnZXIuYFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBTZXQgeCB0byBJbnRlZ2VyUGFydCh4KS5cbiAgICB4ID0gd2ViaWRsLnV0aWwuSW50ZWdlclBhcnQoeClcblxuICAgIC8vIDMuIElmIHggPCBsb3dlckJvdW5kIG9yIHggPiB1cHBlckJvdW5kLCB0aGVuXG4gICAgLy8gICAgdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKHggPCBsb3dlckJvdW5kIHx8IHggPiB1cHBlckJvdW5kKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ0ludGVnZXIgY29udmVyc2lvbicsXG4gICAgICAgIG1lc3NhZ2U6IGBWYWx1ZSBtdXN0IGJlIGJldHdlZW4gJHtsb3dlckJvdW5kfS0ke3VwcGVyQm91bmR9LCBnb3QgJHt4fS5gXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDQuIFJldHVybiB4LlxuICAgIHJldHVybiB4XG4gIH1cblxuICAvLyA3LiBJZiB4IGlzIG5vdCBOYU4gYW5kIHRoZSBjb252ZXJzaW9uIGlzIHRvIGFuIElETFxuICAvLyAgICB0eXBlIGFzc29jaWF0ZWQgd2l0aCB0aGUgW0NsYW1wXSBleHRlbmRlZFxuICAvLyAgICBhdHRyaWJ1dGUsIHRoZW46XG4gIGlmICghTnVtYmVyLmlzTmFOKHgpICYmIG9wdHMuY2xhbXAgPT09IHRydWUpIHtcbiAgICAvLyAxLiBTZXQgeCB0byBtaW4obWF4KHgsIGxvd2VyQm91bmQpLCB1cHBlckJvdW5kKS5cbiAgICB4ID0gTWF0aC5taW4oTWF0aC5tYXgoeCwgbG93ZXJCb3VuZCksIHVwcGVyQm91bmQpXG5cbiAgICAvLyAyLiBSb3VuZCB4IHRvIHRoZSBuZWFyZXN0IGludGVnZXIsIGNob29zaW5nIHRoZVxuICAgIC8vICAgIGV2ZW4gaW50ZWdlciBpZiBpdCBsaWVzIGhhbGZ3YXkgYmV0d2VlbiB0d28sXG4gICAgLy8gICAgYW5kIGNob29zaW5nICswIHJhdGhlciB0aGFuIOKIkjAuXG4gICAgaWYgKE1hdGguZmxvb3IoeCkgJSAyID09PSAwKSB7XG4gICAgICB4ID0gTWF0aC5mbG9vcih4KVxuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gTWF0aC5jZWlsKHgpXG4gICAgfVxuXG4gICAgLy8gMy4gUmV0dXJuIHguXG4gICAgcmV0dXJuIHhcbiAgfVxuXG4gIC8vIDguIElmIHggaXMgTmFOLCArMCwgK+KIniwgb3Ig4oiS4oieLCB0aGVuIHJldHVybiArMC5cbiAgaWYgKFxuICAgIE51bWJlci5pc05hTih4KSB8fFxuICAgICh4ID09PSAwICYmIE9iamVjdC5pcygwLCB4KSkgfHxcbiAgICB4ID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHxcbiAgICB4ID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcbiAgKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIC8vIDkuIFNldCB4IHRvIEludGVnZXJQYXJ0KHgpLlxuICB4ID0gd2ViaWRsLnV0aWwuSW50ZWdlclBhcnQoeClcblxuICAvLyAxMC4gU2V0IHggdG8geCBtb2R1bG8gMl5iaXRMZW5ndGguXG4gIHggPSB4ICUgTWF0aC5wb3coMiwgYml0TGVuZ3RoKVxuXG4gIC8vIDExLiBJZiBzaWduZWRuZXNzIGlzIFwic2lnbmVkXCIgYW5kIHgg4omlIDJeYml0TGVuZ3RoIOKIkiAxLFxuICAvLyAgICB0aGVuIHJldHVybiB4IOKIkiAyXmJpdExlbmd0aC5cbiAgaWYgKHNpZ25lZG5lc3MgPT09ICdzaWduZWQnICYmIHggPj0gTWF0aC5wb3coMiwgYml0TGVuZ3RoKSAtIDEpIHtcbiAgICByZXR1cm4geCAtIE1hdGgucG93KDIsIGJpdExlbmd0aClcbiAgfVxuXG4gIC8vIDEyLiBPdGhlcndpc2UsIHJldHVybiB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2Fic3RyYWN0LW9wZGVmLWludGVnZXJwYXJ0XG53ZWJpZGwudXRpbC5JbnRlZ2VyUGFydCA9IGZ1bmN0aW9uIChuKSB7XG4gIC8vIDEuIExldCByIGJlIGZsb29yKGFicyhuKSkuXG4gIGNvbnN0IHIgPSBNYXRoLmZsb29yKE1hdGguYWJzKG4pKVxuXG4gIC8vIDIuIElmIG4gPCAwLCB0aGVuIHJldHVybiAtMSDDlyByLlxuICBpZiAobiA8IDApIHtcbiAgICByZXR1cm4gLTEgKiByXG4gIH1cblxuICAvLyAzLiBPdGhlcndpc2UsIHJldHVybiByLlxuICByZXR1cm4gclxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLXNlcXVlbmNlXG53ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoY29udmVydGVyKSB7XG4gIHJldHVybiAoVikgPT4ge1xuICAgIC8vIDEuIElmIFR5cGUoVikgaXMgbm90IE9iamVjdCwgdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgIT09ICdPYmplY3QnKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ1NlcXVlbmNlJyxcbiAgICAgICAgbWVzc2FnZTogYFZhbHVlIG9mIHR5cGUgJHt3ZWJpZGwudXRpbC5UeXBlKFYpfSBpcyBub3QgYW4gT2JqZWN0LmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gTGV0IG1ldGhvZCBiZSA/IEdldE1ldGhvZChWLCBAQGl0ZXJhdG9yKS5cbiAgICAvKiogQHR5cGUge0dlbmVyYXRvcn0gKi9cbiAgICBjb25zdCBtZXRob2QgPSBWPy5bU3ltYm9sLml0ZXJhdG9yXT8uKClcbiAgICBjb25zdCBzZXEgPSBbXVxuXG4gICAgLy8gMy4gSWYgbWV0aG9kIGlzIHVuZGVmaW5lZCwgdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKFxuICAgICAgbWV0aG9kID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHR5cGVvZiBtZXRob2QubmV4dCAhPT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6ICdTZXF1ZW5jZScsXG4gICAgICAgIG1lc3NhZ2U6ICdPYmplY3QgaXMgbm90IGFuIGl0ZXJhdG9yLidcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNjcmVhdGUtc2VxdWVuY2UtZnJvbS1pdGVyYWJsZVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBtZXRob2QubmV4dCgpXG5cbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIHNlcS5wdXNoKGNvbnZlcnRlcih2YWx1ZSkpXG4gICAgfVxuXG4gICAgcmV0dXJuIHNlcVxuICB9XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtdG8tcmVjb3JkXG53ZWJpZGwucmVjb3JkQ29udmVydGVyID0gZnVuY3Rpb24gKGtleUNvbnZlcnRlciwgdmFsdWVDb252ZXJ0ZXIpIHtcbiAgcmV0dXJuIChPKSA9PiB7XG4gICAgLy8gMS4gSWYgVHlwZShPKSBpcyBub3QgT2JqZWN0LCB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAod2ViaWRsLnV0aWwuVHlwZShPKSAhPT0gJ09iamVjdCcpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnUmVjb3JkJyxcbiAgICAgICAgbWVzc2FnZTogYFZhbHVlIG9mIHR5cGUgJHt3ZWJpZGwudXRpbC5UeXBlKE8pfSBpcyBub3QgYW4gT2JqZWN0LmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gTGV0IHJlc3VsdCBiZSBhIG5ldyBlbXB0eSBpbnN0YW5jZSBvZiByZWNvcmQ8SywgVj4uXG4gICAgY29uc3QgcmVzdWx0ID0ge31cblxuICAgIGlmICghdHlwZXMuaXNQcm94eShPKSkge1xuICAgICAgLy8gT2JqZWN0LmtleXMgb25seSByZXR1cm5zIGVudW1lcmFibGUgcHJvcGVydGllc1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKE8pXG5cbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgLy8gMS4gTGV0IHR5cGVkS2V5IGJlIGtleSBjb252ZXJ0ZWQgdG8gYW4gSURMIHZhbHVlIG9mIHR5cGUgSy5cbiAgICAgICAgY29uc3QgdHlwZWRLZXkgPSBrZXlDb252ZXJ0ZXIoa2V5KVxuXG4gICAgICAgIC8vIDIuIExldCB2YWx1ZSBiZSA/IEdldChPLCBrZXkpLlxuICAgICAgICAvLyAzLiBMZXQgdHlwZWRWYWx1ZSBiZSB2YWx1ZSBjb252ZXJ0ZWQgdG8gYW4gSURMIHZhbHVlIG9mIHR5cGUgVi5cbiAgICAgICAgY29uc3QgdHlwZWRWYWx1ZSA9IHZhbHVlQ29udmVydGVyKE9ba2V5XSlcblxuICAgICAgICAvLyA0LiBTZXQgcmVzdWx0W3R5cGVkS2V5XSB0byB0eXBlZFZhbHVlLlxuICAgICAgICByZXN1bHRbdHlwZWRLZXldID0gdHlwZWRWYWx1ZVxuICAgICAgfVxuXG4gICAgICAvLyA1LiBSZXR1cm4gcmVzdWx0LlxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIC8vIDMuIExldCBrZXlzIGJlID8gTy5bW093blByb3BlcnR5S2V5c11dKCkuXG4gICAgY29uc3Qga2V5cyA9IFJlZmxlY3Qub3duS2V5cyhPKVxuXG4gICAgLy8gNC4gRm9yIGVhY2gga2V5IG9mIGtleXMuXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgLy8gMS4gTGV0IGRlc2MgYmUgPyBPLltbR2V0T3duUHJvcGVydHldXShrZXkpLlxuICAgICAgY29uc3QgZGVzYyA9IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIGtleSlcblxuICAgICAgLy8gMi4gSWYgZGVzYyBpcyBub3QgdW5kZWZpbmVkIGFuZCBkZXNjLltbRW51bWVyYWJsZV1dIGlzIHRydWU6XG4gICAgICBpZiAoZGVzYz8uZW51bWVyYWJsZSkge1xuICAgICAgICAvLyAxLiBMZXQgdHlwZWRLZXkgYmUga2V5IGNvbnZlcnRlZCB0byBhbiBJREwgdmFsdWUgb2YgdHlwZSBLLlxuICAgICAgICBjb25zdCB0eXBlZEtleSA9IGtleUNvbnZlcnRlcihrZXkpXG5cbiAgICAgICAgLy8gMi4gTGV0IHZhbHVlIGJlID8gR2V0KE8sIGtleSkuXG4gICAgICAgIC8vIDMuIExldCB0eXBlZFZhbHVlIGJlIHZhbHVlIGNvbnZlcnRlZCB0byBhbiBJREwgdmFsdWUgb2YgdHlwZSBWLlxuICAgICAgICBjb25zdCB0eXBlZFZhbHVlID0gdmFsdWVDb252ZXJ0ZXIoT1trZXldKVxuXG4gICAgICAgIC8vIDQuIFNldCByZXN1bHRbdHlwZWRLZXldIHRvIHR5cGVkVmFsdWUuXG4gICAgICAgIHJlc3VsdFt0eXBlZEtleV0gPSB0eXBlZFZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNS4gUmV0dXJuIHJlc3VsdC5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxud2ViaWRsLmludGVyZmFjZUNvbnZlcnRlciA9IGZ1bmN0aW9uIChpKSB7XG4gIHJldHVybiAoViwgb3B0cyA9IHt9KSA9PiB7XG4gICAgaWYgKG9wdHMuc3RyaWN0ICE9PSBmYWxzZSAmJiAhKFYgaW5zdGFuY2VvZiBpKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6IGkubmFtZSxcbiAgICAgICAgbWVzc2FnZTogYEV4cGVjdGVkICR7Vn0gdG8gYmUgYW4gaW5zdGFuY2Ugb2YgJHtpLm5hbWV9LmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIFZcbiAgfVxufVxuXG53ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlciA9IGZ1bmN0aW9uIChjb252ZXJ0ZXJzKSB7XG4gIHJldHVybiAoZGljdGlvbmFyeSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSB3ZWJpZGwudXRpbC5UeXBlKGRpY3Rpb25hcnkpXG4gICAgY29uc3QgZGljdCA9IHt9XG5cbiAgICBpZiAodHlwZSA9PT0gJ051bGwnIHx8IHR5cGUgPT09ICdVbmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZGljdFxuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gJ09iamVjdCcpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnRGljdGlvbmFyeScsXG4gICAgICAgIG1lc3NhZ2U6IGBFeHBlY3RlZCAke2RpY3Rpb25hcnl9IHRvIGJlIG9uZSBvZjogTnVsbCwgVW5kZWZpbmVkLCBPYmplY3QuYFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2YgY29udmVydGVycykge1xuICAgICAgY29uc3QgeyBrZXksIGRlZmF1bHRWYWx1ZSwgcmVxdWlyZWQsIGNvbnZlcnRlciB9ID0gb3B0aW9uc1xuXG4gICAgICBpZiAocmVxdWlyZWQgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKCFoYXNPd24oZGljdGlvbmFyeSwga2V5KSkge1xuICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgIGhlYWRlcjogJ0RpY3Rpb25hcnknLFxuICAgICAgICAgICAgbWVzc2FnZTogYE1pc3NpbmcgcmVxdWlyZWQga2V5IFwiJHtrZXl9XCIuYFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IHZhbHVlID0gZGljdGlvbmFyeVtrZXldXG4gICAgICBjb25zdCBoYXNEZWZhdWx0ID0gaGFzT3duKG9wdGlvbnMsICdkZWZhdWx0VmFsdWUnKVxuXG4gICAgICAvLyBPbmx5IHVzZSBkZWZhdWx0VmFsdWUgaWYgdmFsdWUgaXMgdW5kZWZpbmVkIGFuZFxuICAgICAgLy8gYSBkZWZhdWx0VmFsdWUgb3B0aW9ucyB3YXMgcHJvdmlkZWQuXG4gICAgICBpZiAoaGFzRGVmYXVsdCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID8/IGRlZmF1bHRWYWx1ZVxuICAgICAgfVxuXG4gICAgICAvLyBBIGtleSBjYW4gYmUgb3B0aW9uYWwgYW5kIGhhdmUgbm8gZGVmYXVsdCB2YWx1ZS5cbiAgICAgIC8vIFdoZW4gdGhpcyBoYXBwZW5zLCBkbyBub3QgcGVyZm9ybSBhIGNvbnZlcnNpb24sXG4gICAgICAvLyBhbmQgZG8gbm90IGFzc2lnbiB0aGUga2V5IGEgdmFsdWUuXG4gICAgICBpZiAocmVxdWlyZWQgfHwgaGFzRGVmYXVsdCB8fCB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlID0gY29udmVydGVyKHZhbHVlKVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBvcHRpb25zLmFsbG93ZWRWYWx1ZXMgJiZcbiAgICAgICAgICAhb3B0aW9ucy5hbGxvd2VkVmFsdWVzLmluY2x1ZGVzKHZhbHVlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICBoZWFkZXI6ICdEaWN0aW9uYXJ5JyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGAke3ZhbHVlfSBpcyBub3QgYW4gYWNjZXB0ZWQgdHlwZS4gRXhwZWN0ZWQgb25lIG9mICR7b3B0aW9ucy5hbGxvd2VkVmFsdWVzLmpvaW4oJywgJyl9LmBcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgZGljdFtrZXldID0gdmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGljdFxuICB9XG59XG5cbndlYmlkbC5udWxsYWJsZUNvbnZlcnRlciA9IGZ1bmN0aW9uIChjb252ZXJ0ZXIpIHtcbiAgcmV0dXJuIChWKSA9PiB7XG4gICAgaWYgKFYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBWXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnZlcnRlcihWKVxuICB9XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtRE9NU3RyaW5nXG53ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcgPSBmdW5jdGlvbiAoViwgb3B0cyA9IHt9KSB7XG4gIC8vIDEuIElmIFYgaXMgbnVsbCBhbmQgdGhlIGNvbnZlcnNpb24gaXMgdG8gYW4gSURMIHR5cGVcbiAgLy8gICAgYXNzb2NpYXRlZCB3aXRoIHRoZSBbTGVnYWN5TnVsbFRvRW1wdHlTdHJpbmddXG4gIC8vICAgIGV4dGVuZGVkIGF0dHJpYnV0ZSwgdGhlbiByZXR1cm4gdGhlIERPTVN0cmluZyB2YWx1ZVxuICAvLyAgICB0aGF0IHJlcHJlc2VudHMgdGhlIGVtcHR5IHN0cmluZy5cbiAgaWYgKFYgPT09IG51bGwgJiYgb3B0cy5sZWdhY3lOdWxsVG9FbXB0eVN0cmluZykge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gMi4gTGV0IHggYmUgPyBUb1N0cmluZyhWKS5cbiAgaWYgKHR5cGVvZiBWID09PSAnc3ltYm9sJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGFyZ3VtZW50IG9mIHR5cGUgc3ltYm9sIHRvIHN0cmluZy4nKVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIHRoZSBJREwgRE9NU3RyaW5nIHZhbHVlIHRoYXQgcmVwcmVzZW50cyB0aGVcbiAgLy8gICAgc2FtZSBzZXF1ZW5jZSBvZiBjb2RlIHVuaXRzIGFzIHRoZSBvbmUgdGhlXG4gIC8vICAgIEVDTUFTY3JpcHQgU3RyaW5nIHZhbHVlIHggcmVwcmVzZW50cy5cbiAgcmV0dXJuIFN0cmluZyhWKVxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLUJ5dGVTdHJpbmdcbndlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcgPSBmdW5jdGlvbiAoVikge1xuICAvLyAxLiBMZXQgeCBiZSA/IFRvU3RyaW5nKFYpLlxuICAvLyBOb3RlOiBET01TdHJpbmcgY29udmVydGVyIHBlcmZvcm0gPyBUb1N0cmluZyhWKVxuICBjb25zdCB4ID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKFYpXG5cbiAgLy8gMi4gSWYgdGhlIHZhbHVlIG9mIGFueSBlbGVtZW50IG9mIHggaXMgZ3JlYXRlciB0aGFuXG4gIC8vICAgIDI1NSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHgubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgaWYgKHguY2hhckNvZGVBdChpbmRleCkgPiAyNTUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdDYW5ub3QgY29udmVydCBhcmd1bWVudCB0byBhIEJ5dGVTdHJpbmcgYmVjYXVzZSB0aGUgY2hhcmFjdGVyIGF0ICcgK1xuICAgICAgICBgaW5kZXggJHtpbmRleH0gaGFzIGEgdmFsdWUgb2YgJHt4LmNoYXJDb2RlQXQoaW5kZXgpfSB3aGljaCBpcyBncmVhdGVyIHRoYW4gMjU1LmBcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAvLyAzLiBSZXR1cm4gYW4gSURMIEJ5dGVTdHJpbmcgdmFsdWUgd2hvc2UgbGVuZ3RoIGlzIHRoZVxuICAvLyAgICBsZW5ndGggb2YgeCwgYW5kIHdoZXJlIHRoZSB2YWx1ZSBvZiBlYWNoIGVsZW1lbnQgaXNcbiAgLy8gICAgdGhlIHZhbHVlIG9mIHRoZSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgb2YgeC5cbiAgcmV0dXJuIHhcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1VU1ZTdHJpbmdcbndlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyA9IHRvVVNWU3RyaW5nXG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtYm9vbGVhblxud2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbiA9IGZ1bmN0aW9uIChWKSB7XG4gIC8vIDEuIExldCB4IGJlIHRoZSByZXN1bHQgb2YgY29tcHV0aW5nIFRvQm9vbGVhbihWKS5cbiAgY29uc3QgeCA9IEJvb2xlYW4oVilcblxuICAvLyAyLiBSZXR1cm4gdGhlIElETCBib29sZWFuIHZhbHVlIHRoYXQgaXMgdGhlIG9uZSB0aGF0IHJlcHJlc2VudHNcbiAgLy8gICAgdGhlIHNhbWUgdHJ1dGggdmFsdWUgYXMgdGhlIEVDTUFTY3JpcHQgQm9vbGVhbiB2YWx1ZSB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLWFueVxud2ViaWRsLmNvbnZlcnRlcnMuYW55ID0gZnVuY3Rpb24gKFYpIHtcbiAgcmV0dXJuIFZcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1sb25nLWxvbmdcbndlYmlkbC5jb252ZXJ0ZXJzWydsb25nIGxvbmcnXSA9IGZ1bmN0aW9uIChWKSB7XG4gIC8vIDEuIExldCB4IGJlID8gQ29udmVydFRvSW50KFYsIDY0LCBcInNpZ25lZFwiKS5cbiAgY29uc3QgeCA9IHdlYmlkbC51dGlsLkNvbnZlcnRUb0ludChWLCA2NCwgJ3NpZ25lZCcpXG5cbiAgLy8gMi4gUmV0dXJuIHRoZSBJREwgbG9uZyBsb25nIHZhbHVlIHRoYXQgcmVwcmVzZW50c1xuICAvLyAgICB0aGUgc2FtZSBudW1lcmljIHZhbHVlIGFzIHguXG4gIHJldHVybiB4XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtdW5zaWduZWQtbG9uZy1sb25nXG53ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyBsb25nJ10gPSBmdW5jdGlvbiAoVikge1xuICAvLyAxLiBMZXQgeCBiZSA/IENvbnZlcnRUb0ludChWLCA2NCwgXCJ1bnNpZ25lZFwiKS5cbiAgY29uc3QgeCA9IHdlYmlkbC51dGlsLkNvbnZlcnRUb0ludChWLCA2NCwgJ3Vuc2lnbmVkJylcblxuICAvLyAyLiBSZXR1cm4gdGhlIElETCB1bnNpZ25lZCBsb25nIGxvbmcgdmFsdWUgdGhhdFxuICAvLyAgICByZXByZXNlbnRzIHRoZSBzYW1lIG51bWVyaWMgdmFsdWUgYXMgeC5cbiAgcmV0dXJuIHhcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy11bnNpZ25lZC1sb25nXG53ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyddID0gZnVuY3Rpb24gKFYpIHtcbiAgLy8gMS4gTGV0IHggYmUgPyBDb252ZXJ0VG9JbnQoViwgMzIsIFwidW5zaWduZWRcIikuXG4gIGNvbnN0IHggPSB3ZWJpZGwudXRpbC5Db252ZXJ0VG9JbnQoViwgMzIsICd1bnNpZ25lZCcpXG5cbiAgLy8gMi4gUmV0dXJuIHRoZSBJREwgdW5zaWduZWQgbG9uZyB2YWx1ZSB0aGF0XG4gIC8vICAgIHJlcHJlc2VudHMgdGhlIHNhbWUgbnVtZXJpYyB2YWx1ZSBhcyB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLXVuc2lnbmVkLXNob3J0XG53ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgc2hvcnQnXSA9IGZ1bmN0aW9uIChWLCBvcHRzKSB7XG4gIC8vIDEuIExldCB4IGJlID8gQ29udmVydFRvSW50KFYsIDE2LCBcInVuc2lnbmVkXCIpLlxuICBjb25zdCB4ID0gd2ViaWRsLnV0aWwuQ29udmVydFRvSW50KFYsIDE2LCAndW5zaWduZWQnLCBvcHRzKVxuXG4gIC8vIDIuIFJldHVybiB0aGUgSURMIHVuc2lnbmVkIHNob3J0IHZhbHVlIHRoYXQgcmVwcmVzZW50c1xuICAvLyAgICB0aGUgc2FtZSBudW1lcmljIHZhbHVlIGFzIHguXG4gIHJldHVybiB4XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jaWRsLUFycmF5QnVmZmVyXG53ZWJpZGwuY29udmVydGVycy5BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIChWLCBvcHRzID0ge30pIHtcbiAgLy8gMS4gSWYgVHlwZShWKSBpcyBub3QgT2JqZWN0LCBvciBWIGRvZXMgbm90IGhhdmUgYW5cbiAgLy8gICAgW1tBcnJheUJ1ZmZlckRhdGFdXSBpbnRlcm5hbCBzbG90LCB0aGVuIHRocm93IGFcbiAgLy8gICAgVHlwZUVycm9yLlxuICAvLyBzZWU6IGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvcGVydGllcy1vZi10aGUtYXJyYXlidWZmZXItaW5zdGFuY2VzXG4gIC8vIHNlZTogaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1zaGFyZWRhcnJheWJ1ZmZlci1pbnN0YW5jZXNcbiAgaWYgKFxuICAgIHdlYmlkbC51dGlsLlR5cGUoVikgIT09ICdPYmplY3QnIHx8XG4gICAgIXR5cGVzLmlzQW55QXJyYXlCdWZmZXIoVilcbiAgKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtcbiAgICAgIHByZWZpeDogYCR7Vn1gLFxuICAgICAgYXJndW1lbnQ6IGAke1Z9YCxcbiAgICAgIHR5cGVzOiBbJ0FycmF5QnVmZmVyJ11cbiAgICB9KVxuICB9XG5cbiAgLy8gMi4gSWYgdGhlIGNvbnZlcnNpb24gaXMgbm90IHRvIGFuIElETCB0eXBlIGFzc29jaWF0ZWRcbiAgLy8gICAgd2l0aCB0aGUgW0FsbG93U2hhcmVkXSBleHRlbmRlZCBhdHRyaWJ1dGUsIGFuZFxuICAvLyAgICBJc1NoYXJlZEFycmF5QnVmZmVyKFYpIGlzIHRydWUsIHRoZW4gdGhyb3cgYVxuICAvLyAgICBUeXBlRXJyb3IuXG4gIGlmIChvcHRzLmFsbG93U2hhcmVkID09PSBmYWxzZSAmJiB0eXBlcy5pc1NoYXJlZEFycmF5QnVmZmVyKFYpKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgaGVhZGVyOiAnQXJyYXlCdWZmZXInLFxuICAgICAgbWVzc2FnZTogJ1NoYXJlZEFycmF5QnVmZmVyIGlzIG5vdCBhbGxvd2VkLidcbiAgICB9KVxuICB9XG5cbiAgLy8gMy4gSWYgdGhlIGNvbnZlcnNpb24gaXMgbm90IHRvIGFuIElETCB0eXBlIGFzc29jaWF0ZWRcbiAgLy8gICAgd2l0aCB0aGUgW0FsbG93UmVzaXphYmxlXSBleHRlbmRlZCBhdHRyaWJ1dGUsIGFuZFxuICAvLyAgICBJc1Jlc2l6YWJsZUFycmF5QnVmZmVyKFYpIGlzIHRydWUsIHRoZW4gdGhyb3cgYVxuICAvLyAgICBUeXBlRXJyb3IuXG4gIC8vIE5vdGU6IHJlc2l6YWJsZSBBcnJheUJ1ZmZlcnMgYXJlIGN1cnJlbnRseSBhIHByb3Bvc2FsLlxuXG4gIC8vIDQuIFJldHVybiB0aGUgSURMIEFycmF5QnVmZmVyIHZhbHVlIHRoYXQgaXMgYVxuICAvLyAgICByZWZlcmVuY2UgdG8gdGhlIHNhbWUgb2JqZWN0IGFzIFYuXG4gIHJldHVybiBWXG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLlR5cGVkQXJyYXkgPSBmdW5jdGlvbiAoViwgVCwgb3B0cyA9IHt9KSB7XG4gIC8vIDEuIExldCBUIGJlIHRoZSBJREwgdHlwZSBWIGlzIGJlaW5nIGNvbnZlcnRlZCB0by5cblxuICAvLyAyLiBJZiBUeXBlKFYpIGlzIG5vdCBPYmplY3QsIG9yIFYgZG9lcyBub3QgaGF2ZSBhXG4gIC8vICAgIFtbVHlwZWRBcnJheU5hbWVdXSBpbnRlcm5hbCBzbG90IHdpdGggYSB2YWx1ZVxuICAvLyAgICBlcXVhbCB0byBU4oCZcyBuYW1lLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICBpZiAoXG4gICAgd2ViaWRsLnV0aWwuVHlwZShWKSAhPT0gJ09iamVjdCcgfHxcbiAgICAhdHlwZXMuaXNUeXBlZEFycmF5KFYpIHx8XG4gICAgVi5jb25zdHJ1Y3Rvci5uYW1lICE9PSBULm5hbWVcbiAgKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtcbiAgICAgIHByZWZpeDogYCR7VC5uYW1lfWAsXG4gICAgICBhcmd1bWVudDogYCR7Vn1gLFxuICAgICAgdHlwZXM6IFtULm5hbWVdXG4gICAgfSlcbiAgfVxuXG4gIC8vIDMuIElmIHRoZSBjb252ZXJzaW9uIGlzIG5vdCB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtBbGxvd1NoYXJlZF0gZXh0ZW5kZWQgYXR0cmlidXRlLCBhbmRcbiAgLy8gICAgSXNTaGFyZWRBcnJheUJ1ZmZlcihWLltbVmlld2VkQXJyYXlCdWZmZXJdXSkgaXNcbiAgLy8gICAgdHJ1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKG9wdHMuYWxsb3dTaGFyZWQgPT09IGZhbHNlICYmIHR5cGVzLmlzU2hhcmVkQXJyYXlCdWZmZXIoVi5idWZmZXIpKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgaGVhZGVyOiAnQXJyYXlCdWZmZXInLFxuICAgICAgbWVzc2FnZTogJ1NoYXJlZEFycmF5QnVmZmVyIGlzIG5vdCBhbGxvd2VkLidcbiAgICB9KVxuICB9XG5cbiAgLy8gNC4gSWYgdGhlIGNvbnZlcnNpb24gaXMgbm90IHRvIGFuIElETCB0eXBlIGFzc29jaWF0ZWRcbiAgLy8gICAgd2l0aCB0aGUgW0FsbG93UmVzaXphYmxlXSBleHRlbmRlZCBhdHRyaWJ1dGUsIGFuZFxuICAvLyAgICBJc1Jlc2l6YWJsZUFycmF5QnVmZmVyKFYuW1tWaWV3ZWRBcnJheUJ1ZmZlcl1dKSBpc1xuICAvLyAgICB0cnVlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAvLyBOb3RlOiByZXNpemFibGUgYXJyYXkgYnVmZmVycyBhcmUgY3VycmVudGx5IGEgcHJvcG9zYWxcblxuICAvLyA1LiBSZXR1cm4gdGhlIElETCB2YWx1ZSBvZiB0eXBlIFQgdGhhdCBpcyBhIHJlZmVyZW5jZVxuICAvLyAgICB0byB0aGUgc2FtZSBvYmplY3QgYXMgVi5cbiAgcmV0dXJuIFZcbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuRGF0YVZpZXcgPSBmdW5jdGlvbiAoViwgb3B0cyA9IHt9KSB7XG4gIC8vIDEuIElmIFR5cGUoVikgaXMgbm90IE9iamVjdCwgb3IgViBkb2VzIG5vdCBoYXZlIGFcbiAgLy8gICAgW1tEYXRhVmlld11dIGludGVybmFsIHNsb3QsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGlmICh3ZWJpZGwudXRpbC5UeXBlKFYpICE9PSAnT2JqZWN0JyB8fCAhdHlwZXMuaXNEYXRhVmlldyhWKSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIGhlYWRlcjogJ0RhdGFWaWV3JyxcbiAgICAgIG1lc3NhZ2U6ICdPYmplY3QgaXMgbm90IGEgRGF0YVZpZXcuJ1xuICAgIH0pXG4gIH1cblxuICAvLyAyLiBJZiB0aGUgY29udmVyc2lvbiBpcyBub3QgdG8gYW4gSURMIHR5cGUgYXNzb2NpYXRlZFxuICAvLyAgICB3aXRoIHRoZSBbQWxsb3dTaGFyZWRdIGV4dGVuZGVkIGF0dHJpYnV0ZSwgYW5kXG4gIC8vICAgIElzU2hhcmVkQXJyYXlCdWZmZXIoVi5bW1ZpZXdlZEFycmF5QnVmZmVyXV0pIGlzIHRydWUsXG4gIC8vICAgIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGlmIChvcHRzLmFsbG93U2hhcmVkID09PSBmYWxzZSAmJiB0eXBlcy5pc1NoYXJlZEFycmF5QnVmZmVyKFYuYnVmZmVyKSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIGhlYWRlcjogJ0FycmF5QnVmZmVyJyxcbiAgICAgIG1lc3NhZ2U6ICdTaGFyZWRBcnJheUJ1ZmZlciBpcyBub3QgYWxsb3dlZC4nXG4gICAgfSlcbiAgfVxuXG4gIC8vIDMuIElmIHRoZSBjb252ZXJzaW9uIGlzIG5vdCB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtBbGxvd1Jlc2l6YWJsZV0gZXh0ZW5kZWQgYXR0cmlidXRlLCBhbmRcbiAgLy8gICAgSXNSZXNpemFibGVBcnJheUJ1ZmZlcihWLltbVmlld2VkQXJyYXlCdWZmZXJdXSkgaXNcbiAgLy8gICAgdHJ1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgLy8gTm90ZTogcmVzaXphYmxlIEFycmF5QnVmZmVycyBhcmUgY3VycmVudGx5IGEgcHJvcG9zYWxcblxuICAvLyA0LiBSZXR1cm4gdGhlIElETCBEYXRhVmlldyB2YWx1ZSB0aGF0IGlzIGEgcmVmZXJlbmNlXG4gIC8vICAgIHRvIHRoZSBzYW1lIG9iamVjdCBhcyBWLlxuICByZXR1cm4gVlxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI0J1ZmZlclNvdXJjZVxud2ViaWRsLmNvbnZlcnRlcnMuQnVmZmVyU291cmNlID0gZnVuY3Rpb24gKFYsIG9wdHMgPSB7fSkge1xuICBpZiAodHlwZXMuaXNBbnlBcnJheUJ1ZmZlcihWKSkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5BcnJheUJ1ZmZlcihWLCBvcHRzKVxuICB9XG5cbiAgaWYgKHR5cGVzLmlzVHlwZWRBcnJheShWKSkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5UeXBlZEFycmF5KFYsIFYuY29uc3RydWN0b3IpXG4gIH1cblxuICBpZiAodHlwZXMuaXNEYXRhVmlldyhWKSkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5EYXRhVmlldyhWLCBvcHRzKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ291bGQgbm90IGNvbnZlcnQgJHtWfSB0byBhIEJ1ZmZlclNvdXJjZS5gKVxufVxuXG53ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8Qnl0ZVN0cmluZz4nXSA9IHdlYmlkbC5zZXF1ZW5jZUNvbnZlcnRlcihcbiAgd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZ1xuKVxuXG53ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8c2VxdWVuY2U8Qnl0ZVN0cmluZz4+J10gPSB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIoXG4gIHdlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxCeXRlU3RyaW5nPiddXG4pXG5cbndlYmlkbC5jb252ZXJ0ZXJzWydyZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz4nXSA9IHdlYmlkbC5yZWNvcmRDb252ZXJ0ZXIoXG4gIHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcsXG4gIHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmdcbilcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHdlYmlkbFxufVxuIl0sIm5hbWVzIjpbInR5cGVzIiwicmVxdWlyZSIsImhhc093biIsInRvVVNWU3RyaW5nIiwid2ViaWRsIiwiY29udmVydGVycyIsInV0aWwiLCJlcnJvcnMiLCJleGNlcHRpb24iLCJtZXNzYWdlIiwiVHlwZUVycm9yIiwiaGVhZGVyIiwiY29udmVyc2lvbkZhaWxlZCIsImNvbnRleHQiLCJwbHVyYWwiLCJsZW5ndGgiLCJhcmd1bWVudCIsImpvaW4iLCJwcmVmaXgiLCJpbnZhbGlkQXJndW1lbnQiLCJ2YWx1ZSIsInR5cGUiLCJicmFuZENoZWNrIiwiViIsIkkiLCJvcHRzIiwidW5kZWZpbmVkIiwic3RyaWN0IiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJwcm90b3R5cGUiLCJhcmd1bWVudExlbmd0aENoZWNrIiwibWluIiwiY3R4IiwiaWxsZWdhbENvbnN0cnVjdG9yIiwiVHlwZSIsIkNvbnZlcnRUb0ludCIsImJpdExlbmd0aCIsInNpZ25lZG5lc3MiLCJ1cHBlckJvdW5kIiwibG93ZXJCb3VuZCIsIk1hdGgiLCJwb3ciLCJ4IiwiTnVtYmVyIiwiZW5mb3JjZVJhbmdlIiwiaXNOYU4iLCJQT1NJVElWRV9JTkZJTklUWSIsIk5FR0FUSVZFX0lORklOSVRZIiwiSW50ZWdlclBhcnQiLCJjbGFtcCIsIm1heCIsImZsb29yIiwiY2VpbCIsIk9iamVjdCIsImlzIiwibiIsInIiLCJhYnMiLCJzZXF1ZW5jZUNvbnZlcnRlciIsImNvbnZlcnRlciIsIm1ldGhvZCIsIml0ZXJhdG9yIiwic2VxIiwibmV4dCIsImRvbmUiLCJwdXNoIiwicmVjb3JkQ29udmVydGVyIiwia2V5Q29udmVydGVyIiwidmFsdWVDb252ZXJ0ZXIiLCJPIiwicmVzdWx0IiwiaXNQcm94eSIsImtleXMiLCJrZXkiLCJ0eXBlZEtleSIsInR5cGVkVmFsdWUiLCJSZWZsZWN0Iiwib3duS2V5cyIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiaW50ZXJmYWNlQ29udmVydGVyIiwiaSIsIm5hbWUiLCJkaWN0aW9uYXJ5Q29udmVydGVyIiwiZGljdGlvbmFyeSIsImRpY3QiLCJvcHRpb25zIiwiZGVmYXVsdFZhbHVlIiwicmVxdWlyZWQiLCJoYXNEZWZhdWx0IiwiYWxsb3dlZFZhbHVlcyIsImluY2x1ZGVzIiwibnVsbGFibGVDb252ZXJ0ZXIiLCJET01TdHJpbmciLCJsZWdhY3lOdWxsVG9FbXB0eVN0cmluZyIsIlN0cmluZyIsIkJ5dGVTdHJpbmciLCJpbmRleCIsImNoYXJDb2RlQXQiLCJVU1ZTdHJpbmciLCJib29sZWFuIiwiQm9vbGVhbiIsImFueSIsIkFycmF5QnVmZmVyIiwiaXNBbnlBcnJheUJ1ZmZlciIsImFsbG93U2hhcmVkIiwiaXNTaGFyZWRBcnJheUJ1ZmZlciIsIlR5cGVkQXJyYXkiLCJUIiwiaXNUeXBlZEFycmF5IiwiY29uc3RydWN0b3IiLCJidWZmZXIiLCJEYXRhVmlldyIsImlzRGF0YVZpZXciLCJCdWZmZXJTb3VyY2UiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/webidl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/fileapi/encoding.js":
/*!***************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/fileapi/encoding.js ***!
  \***************************************************************************/
/***/ ((module) => {

eval("\n/**\n * @see https://encoding.spec.whatwg.org/#concept-encoding-get\n * @param {string|undefined} label\n */ function getEncoding(label) {\n    if (!label) {\n        return \"failure\";\n    }\n    // 1. Remove any leading and trailing ASCII whitespace from label.\n    // 2. If label is an ASCII case-insensitive match for any of the\n    //    labels listed in the table below, then return the\n    //    corresponding encoding; otherwise return failure.\n    switch(label.trim().toLowerCase()){\n        case \"unicode-1-1-utf-8\":\n        case \"unicode11utf8\":\n        case \"unicode20utf8\":\n        case \"utf-8\":\n        case \"utf8\":\n        case \"x-unicode20utf8\":\n            return \"UTF-8\";\n        case \"866\":\n        case \"cp866\":\n        case \"csibm866\":\n        case \"ibm866\":\n            return \"IBM866\";\n        case \"csisolatin2\":\n        case \"iso-8859-2\":\n        case \"iso-ir-101\":\n        case \"iso8859-2\":\n        case \"iso88592\":\n        case \"iso_8859-2\":\n        case \"iso_8859-2:1987\":\n        case \"l2\":\n        case \"latin2\":\n            return \"ISO-8859-2\";\n        case \"csisolatin3\":\n        case \"iso-8859-3\":\n        case \"iso-ir-109\":\n        case \"iso8859-3\":\n        case \"iso88593\":\n        case \"iso_8859-3\":\n        case \"iso_8859-3:1988\":\n        case \"l3\":\n        case \"latin3\":\n            return \"ISO-8859-3\";\n        case \"csisolatin4\":\n        case \"iso-8859-4\":\n        case \"iso-ir-110\":\n        case \"iso8859-4\":\n        case \"iso88594\":\n        case \"iso_8859-4\":\n        case \"iso_8859-4:1988\":\n        case \"l4\":\n        case \"latin4\":\n            return \"ISO-8859-4\";\n        case \"csisolatincyrillic\":\n        case \"cyrillic\":\n        case \"iso-8859-5\":\n        case \"iso-ir-144\":\n        case \"iso8859-5\":\n        case \"iso88595\":\n        case \"iso_8859-5\":\n        case \"iso_8859-5:1988\":\n            return \"ISO-8859-5\";\n        case \"arabic\":\n        case \"asmo-708\":\n        case \"csiso88596e\":\n        case \"csiso88596i\":\n        case \"csisolatinarabic\":\n        case \"ecma-114\":\n        case \"iso-8859-6\":\n        case \"iso-8859-6-e\":\n        case \"iso-8859-6-i\":\n        case \"iso-ir-127\":\n        case \"iso8859-6\":\n        case \"iso88596\":\n        case \"iso_8859-6\":\n        case \"iso_8859-6:1987\":\n            return \"ISO-8859-6\";\n        case \"csisolatingreek\":\n        case \"ecma-118\":\n        case \"elot_928\":\n        case \"greek\":\n        case \"greek8\":\n        case \"iso-8859-7\":\n        case \"iso-ir-126\":\n        case \"iso8859-7\":\n        case \"iso88597\":\n        case \"iso_8859-7\":\n        case \"iso_8859-7:1987\":\n        case \"sun_eu_greek\":\n            return \"ISO-8859-7\";\n        case \"csiso88598e\":\n        case \"csisolatinhebrew\":\n        case \"hebrew\":\n        case \"iso-8859-8\":\n        case \"iso-8859-8-e\":\n        case \"iso-ir-138\":\n        case \"iso8859-8\":\n        case \"iso88598\":\n        case \"iso_8859-8\":\n        case \"iso_8859-8:1988\":\n        case \"visual\":\n            return \"ISO-8859-8\";\n        case \"csiso88598i\":\n        case \"iso-8859-8-i\":\n        case \"logical\":\n            return \"ISO-8859-8-I\";\n        case \"csisolatin6\":\n        case \"iso-8859-10\":\n        case \"iso-ir-157\":\n        case \"iso8859-10\":\n        case \"iso885910\":\n        case \"l6\":\n        case \"latin6\":\n            return \"ISO-8859-10\";\n        case \"iso-8859-13\":\n        case \"iso8859-13\":\n        case \"iso885913\":\n            return \"ISO-8859-13\";\n        case \"iso-8859-14\":\n        case \"iso8859-14\":\n        case \"iso885914\":\n            return \"ISO-8859-14\";\n        case \"csisolatin9\":\n        case \"iso-8859-15\":\n        case \"iso8859-15\":\n        case \"iso885915\":\n        case \"iso_8859-15\":\n        case \"l9\":\n            return \"ISO-8859-15\";\n        case \"iso-8859-16\":\n            return \"ISO-8859-16\";\n        case \"cskoi8r\":\n        case \"koi\":\n        case \"koi8\":\n        case \"koi8-r\":\n        case \"koi8_r\":\n            return \"KOI8-R\";\n        case \"koi8-ru\":\n        case \"koi8-u\":\n            return \"KOI8-U\";\n        case \"csmacintosh\":\n        case \"mac\":\n        case \"macintosh\":\n        case \"x-mac-roman\":\n            return \"macintosh\";\n        case \"iso-8859-11\":\n        case \"iso8859-11\":\n        case \"iso885911\":\n        case \"tis-620\":\n        case \"windows-874\":\n            return \"windows-874\";\n        case \"cp1250\":\n        case \"windows-1250\":\n        case \"x-cp1250\":\n            return \"windows-1250\";\n        case \"cp1251\":\n        case \"windows-1251\":\n        case \"x-cp1251\":\n            return \"windows-1251\";\n        case \"ansi_x3.4-1968\":\n        case \"ascii\":\n        case \"cp1252\":\n        case \"cp819\":\n        case \"csisolatin1\":\n        case \"ibm819\":\n        case \"iso-8859-1\":\n        case \"iso-ir-100\":\n        case \"iso8859-1\":\n        case \"iso88591\":\n        case \"iso_8859-1\":\n        case \"iso_8859-1:1987\":\n        case \"l1\":\n        case \"latin1\":\n        case \"us-ascii\":\n        case \"windows-1252\":\n        case \"x-cp1252\":\n            return \"windows-1252\";\n        case \"cp1253\":\n        case \"windows-1253\":\n        case \"x-cp1253\":\n            return \"windows-1253\";\n        case \"cp1254\":\n        case \"csisolatin5\":\n        case \"iso-8859-9\":\n        case \"iso-ir-148\":\n        case \"iso8859-9\":\n        case \"iso88599\":\n        case \"iso_8859-9\":\n        case \"iso_8859-9:1989\":\n        case \"l5\":\n        case \"latin5\":\n        case \"windows-1254\":\n        case \"x-cp1254\":\n            return \"windows-1254\";\n        case \"cp1255\":\n        case \"windows-1255\":\n        case \"x-cp1255\":\n            return \"windows-1255\";\n        case \"cp1256\":\n        case \"windows-1256\":\n        case \"x-cp1256\":\n            return \"windows-1256\";\n        case \"cp1257\":\n        case \"windows-1257\":\n        case \"x-cp1257\":\n            return \"windows-1257\";\n        case \"cp1258\":\n        case \"windows-1258\":\n        case \"x-cp1258\":\n            return \"windows-1258\";\n        case \"x-mac-cyrillic\":\n        case \"x-mac-ukrainian\":\n            return \"x-mac-cyrillic\";\n        case \"chinese\":\n        case \"csgb2312\":\n        case \"csiso58gb231280\":\n        case \"gb2312\":\n        case \"gb_2312\":\n        case \"gb_2312-80\":\n        case \"gbk\":\n        case \"iso-ir-58\":\n        case \"x-gbk\":\n            return \"GBK\";\n        case \"gb18030\":\n            return \"gb18030\";\n        case \"big5\":\n        case \"big5-hkscs\":\n        case \"cn-big5\":\n        case \"csbig5\":\n        case \"x-x-big5\":\n            return \"Big5\";\n        case \"cseucpkdfmtjapanese\":\n        case \"euc-jp\":\n        case \"x-euc-jp\":\n            return \"EUC-JP\";\n        case \"csiso2022jp\":\n        case \"iso-2022-jp\":\n            return \"ISO-2022-JP\";\n        case \"csshiftjis\":\n        case \"ms932\":\n        case \"ms_kanji\":\n        case \"shift-jis\":\n        case \"shift_jis\":\n        case \"sjis\":\n        case \"windows-31j\":\n        case \"x-sjis\":\n            return \"Shift_JIS\";\n        case \"cseuckr\":\n        case \"csksc56011987\":\n        case \"euc-kr\":\n        case \"iso-ir-149\":\n        case \"korean\":\n        case \"ks_c_5601-1987\":\n        case \"ks_c_5601-1989\":\n        case \"ksc5601\":\n        case \"ksc_5601\":\n        case \"windows-949\":\n            return \"EUC-KR\";\n        case \"csiso2022kr\":\n        case \"hz-gb-2312\":\n        case \"iso-2022-cn\":\n        case \"iso-2022-cn-ext\":\n        case \"iso-2022-kr\":\n        case \"replacement\":\n            return \"replacement\";\n        case \"unicodefffe\":\n        case \"utf-16be\":\n            return \"UTF-16BE\";\n        case \"csunicode\":\n        case \"iso-10646-ucs-2\":\n        case \"ucs-2\":\n        case \"unicode\":\n        case \"unicodefeff\":\n        case \"utf-16\":\n        case \"utf-16le\":\n            return \"UTF-16LE\";\n        case \"x-user-defined\":\n            return \"x-user-defined\";\n        default:\n            return \"failure\";\n    }\n}\nmodule.exports = {\n    getEncoding\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmlsZWFwaS9lbmNvZGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBOzs7Q0FHQyxHQUNELFNBQVNBLFlBQWFDLEtBQUs7SUFDekIsSUFBSSxDQUFDQSxPQUFPO1FBQ1YsT0FBTztJQUNUO0lBRUEsa0VBQWtFO0lBQ2xFLGdFQUFnRTtJQUNoRSx1REFBdUQ7SUFDdkQsdURBQXVEO0lBQ3ZELE9BQVFBLE1BQU1DLElBQUksR0FBR0MsV0FBVztRQUM5QixLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVDtZQUFTLE9BQU87SUFDbEI7QUFDRjtBQUVBQyxPQUFPQyxPQUFPLEdBQUc7SUFDZkw7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZpbGVhcGkvZW5jb2RpbmcuanM/YTZiNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZW5jb2Rpbmcuc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWVuY29kaW5nLWdldFxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBsYWJlbFxuICovXG5mdW5jdGlvbiBnZXRFbmNvZGluZyAobGFiZWwpIHtcbiAgaWYgKCFsYWJlbCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDEuIFJlbW92ZSBhbnkgbGVhZGluZyBhbmQgdHJhaWxpbmcgQVNDSUkgd2hpdGVzcGFjZSBmcm9tIGxhYmVsLlxuICAvLyAyLiBJZiBsYWJlbCBpcyBhbiBBU0NJSSBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvciBhbnkgb2YgdGhlXG4gIC8vICAgIGxhYmVscyBsaXN0ZWQgaW4gdGhlIHRhYmxlIGJlbG93LCB0aGVuIHJldHVybiB0aGVcbiAgLy8gICAgY29ycmVzcG9uZGluZyBlbmNvZGluZzsgb3RoZXJ3aXNlIHJldHVybiBmYWlsdXJlLlxuICBzd2l0Y2ggKGxhYmVsLnRyaW0oKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAndW5pY29kZS0xLTEtdXRmLTgnOlxuICAgIGNhc2UgJ3VuaWNvZGUxMXV0ZjgnOlxuICAgIGNhc2UgJ3VuaWNvZGUyMHV0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd4LXVuaWNvZGUyMHV0ZjgnOlxuICAgICAgcmV0dXJuICdVVEYtOCdcbiAgICBjYXNlICc4NjYnOlxuICAgIGNhc2UgJ2NwODY2JzpcbiAgICBjYXNlICdjc2libTg2Nic6XG4gICAgY2FzZSAnaWJtODY2JzpcbiAgICAgIHJldHVybiAnSUJNODY2J1xuICAgIGNhc2UgJ2NzaXNvbGF0aW4yJzpcbiAgICBjYXNlICdpc28tODg1OS0yJzpcbiAgICBjYXNlICdpc28taXItMTAxJzpcbiAgICBjYXNlICdpc284ODU5LTInOlxuICAgIGNhc2UgJ2lzbzg4NTkyJzpcbiAgICBjYXNlICdpc29fODg1OS0yJzpcbiAgICBjYXNlICdpc29fODg1OS0yOjE5ODcnOlxuICAgIGNhc2UgJ2wyJzpcbiAgICBjYXNlICdsYXRpbjInOlxuICAgICAgcmV0dXJuICdJU08tODg1OS0yJ1xuICAgIGNhc2UgJ2NzaXNvbGF0aW4zJzpcbiAgICBjYXNlICdpc28tODg1OS0zJzpcbiAgICBjYXNlICdpc28taXItMTA5JzpcbiAgICBjYXNlICdpc284ODU5LTMnOlxuICAgIGNhc2UgJ2lzbzg4NTkzJzpcbiAgICBjYXNlICdpc29fODg1OS0zJzpcbiAgICBjYXNlICdpc29fODg1OS0zOjE5ODgnOlxuICAgIGNhc2UgJ2wzJzpcbiAgICBjYXNlICdsYXRpbjMnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS0zJ1xuICAgIGNhc2UgJ2NzaXNvbGF0aW40JzpcbiAgICBjYXNlICdpc28tODg1OS00JzpcbiAgICBjYXNlICdpc28taXItMTEwJzpcbiAgICBjYXNlICdpc284ODU5LTQnOlxuICAgIGNhc2UgJ2lzbzg4NTk0JzpcbiAgICBjYXNlICdpc29fODg1OS00JzpcbiAgICBjYXNlICdpc29fODg1OS00OjE5ODgnOlxuICAgIGNhc2UgJ2w0JzpcbiAgICBjYXNlICdsYXRpbjQnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS00J1xuICAgIGNhc2UgJ2NzaXNvbGF0aW5jeXJpbGxpYyc6XG4gICAgY2FzZSAnY3lyaWxsaWMnOlxuICAgIGNhc2UgJ2lzby04ODU5LTUnOlxuICAgIGNhc2UgJ2lzby1pci0xNDQnOlxuICAgIGNhc2UgJ2lzbzg4NTktNSc6XG4gICAgY2FzZSAnaXNvODg1OTUnOlxuICAgIGNhc2UgJ2lzb184ODU5LTUnOlxuICAgIGNhc2UgJ2lzb184ODU5LTU6MTk4OCc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTUnXG4gICAgY2FzZSAnYXJhYmljJzpcbiAgICBjYXNlICdhc21vLTcwOCc6XG4gICAgY2FzZSAnY3Npc284ODU5NmUnOlxuICAgIGNhc2UgJ2NzaXNvODg1OTZpJzpcbiAgICBjYXNlICdjc2lzb2xhdGluYXJhYmljJzpcbiAgICBjYXNlICdlY21hLTExNCc6XG4gICAgY2FzZSAnaXNvLTg4NTktNic6XG4gICAgY2FzZSAnaXNvLTg4NTktNi1lJzpcbiAgICBjYXNlICdpc28tODg1OS02LWknOlxuICAgIGNhc2UgJ2lzby1pci0xMjcnOlxuICAgIGNhc2UgJ2lzbzg4NTktNic6XG4gICAgY2FzZSAnaXNvODg1OTYnOlxuICAgIGNhc2UgJ2lzb184ODU5LTYnOlxuICAgIGNhc2UgJ2lzb184ODU5LTY6MTk4Nyc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTYnXG4gICAgY2FzZSAnY3Npc29sYXRpbmdyZWVrJzpcbiAgICBjYXNlICdlY21hLTExOCc6XG4gICAgY2FzZSAnZWxvdF85MjgnOlxuICAgIGNhc2UgJ2dyZWVrJzpcbiAgICBjYXNlICdncmVlazgnOlxuICAgIGNhc2UgJ2lzby04ODU5LTcnOlxuICAgIGNhc2UgJ2lzby1pci0xMjYnOlxuICAgIGNhc2UgJ2lzbzg4NTktNyc6XG4gICAgY2FzZSAnaXNvODg1OTcnOlxuICAgIGNhc2UgJ2lzb184ODU5LTcnOlxuICAgIGNhc2UgJ2lzb184ODU5LTc6MTk4Nyc6XG4gICAgY2FzZSAnc3VuX2V1X2dyZWVrJzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktNydcbiAgICBjYXNlICdjc2lzbzg4NTk4ZSc6XG4gICAgY2FzZSAnY3Npc29sYXRpbmhlYnJldyc6XG4gICAgY2FzZSAnaGVicmV3JzpcbiAgICBjYXNlICdpc28tODg1OS04JzpcbiAgICBjYXNlICdpc28tODg1OS04LWUnOlxuICAgIGNhc2UgJ2lzby1pci0xMzgnOlxuICAgIGNhc2UgJ2lzbzg4NTktOCc6XG4gICAgY2FzZSAnaXNvODg1OTgnOlxuICAgIGNhc2UgJ2lzb184ODU5LTgnOlxuICAgIGNhc2UgJ2lzb184ODU5LTg6MTk4OCc6XG4gICAgY2FzZSAndmlzdWFsJzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktOCdcbiAgICBjYXNlICdjc2lzbzg4NTk4aSc6XG4gICAgY2FzZSAnaXNvLTg4NTktOC1pJzpcbiAgICBjYXNlICdsb2dpY2FsJzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktOC1JJ1xuICAgIGNhc2UgJ2NzaXNvbGF0aW42JzpcbiAgICBjYXNlICdpc28tODg1OS0xMCc6XG4gICAgY2FzZSAnaXNvLWlyLTE1Nyc6XG4gICAgY2FzZSAnaXNvODg1OS0xMCc6XG4gICAgY2FzZSAnaXNvODg1OTEwJzpcbiAgICBjYXNlICdsNic6XG4gICAgY2FzZSAnbGF0aW42JzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktMTAnXG4gICAgY2FzZSAnaXNvLTg4NTktMTMnOlxuICAgIGNhc2UgJ2lzbzg4NTktMTMnOlxuICAgIGNhc2UgJ2lzbzg4NTkxMyc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTEzJ1xuICAgIGNhc2UgJ2lzby04ODU5LTE0JzpcbiAgICBjYXNlICdpc284ODU5LTE0JzpcbiAgICBjYXNlICdpc284ODU5MTQnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS0xNCdcbiAgICBjYXNlICdjc2lzb2xhdGluOSc6XG4gICAgY2FzZSAnaXNvLTg4NTktMTUnOlxuICAgIGNhc2UgJ2lzbzg4NTktMTUnOlxuICAgIGNhc2UgJ2lzbzg4NTkxNSc6XG4gICAgY2FzZSAnaXNvXzg4NTktMTUnOlxuICAgIGNhc2UgJ2w5JzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktMTUnXG4gICAgY2FzZSAnaXNvLTg4NTktMTYnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS0xNidcbiAgICBjYXNlICdjc2tvaThyJzpcbiAgICBjYXNlICdrb2knOlxuICAgIGNhc2UgJ2tvaTgnOlxuICAgIGNhc2UgJ2tvaTgtcic6XG4gICAgY2FzZSAna29pOF9yJzpcbiAgICAgIHJldHVybiAnS09JOC1SJ1xuICAgIGNhc2UgJ2tvaTgtcnUnOlxuICAgIGNhc2UgJ2tvaTgtdSc6XG4gICAgICByZXR1cm4gJ0tPSTgtVSdcbiAgICBjYXNlICdjc21hY2ludG9zaCc6XG4gICAgY2FzZSAnbWFjJzpcbiAgICBjYXNlICdtYWNpbnRvc2gnOlxuICAgIGNhc2UgJ3gtbWFjLXJvbWFuJzpcbiAgICAgIHJldHVybiAnbWFjaW50b3NoJ1xuICAgIGNhc2UgJ2lzby04ODU5LTExJzpcbiAgICBjYXNlICdpc284ODU5LTExJzpcbiAgICBjYXNlICdpc284ODU5MTEnOlxuICAgIGNhc2UgJ3Rpcy02MjAnOlxuICAgIGNhc2UgJ3dpbmRvd3MtODc0JzpcbiAgICAgIHJldHVybiAnd2luZG93cy04NzQnXG4gICAgY2FzZSAnY3AxMjUwJzpcbiAgICBjYXNlICd3aW5kb3dzLTEyNTAnOlxuICAgIGNhc2UgJ3gtY3AxMjUwJzpcbiAgICAgIHJldHVybiAnd2luZG93cy0xMjUwJ1xuICAgIGNhc2UgJ2NwMTI1MSc6XG4gICAgY2FzZSAnd2luZG93cy0xMjUxJzpcbiAgICBjYXNlICd4LWNwMTI1MSc6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtMTI1MSdcbiAgICBjYXNlICdhbnNpX3gzLjQtMTk2OCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2NwMTI1Mic6XG4gICAgY2FzZSAnY3A4MTknOlxuICAgIGNhc2UgJ2NzaXNvbGF0aW4xJzpcbiAgICBjYXNlICdpYm04MTknOlxuICAgIGNhc2UgJ2lzby04ODU5LTEnOlxuICAgIGNhc2UgJ2lzby1pci0xMDAnOlxuICAgIGNhc2UgJ2lzbzg4NTktMSc6XG4gICAgY2FzZSAnaXNvODg1OTEnOlxuICAgIGNhc2UgJ2lzb184ODU5LTEnOlxuICAgIGNhc2UgJ2lzb184ODU5LTE6MTk4Nyc6XG4gICAgY2FzZSAnbDEnOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAndXMtYXNjaWknOlxuICAgIGNhc2UgJ3dpbmRvd3MtMTI1Mic6XG4gICAgY2FzZSAneC1jcDEyNTInOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTEyNTInXG4gICAgY2FzZSAnY3AxMjUzJzpcbiAgICBjYXNlICd3aW5kb3dzLTEyNTMnOlxuICAgIGNhc2UgJ3gtY3AxMjUzJzpcbiAgICAgIHJldHVybiAnd2luZG93cy0xMjUzJ1xuICAgIGNhc2UgJ2NwMTI1NCc6XG4gICAgY2FzZSAnY3Npc29sYXRpbjUnOlxuICAgIGNhc2UgJ2lzby04ODU5LTknOlxuICAgIGNhc2UgJ2lzby1pci0xNDgnOlxuICAgIGNhc2UgJ2lzbzg4NTktOSc6XG4gICAgY2FzZSAnaXNvODg1OTknOlxuICAgIGNhc2UgJ2lzb184ODU5LTknOlxuICAgIGNhc2UgJ2lzb184ODU5LTk6MTk4OSc6XG4gICAgY2FzZSAnbDUnOlxuICAgIGNhc2UgJ2xhdGluNSc6XG4gICAgY2FzZSAnd2luZG93cy0xMjU0JzpcbiAgICBjYXNlICd4LWNwMTI1NCc6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtMTI1NCdcbiAgICBjYXNlICdjcDEyNTUnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMTI1NSc6XG4gICAgY2FzZSAneC1jcDEyNTUnOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTEyNTUnXG4gICAgY2FzZSAnY3AxMjU2JzpcbiAgICBjYXNlICd3aW5kb3dzLTEyNTYnOlxuICAgIGNhc2UgJ3gtY3AxMjU2JzpcbiAgICAgIHJldHVybiAnd2luZG93cy0xMjU2J1xuICAgIGNhc2UgJ2NwMTI1Nyc6XG4gICAgY2FzZSAnd2luZG93cy0xMjU3JzpcbiAgICBjYXNlICd4LWNwMTI1Nyc6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtMTI1NydcbiAgICBjYXNlICdjcDEyNTgnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMTI1OCc6XG4gICAgY2FzZSAneC1jcDEyNTgnOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTEyNTgnXG4gICAgY2FzZSAneC1tYWMtY3lyaWxsaWMnOlxuICAgIGNhc2UgJ3gtbWFjLXVrcmFpbmlhbic6XG4gICAgICByZXR1cm4gJ3gtbWFjLWN5cmlsbGljJ1xuICAgIGNhc2UgJ2NoaW5lc2UnOlxuICAgIGNhc2UgJ2NzZ2IyMzEyJzpcbiAgICBjYXNlICdjc2lzbzU4Z2IyMzEyODAnOlxuICAgIGNhc2UgJ2diMjMxMic6XG4gICAgY2FzZSAnZ2JfMjMxMic6XG4gICAgY2FzZSAnZ2JfMjMxMi04MCc6XG4gICAgY2FzZSAnZ2JrJzpcbiAgICBjYXNlICdpc28taXItNTgnOlxuICAgIGNhc2UgJ3gtZ2JrJzpcbiAgICAgIHJldHVybiAnR0JLJ1xuICAgIGNhc2UgJ2diMTgwMzAnOlxuICAgICAgcmV0dXJuICdnYjE4MDMwJ1xuICAgIGNhc2UgJ2JpZzUnOlxuICAgIGNhc2UgJ2JpZzUtaGtzY3MnOlxuICAgIGNhc2UgJ2NuLWJpZzUnOlxuICAgIGNhc2UgJ2NzYmlnNSc6XG4gICAgY2FzZSAneC14LWJpZzUnOlxuICAgICAgcmV0dXJuICdCaWc1J1xuICAgIGNhc2UgJ2NzZXVjcGtkZm10amFwYW5lc2UnOlxuICAgIGNhc2UgJ2V1Yy1qcCc6XG4gICAgY2FzZSAneC1ldWMtanAnOlxuICAgICAgcmV0dXJuICdFVUMtSlAnXG4gICAgY2FzZSAnY3Npc28yMDIyanAnOlxuICAgIGNhc2UgJ2lzby0yMDIyLWpwJzpcbiAgICAgIHJldHVybiAnSVNPLTIwMjItSlAnXG4gICAgY2FzZSAnY3NzaGlmdGppcyc6XG4gICAgY2FzZSAnbXM5MzInOlxuICAgIGNhc2UgJ21zX2thbmppJzpcbiAgICBjYXNlICdzaGlmdC1qaXMnOlxuICAgIGNhc2UgJ3NoaWZ0X2ppcyc6XG4gICAgY2FzZSAnc2ppcyc6XG4gICAgY2FzZSAnd2luZG93cy0zMWonOlxuICAgIGNhc2UgJ3gtc2ppcyc6XG4gICAgICByZXR1cm4gJ1NoaWZ0X0pJUydcbiAgICBjYXNlICdjc2V1Y2tyJzpcbiAgICBjYXNlICdjc2tzYzU2MDExOTg3JzpcbiAgICBjYXNlICdldWMta3InOlxuICAgIGNhc2UgJ2lzby1pci0xNDknOlxuICAgIGNhc2UgJ2tvcmVhbic6XG4gICAgY2FzZSAna3NfY181NjAxLTE5ODcnOlxuICAgIGNhc2UgJ2tzX2NfNTYwMS0xOTg5JzpcbiAgICBjYXNlICdrc2M1NjAxJzpcbiAgICBjYXNlICdrc2NfNTYwMSc6XG4gICAgY2FzZSAnd2luZG93cy05NDknOlxuICAgICAgcmV0dXJuICdFVUMtS1InXG4gICAgY2FzZSAnY3Npc28yMDIya3InOlxuICAgIGNhc2UgJ2h6LWdiLTIzMTInOlxuICAgIGNhc2UgJ2lzby0yMDIyLWNuJzpcbiAgICBjYXNlICdpc28tMjAyMi1jbi1leHQnOlxuICAgIGNhc2UgJ2lzby0yMDIyLWtyJzpcbiAgICBjYXNlICdyZXBsYWNlbWVudCc6XG4gICAgICByZXR1cm4gJ3JlcGxhY2VtZW50J1xuICAgIGNhc2UgJ3VuaWNvZGVmZmZlJzpcbiAgICBjYXNlICd1dGYtMTZiZSc6XG4gICAgICByZXR1cm4gJ1VURi0xNkJFJ1xuICAgIGNhc2UgJ2NzdW5pY29kZSc6XG4gICAgY2FzZSAnaXNvLTEwNjQ2LXVjcy0yJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndW5pY29kZSc6XG4gICAgY2FzZSAndW5pY29kZWZlZmYnOlxuICAgIGNhc2UgJ3V0Zi0xNic6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuICdVVEYtMTZMRSdcbiAgICBjYXNlICd4LXVzZXItZGVmaW5lZCc6XG4gICAgICByZXR1cm4gJ3gtdXNlci1kZWZpbmVkJ1xuICAgIGRlZmF1bHQ6IHJldHVybiAnZmFpbHVyZSdcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0RW5jb2Rpbmdcbn1cbiJdLCJuYW1lcyI6WyJnZXRFbmNvZGluZyIsImxhYmVsIiwidHJpbSIsInRvTG93ZXJDYXNlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/fileapi/encoding.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/fileapi/filereader.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/fileapi/filereader.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { staticPropertyDescriptors, readOperation, fireAProgressEvent } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fileapi/util.js\");\nconst { kState, kError, kResult, kEvents, kAborted } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fileapi/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/webidl.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nclass FileReader extends EventTarget {\n    constructor(){\n        super();\n        this[kState] = \"empty\";\n        this[kResult] = null;\n        this[kError] = null;\n        this[kEvents] = {\n            loadend: null,\n            error: null,\n            abort: null,\n            load: null,\n            progress: null,\n            loadstart: null\n        };\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer\n   * @param {import('buffer').Blob} blob\n   */ readAsArrayBuffer(blob) {\n        webidl.brandCheck(this, FileReader);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FileReader.readAsArrayBuffer\"\n        });\n        blob = webidl.converters.Blob(blob, {\n            strict: false\n        });\n        // The readAsArrayBuffer(blob) method, when invoked,\n        // must initiate a read operation for blob with ArrayBuffer.\n        readOperation(this, blob, \"ArrayBuffer\");\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#readAsBinaryString\n   * @param {import('buffer').Blob} blob\n   */ readAsBinaryString(blob) {\n        webidl.brandCheck(this, FileReader);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FileReader.readAsBinaryString\"\n        });\n        blob = webidl.converters.Blob(blob, {\n            strict: false\n        });\n        // The readAsBinaryString(blob) method, when invoked,\n        // must initiate a read operation for blob with BinaryString.\n        readOperation(this, blob, \"BinaryString\");\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#readAsDataText\n   * @param {import('buffer').Blob} blob\n   * @param {string?} encoding\n   */ readAsText(blob, encoding = undefined) {\n        webidl.brandCheck(this, FileReader);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FileReader.readAsText\"\n        });\n        blob = webidl.converters.Blob(blob, {\n            strict: false\n        });\n        if (encoding !== undefined) {\n            encoding = webidl.converters.DOMString(encoding);\n        }\n        // The readAsText(blob, encoding) method, when invoked,\n        // must initiate a read operation for blob with Text and encoding.\n        readOperation(this, blob, \"Text\", encoding);\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL\n   * @param {import('buffer').Blob} blob\n   */ readAsDataURL(blob) {\n        webidl.brandCheck(this, FileReader);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FileReader.readAsDataURL\"\n        });\n        blob = webidl.converters.Blob(blob, {\n            strict: false\n        });\n        // The readAsDataURL(blob) method, when invoked, must\n        // initiate a read operation for blob with DataURL.\n        readOperation(this, blob, \"DataURL\");\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dfn-abort\n   */ abort() {\n        // 1. If this's state is \"empty\" or if this's state is\n        //    \"done\" set this's result to null and terminate\n        //    this algorithm.\n        if (this[kState] === \"empty\" || this[kState] === \"done\") {\n            this[kResult] = null;\n            return;\n        }\n        // 2. If this's state is \"loading\" set this's state to\n        //    \"done\" and set this's result to null.\n        if (this[kState] === \"loading\") {\n            this[kState] = \"done\";\n            this[kResult] = null;\n        }\n        // 3. If there are any tasks from this on the file reading\n        //    task source in an affiliated task queue, then remove\n        //    those tasks from that task queue.\n        this[kAborted] = true;\n        // 4. Terminate the algorithm for the read method being processed.\n        // TODO\n        // 5. Fire a progress event called abort at this.\n        fireAProgressEvent(\"abort\", this);\n        // 6. If this's state is not \"loading\", fire a progress\n        //    event called loadend at this.\n        if (this[kState] !== \"loading\") {\n            fireAProgressEvent(\"loadend\", this);\n        }\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate\n   */ get readyState() {\n        webidl.brandCheck(this, FileReader);\n        switch(this[kState]){\n            case \"empty\":\n                return this.EMPTY;\n            case \"loading\":\n                return this.LOADING;\n            case \"done\":\n                return this.DONE;\n        }\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dom-filereader-result\n   */ get result() {\n        webidl.brandCheck(this, FileReader);\n        // The result attributes getter, when invoked, must return\n        // this's result.\n        return this[kResult];\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dom-filereader-error\n   */ get error() {\n        webidl.brandCheck(this, FileReader);\n        // The error attributes getter, when invoked, must return\n        // this's error.\n        return this[kError];\n    }\n    get onloadend() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].loadend;\n    }\n    set onloadend(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].loadend) {\n            this.removeEventListener(\"loadend\", this[kEvents].loadend);\n        }\n        if (typeof fn === \"function\") {\n            this[kEvents].loadend = fn;\n            this.addEventListener(\"loadend\", fn);\n        } else {\n            this[kEvents].loadend = null;\n        }\n    }\n    get onerror() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].error;\n    }\n    set onerror(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].error) {\n            this.removeEventListener(\"error\", this[kEvents].error);\n        }\n        if (typeof fn === \"function\") {\n            this[kEvents].error = fn;\n            this.addEventListener(\"error\", fn);\n        } else {\n            this[kEvents].error = null;\n        }\n    }\n    get onloadstart() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].loadstart;\n    }\n    set onloadstart(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].loadstart) {\n            this.removeEventListener(\"loadstart\", this[kEvents].loadstart);\n        }\n        if (typeof fn === \"function\") {\n            this[kEvents].loadstart = fn;\n            this.addEventListener(\"loadstart\", fn);\n        } else {\n            this[kEvents].loadstart = null;\n        }\n    }\n    get onprogress() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].progress;\n    }\n    set onprogress(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].progress) {\n            this.removeEventListener(\"progress\", this[kEvents].progress);\n        }\n        if (typeof fn === \"function\") {\n            this[kEvents].progress = fn;\n            this.addEventListener(\"progress\", fn);\n        } else {\n            this[kEvents].progress = null;\n        }\n    }\n    get onload() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].load;\n    }\n    set onload(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].load) {\n            this.removeEventListener(\"load\", this[kEvents].load);\n        }\n        if (typeof fn === \"function\") {\n            this[kEvents].load = fn;\n            this.addEventListener(\"load\", fn);\n        } else {\n            this[kEvents].load = null;\n        }\n    }\n    get onabort() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].abort;\n    }\n    set onabort(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].abort) {\n            this.removeEventListener(\"abort\", this[kEvents].abort);\n        }\n        if (typeof fn === \"function\") {\n            this[kEvents].abort = fn;\n            this.addEventListener(\"abort\", fn);\n        } else {\n            this[kEvents].abort = null;\n        }\n    }\n}\n// https://w3c.github.io/FileAPI/#dom-filereader-empty\nFileReader.EMPTY = FileReader.prototype.EMPTY = 0;\n// https://w3c.github.io/FileAPI/#dom-filereader-loading\nFileReader.LOADING = FileReader.prototype.LOADING = 1;\n// https://w3c.github.io/FileAPI/#dom-filereader-done\nFileReader.DONE = FileReader.prototype.DONE = 2;\nObject.defineProperties(FileReader.prototype, {\n    EMPTY: staticPropertyDescriptors,\n    LOADING: staticPropertyDescriptors,\n    DONE: staticPropertyDescriptors,\n    readAsArrayBuffer: kEnumerableProperty,\n    readAsBinaryString: kEnumerableProperty,\n    readAsText: kEnumerableProperty,\n    readAsDataURL: kEnumerableProperty,\n    abort: kEnumerableProperty,\n    readyState: kEnumerableProperty,\n    result: kEnumerableProperty,\n    error: kEnumerableProperty,\n    onloadstart: kEnumerableProperty,\n    onprogress: kEnumerableProperty,\n    onload: kEnumerableProperty,\n    onabort: kEnumerableProperty,\n    onerror: kEnumerableProperty,\n    onloadend: kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: \"FileReader\",\n        writable: false,\n        enumerable: false,\n        configurable: true\n    }\n});\nObject.defineProperties(FileReader, {\n    EMPTY: staticPropertyDescriptors,\n    LOADING: staticPropertyDescriptors,\n    DONE: staticPropertyDescriptors\n});\nmodule.exports = {\n    FileReader\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmlsZWFwaS9maWxlcmVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUNKQSx5QkFBeUIsRUFDekJDLGFBQWEsRUFDYkMsa0JBQWtCLEVBQ25CLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUNKQyxNQUFNLEVBQ05DLE1BQU0sRUFDTkMsT0FBTyxFQUNQQyxPQUFPLEVBQ1BDLFFBQVEsRUFDVCxHQUFHTCxtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRU0sTUFBTSxFQUFFLEdBQUdOLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRU8sbUJBQW1CLEVBQUUsR0FBR1AsbUJBQU9BLENBQUM7QUFFeEMsTUFBTVEsbUJBQW1CQztJQUN2QkMsYUFBZTtRQUNiLEtBQUs7UUFFTCxJQUFJLENBQUNULE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0UsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0QsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDRSxRQUFRLEdBQUc7WUFDZE8sU0FBUztZQUNUQyxPQUFPO1lBQ1BDLE9BQU87WUFDUEMsTUFBTTtZQUNOQyxVQUFVO1lBQ1ZDLFdBQVc7UUFDYjtJQUNGO0lBRUE7OztHQUdDLEdBQ0RDLGtCQUFtQkMsSUFBSSxFQUFFO1FBQ3ZCWixPQUFPYSxVQUFVLENBQUMsSUFBSSxFQUFFWDtRQUV4QkYsT0FBT2MsbUJBQW1CLENBQUNDLFdBQVcsR0FBRztZQUFFQyxRQUFRO1FBQStCO1FBRWxGSixPQUFPWixPQUFPaUIsVUFBVSxDQUFDQyxJQUFJLENBQUNOLE1BQU07WUFBRU8sUUFBUTtRQUFNO1FBRXBELG9EQUFvRDtRQUNwRCw0REFBNEQ7UUFDNUQzQixjQUFjLElBQUksRUFBRW9CLE1BQU07SUFDNUI7SUFFQTs7O0dBR0MsR0FDRFEsbUJBQW9CUixJQUFJLEVBQUU7UUFDeEJaLE9BQU9hLFVBQVUsQ0FBQyxJQUFJ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SSxHQUFHM0IsV0FBV3NDLFNBQVMsQ0FBQ1gsSUFBSSxHQUFHO0FBRTlDWSxPQUFPQyxnQkFBZ0IsQ0FBQ3hDLFdBQVdzQyxTQUFTLEVBQUU7SUFDNUNiLE9BQU9wQztJQUNQcUMsU0FBU3JDO0lBQ1RzQyxNQUFNdEM7SUFDTm9CLG1CQUFtQlY7SUFDbkJtQixvQkFBb0JuQjtJQUNwQm9CLFlBQVlwQjtJQUNad0IsZUFBZXhCO0lBQ2ZNLE9BQU9OO0lBQ1B5QixZQUFZekI7SUFDWjZCLFFBQVE3QjtJQUNSSyxPQUFPTDtJQUNQbUMsYUFBYW5DO0lBQ2JvQyxZQUFZcEM7SUFDWnFDLFFBQVFyQztJQUNSc0MsU0FBU3RDO0lBQ1RrQyxTQUFTbEM7SUFDVDhCLFdBQVc5QjtJQUNYLENBQUMwQyxPQUFPQyxXQUFXLENBQUMsRUFBRTtRQUNwQkMsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFlBQVk7UUFDWkMsY0FBYztJQUNoQjtBQUNGO0FBRUFQLE9BQU9DLGdCQUFnQixDQUFDeEMsWUFBWTtJQUNsQ3lCLE9BQU9wQztJQUNQcUMsU0FBU3JDO0lBQ1RzQyxNQUFNdEM7QUFDUjtBQUVBMEQsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZoRDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1maWdodGVyLWFjYWRlbXkvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmlsZWFwaS9maWxlcmVhZGVyLmpzPzYwYTciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgcmVhZE9wZXJhdGlvbixcbiAgZmlyZUFQcm9ncmVzc0V2ZW50XG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHtcbiAga1N0YXRlLFxuICBrRXJyb3IsXG4gIGtSZXN1bHQsXG4gIGtFdmVudHMsXG4gIGtBYm9ydGVkXG59ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi9mZXRjaC93ZWJpZGwnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuXG5jbGFzcyBGaWxlUmVhZGVyIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpc1trU3RhdGVdID0gJ2VtcHR5J1xuICAgIHRoaXNba1Jlc3VsdF0gPSBudWxsXG4gICAgdGhpc1trRXJyb3JdID0gbnVsbFxuICAgIHRoaXNba0V2ZW50c10gPSB7XG4gICAgICBsb2FkZW5kOiBudWxsLFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgICBhYm9ydDogbnVsbCxcbiAgICAgIGxvYWQ6IG51bGwsXG4gICAgICBwcm9ncmVzczogbnVsbCxcbiAgICAgIGxvYWRzdGFydDogbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNkZm4tcmVhZEFzQXJyYXlCdWZmZXJcbiAgICogQHBhcmFtIHtpbXBvcnQoJ2J1ZmZlcicpLkJsb2J9IGJsb2JcbiAgICovXG4gIHJlYWRBc0FycmF5QnVmZmVyIChibG9iKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdGaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyJyB9KVxuXG4gICAgYmxvYiA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IoYmxvYiwgeyBzdHJpY3Q6IGZhbHNlIH0pXG5cbiAgICAvLyBUaGUgcmVhZEFzQXJyYXlCdWZmZXIoYmxvYikgbWV0aG9kLCB3aGVuIGludm9rZWQsXG4gICAgLy8gbXVzdCBpbml0aWF0ZSBhIHJlYWQgb3BlcmF0aW9uIGZvciBibG9iIHdpdGggQXJyYXlCdWZmZXIuXG4gICAgcmVhZE9wZXJhdGlvbih0aGlzLCBibG9iLCAnQXJyYXlCdWZmZXInKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI3JlYWRBc0JpbmFyeVN0cmluZ1xuICAgKiBAcGFyYW0ge2ltcG9ydCgnYnVmZmVyJykuQmxvYn0gYmxvYlxuICAgKi9cbiAgcmVhZEFzQmluYXJ5U3RyaW5nIChibG9iKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdGaWxlUmVhZGVyLnJlYWRBc0JpbmFyeVN0cmluZycgfSlcblxuICAgIGJsb2IgPSB3ZWJpZGwuY29udmVydGVycy5CbG9iKGJsb2IsIHsgc3RyaWN0OiBmYWxzZSB9KVxuXG4gICAgLy8gVGhlIHJlYWRBc0JpbmFyeVN0cmluZyhibG9iKSBtZXRob2QsIHdoZW4gaW52b2tlZCxcbiAgICAvLyBtdXN0IGluaXRpYXRlIGEgcmVhZCBvcGVyYXRpb24gZm9yIGJsb2Igd2l0aCBCaW5hcnlTdHJpbmcuXG4gICAgcmVhZE9wZXJhdGlvbih0aGlzLCBibG9iLCAnQmluYXJ5U3RyaW5nJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNyZWFkQXNEYXRhVGV4dFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnYnVmZmVyJykuQmxvYn0gYmxvYlxuICAgKiBAcGFyYW0ge3N0cmluZz99IGVuY29kaW5nXG4gICAqL1xuICByZWFkQXNUZXh0IChibG9iLCBlbmNvZGluZyA9IHVuZGVmaW5lZCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnRmlsZVJlYWRlci5yZWFkQXNUZXh0JyB9KVxuXG4gICAgYmxvYiA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IoYmxvYiwgeyBzdHJpY3Q6IGZhbHNlIH0pXG5cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZW5jb2RpbmcgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcoZW5jb2RpbmcpXG4gICAgfVxuXG4gICAgLy8gVGhlIHJlYWRBc1RleHQoYmxvYiwgZW5jb2RpbmcpIG1ldGhvZCwgd2hlbiBpbnZva2VkLFxuICAgIC8vIG11c3QgaW5pdGlhdGUgYSByZWFkIG9wZXJhdGlvbiBmb3IgYmxvYiB3aXRoIFRleHQgYW5kIGVuY29kaW5nLlxuICAgIHJlYWRPcGVyYXRpb24odGhpcywgYmxvYiwgJ1RleHQnLCBlbmNvZGluZylcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNkZm4tcmVhZEFzRGF0YVVSTFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnYnVmZmVyJykuQmxvYn0gYmxvYlxuICAgKi9cbiAgcmVhZEFzRGF0YVVSTCAoYmxvYikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnRmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMJyB9KVxuXG4gICAgYmxvYiA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IoYmxvYiwgeyBzdHJpY3Q6IGZhbHNlIH0pXG5cbiAgICAvLyBUaGUgcmVhZEFzRGF0YVVSTChibG9iKSBtZXRob2QsIHdoZW4gaW52b2tlZCwgbXVzdFxuICAgIC8vIGluaXRpYXRlIGEgcmVhZCBvcGVyYXRpb24gZm9yIGJsb2Igd2l0aCBEYXRhVVJMLlxuICAgIHJlYWRPcGVyYXRpb24odGhpcywgYmxvYiwgJ0RhdGFVUkwnKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2Rmbi1hYm9ydFxuICAgKi9cbiAgYWJvcnQgKCkge1xuICAgIC8vIDEuIElmIHRoaXMncyBzdGF0ZSBpcyBcImVtcHR5XCIgb3IgaWYgdGhpcydzIHN0YXRlIGlzXG4gICAgLy8gICAgXCJkb25lXCIgc2V0IHRoaXMncyByZXN1bHQgdG8gbnVsbCBhbmQgdGVybWluYXRlXG4gICAgLy8gICAgdGhpcyBhbGdvcml0aG0uXG4gICAgaWYgKHRoaXNba1N0YXRlXSA9PT0gJ2VtcHR5JyB8fCB0aGlzW2tTdGF0ZV0gPT09ICdkb25lJykge1xuICAgICAgdGhpc1trUmVzdWx0XSA9IG51bGxcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIDIuIElmIHRoaXMncyBzdGF0ZSBpcyBcImxvYWRpbmdcIiBzZXQgdGhpcydzIHN0YXRlIHRvXG4gICAgLy8gICAgXCJkb25lXCIgYW5kIHNldCB0aGlzJ3MgcmVzdWx0IHRvIG51bGwuXG4gICAgaWYgKHRoaXNba1N0YXRlXSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICB0aGlzW2tTdGF0ZV0gPSAnZG9uZSdcbiAgICAgIHRoaXNba1Jlc3VsdF0gPSBudWxsXG4gICAgfVxuXG4gICAgLy8gMy4gSWYgdGhlcmUgYXJlIGFueSB0YXNrcyBmcm9tIHRoaXMgb24gdGhlIGZpbGUgcmVhZGluZ1xuICAgIC8vICAgIHRhc2sgc291cmNlIGluIGFuIGFmZmlsaWF0ZWQgdGFzayBxdWV1ZSwgdGhlbiByZW1vdmVcbiAgICAvLyAgICB0aG9zZSB0YXNrcyBmcm9tIHRoYXQgdGFzayBxdWV1ZS5cbiAgICB0aGlzW2tBYm9ydGVkXSA9IHRydWVcblxuICAgIC8vIDQuIFRlcm1pbmF0ZSB0aGUgYWxnb3JpdGhtIGZvciB0aGUgcmVhZCBtZXRob2QgYmVpbmcgcHJvY2Vzc2VkLlxuICAgIC8vIFRPRE9cblxuICAgIC8vIDUuIEZpcmUgYSBwcm9ncmVzcyBldmVudCBjYWxsZWQgYWJvcnQgYXQgdGhpcy5cbiAgICBmaXJlQVByb2dyZXNzRXZlbnQoJ2Fib3J0JywgdGhpcylcblxuICAgIC8vIDYuIElmIHRoaXMncyBzdGF0ZSBpcyBub3QgXCJsb2FkaW5nXCIsIGZpcmUgYSBwcm9ncmVzc1xuICAgIC8vICAgIGV2ZW50IGNhbGxlZCBsb2FkZW5kIGF0IHRoaXMuXG4gICAgaWYgKHRoaXNba1N0YXRlXSAhPT0gJ2xvYWRpbmcnKSB7XG4gICAgICBmaXJlQVByb2dyZXNzRXZlbnQoJ2xvYWRlbmQnLCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNkb20tZmlsZXJlYWRlci1yZWFkeXN0YXRlXG4gICAqL1xuICBnZXQgcmVhZHlTdGF0ZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHN3aXRjaCAodGhpc1trU3RhdGVdKSB7XG4gICAgICBjYXNlICdlbXB0eSc6IHJldHVybiB0aGlzLkVNUFRZXG4gICAgICBjYXNlICdsb2FkaW5nJzogcmV0dXJuIHRoaXMuTE9BRElOR1xuICAgICAgY2FzZSAnZG9uZSc6IHJldHVybiB0aGlzLkRPTkVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZG9tLWZpbGVyZWFkZXItcmVzdWx0XG4gICAqL1xuICBnZXQgcmVzdWx0ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgLy8gVGhlIHJlc3VsdCBhdHRyaWJ1dGXigJlzIGdldHRlciwgd2hlbiBpbnZva2VkLCBtdXN0IHJldHVyblxuICAgIC8vIHRoaXMncyByZXN1bHQuXG4gICAgcmV0dXJuIHRoaXNba1Jlc3VsdF1cbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNkb20tZmlsZXJlYWRlci1lcnJvclxuICAgKi9cbiAgZ2V0IGVycm9yICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgLy8gVGhlIGVycm9yIGF0dHJpYnV0ZeKAmXMgZ2V0dGVyLCB3aGVuIGludm9rZWQsIG11c3QgcmV0dXJuXG4gICAgLy8gdGhpcydzIGVycm9yLlxuICAgIHJldHVybiB0aGlzW2tFcnJvcl1cbiAgfVxuXG4gIGdldCBvbmxvYWRlbmQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICByZXR1cm4gdGhpc1trRXZlbnRzXS5sb2FkZW5kXG4gIH1cblxuICBzZXQgb25sb2FkZW5kIChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICBpZiAodGhpc1trRXZlbnRzXS5sb2FkZW5kKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWRlbmQnLCB0aGlzW2tFdmVudHNdLmxvYWRlbmQpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1trRXZlbnRzXS5sb2FkZW5kID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tFdmVudHNdLmxvYWRlbmQgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IG9uZXJyb3IgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICByZXR1cm4gdGhpc1trRXZlbnRzXS5lcnJvclxuICB9XG5cbiAgc2V0IG9uZXJyb3IgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIGlmICh0aGlzW2tFdmVudHNdLmVycm9yKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpc1trRXZlbnRzXS5lcnJvcilcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2tFdmVudHNdLmVycm9yID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trRXZlbnRzXS5lcnJvciA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25sb2Fkc3RhcnQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICByZXR1cm4gdGhpc1trRXZlbnRzXS5sb2Fkc3RhcnRcbiAgfVxuXG4gIHNldCBvbmxvYWRzdGFydCAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgaWYgKHRoaXNba0V2ZW50c10ubG9hZHN0YXJ0KSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWRzdGFydCcsIHRoaXNba0V2ZW50c10ubG9hZHN0YXJ0KVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNba0V2ZW50c10ubG9hZHN0YXJ0ID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbG9hZHN0YXJ0JywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0V2ZW50c10ubG9hZHN0YXJ0ID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbnByb2dyZXNzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgcmV0dXJuIHRoaXNba0V2ZW50c10ucHJvZ3Jlc3NcbiAgfVxuXG4gIHNldCBvbnByb2dyZXNzIChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICBpZiAodGhpc1trRXZlbnRzXS5wcm9ncmVzcykge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHRoaXNba0V2ZW50c10ucHJvZ3Jlc3MpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1trRXZlbnRzXS5wcm9ncmVzcyA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0V2ZW50c10ucHJvZ3Jlc3MgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IG9ubG9hZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHJldHVybiB0aGlzW2tFdmVudHNdLmxvYWRcbiAgfVxuXG4gIHNldCBvbmxvYWQgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIGlmICh0aGlzW2tFdmVudHNdLmxvYWQpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXNba0V2ZW50c10ubG9hZClcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2tFdmVudHNdLmxvYWQgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0V2ZW50c10ubG9hZCA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25hYm9ydCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHJldHVybiB0aGlzW2tFdmVudHNdLmFib3J0XG4gIH1cblxuICBzZXQgb25hYm9ydCAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgaWYgKHRoaXNba0V2ZW50c10uYWJvcnQpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCB0aGlzW2tFdmVudHNdLmFib3J0KVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNba0V2ZW50c10uYWJvcnQgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tFdmVudHNdLmFib3J0ID0gbnVsbFxuICAgIH1cbiAgfVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZG9tLWZpbGVyZWFkZXItZW1wdHlcbkZpbGVSZWFkZXIuRU1QVFkgPSBGaWxlUmVhZGVyLnByb3RvdHlwZS5FTVBUWSA9IDBcbi8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNkb20tZmlsZXJlYWRlci1sb2FkaW5nXG5GaWxlUmVhZGVyLkxPQURJTkcgPSBGaWxlUmVhZGVyLnByb3RvdHlwZS5MT0FESU5HID0gMVxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2RvbS1maWxlcmVhZGVyLWRvbmVcbkZpbGVSZWFkZXIuRE9ORSA9IEZpbGVSZWFkZXIucHJvdG90eXBlLkRPTkUgPSAyXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZpbGVSZWFkZXIucHJvdG90eXBlLCB7XG4gIEVNUFRZOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBMT0FESU5HOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBET05FOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICByZWFkQXNBcnJheUJ1ZmZlcjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVhZEFzQmluYXJ5U3RyaW5nOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWFkQXNUZXh0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWFkQXNEYXRhVVJMOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBhYm9ydDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVhZHlTdGF0ZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVzdWx0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBlcnJvcjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25sb2Fkc3RhcnQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9ucHJvZ3Jlc3M6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9ubG9hZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25hYm9ydDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25lcnJvcjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25sb2FkZW5kOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnRmlsZVJlYWRlcicsXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhGaWxlUmVhZGVyLCB7XG4gIEVNUFRZOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBMT0FESU5HOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBET05FOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRmlsZVJlYWRlclxufVxuIl0sIm5hbWVzIjpbInN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMiLCJyZWFkT3BlcmF0aW9uIiwiZmlyZUFQcm9ncmVzc0V2ZW50IiwicmVxdWlyZSIsImtTdGF0ZSIsImtFcnJvciIsImtSZXN1bHQiLCJrRXZlbnRzIiwia0Fib3J0ZWQiLCJ3ZWJpZGwiLCJrRW51bWVyYWJsZVByb3BlcnR5IiwiRmlsZVJlYWRlciIsIkV2ZW50VGFyZ2V0IiwiY29uc3RydWN0b3IiLCJsb2FkZW5kIiwiZXJyb3IiLCJhYm9ydCIsImxvYWQiLCJwcm9ncmVzcyIsImxvYWRzdGFydCIsInJlYWRBc0FycmF5QnVmZmVyIiwiYmxvYiIsImJyYW5kQ2hlY2siLCJhcmd1bWVudExlbmd0aENoZWNrIiwiYXJndW1lbnRzIiwiaGVhZGVyIiwiY29udmVydGVycyIsIkJsb2IiLCJzdHJpY3QiLCJyZWFkQXNCaW5hcnlTdHJpbmciLCJyZWFkQXNUZXh0IiwiZW5jb2RpbmciLCJ1bmRlZmluZWQiLCJET01TdHJpbmciLCJyZWFkQXNEYXRhVVJMIiwicmVhZHlTdGF0ZSIsIkVNUFRZIiwiTE9BRElORyIsIkRPTkUiLCJyZXN1bHQiLCJvbmxvYWRlbmQiLCJmbiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwib25lcnJvciIsIm9ubG9hZHN0YXJ0Iiwib25wcm9ncmVzcyIsIm9ubG9hZCIsIm9uYWJvcnQiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/fileapi/filereader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/fileapi/progressevent.js":
/*!********************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/fileapi/progressevent.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/webidl.js\");\nconst kState = Symbol(\"ProgressEvent state\");\n/**\n * @see https://xhr.spec.whatwg.org/#progressevent\n */ class ProgressEvent extends Event {\n    constructor(type, eventInitDict = {}){\n        type = webidl.converters.DOMString(type);\n        eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});\n        super(type, eventInitDict);\n        this[kState] = {\n            lengthComputable: eventInitDict.lengthComputable,\n            loaded: eventInitDict.loaded,\n            total: eventInitDict.total\n        };\n    }\n    get lengthComputable() {\n        webidl.brandCheck(this, ProgressEvent);\n        return this[kState].lengthComputable;\n    }\n    get loaded() {\n        webidl.brandCheck(this, ProgressEvent);\n        return this[kState].loaded;\n    }\n    get total() {\n        webidl.brandCheck(this, ProgressEvent);\n        return this[kState].total;\n    }\n}\nwebidl.converters.ProgressEventInit = webidl.dictionaryConverter([\n    {\n        key: \"lengthComputable\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: \"loaded\",\n        converter: webidl.converters[\"unsigned long long\"],\n        defaultValue: 0\n    },\n    {\n        key: \"total\",\n        converter: webidl.converters[\"unsigned long long\"],\n        defaultValue: 0\n    },\n    {\n        key: \"bubbles\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: \"cancelable\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: \"composed\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    }\n]);\nmodule.exports = {\n    ProgressEvent\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmlsZWFwaS9wcm9ncmVzc2V2ZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxNQUFNLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFFM0IsTUFBTUMsU0FBU0MsT0FBTztBQUV0Qjs7Q0FFQyxHQUNELE1BQU1DLHNCQUFzQkM7SUFDMUJDLFlBQWFDLElBQUksRUFBRUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFFO1FBQ3JDRCxPQUFPUCxPQUFPUyxVQUFVLENBQUNDLFNBQVMsQ0FBQ0g7UUFDbkNDLGdCQUFnQlIsT0FBT1MsVUFBVSxDQUFDRSxpQkFBaUIsQ0FBQ0gsaUJBQWlCLENBQUM7UUFFdEUsS0FBSyxDQUFDRCxNQUFNQztRQUVaLElBQUksQ0FBQ04sT0FBTyxHQUFHO1lBQ2JVLGtCQUFrQkosY0FBY0ksZ0JBQWdCO1lBQ2hEQyxRQUFRTCxjQUFjSyxNQUFNO1lBQzVCQyxPQUFPTixjQUFjTSxLQUFLO1FBQzVCO0lBQ0Y7SUFFQSxJQUFJRixtQkFBb0I7UUFDdEJaLE9BQU9lLFVBQVUsQ0FBQyxJQUFJLEVBQUVYO1FBRXhCLE9BQU8sSUFBSSxDQUFDRixPQUFPLENBQUNVLGdCQUFnQjtJQUN0QztJQUVBLElBQUlDLFNBQVU7UUFDWmIsT0FBT2UsVUFBVSxDQUFDLElBQUksRUFBRVg7UUFFeEIsT0FBTyxJQUFJLENBQUNGLE9BQU8sQ0FBQ1csTUFBTTtJQUM1QjtJQUVBLElBQUlDLFFBQVM7UUFDWGQsT0FBT2UsVUFBVSxDQUFDLElBQUksRUFBRVg7UUFFeEIsT0FBTyxJQUFJLENBQUNGLE9BQU8sQ0FBQ1ksS0FBSztJQUMzQjtBQUNGO0FBRUFkLE9BQU9TLFVBQVUsQ0FBQ0UsaUJBQWlCLEdBQUdYLE9BQU9nQixtQkFBbUIsQ0FBQztJQUMvRDtRQUNFQyxLQUFLO1FBQ0xDLFdBQVdsQixPQUFPUyxVQUFVLENBQUNVLE9BQU87UUFDcENDLGNBQWM7SUFDaEI7SUFDQTtRQUNFSCxLQUFLO1FBQ0xDLFdBQVdsQixPQUFPUyxVQUFVLENBQUMscUJBQXFCO1FBQ2xEVyxjQUFjO0lBQ2hCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXbEIsT0FBT1MsVUFBVSxDQUFDLHFCQUFxQjtRQUNsRFcsY0FBYztJQUNoQjtJQUNBO1FBQ0VILEtBQUs7UUFDTEMsV0FBV2xCLE9BQU9TLFVBQVUsQ0FBQ1UsT0FBTztRQUNwQ0MsY0FBYztJQUNoQjtJQUNBO1FBQ0VILEtBQUs7UUFDTEMsV0FBV2xCLE9BQU9TLFVBQVUsQ0FBQ1UsT0FBTztRQUNwQ0MsY0FBYztJQUNoQjtJQUNBO1FBQ0VILEtBQUs7UUFDTEMsV0FBV2xCLE9BQU9TLFVBQVUsQ0FBQ1UsT0FBTztRQUNwQ0MsY0FBYztJQUNoQjtDQUNEO0FBRURDLE9BQU9DLE9BQU8sR0FBRztJQUNmbEI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZpbGVhcGkvcHJvZ3Jlc3NldmVudC5qcz8zNDAwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvd2ViaWRsJylcblxuY29uc3Qga1N0YXRlID0gU3ltYm9sKCdQcm9ncmVzc0V2ZW50IHN0YXRlJylcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8veGhyLnNwZWMud2hhdHdnLm9yZy8jcHJvZ3Jlc3NldmVudFxuICovXG5jbGFzcyBQcm9ncmVzc0V2ZW50IGV4dGVuZHMgRXZlbnQge1xuICBjb25zdHJ1Y3RvciAodHlwZSwgZXZlbnRJbml0RGljdCA9IHt9KSB7XG4gICAgdHlwZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyh0eXBlKVxuICAgIGV2ZW50SW5pdERpY3QgPSB3ZWJpZGwuY29udmVydGVycy5Qcm9ncmVzc0V2ZW50SW5pdChldmVudEluaXREaWN0ID8/IHt9KVxuXG4gICAgc3VwZXIodHlwZSwgZXZlbnRJbml0RGljdClcblxuICAgIHRoaXNba1N0YXRlXSA9IHtcbiAgICAgIGxlbmd0aENvbXB1dGFibGU6IGV2ZW50SW5pdERpY3QubGVuZ3RoQ29tcHV0YWJsZSxcbiAgICAgIGxvYWRlZDogZXZlbnRJbml0RGljdC5sb2FkZWQsXG4gICAgICB0b3RhbDogZXZlbnRJbml0RGljdC50b3RhbFxuICAgIH1cbiAgfVxuXG4gIGdldCBsZW5ndGhDb21wdXRhYmxlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBQcm9ncmVzc0V2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5sZW5ndGhDb21wdXRhYmxlXG4gIH1cblxuICBnZXQgbG9hZGVkICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBQcm9ncmVzc0V2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5sb2FkZWRcbiAgfVxuXG4gIGdldCB0b3RhbCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUHJvZ3Jlc3NFdmVudClcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0udG90YWxcbiAgfVxufVxuXG53ZWJpZGwuY29udmVydGVycy5Qcm9ncmVzc0V2ZW50SW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGtleTogJ2xlbmd0aENvbXB1dGFibGUnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6IGZhbHNlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdsb2FkZWQnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIGxvbmcgbG9uZyddLFxuICAgIGRlZmF1bHRWYWx1ZTogMFxuICB9LFxuICB7XG4gICAga2V5OiAndG90YWwnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIGxvbmcgbG9uZyddLFxuICAgIGRlZmF1bHRWYWx1ZTogMFxuICB9LFxuICB7XG4gICAga2V5OiAnYnViYmxlcycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2NhbmNlbGFibGUnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6IGZhbHNlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjb21wb3NlZCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogZmFsc2VcbiAgfVxuXSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFByb2dyZXNzRXZlbnRcbn1cbiJdLCJuYW1lcyI6WyJ3ZWJpZGwiLCJyZXF1aXJlIiwia1N0YXRlIiwiU3ltYm9sIiwiUHJvZ3Jlc3NFdmVudCIsIkV2ZW50IiwiY29uc3RydWN0b3IiLCJ0eXBlIiwiZXZlbnRJbml0RGljdCIsImNvbnZlcnRlcnMiLCJET01TdHJpbmciLCJQcm9ncmVzc0V2ZW50SW5pdCIsImxlbmd0aENvbXB1dGFibGUiLCJsb2FkZWQiLCJ0b3RhbCIsImJyYW5kQ2hlY2siLCJkaWN0aW9uYXJ5Q29udmVydGVyIiwia2V5IiwiY29udmVydGVyIiwiYm9vbGVhbiIsImRlZmF1bHRWYWx1ZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/fileapi/progressevent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/fileapi/symbols.js":
/*!**************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/fileapi/symbols.js ***!
  \**************************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    kState: Symbol(\"FileReader state\"),\n    kResult: Symbol(\"FileReader result\"),\n    kError: Symbol(\"FileReader error\"),\n    kLastProgressEventFired: Symbol(\"FileReader last progress event fired timestamp\"),\n    kEvents: Symbol(\"FileReader events\"),\n    kAborted: Symbol(\"FileReader aborted\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmlsZWFwaS9zeW1ib2xzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLE9BQU9DLE9BQU8sR0FBRztJQUNmQyxRQUFRQyxPQUFPO0lBQ2ZDLFNBQVNELE9BQU87SUFDaEJFLFFBQVFGLE9BQU87SUFDZkcseUJBQXlCSCxPQUFPO0lBQ2hDSSxTQUFTSixPQUFPO0lBQ2hCSyxVQUFVTCxPQUFPO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1maWdodGVyLWFjYWRlbXkvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmlsZWFwaS9zeW1ib2xzLmpzP2RlNDEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrU3RhdGU6IFN5bWJvbCgnRmlsZVJlYWRlciBzdGF0ZScpLFxuICBrUmVzdWx0OiBTeW1ib2woJ0ZpbGVSZWFkZXIgcmVzdWx0JyksXG4gIGtFcnJvcjogU3ltYm9sKCdGaWxlUmVhZGVyIGVycm9yJyksXG4gIGtMYXN0UHJvZ3Jlc3NFdmVudEZpcmVkOiBTeW1ib2woJ0ZpbGVSZWFkZXIgbGFzdCBwcm9ncmVzcyBldmVudCBmaXJlZCB0aW1lc3RhbXAnKSxcbiAga0V2ZW50czogU3ltYm9sKCdGaWxlUmVhZGVyIGV2ZW50cycpLFxuICBrQWJvcnRlZDogU3ltYm9sKCdGaWxlUmVhZGVyIGFib3J0ZWQnKVxufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJrU3RhdGUiLCJTeW1ib2wiLCJrUmVzdWx0Iiwia0Vycm9yIiwia0xhc3RQcm9ncmVzc0V2ZW50RmlyZWQiLCJrRXZlbnRzIiwia0Fib3J0ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/fileapi/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/fileapi/util.js":
/*!***********************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/fileapi/util.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kState, kError, kResult, kAborted, kLastProgressEventFired } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fileapi/symbols.js\");\nconst { ProgressEvent } = __webpack_require__(/*! ./progressevent */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fileapi/progressevent.js\");\nconst { getEncoding } = __webpack_require__(/*! ./encoding */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fileapi/encoding.js\");\nconst { DOMException } = __webpack_require__(/*! ../fetch/constants */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/constants.js\");\nconst { serializeAMimeType, parseMIMEType } = __webpack_require__(/*! ../fetch/dataURL */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/dataURL.js\");\nconst { types } = __webpack_require__(/*! util */ \"util\");\nconst { StringDecoder } = __webpack_require__(/*! string_decoder */ \"string_decoder\");\nconst { btoa } = __webpack_require__(/*! buffer */ \"buffer\");\n/** @type {PropertyDescriptor} */ const staticPropertyDescriptors = {\n    enumerable: true,\n    writable: false,\n    configurable: false\n};\n/**\n * @see https://w3c.github.io/FileAPI/#readOperation\n * @param {import('./filereader').FileReader} fr\n * @param {import('buffer').Blob} blob\n * @param {string} type\n * @param {string?} encodingName\n */ function readOperation(fr, blob, type, encodingName) {\n    // 1. If frs state is \"loading\", throw an InvalidStateError\n    //    DOMException.\n    if (fr[kState] === \"loading\") {\n        throw new DOMException(\"Invalid state\", \"InvalidStateError\");\n    }\n    // 2. Set frs state to \"loading\".\n    fr[kState] = \"loading\";\n    // 3. Set frs result to null.\n    fr[kResult] = null;\n    // 4. Set frs error to null.\n    fr[kError] = null;\n    // 5. Let stream be the result of calling get stream on blob.\n    /** @type {import('stream/web').ReadableStream} */ const stream = blob.stream();\n    // 6. Let reader be the result of getting a reader from stream.\n    const reader = stream.getReader();\n    // 7. Let bytes be an empty byte sequence.\n    /** @type {Uint8Array[]} */ const bytes = [];\n    // 8. Let chunkPromise be the result of reading a chunk from\n    //    stream with reader.\n    let chunkPromise = reader.read();\n    // 9. Let isFirstChunk be true.\n    let isFirstChunk = true;\n    (async ()=>{\n        while(!fr[kAborted]){\n            // 1. Wait for chunkPromise to be fulfilled or rejected.\n            try {\n                const { done, value } = await chunkPromise;\n                // 2. If chunkPromise is fulfilled, and isFirstChunk is\n                //    true, queue a task to fire a progress event called\n                //    loadstart at fr.\n                if (isFirstChunk && !fr[kAborted]) {\n                    queueMicrotask(()=>{\n                        fireAProgressEvent(\"loadstart\", fr);\n                    });\n                }\n                // 3. Set isFirstChunk to false.\n                isFirstChunk = false;\n                // 4. If chunkPromise is fulfilled with an object whose\n                //    done property is false and whose value property is\n                //    a Uint8Array object, run these steps:\n                if (!done && types.isUint8Array(value)) {\n                    // 1. Let bs be the byte sequence represented by the\n                    //    Uint8Array object.\n                    // 2. Append bs to bytes.\n                    bytes.push(value);\n                    // 3. If roughly 50ms have passed since these steps\n                    //    were last invoked, queue a task to fire a\n                    //    progress event called progress at fr.\n                    if ((fr[kLastProgressEventFired] === undefined || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {\n                        fr[kLastProgressEventFired] = Date.now();\n                        queueMicrotask(()=>{\n                            fireAProgressEvent(\"progress\", fr);\n                        });\n                    }\n                    // 4. Set chunkPromise to the result of reading a\n                    //    chunk from stream with reader.\n                    chunkPromise = reader.read();\n                } else if (done) {\n                    // 5. Otherwise, if chunkPromise is fulfilled with an\n                    //    object whose done property is true, queue a task\n                    //    to run the following steps and abort this algorithm:\n                    queueMicrotask(()=>{\n                        // 1. Set frs state to \"done\".\n                        fr[kState] = \"done\";\n                        // 2. Let result be the result of package data given\n                        //    bytes, type, blobs type, and encodingName.\n                        try {\n                            const result = packageData(bytes, type, blob.type, encodingName);\n                            // 4. Else:\n                            if (fr[kAborted]) {\n                                return;\n                            }\n                            // 1. Set frs result to result.\n                            fr[kResult] = result;\n                            // 2. Fire a progress event called load at the fr.\n                            fireAProgressEvent(\"load\", fr);\n                        } catch (error) {\n                            // 3. If package data threw an exception error:\n                            // 1. Set frs error to error.\n                            fr[kError] = error;\n                            // 2. Fire a progress event called error at fr.\n                            fireAProgressEvent(\"error\", fr);\n                        }\n                        // 5. If frs state is not \"loading\", fire a progress\n                        //    event called loadend at the fr.\n                        if (fr[kState] !== \"loading\") {\n                            fireAProgressEvent(\"loadend\", fr);\n                        }\n                    });\n                    break;\n                }\n            } catch (error) {\n                if (fr[kAborted]) {\n                    return;\n                }\n                // 6. Otherwise, if chunkPromise is rejected with an\n                //    error error, queue a task to run the following\n                //    steps and abort this algorithm:\n                queueMicrotask(()=>{\n                    // 1. Set frs state to \"done\".\n                    fr[kState] = \"done\";\n                    // 2. Set frs error to error.\n                    fr[kError] = error;\n                    // 3. Fire a progress event called error at fr.\n                    fireAProgressEvent(\"error\", fr);\n                    // 4. If frs state is not \"loading\", fire a progress\n                    //    event called loadend at fr.\n                    if (fr[kState] !== \"loading\") {\n                        fireAProgressEvent(\"loadend\", fr);\n                    }\n                });\n                break;\n            }\n        }\n    })();\n}\n/**\n * @see https://w3c.github.io/FileAPI/#fire-a-progress-event\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e The name of the event\n * @param {import('./filereader').FileReader} reader\n */ function fireAProgressEvent(e, reader) {\n    // The progress event e does not bubble. e.bubbles must be false\n    // The progress event e is NOT cancelable. e.cancelable must be false\n    const event = new ProgressEvent(e, {\n        bubbles: false,\n        cancelable: false\n    });\n    reader.dispatchEvent(event);\n}\n/**\n * @see https://w3c.github.io/FileAPI/#blob-package-data\n * @param {Uint8Array[]} bytes\n * @param {string} type\n * @param {string?} mimeType\n * @param {string?} encodingName\n */ function packageData(bytes, type, mimeType, encodingName) {\n    // 1. A Blob has an associated package data algorithm, given\n    //    bytes, a type, a optional mimeType, and a optional\n    //    encodingName, which switches on type and runs the\n    //    associated steps:\n    switch(type){\n        case \"DataURL\":\n            {\n                // 1. Return bytes as a DataURL [RFC2397] subject to\n                //    the considerations below:\n                //  * Use mimeType as part of the Data URL if it is\n                //    available in keeping with the Data URL\n                //    specification [RFC2397].\n                //  * If mimeType is not available return a Data URL\n                //    without a media-type. [RFC2397].\n                // https://datatracker.ietf.org/doc/html/rfc2397#section-3\n                // dataurl    := \"data:\" [ mediatype ] [ \";base64\" ] \",\" data\n                // mediatype  := [ type \"/\" subtype ] *( \";\" parameter )\n                // data       := *urlchar\n                // parameter  := attribute \"=\" value\n                let dataURL = \"data:\";\n                const parsed = parseMIMEType(mimeType || \"application/octet-stream\");\n                if (parsed !== \"failure\") {\n                    dataURL += serializeAMimeType(parsed);\n                }\n                dataURL += \";base64,\";\n                const decoder = new StringDecoder(\"latin1\");\n                for (const chunk of bytes){\n                    dataURL += btoa(decoder.write(chunk));\n                }\n                dataURL += btoa(decoder.end());\n                return dataURL;\n            }\n        case \"Text\":\n            {\n                // 1. Let encoding be failure\n                let encoding = \"failure\";\n                // 2. If the encodingName is present, set encoding to the\n                //    result of getting an encoding from encodingName.\n                if (encodingName) {\n                    encoding = getEncoding(encodingName);\n                }\n                // 3. If encoding is failure, and mimeType is present:\n                if (encoding === \"failure\" && mimeType) {\n                    // 1. Let type be the result of parse a MIME type\n                    //    given mimeType.\n                    const type = parseMIMEType(mimeType);\n                    // 2. If type is not failure, set encoding to the result\n                    //    of getting an encoding from types parameters[\"charset\"].\n                    if (type !== \"failure\") {\n                        encoding = getEncoding(type.parameters.get(\"charset\"));\n                    }\n                }\n                // 4. If encoding is failure, then set encoding to UTF-8.\n                if (encoding === \"failure\") {\n                    encoding = \"UTF-8\";\n                }\n                // 5. Decode bytes using fallback encoding encoding, and\n                //    return the result.\n                return decode(bytes, encoding);\n            }\n        case \"ArrayBuffer\":\n            {\n                // Return a new ArrayBuffer whose contents are bytes.\n                const sequence = combineByteSequences(bytes);\n                return sequence.buffer;\n            }\n        case \"BinaryString\":\n            {\n                // Return bytes as a binary string, in which every byte\n                //  is represented by a code unit of equal value [0..255].\n                let binaryString = \"\";\n                const decoder = new StringDecoder(\"latin1\");\n                for (const chunk of bytes){\n                    binaryString += decoder.write(chunk);\n                }\n                binaryString += decoder.end();\n                return binaryString;\n            }\n    }\n}\n/**\n * @see https://encoding.spec.whatwg.org/#decode\n * @param {Uint8Array[]} ioQueue\n * @param {string} encoding\n */ function decode(ioQueue, encoding) {\n    const bytes = combineByteSequences(ioQueue);\n    // 1. Let BOMEncoding be the result of BOM sniffing ioQueue.\n    const BOMEncoding = BOMSniffing(bytes);\n    let slice = 0;\n    // 2. If BOMEncoding is non-null:\n    if (BOMEncoding !== null) {\n        // 1. Set encoding to BOMEncoding.\n        encoding = BOMEncoding;\n        // 2. Read three bytes from ioQueue, if BOMEncoding is\n        //    UTF-8; otherwise read two bytes.\n        //    (Do nothing with those bytes.)\n        slice = BOMEncoding === \"UTF-8\" ? 3 : 2;\n    }\n    // 3. Process a queue with an instance of encodings\n    //    decoder, ioQueue, output, and \"replacement\".\n    // 4. Return output.\n    const sliced = bytes.slice(slice);\n    return new TextDecoder(encoding).decode(sliced);\n}\n/**\n * @see https://encoding.spec.whatwg.org/#bom-sniff\n * @param {Uint8Array} ioQueue\n */ function BOMSniffing(ioQueue) {\n    // 1. Let BOM be the result of peeking 3 bytes from ioQueue,\n    //    converted to a byte sequence.\n    const [a, b, c] = ioQueue;\n    // 2. For each of the rows in the table below, starting with\n    //    the first one and going down, if BOM starts with the\n    //    bytes given in the first column, then return the\n    //    encoding given in the cell in the second column of that\n    //    row. Otherwise, return null.\n    if (a === 0xEF && b === 0xBB && c === 0xBF) {\n        return \"UTF-8\";\n    } else if (a === 0xFE && b === 0xFF) {\n        return \"UTF-16BE\";\n    } else if (a === 0xFF && b === 0xFE) {\n        return \"UTF-16LE\";\n    }\n    return null;\n}\n/**\n * @param {Uint8Array[]} sequences\n */ function combineByteSequences(sequences) {\n    const size = sequences.reduce((a, b)=>{\n        return a + b.byteLength;\n    }, 0);\n    let offset = 0;\n    return sequences.reduce((a, b)=>{\n        a.set(b, offset);\n        offset += b.byteLength;\n        return a;\n    }, new Uint8Array(size));\n}\nmodule.exports = {\n    staticPropertyDescriptors,\n    readOperation,\n    fireAProgressEvent\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmlsZWFwaS91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUNKQSxNQUFNLEVBQ05DLE1BQU0sRUFDTkMsT0FBTyxFQUNQQyxRQUFRLEVBQ1JDLHVCQUF1QixFQUN4QixHQUFHQyxtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRUMsYUFBYSxFQUFFLEdBQUdELG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU0sRUFBRUUsV0FBVyxFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBQ2hDLE1BQU0sRUFBRUcsWUFBWSxFQUFFLEdBQUdILG1CQUFPQSxDQUFDO0FBQ2pDLE1BQU0sRUFBRUksa0JBQWtCLEVBQUVDLGFBQWEsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUN0RCxNQUFNLEVBQUVNLEtBQUssRUFBRSxHQUFHTixtQkFBT0EsQ0FBQztBQUMxQixNQUFNLEVBQUVPLGFBQWEsRUFBRSxHQUFHUCxtQkFBT0EsQ0FBQztBQUNsQyxNQUFNLEVBQUVRLElBQUksRUFBRSxHQUFHUixtQkFBT0EsQ0FBQztBQUV6QiwrQkFBK0IsR0FDL0IsTUFBTVMsNEJBQTRCO0lBQ2hDQyxZQUFZO0lBQ1pDLFVBQVU7SUFDVkMsY0FBYztBQUNoQjtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLGNBQWVDLEVBQUUsRUFBRUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLFlBQVk7SUFDbEQsNERBQTREO0lBQzVELG1CQUFtQjtJQUNuQixJQUFJSCxFQUFFLENBQUNuQixPQUFPLEtBQUssV0FBVztRQUM1QixNQUFNLElBQUlRLGFBQWEsaUJBQWlCO0lBQzFDO0lBRUEsa0NBQWtDO0lBQ2xDVyxFQUFFLENBQUNuQixPQUFPLEdBQUc7SUFFYiw4QkFBOEI7SUFDOUJtQixFQUFFLENBQUNqQixRQUFRLEdBQUc7SUFFZCw2QkFBNkI7SUFDN0JpQixFQUFFLENBQUNsQixPQUFPLEdBQUc7SUFFYiw2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c291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1maWdodGVyLWFjYWRlbXkvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmlsZWFwaS91dGlsLmpzPzgxNDgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAga1N0YXRlLFxuICBrRXJyb3IsXG4gIGtSZXN1bHQsXG4gIGtBYm9ydGVkLFxuICBrTGFzdFByb2dyZXNzRXZlbnRGaXJlZFxufSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IFByb2dyZXNzRXZlbnQgfSA9IHJlcXVpcmUoJy4vcHJvZ3Jlc3NldmVudCcpXG5jb25zdCB7IGdldEVuY29kaW5nIH0gPSByZXF1aXJlKCcuL2VuY29kaW5nJylcbmNvbnN0IHsgRE9NRXhjZXB0aW9uIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9jb25zdGFudHMnKVxuY29uc3QgeyBzZXJpYWxpemVBTWltZVR5cGUsIHBhcnNlTUlNRVR5cGUgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2RhdGFVUkwnKVxuY29uc3QgeyB0eXBlcyB9ID0gcmVxdWlyZSgndXRpbCcpXG5jb25zdCB7IFN0cmluZ0RlY29kZXIgfSA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJylcbmNvbnN0IHsgYnRvYSB9ID0gcmVxdWlyZSgnYnVmZmVyJylcblxuLyoqIEB0eXBlIHtQcm9wZXJ0eURlc2NyaXB0b3J9ICovXG5jb25zdCBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogZmFsc2UsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2Vcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNyZWFkT3BlcmF0aW9uXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9maWxlcmVhZGVyJykuRmlsZVJlYWRlcn0gZnJcbiAqIEBwYXJhbSB7aW1wb3J0KCdidWZmZXInKS5CbG9ifSBibG9iXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtzdHJpbmc/fSBlbmNvZGluZ05hbWVcbiAqL1xuZnVuY3Rpb24gcmVhZE9wZXJhdGlvbiAoZnIsIGJsb2IsIHR5cGUsIGVuY29kaW5nTmFtZSkge1xuICAvLyAxLiBJZiBmcuKAmXMgc3RhdGUgaXMgXCJsb2FkaW5nXCIsIHRocm93IGFuIEludmFsaWRTdGF0ZUVycm9yXG4gIC8vICAgIERPTUV4Y2VwdGlvbi5cbiAgaWYgKGZyW2tTdGF0ZV0gPT09ICdsb2FkaW5nJykge1xuICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0ludmFsaWQgc3RhdGUnLCAnSW52YWxpZFN0YXRlRXJyb3InKVxuICB9XG5cbiAgLy8gMi4gU2V0IGZy4oCZcyBzdGF0ZSB0byBcImxvYWRpbmdcIi5cbiAgZnJba1N0YXRlXSA9ICdsb2FkaW5nJ1xuXG4gIC8vIDMuIFNldCBmcuKAmXMgcmVzdWx0IHRvIG51bGwuXG4gIGZyW2tSZXN1bHRdID0gbnVsbFxuXG4gIC8vIDQuIFNldCBmcuKAmXMgZXJyb3IgdG8gbnVsbC5cbiAgZnJba0Vycm9yXSA9IG51bGxcblxuICAvLyA1LiBMZXQgc3RyZWFtIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyBnZXQgc3RyZWFtIG9uIGJsb2IuXG4gIC8qKiBAdHlwZSB7aW1wb3J0KCdzdHJlYW0vd2ViJykuUmVhZGFibGVTdHJlYW19ICovXG4gIGNvbnN0IHN0cmVhbSA9IGJsb2Iuc3RyZWFtKClcblxuICAvLyA2LiBMZXQgcmVhZGVyIGJlIHRoZSByZXN1bHQgb2YgZ2V0dGluZyBhIHJlYWRlciBmcm9tIHN0cmVhbS5cbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpXG5cbiAgLy8gNy4gTGV0IGJ5dGVzIGJlIGFuIGVtcHR5IGJ5dGUgc2VxdWVuY2UuXG4gIC8qKiBAdHlwZSB7VWludDhBcnJheVtdfSAqL1xuICBjb25zdCBieXRlcyA9IFtdXG5cbiAgLy8gOC4gTGV0IGNodW5rUHJvbWlzZSBiZSB0aGUgcmVzdWx0IG9mIHJlYWRpbmcgYSBjaHVuayBmcm9tXG4gIC8vICAgIHN0cmVhbSB3aXRoIHJlYWRlci5cbiAgbGV0IGNodW5rUHJvbWlzZSA9IHJlYWRlci5yZWFkKClcblxuICAvLyA5LiBMZXQgaXNGaXJzdENodW5rIGJlIHRydWUuXG4gIGxldCBpc0ZpcnN0Q2h1bmsgPSB0cnVlXG5cbiAgLy8gMTAuIEluIHBhcmFsbGVsLCB3aGlsZSB0cnVlOlxuICAvLyBOb3RlOiBcIkluIHBhcmFsbGVsXCIganVzdCBtZWFucyBub24tYmxvY2tpbmdcbiAgLy8gTm90ZSAyOiByZWFkT3BlcmF0aW9uIGl0c2VsZiBjYW5ub3QgYmUgYXN5bmMgYXMgZG91YmxlXG4gIC8vIHJlYWRpbmcgdGhlIGJvZHkgd291bGQgdGhlbiByZWplY3QgdGhlIHByb21pc2UsIGluc3RlYWRcbiAgLy8gb2YgdGhyb3dpbmcgYW4gZXJyb3IuXG4gIDsoYXN5bmMgKCkgPT4ge1xuICAgIHdoaWxlICghZnJba0Fib3J0ZWRdKSB7XG4gICAgICAvLyAxLiBXYWl0IGZvciBjaHVua1Byb21pc2UgdG8gYmUgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgY2h1bmtQcm9taXNlXG5cbiAgICAgICAgLy8gMi4gSWYgY2h1bmtQcm9taXNlIGlzIGZ1bGZpbGxlZCwgYW5kIGlzRmlyc3RDaHVuayBpc1xuICAgICAgICAvLyAgICB0cnVlLCBxdWV1ZSBhIHRhc2sgdG8gZmlyZSBhIHByb2dyZXNzIGV2ZW50IGNhbGxlZFxuICAgICAgICAvLyAgICBsb2Fkc3RhcnQgYXQgZnIuXG4gICAgICAgIGlmIChpc0ZpcnN0Q2h1bmsgJiYgIWZyW2tBYm9ydGVkXSkge1xuICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgnbG9hZHN0YXJ0JywgZnIpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuIFNldCBpc0ZpcnN0Q2h1bmsgdG8gZmFsc2UuXG4gICAgICAgIGlzRmlyc3RDaHVuayA9IGZhbHNlXG5cbiAgICAgICAgLy8gNC4gSWYgY2h1bmtQcm9taXNlIGlzIGZ1bGZpbGxlZCB3aXRoIGFuIG9iamVjdCB3aG9zZVxuICAgICAgICAvLyAgICBkb25lIHByb3BlcnR5IGlzIGZhbHNlIGFuZCB3aG9zZSB2YWx1ZSBwcm9wZXJ0eSBpc1xuICAgICAgICAvLyAgICBhIFVpbnQ4QXJyYXkgb2JqZWN0LCBydW4gdGhlc2Ugc3RlcHM6XG4gICAgICAgIGlmICghZG9uZSAmJiB0eXBlcy5pc1VpbnQ4QXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgLy8gMS4gTGV0IGJzIGJlIHRoZSBieXRlIHNlcXVlbmNlIHJlcHJlc2VudGVkIGJ5IHRoZVxuICAgICAgICAgIC8vICAgIFVpbnQ4QXJyYXkgb2JqZWN0LlxuXG4gICAgICAgICAgLy8gMi4gQXBwZW5kIGJzIHRvIGJ5dGVzLlxuICAgICAgICAgIGJ5dGVzLnB1c2godmFsdWUpXG5cbiAgICAgICAgICAvLyAzLiBJZiByb3VnaGx5IDUwbXMgaGF2ZSBwYXNzZWQgc2luY2UgdGhlc2Ugc3RlcHNcbiAgICAgICAgICAvLyAgICB3ZXJlIGxhc3QgaW52b2tlZCwgcXVldWUgYSB0YXNrIHRvIGZpcmUgYVxuICAgICAgICAgIC8vICAgIHByb2dyZXNzIGV2ZW50IGNhbGxlZCBwcm9ncmVzcyBhdCBmci5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgIGZyW2tMYXN0UHJvZ3Jlc3NFdmVudEZpcmVkXSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgIERhdGUubm93KCkgLSBmcltrTGFzdFByb2dyZXNzRXZlbnRGaXJlZF0gPj0gNTBcbiAgICAgICAgICAgICkgJiZcbiAgICAgICAgICAgICFmcltrQWJvcnRlZF1cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGZyW2tMYXN0UHJvZ3Jlc3NFdmVudEZpcmVkXSA9IERhdGUubm93KClcbiAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgICAgZmlyZUFQcm9ncmVzc0V2ZW50KCdwcm9ncmVzcycsIGZyKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LiBTZXQgY2h1bmtQcm9taXNlIHRvIHRoZSByZXN1bHQgb2YgcmVhZGluZyBhXG4gICAgICAgICAgLy8gICAgY2h1bmsgZnJvbSBzdHJlYW0gd2l0aCByZWFkZXIuXG4gICAgICAgICAgY2h1bmtQcm9taXNlID0gcmVhZGVyLnJlYWQoKVxuICAgICAgICB9IGVsc2UgaWYgKGRvbmUpIHtcbiAgICAgICAgICAvLyA1LiBPdGhlcndpc2UsIGlmIGNodW5rUHJvbWlzZSBpcyBmdWxmaWxsZWQgd2l0aCBhblxuICAgICAgICAgIC8vICAgIG9iamVjdCB3aG9zZSBkb25lIHByb3BlcnR5IGlzIHRydWUsIHF1ZXVlIGEgdGFza1xuICAgICAgICAgIC8vICAgIHRvIHJ1biB0aGUgZm9sbG93aW5nIHN0ZXBzIGFuZCBhYm9ydCB0aGlzIGFsZ29yaXRobTpcbiAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAvLyAxLiBTZXQgZnLigJlzIHN0YXRlIHRvIFwiZG9uZVwiLlxuICAgICAgICAgICAgZnJba1N0YXRlXSA9ICdkb25lJ1xuXG4gICAgICAgICAgICAvLyAyLiBMZXQgcmVzdWx0IGJlIHRoZSByZXN1bHQgb2YgcGFja2FnZSBkYXRhIGdpdmVuXG4gICAgICAgICAgICAvLyAgICBieXRlcywgdHlwZSwgYmxvYuKAmXMgdHlwZSwgYW5kIGVuY29kaW5nTmFtZS5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhY2thZ2VEYXRhKGJ5dGVzLCB0eXBlLCBibG9iLnR5cGUsIGVuY29kaW5nTmFtZSlcblxuICAgICAgICAgICAgICAvLyA0LiBFbHNlOlxuXG4gICAgICAgICAgICAgIGlmIChmcltrQWJvcnRlZF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIDEuIFNldCBmcuKAmXMgcmVzdWx0IHRvIHJlc3VsdC5cbiAgICAgICAgICAgICAgZnJba1Jlc3VsdF0gPSByZXN1bHRcblxuICAgICAgICAgICAgICAvLyAyLiBGaXJlIGEgcHJvZ3Jlc3MgZXZlbnQgY2FsbGVkIGxvYWQgYXQgdGhlIGZyLlxuICAgICAgICAgICAgICBmaXJlQVByb2dyZXNzRXZlbnQoJ2xvYWQnLCBmcilcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIC8vIDMuIElmIHBhY2thZ2UgZGF0YSB0aHJldyBhbiBleGNlcHRpb24gZXJyb3I6XG5cbiAgICAgICAgICAgICAgLy8gMS4gU2V0IGZy4oCZcyBlcnJvciB0byBlcnJvci5cbiAgICAgICAgICAgICAgZnJba0Vycm9yXSA9IGVycm9yXG5cbiAgICAgICAgICAgICAgLy8gMi4gRmlyZSBhIHByb2dyZXNzIGV2ZW50IGNhbGxlZCBlcnJvciBhdCBmci5cbiAgICAgICAgICAgICAgZmlyZUFQcm9ncmVzc0V2ZW50KCdlcnJvcicsIGZyKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyA1LiBJZiBmcuKAmXMgc3RhdGUgaXMgbm90IFwibG9hZGluZ1wiLCBmaXJlIGEgcHJvZ3Jlc3NcbiAgICAgICAgICAgIC8vICAgIGV2ZW50IGNhbGxlZCBsb2FkZW5kIGF0IHRoZSBmci5cbiAgICAgICAgICAgIGlmIChmcltrU3RhdGVdICE9PSAnbG9hZGluZycpIHtcbiAgICAgICAgICAgICAgZmlyZUFQcm9ncmVzc0V2ZW50KCdsb2FkZW5kJywgZnIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChmcltrQWJvcnRlZF0pIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDYuIE90aGVyd2lzZSwgaWYgY2h1bmtQcm9taXNlIGlzIHJlamVjdGVkIHdpdGggYW5cbiAgICAgICAgLy8gICAgZXJyb3IgZXJyb3IsIHF1ZXVlIGEgdGFzayB0byBydW4gdGhlIGZvbGxvd2luZ1xuICAgICAgICAvLyAgICBzdGVwcyBhbmQgYWJvcnQgdGhpcyBhbGdvcml0aG06XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAvLyAxLiBTZXQgZnLigJlzIHN0YXRlIHRvIFwiZG9uZVwiLlxuICAgICAgICAgIGZyW2tTdGF0ZV0gPSAnZG9uZSdcblxuICAgICAgICAgIC8vIDIuIFNldCBmcuKAmXMgZXJyb3IgdG8gZXJyb3IuXG4gICAgICAgICAgZnJba0Vycm9yXSA9IGVycm9yXG5cbiAgICAgICAgICAvLyAzLiBGaXJlIGEgcHJvZ3Jlc3MgZXZlbnQgY2FsbGVkIGVycm9yIGF0IGZyLlxuICAgICAgICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgnZXJyb3InLCBmcilcblxuICAgICAgICAgIC8vIDQuIElmIGZy4oCZcyBzdGF0ZSBpcyBub3QgXCJsb2FkaW5nXCIsIGZpcmUgYSBwcm9ncmVzc1xuICAgICAgICAgIC8vICAgIGV2ZW50IGNhbGxlZCBsb2FkZW5kIGF0IGZyLlxuICAgICAgICAgIGlmIChmcltrU3RhdGVdICE9PSAnbG9hZGluZycpIHtcbiAgICAgICAgICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgnbG9hZGVuZCcsIGZyKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfSkoKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2ZpcmUtYS1wcm9ncmVzcy1ldmVudFxuICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtZXZlbnQtZmlyZVxuICogQHBhcmFtIHtzdHJpbmd9IGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9maWxlcmVhZGVyJykuRmlsZVJlYWRlcn0gcmVhZGVyXG4gKi9cbmZ1bmN0aW9uIGZpcmVBUHJvZ3Jlc3NFdmVudCAoZSwgcmVhZGVyKSB7XG4gIC8vIFRoZSBwcm9ncmVzcyBldmVudCBlIGRvZXMgbm90IGJ1YmJsZS4gZS5idWJibGVzIG11c3QgYmUgZmFsc2VcbiAgLy8gVGhlIHByb2dyZXNzIGV2ZW50IGUgaXMgTk9UIGNhbmNlbGFibGUuIGUuY2FuY2VsYWJsZSBtdXN0IGJlIGZhbHNlXG4gIGNvbnN0IGV2ZW50ID0gbmV3IFByb2dyZXNzRXZlbnQoZSwge1xuICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gIH0pXG5cbiAgcmVhZGVyLmRpc3BhdGNoRXZlbnQoZXZlbnQpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jYmxvYi1wYWNrYWdlLWRhdGFcbiAqIEBwYXJhbSB7VWludDhBcnJheVtdfSBieXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nP30gbWltZVR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nP30gZW5jb2RpbmdOYW1lXG4gKi9cbmZ1bmN0aW9uIHBhY2thZ2VEYXRhIChieXRlcywgdHlwZSwgbWltZVR5cGUsIGVuY29kaW5nTmFtZSkge1xuICAvLyAxLiBBIEJsb2IgaGFzIGFuIGFzc29jaWF0ZWQgcGFja2FnZSBkYXRhIGFsZ29yaXRobSwgZ2l2ZW5cbiAgLy8gICAgYnl0ZXMsIGEgdHlwZSwgYSBvcHRpb25hbCBtaW1lVHlwZSwgYW5kIGEgb3B0aW9uYWxcbiAgLy8gICAgZW5jb2RpbmdOYW1lLCB3aGljaCBzd2l0Y2hlcyBvbiB0eXBlIGFuZCBydW5zIHRoZVxuICAvLyAgICBhc3NvY2lhdGVkIHN0ZXBzOlxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ0RhdGFVUkwnOiB7XG4gICAgICAvLyAxLiBSZXR1cm4gYnl0ZXMgYXMgYSBEYXRhVVJMIFtSRkMyMzk3XSBzdWJqZWN0IHRvXG4gICAgICAvLyAgICB0aGUgY29uc2lkZXJhdGlvbnMgYmVsb3c6XG4gICAgICAvLyAgKiBVc2UgbWltZVR5cGUgYXMgcGFydCBvZiB0aGUgRGF0YSBVUkwgaWYgaXQgaXNcbiAgICAgIC8vICAgIGF2YWlsYWJsZSBpbiBrZWVwaW5nIHdpdGggdGhlIERhdGEgVVJMXG4gICAgICAvLyAgICBzcGVjaWZpY2F0aW9uIFtSRkMyMzk3XS5cbiAgICAgIC8vICAqIElmIG1pbWVUeXBlIGlzIG5vdCBhdmFpbGFibGUgcmV0dXJuIGEgRGF0YSBVUkxcbiAgICAgIC8vICAgIHdpdGhvdXQgYSBtZWRpYS10eXBlLiBbUkZDMjM5N10uXG5cbiAgICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjMjM5NyNzZWN0aW9uLTNcbiAgICAgIC8vIGRhdGF1cmwgICAgOj0gXCJkYXRhOlwiIFsgbWVkaWF0eXBlIF0gWyBcIjtiYXNlNjRcIiBdIFwiLFwiIGRhdGFcbiAgICAgIC8vIG1lZGlhdHlwZSAgOj0gWyB0eXBlIFwiL1wiIHN1YnR5cGUgXSAqKCBcIjtcIiBwYXJhbWV0ZXIgKVxuICAgICAgLy8gZGF0YSAgICAgICA6PSAqdXJsY2hhclxuICAgICAgLy8gcGFyYW1ldGVyICA6PSBhdHRyaWJ1dGUgXCI9XCIgdmFsdWVcbiAgICAgIGxldCBkYXRhVVJMID0gJ2RhdGE6J1xuXG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZU1JTUVUeXBlKG1pbWVUeXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKVxuXG4gICAgICBpZiAocGFyc2VkICE9PSAnZmFpbHVyZScpIHtcbiAgICAgICAgZGF0YVVSTCArPSBzZXJpYWxpemVBTWltZVR5cGUocGFyc2VkKVxuICAgICAgfVxuXG4gICAgICBkYXRhVVJMICs9ICc7YmFzZTY0LCdcblxuICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKCdsYXRpbjEnKVxuXG4gICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGJ5dGVzKSB7XG4gICAgICAgIGRhdGFVUkwgKz0gYnRvYShkZWNvZGVyLndyaXRlKGNodW5rKSlcbiAgICAgIH1cblxuICAgICAgZGF0YVVSTCArPSBidG9hKGRlY29kZXIuZW5kKCkpXG5cbiAgICAgIHJldHVybiBkYXRhVVJMXG4gICAgfVxuICAgIGNhc2UgJ1RleHQnOiB7XG4gICAgICAvLyAxLiBMZXQgZW5jb2RpbmcgYmUgZmFpbHVyZVxuICAgICAgbGV0IGVuY29kaW5nID0gJ2ZhaWx1cmUnXG5cbiAgICAgIC8vIDIuIElmIHRoZSBlbmNvZGluZ05hbWUgaXMgcHJlc2VudCwgc2V0IGVuY29kaW5nIHRvIHRoZVxuICAgICAgLy8gICAgcmVzdWx0IG9mIGdldHRpbmcgYW4gZW5jb2RpbmcgZnJvbSBlbmNvZGluZ05hbWUuXG4gICAgICBpZiAoZW5jb2RpbmdOYW1lKSB7XG4gICAgICAgIGVuY29kaW5nID0gZ2V0RW5jb2RpbmcoZW5jb2RpbmdOYW1lKVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBJZiBlbmNvZGluZyBpcyBmYWlsdXJlLCBhbmQgbWltZVR5cGUgaXMgcHJlc2VudDpcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2ZhaWx1cmUnICYmIG1pbWVUeXBlKSB7XG4gICAgICAgIC8vIDEuIExldCB0eXBlIGJlIHRoZSByZXN1bHQgb2YgcGFyc2UgYSBNSU1FIHR5cGVcbiAgICAgICAgLy8gICAgZ2l2ZW4gbWltZVR5cGUuXG4gICAgICAgIGNvbnN0IHR5cGUgPSBwYXJzZU1JTUVUeXBlKG1pbWVUeXBlKVxuXG4gICAgICAgIC8vIDIuIElmIHR5cGUgaXMgbm90IGZhaWx1cmUsIHNldCBlbmNvZGluZyB0byB0aGUgcmVzdWx0XG4gICAgICAgIC8vICAgIG9mIGdldHRpbmcgYW4gZW5jb2RpbmcgZnJvbSB0eXBl4oCZcyBwYXJhbWV0ZXJzW1wiY2hhcnNldFwiXS5cbiAgICAgICAgaWYgKHR5cGUgIT09ICdmYWlsdXJlJykge1xuICAgICAgICAgIGVuY29kaW5nID0gZ2V0RW5jb2RpbmcodHlwZS5wYXJhbWV0ZXJzLmdldCgnY2hhcnNldCcpKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIDQuIElmIGVuY29kaW5nIGlzIGZhaWx1cmUsIHRoZW4gc2V0IGVuY29kaW5nIHRvIFVURi04LlxuICAgICAgaWYgKGVuY29kaW5nID09PSAnZmFpbHVyZScpIHtcbiAgICAgICAgZW5jb2RpbmcgPSAnVVRGLTgnXG4gICAgICB9XG5cbiAgICAgIC8vIDUuIERlY29kZSBieXRlcyB1c2luZyBmYWxsYmFjayBlbmNvZGluZyBlbmNvZGluZywgYW5kXG4gICAgICAvLyAgICByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICAgIHJldHVybiBkZWNvZGUoYnl0ZXMsIGVuY29kaW5nKVxuICAgIH1cbiAgICBjYXNlICdBcnJheUJ1ZmZlcic6IHtcbiAgICAgIC8vIFJldHVybiBhIG5ldyBBcnJheUJ1ZmZlciB3aG9zZSBjb250ZW50cyBhcmUgYnl0ZXMuXG4gICAgICBjb25zdCBzZXF1ZW5jZSA9IGNvbWJpbmVCeXRlU2VxdWVuY2VzKGJ5dGVzKVxuXG4gICAgICByZXR1cm4gc2VxdWVuY2UuYnVmZmVyXG4gICAgfVxuICAgIGNhc2UgJ0JpbmFyeVN0cmluZyc6IHtcbiAgICAgIC8vIFJldHVybiBieXRlcyBhcyBhIGJpbmFyeSBzdHJpbmcsIGluIHdoaWNoIGV2ZXJ5IGJ5dGVcbiAgICAgIC8vICBpcyByZXByZXNlbnRlZCBieSBhIGNvZGUgdW5pdCBvZiBlcXVhbCB2YWx1ZSBbMC4uMjU1XS5cbiAgICAgIGxldCBiaW5hcnlTdHJpbmcgPSAnJ1xuXG4gICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoJ2xhdGluMScpXG5cbiAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgYnl0ZXMpIHtcbiAgICAgICAgYmluYXJ5U3RyaW5nICs9IGRlY29kZXIud3JpdGUoY2h1bmspXG4gICAgICB9XG5cbiAgICAgIGJpbmFyeVN0cmluZyArPSBkZWNvZGVyLmVuZCgpXG5cbiAgICAgIHJldHVybiBiaW5hcnlTdHJpbmdcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZW5jb2Rpbmcuc3BlYy53aGF0d2cub3JnLyNkZWNvZGVcbiAqIEBwYXJhbSB7VWludDhBcnJheVtdfSBpb1F1ZXVlXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmdcbiAqL1xuZnVuY3Rpb24gZGVjb2RlIChpb1F1ZXVlLCBlbmNvZGluZykge1xuICBjb25zdCBieXRlcyA9IGNvbWJpbmVCeXRlU2VxdWVuY2VzKGlvUXVldWUpXG5cbiAgLy8gMS4gTGV0IEJPTUVuY29kaW5nIGJlIHRoZSByZXN1bHQgb2YgQk9NIHNuaWZmaW5nIGlvUXVldWUuXG4gIGNvbnN0IEJPTUVuY29kaW5nID0gQk9NU25pZmZpbmcoYnl0ZXMpXG5cbiAgbGV0IHNsaWNlID0gMFxuXG4gIC8vIDIuIElmIEJPTUVuY29kaW5nIGlzIG5vbi1udWxsOlxuICBpZiAoQk9NRW5jb2RpbmcgIT09IG51bGwpIHtcbiAgICAvLyAxLiBTZXQgZW5jb2RpbmcgdG8gQk9NRW5jb2RpbmcuXG4gICAgZW5jb2RpbmcgPSBCT01FbmNvZGluZ1xuXG4gICAgLy8gMi4gUmVhZCB0aHJlZSBieXRlcyBmcm9tIGlvUXVldWUsIGlmIEJPTUVuY29kaW5nIGlzXG4gICAgLy8gICAgVVRGLTg7IG90aGVyd2lzZSByZWFkIHR3byBieXRlcy5cbiAgICAvLyAgICAoRG8gbm90aGluZyB3aXRoIHRob3NlIGJ5dGVzLilcbiAgICBzbGljZSA9IEJPTUVuY29kaW5nID09PSAnVVRGLTgnID8gMyA6IDJcbiAgfVxuXG4gIC8vIDMuIFByb2Nlc3MgYSBxdWV1ZSB3aXRoIGFuIGluc3RhbmNlIG9mIGVuY29kaW5n4oCZc1xuICAvLyAgICBkZWNvZGVyLCBpb1F1ZXVlLCBvdXRwdXQsIGFuZCBcInJlcGxhY2VtZW50XCIuXG5cbiAgLy8gNC4gUmV0dXJuIG91dHB1dC5cblxuICBjb25zdCBzbGljZWQgPSBieXRlcy5zbGljZShzbGljZSlcbiAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZykuZGVjb2RlKHNsaWNlZClcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZW5jb2Rpbmcuc3BlYy53aGF0d2cub3JnLyNib20tc25pZmZcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gaW9RdWV1ZVxuICovXG5mdW5jdGlvbiBCT01TbmlmZmluZyAoaW9RdWV1ZSkge1xuICAvLyAxLiBMZXQgQk9NIGJlIHRoZSByZXN1bHQgb2YgcGVla2luZyAzIGJ5dGVzIGZyb20gaW9RdWV1ZSxcbiAgLy8gICAgY29udmVydGVkIHRvIGEgYnl0ZSBzZXF1ZW5jZS5cbiAgY29uc3QgW2EsIGIsIGNdID0gaW9RdWV1ZVxuXG4gIC8vIDIuIEZvciBlYWNoIG9mIHRoZSByb3dzIGluIHRoZSB0YWJsZSBiZWxvdywgc3RhcnRpbmcgd2l0aFxuICAvLyAgICB0aGUgZmlyc3Qgb25lIGFuZCBnb2luZyBkb3duLCBpZiBCT00gc3RhcnRzIHdpdGggdGhlXG4gIC8vICAgIGJ5dGVzIGdpdmVuIGluIHRoZSBmaXJzdCBjb2x1bW4sIHRoZW4gcmV0dXJuIHRoZVxuICAvLyAgICBlbmNvZGluZyBnaXZlbiBpbiB0aGUgY2VsbCBpbiB0aGUgc2Vjb25kIGNvbHVtbiBvZiB0aGF0XG4gIC8vICAgIHJvdy4gT3RoZXJ3aXNlLCByZXR1cm4gbnVsbC5cbiAgaWYgKGEgPT09IDB4RUYgJiYgYiA9PT0gMHhCQiAmJiBjID09PSAweEJGKSB7XG4gICAgcmV0dXJuICdVVEYtOCdcbiAgfSBlbHNlIGlmIChhID09PSAweEZFICYmIGIgPT09IDB4RkYpIHtcbiAgICByZXR1cm4gJ1VURi0xNkJFJ1xuICB9IGVsc2UgaWYgKGEgPT09IDB4RkYgJiYgYiA9PT0gMHhGRSkge1xuICAgIHJldHVybiAnVVRGLTE2TEUnXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheVtdfSBzZXF1ZW5jZXNcbiAqL1xuZnVuY3Rpb24gY29tYmluZUJ5dGVTZXF1ZW5jZXMgKHNlcXVlbmNlcykge1xuICBjb25zdCBzaXplID0gc2VxdWVuY2VzLnJlZHVjZSgoYSwgYikgPT4ge1xuICAgIHJldHVybiBhICsgYi5ieXRlTGVuZ3RoXG4gIH0sIDApXG5cbiAgbGV0IG9mZnNldCA9IDBcblxuICByZXR1cm4gc2VxdWVuY2VzLnJlZHVjZSgoYSwgYikgPT4ge1xuICAgIGEuc2V0KGIsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gYi5ieXRlTGVuZ3RoXG4gICAgcmV0dXJuIGFcbiAgfSwgbmV3IFVpbnQ4QXJyYXkoc2l6ZSkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICByZWFkT3BlcmF0aW9uLFxuICBmaXJlQVByb2dyZXNzRXZlbnRcbn1cbiJdLCJuYW1lcyI6WyJrU3RhdGUiLCJrRXJyb3IiLCJrUmVzdWx0Iiwia0Fib3J0ZWQiLCJrTGFzdFByb2dyZXNzRXZlbnRGaXJlZCIsInJlcXVpcmUiLCJQcm9ncmVzc0V2ZW50IiwiZ2V0RW5jb2RpbmciLCJET01FeGNlcHRpb24iLCJzZXJpYWxpemVBTWltZVR5cGUiLCJwYXJzZU1JTUVUeXBlIiwidHlwZXMiLCJTdHJpbmdEZWNvZGVyIiwiYnRvYSIsInN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJyZWFkT3BlcmF0aW9uIiwiZnIiLCJibG9iIiwidHlwZSIsImVuY29kaW5nTmFtZSIsInN0cmVhbSIsInJlYWRlciIsImdldFJlYWRlciIsImJ5dGVzIiwiY2h1bmtQcm9taXNlIiwicmVhZCIsImlzRmlyc3RDaHVuayIsImRvbmUiLCJ2YWx1ZSIsInF1ZXVlTWljcm90YXNrIiwiZmlyZUFQcm9ncmVzc0V2ZW50IiwiaXNVaW50OEFycmF5IiwicHVzaCIsInVuZGVmaW5lZCIsIkRhdGUiLCJub3ciLCJyZXN1bHQiLCJwYWNrYWdlRGF0YSIsImVycm9yIiwiZSIsImV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJkaXNwYXRjaEV2ZW50IiwibWltZVR5cGUiLCJkYXRhVVJMIiwicGFyc2VkIiwiZGVjb2RlciIsImNodW5rIiwid3JpdGUiLCJlbmQiLCJlbmNvZGluZyIsInBhcmFtZXRlcnMiLCJnZXQiLCJkZWNvZGUiLCJzZXF1ZW5jZSIsImNvbWJpbmVCeXRlU2VxdWVuY2VzIiwiYnVmZmVyIiwiYmluYXJ5U3RyaW5nIiwiaW9RdWV1ZSIsIkJPTUVuY29kaW5nIiwiQk9NU25pZmZpbmciLCJzbGljZSIsInNsaWNlZCIsIlRleHREZWNvZGVyIiwiYSIsImIiLCJjIiwic2VxdWVuY2VzIiwic2l6ZSIsInJlZHVjZSIsImJ5dGVMZW5ndGgiLCJvZmZzZXQiLCJzZXQiLCJVaW50OEFycmF5IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/fileapi/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/global.js":
/*!*****************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/global.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n// We include a version number for the Dispatcher API. In case of breaking changes,\n// this version number must be increased to avoid conflicts.\nconst globalDispatcher = Symbol.for(\"undici.globalDispatcher.1\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\nconst Agent = __webpack_require__(/*! ./agent */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/agent.js\");\nif (getGlobalDispatcher() === undefined) {\n    setGlobalDispatcher(new Agent());\n}\nfunction setGlobalDispatcher(agent) {\n    if (!agent || typeof agent.dispatch !== \"function\") {\n        throw new InvalidArgumentError(\"Argument agent must implement Agent\");\n    }\n    Object.defineProperty(globalThis, globalDispatcher, {\n        value: agent,\n        writable: true,\n        enumerable: false,\n        configurable: false\n    });\n}\nfunction getGlobalDispatcher() {\n    return globalThis[globalDispatcher];\n}\nmodule.exports = {\n    setGlobalDispatcher,\n    getGlobalDispatcher\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZ2xvYmFsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsbUZBQW1GO0FBQ25GLDREQUE0RDtBQUM1RCxNQUFNQSxtQkFBbUJDLE9BQU9DLEdBQUcsQ0FBQztBQUNwQyxNQUFNLEVBQUVDLG9CQUFvQixFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ3pDLE1BQU1DLFFBQVFELG1CQUFPQSxDQUFDO0FBRXRCLElBQUlFLDBCQUEwQkMsV0FBVztJQUN2Q0Msb0JBQW9CLElBQUlIO0FBQzFCO0FBRUEsU0FBU0csb0JBQXFCQyxLQUFLO0lBQ2pDLElBQUksQ0FBQ0EsU0FBUyxPQUFPQSxNQUFNQyxRQUFRLEtBQUssWUFBWTtRQUNsRCxNQUFNLElBQUlQLHFCQUFxQjtJQUNqQztJQUNBUSxPQUFPQyxjQUFjLENBQUNDLFlBQVliLGtCQUFrQjtRQUNsRGMsT0FBT0w7UUFDUE0sVUFBVTtRQUNWQyxZQUFZO1FBQ1pDLGNBQWM7SUFDaEI7QUFDRjtBQUVBLFNBQVNYO0lBQ1AsT0FBT08sVUFBVSxDQUFDYixpQkFBaUI7QUFDckM7QUFFQWtCLE9BQU9DLE9BQU8sR0FBRztJQUNmWDtJQUNBRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1maWdodGVyLWFjYWRlbXkvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZ2xvYmFsLmpzPzk4ZTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIFdlIGluY2x1ZGUgYSB2ZXJzaW9uIG51bWJlciBmb3IgdGhlIERpc3BhdGNoZXIgQVBJLiBJbiBjYXNlIG9mIGJyZWFraW5nIGNoYW5nZXMsXG4vLyB0aGlzIHZlcnNpb24gbnVtYmVyIG11c3QgYmUgaW5jcmVhc2VkIHRvIGF2b2lkIGNvbmZsaWN0cy5cbmNvbnN0IGdsb2JhbERpc3BhdGNoZXIgPSBTeW1ib2wuZm9yKCd1bmRpY2kuZ2xvYmFsRGlzcGF0Y2hlci4xJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4vY29yZS9lcnJvcnMnKVxuY29uc3QgQWdlbnQgPSByZXF1aXJlKCcuL2FnZW50JylcblxuaWYgKGdldEdsb2JhbERpc3BhdGNoZXIoKSA9PT0gdW5kZWZpbmVkKSB7XG4gIHNldEdsb2JhbERpc3BhdGNoZXIobmV3IEFnZW50KCkpXG59XG5cbmZ1bmN0aW9uIHNldEdsb2JhbERpc3BhdGNoZXIgKGFnZW50KSB7XG4gIGlmICghYWdlbnQgfHwgdHlwZW9mIGFnZW50LmRpc3BhdGNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdBcmd1bWVudCBhZ2VudCBtdXN0IGltcGxlbWVudCBBZ2VudCcpXG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbFRoaXMsIGdsb2JhbERpc3BhdGNoZXIsIHtcbiAgICB2YWx1ZTogYWdlbnQsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5mdW5jdGlvbiBnZXRHbG9iYWxEaXNwYXRjaGVyICgpIHtcbiAgcmV0dXJuIGdsb2JhbFRoaXNbZ2xvYmFsRGlzcGF0Y2hlcl1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldEdsb2JhbERpc3BhdGNoZXIsXG4gIGdldEdsb2JhbERpc3BhdGNoZXJcbn1cbiJdLCJuYW1lcyI6WyJnbG9iYWxEaXNwYXRjaGVyIiwiU3ltYm9sIiwiZm9yIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJyZXF1aXJlIiwiQWdlbnQiLCJnZXRHbG9iYWxEaXNwYXRjaGVyIiwidW5kZWZpbmVkIiwic2V0R2xvYmFsRGlzcGF0Y2hlciIsImFnZW50IiwiZGlzcGF0Y2giLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdsb2JhbFRoaXMiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/global.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/handler/DecoratorHandler.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/handler/DecoratorHandler.js ***!
  \***********************************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = class DecoratorHandler {\n    constructor(handler){\n        this.handler = handler;\n    }\n    onConnect(...args) {\n        return this.handler.onConnect(...args);\n    }\n    onError(...args) {\n        return this.handler.onError(...args);\n    }\n    onUpgrade(...args) {\n        return this.handler.onUpgrade(...args);\n    }\n    onHeaders(...args) {\n        return this.handler.onHeaders(...args);\n    }\n    onData(...args) {\n        return this.handler.onData(...args);\n    }\n    onComplete(...args) {\n        return this.handler.onComplete(...args);\n    }\n    onBodySent(...args) {\n        return this.handler.onBodySent(...args);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaGFuZGxlci9EZWNvcmF0b3JIYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLE9BQU9DLE9BQU8sR0FBRyxNQUFNQztJQUNyQkMsWUFBYUMsT0FBTyxDQUFFO1FBQ3BCLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNqQjtJQUVBQyxVQUFXLEdBQUdDLElBQUksRUFBRTtRQUNsQixPQUFPLElBQUksQ0FBQ0YsT0FBTyxDQUFDQyxTQUFTLElBQUlDO0lBQ25DO0lBRUFDLFFBQVMsR0FBR0QsSUFBSSxFQUFFO1FBQ2hCLE9BQU8sSUFBSSxDQUFDRixPQUFPLENBQUNHLE9BQU8sSUFBSUQ7SUFDakM7SUFFQUUsVUFBVyxHQUFHRixJQUFJLEVBQUU7UUFDbEIsT0FBTyxJQUFJLENBQUNGLE9BQU8sQ0FBQ0ksU0FBUyxJQUFJRjtJQUNuQztJQUVBRyxVQUFXLEdBQUdILElBQUksRUFBRTtRQUNsQixPQUFPLElBQUksQ0FBQ0YsT0FBTyxDQUFDSyxTQUFTLElBQUlIO0lBQ25DO0lBRUFJLE9BQVEsR0FBR0osSUFBSSxFQUFFO1FBQ2YsT0FBTyxJQUFJLENBQUNGLE9BQU8sQ0FBQ00sTUFBTSxJQUFJSjtJQUNoQztJQUVBSyxXQUFZLEdBQUdMLElBQUksRUFBRTtRQUNuQixPQUFPLElBQUksQ0FBQ0YsT0FBTyxDQUFDTyxVQUFVLElBQUlMO0lBQ3BDO0lBRUFNLFdBQVksR0FBR04sSUFBSSxFQUFFO1FBQ25CLE9BQU8sSUFBSSxDQUFDRixPQUFPLENBQUNRLFVBQVUsSUFBSU47SUFDcEM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2hhbmRsZXIvRGVjb3JhdG9ySGFuZGxlci5qcz82YzI4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIERlY29yYXRvckhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoaGFuZGxlcikge1xuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXJcbiAgfVxuXG4gIG9uQ29ubmVjdCAoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25Db25uZWN0KC4uLmFyZ3MpXG4gIH1cblxuICBvbkVycm9yICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkVycm9yKC4uLmFyZ3MpXG4gIH1cblxuICBvblVwZ3JhZGUgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uVXBncmFkZSguLi5hcmdzKVxuICB9XG5cbiAgb25IZWFkZXJzICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkhlYWRlcnMoLi4uYXJncylcbiAgfVxuXG4gIG9uRGF0YSAoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25EYXRhKC4uLmFyZ3MpXG4gIH1cblxuICBvbkNvbXBsZXRlICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkNvbXBsZXRlKC4uLmFyZ3MpXG4gIH1cblxuICBvbkJvZHlTZW50ICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkJvZHlTZW50KC4uLmFyZ3MpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiRGVjb3JhdG9ySGFuZGxlciIsImNvbnN0cnVjdG9yIiwiaGFuZGxlciIsIm9uQ29ubmVjdCIsImFyZ3MiLCJvbkVycm9yIiwib25VcGdyYWRlIiwib25IZWFkZXJzIiwib25EYXRhIiwib25Db21wbGV0ZSIsIm9uQm9keVNlbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/handler/DecoratorHandler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/handler/RedirectHandler.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/handler/RedirectHandler.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst { kBodyUsed } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\nconst EE = __webpack_require__(/*! events */ \"events\");\nconst redirectableStatusCodes = [\n    300,\n    301,\n    302,\n    303,\n    307,\n    308\n];\nconst kBody = Symbol(\"body\");\nclass BodyAsyncIterable {\n    constructor(body){\n        this[kBody] = body;\n        this[kBodyUsed] = false;\n    }\n    async *[Symbol.asyncIterator]() {\n        assert(!this[kBodyUsed], \"disturbed\");\n        this[kBodyUsed] = true;\n        yield* this[kBody];\n    }\n}\nclass RedirectHandler {\n    constructor(dispatch, maxRedirections, opts, handler){\n        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n            throw new InvalidArgumentError(\"maxRedirections must be a positive number\");\n        }\n        util.validateHandler(handler, opts.method, opts.upgrade);\n        this.dispatch = dispatch;\n        this.location = null;\n        this.abort = null;\n        this.opts = {\n            ...opts,\n            maxRedirections: 0\n        } // opts must be a copy\n        ;\n        this.maxRedirections = maxRedirections;\n        this.handler = handler;\n        this.history = [];\n        if (util.isStream(this.opts.body)) {\n            // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp\n            // so that it can be dispatched again?\n            // TODO (fix): Do we need 100-expect support to provide a way to do this properly?\n            if (util.bodyLength(this.opts.body) === 0) {\n                this.opts.body.on(\"data\", function() {\n                    assert(false);\n                });\n            }\n            if (typeof this.opts.body.readableDidRead !== \"boolean\") {\n                this.opts.body[kBodyUsed] = false;\n                EE.prototype.on.call(this.opts.body, \"data\", function() {\n                    this[kBodyUsed] = true;\n                });\n            }\n        } else if (this.opts.body && typeof this.opts.body.pipeTo === \"function\") {\n            // TODO (fix): We can't access ReadableStream internal state\n            // to determine whether or not it has been disturbed. This is just\n            // a workaround.\n            this.opts.body = new BodyAsyncIterable(this.opts.body);\n        } else if (this.opts.body && typeof this.opts.body !== \"string\" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) {\n            // TODO: Should we allow re-using iterable if !this.opts.idempotent\n            // or through some other flag?\n            this.opts.body = new BodyAsyncIterable(this.opts.body);\n        }\n    }\n    onConnect(abort) {\n        this.abort = abort;\n        this.handler.onConnect(abort, {\n            history: this.history\n        });\n    }\n    onUpgrade(statusCode, headers, socket) {\n        this.handler.onUpgrade(statusCode, headers, socket);\n    }\n    onError(error) {\n        this.handler.onError(error);\n    }\n    onHeaders(statusCode, headers, resume, statusText) {\n        this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);\n        if (this.opts.origin) {\n            this.history.push(new URL(this.opts.path, this.opts.origin));\n        }\n        if (!this.location) {\n            return this.handler.onHeaders(statusCode, headers, resume, statusText);\n        }\n        const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));\n        const path = search ? `${pathname}${search}` : pathname;\n        // Remove headers referring to the original URL.\n        // By default it is Host only, unless it's a 303 (see below), which removes also all Content-* headers.\n        // https://tools.ietf.org/html/rfc7231#section-6.4\n        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);\n        this.opts.path = path;\n        this.opts.origin = origin;\n        this.opts.maxRedirections = 0;\n        this.opts.query = null;\n        // https://tools.ietf.org/html/rfc7231#section-6.4.4\n        // In case of HTTP 303, always replace method to be either HEAD or GET\n        if (statusCode === 303 && this.opts.method !== \"HEAD\") {\n            this.opts.method = \"GET\";\n            this.opts.body = null;\n        }\n    }\n    onData(chunk) {\n        if (this.location) {\n        /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response bodies.\n\n        Redirection is used to serve the requested resource from another URL, so it is assumes that\n        no body is generated (and thus can be ignored). Even though generating a body is not prohibited.\n\n        For status 301, 302, 303, 307 and 308 (the latter from RFC 7238), the specs mention that the body usually\n        (which means it's optional and not mandated) contain just an hyperlink to the value of\n        the Location response header, so the body can be ignored safely.\n\n        For status 300, which is \"Multiple Choices\", the spec mentions both generating a Location\n        response header AND a response body with the other possible location to follow.\n        Since the spec explicitily chooses not to specify a format for such body and leave it to\n        servers and browsers implementors, we ignore the body as there is no specified way to eventually parse it.\n      */ } else {\n            return this.handler.onData(chunk);\n        }\n    }\n    onComplete(trailers) {\n        if (this.location) {\n            /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response trailers as they are not expected in case of redirections\n        and neither are useful if present.\n\n        See comment on onData method above for more detailed informations.\n      */ this.location = null;\n            this.abort = null;\n            this.dispatch(this.opts, this);\n        } else {\n            this.handler.onComplete(trailers);\n        }\n    }\n    onBodySent(chunk) {\n        if (this.handler.onBodySent) {\n            this.handler.onBodySent(chunk);\n        }\n    }\n}\nfunction parseLocation(statusCode, headers) {\n    if (redirectableStatusCodes.indexOf(statusCode) === -1) {\n        return null;\n    }\n    for(let i = 0; i < headers.length; i += 2){\n        if (headers[i].toString().toLowerCase() === \"location\") {\n            return headers[i + 1];\n        }\n    }\n}\n// https://tools.ietf.org/html/rfc7231#section-6.4.4\nfunction shouldRemoveHeader(header, removeContent, unknownOrigin) {\n    return header.length === 4 && header.toString().toLowerCase() === \"host\" || removeContent && header.toString().toLowerCase().indexOf(\"content-\") === 0 || unknownOrigin && header.length === 13 && header.toString().toLowerCase() === \"authorization\" || unknownOrigin && header.length === 6 && header.toString().toLowerCase() === \"cookie\";\n}\n// https://tools.ietf.org/html/rfc7231#section-6.4\nfunction cleanRequestHeaders(headers, removeContent, unknownOrigin) {\n    const ret = [];\n    if (Array.isArray(headers)) {\n        for(let i = 0; i < headers.length; i += 2){\n            if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {\n                ret.push(headers[i], headers[i + 1]);\n            }\n        }\n    } else if (headers && typeof headers === \"object\") {\n        for (const key of Object.keys(headers)){\n            if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {\n                ret.push(key, headers[key]);\n            }\n        }\n    } else {\n        assert(headers == null, \"headers must be an object or an array\");\n    }\n    return ret;\n}\nmodule.exports = RedirectHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaGFuZGxlci9SZWRpcmVjdEhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxPQUFPQyxtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQUVDLFNBQVMsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUM5QixNQUFNRSxTQUFTRixtQkFBT0EsQ0FBQztBQUN2QixNQUFNLEVBQUVHLG9CQUFvQixFQUFFLEdBQUdILG1CQUFPQSxDQUFDO0FBQ3pDLE1BQU1JLEtBQUtKLG1CQUFPQSxDQUFDO0FBRW5CLE1BQU1LLDBCQUEwQjtJQUFDO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztDQUFJO0FBRTlELE1BQU1DLFFBQVFDLE9BQU87QUFFckIsTUFBTUM7SUFDSkMsWUFBYUMsSUFBSSxDQUFFO1FBQ2pCLElBQUksQ0FBQ0osTUFBTSxHQUFHSTtRQUNkLElBQUksQ0FBQ1QsVUFBVSxHQUFHO0lBQ3BCO0lBRUEsT0FBUSxDQUFDTSxPQUFPSSxhQUFhLENBQUMsR0FBSTtRQUNoQ1QsT0FBTyxDQUFDLElBQUksQ0FBQ0QsVUFBVSxFQUFFO1FBQ3pCLElBQUksQ0FBQ0EsVUFBVSxHQUFHO1FBQ2xCLE9BQVEsSUFBSSxDQUFDSyxNQUFNO0lBQ3JCO0FBQ0Y7QUFFQSxNQUFNTTtJQUNKSCxZQUFhSSxRQUFRLEVBQUVDLGVBQWUsRUFBRUMsSUFBSSxFQUFFQyxPQUFPLENBQUU7UUFDckQsSUFBSUYsbUJBQW1CLFFBQVMsRUFBQ0csT0FBT0MsU0FBUyxDQUFDSixvQkFBb0JBLGtCQUFrQixJQUFJO1lBQzFGLE1BQU0sSUFBSVgscUJBQXFCO1FBQ2pDO1FBRUFKLEtBQUtvQixlQUFlLENBQUNILFNBQVNELEtBQUtLLE1BQU0sRUFBRUwsS0FBS00sT0FBTztRQUV2RCxJQUFJLENBQUNSLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDUyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxD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bXkvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaGFuZGxlci9SZWRpcmVjdEhhbmRsZXIuanM/YzVjYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGtCb2R5VXNlZCB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpXG5cbmNvbnN0IHJlZGlyZWN0YWJsZVN0YXR1c0NvZGVzID0gWzMwMCwgMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cbmNvbnN0IGtCb2R5ID0gU3ltYm9sKCdib2R5JylcblxuY2xhc3MgQm9keUFzeW5jSXRlcmFibGUge1xuICBjb25zdHJ1Y3RvciAoYm9keSkge1xuICAgIHRoaXNba0JvZHldID0gYm9keVxuICAgIHRoaXNba0JvZHlVc2VkXSA9IGZhbHNlXG4gIH1cblxuICBhc3luYyAqIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gKCkge1xuICAgIGFzc2VydCghdGhpc1trQm9keVVzZWRdLCAnZGlzdHVyYmVkJylcbiAgICB0aGlzW2tCb2R5VXNlZF0gPSB0cnVlXG4gICAgeWllbGQgKiB0aGlzW2tCb2R5XVxuICB9XG59XG5cbmNsYXNzIFJlZGlyZWN0SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yIChkaXNwYXRjaCwgbWF4UmVkaXJlY3Rpb25zLCBvcHRzLCBoYW5kbGVyKSB7XG4gICAgaWYgKG1heFJlZGlyZWN0aW9ucyAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZWRpcmVjdGlvbnMpIHx8IG1heFJlZGlyZWN0aW9ucyA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heFJlZGlyZWN0aW9ucyBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICB1dGlsLnZhbGlkYXRlSGFuZGxlcihoYW5kbGVyLCBvcHRzLm1ldGhvZCwgb3B0cy51cGdyYWRlKVxuXG4gICAgdGhpcy5kaXNwYXRjaCA9IGRpc3BhdGNoXG4gICAgdGhpcy5sb2NhdGlvbiA9IG51bGxcbiAgICB0aGlzLmFib3J0ID0gbnVsbFxuICAgIHRoaXMub3B0cyA9IHsgLi4ub3B0cywgbWF4UmVkaXJlY3Rpb25zOiAwIH0gLy8gb3B0cyBtdXN0IGJlIGEgY29weVxuICAgIHRoaXMubWF4UmVkaXJlY3Rpb25zID0gbWF4UmVkaXJlY3Rpb25zXG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlclxuICAgIHRoaXMuaGlzdG9yeSA9IFtdXG5cbiAgICBpZiAodXRpbC5pc1N0cmVhbSh0aGlzLm9wdHMuYm9keSkpIHtcbiAgICAgIC8vIFRPRE8gKGZpeCk6IFByb3ZpZGUgc29tZSB3YXkgZm9yIHRoZSB1c2VyIHRvIGNhY2hlIHRoZSBmaWxlIHRvIGUuZy4gL3RtcFxuICAgICAgLy8gc28gdGhhdCBpdCBjYW4gYmUgZGlzcGF0Y2hlZCBhZ2Fpbj9cbiAgICAgIC8vIFRPRE8gKGZpeCk6IERvIHdlIG5lZWQgMTAwLWV4cGVjdCBzdXBwb3J0IHRvIHByb3ZpZGUgYSB3YXkgdG8gZG8gdGhpcyBwcm9wZXJseT9cbiAgICAgIGlmICh1dGlsLmJvZHlMZW5ndGgodGhpcy5vcHRzLmJvZHkpID09PSAwKSB7XG4gICAgICAgIHRoaXMub3B0cy5ib2R5XG4gICAgICAgICAgLm9uKCdkYXRhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlKVxuICAgICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLmJvZHkucmVhZGFibGVEaWRSZWFkICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhpcy5vcHRzLmJvZHlba0JvZHlVc2VkXSA9IGZhbHNlXG4gICAgICAgIEVFLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMub3B0cy5ib2R5LCAnZGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzW2tCb2R5VXNlZF0gPSB0cnVlXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdHMuYm9keSAmJiB0eXBlb2YgdGhpcy5vcHRzLmJvZHkucGlwZVRvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBUT0RPIChmaXgpOiBXZSBjYW4ndCBhY2Nlc3MgUmVhZGFibGVTdHJlYW0gaW50ZXJuYWwgc3RhdGVcbiAgICAgIC8vIHRvIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCBpdCBoYXMgYmVlbiBkaXN0dXJiZWQuIFRoaXMgaXMganVzdFxuICAgICAgLy8gYSB3b3JrYXJvdW5kLlxuICAgICAgdGhpcy5vcHRzLmJvZHkgPSBuZXcgQm9keUFzeW5jSXRlcmFibGUodGhpcy5vcHRzLmJvZHkpXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRoaXMub3B0cy5ib2R5ICYmXG4gICAgICB0eXBlb2YgdGhpcy5vcHRzLmJvZHkgIT09ICdzdHJpbmcnICYmXG4gICAgICAhQXJyYXlCdWZmZXIuaXNWaWV3KHRoaXMub3B0cy5ib2R5KSAmJlxuICAgICAgdXRpbC5pc0l0ZXJhYmxlKHRoaXMub3B0cy5ib2R5KVxuICAgICkge1xuICAgICAgLy8gVE9ETzogU2hvdWxkIHdlIGFsbG93IHJlLXVzaW5nIGl0ZXJhYmxlIGlmICF0aGlzLm9wdHMuaWRlbXBvdGVudFxuICAgICAgLy8gb3IgdGhyb3VnaCBzb21lIG90aGVyIGZsYWc/XG4gICAgICB0aGlzLm9wdHMuYm9keSA9IG5ldyBCb2R5QXN5bmNJdGVyYWJsZSh0aGlzLm9wdHMuYm9keSlcbiAgICB9XG4gIH1cblxuICBvbkNvbm5lY3QgKGFib3J0KSB7XG4gICAgdGhpcy5hYm9ydCA9IGFib3J0XG4gICAgdGhpcy5oYW5kbGVyLm9uQ29ubmVjdChhYm9ydCwgeyBoaXN0b3J5OiB0aGlzLmhpc3RvcnkgfSlcbiAgfVxuXG4gIG9uVXBncmFkZSAoc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KSB7XG4gICAgdGhpcy5oYW5kbGVyLm9uVXBncmFkZShzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpXG4gIH1cblxuICBvbkVycm9yIChlcnJvcikge1xuICAgIHRoaXMuaGFuZGxlci5vbkVycm9yKGVycm9yKVxuICB9XG5cbiAgb25IZWFkZXJzIChzdGF0dXNDb2RlLCBoZWFkZXJzLCByZXN1bWUsIHN0YXR1c1RleHQpIHtcbiAgICB0aGlzLmxvY2F0aW9uID0gdGhpcy5oaXN0b3J5Lmxlbmd0aCA+PSB0aGlzLm1heFJlZGlyZWN0aW9ucyB8fCB1dGlsLmlzRGlzdHVyYmVkKHRoaXMub3B0cy5ib2R5KVxuICAgICAgPyBudWxsXG4gICAgICA6IHBhcnNlTG9jYXRpb24oc3RhdHVzQ29kZSwgaGVhZGVycylcblxuICAgIGlmICh0aGlzLm9wdHMub3JpZ2luKSB7XG4gICAgICB0aGlzLmhpc3RvcnkucHVzaChuZXcgVVJMKHRoaXMub3B0cy5wYXRoLCB0aGlzLm9wdHMub3JpZ2luKSlcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubG9jYXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25IZWFkZXJzKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHJlc3VtZSwgc3RhdHVzVGV4dClcbiAgICB9XG5cbiAgICBjb25zdCB7IG9yaWdpbiwgcGF0aG5hbWUsIHNlYXJjaCB9ID0gdXRpbC5wYXJzZVVSTChuZXcgVVJMKHRoaXMubG9jYXRpb24sIHRoaXMub3B0cy5vcmlnaW4gJiYgbmV3IFVSTCh0aGlzLm9wdHMucGF0aCwgdGhpcy5vcHRzLm9yaWdpbikpKVxuICAgIGNvbnN0IHBhdGggPSBzZWFyY2ggPyBgJHtwYXRobmFtZX0ke3NlYXJjaH1gIDogcGF0aG5hbWVcblxuICAgIC8vIFJlbW92ZSBoZWFkZXJzIHJlZmVycmluZyB0byB0aGUgb3JpZ2luYWwgVVJMLlxuICAgIC8vIEJ5IGRlZmF1bHQgaXQgaXMgSG9zdCBvbmx5LCB1bmxlc3MgaXQncyBhIDMwMyAoc2VlIGJlbG93KSwgd2hpY2ggcmVtb3ZlcyBhbHNvIGFsbCBDb250ZW50LSogaGVhZGVycy5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNFxuICAgIHRoaXMub3B0cy5oZWFkZXJzID0gY2xlYW5SZXF1ZXN0SGVhZGVycyh0aGlzLm9wdHMuaGVhZGVycywgc3RhdHVzQ29kZSA9PT0gMzAzLCB0aGlzLm9wdHMub3JpZ2luICE9PSBvcmlnaW4pXG4gICAgdGhpcy5vcHRzLnBhdGggPSBwYXRoXG4gICAgdGhpcy5vcHRzLm9yaWdpbiA9IG9yaWdpblxuICAgIHRoaXMub3B0cy5tYXhSZWRpcmVjdGlvbnMgPSAwXG4gICAgdGhpcy5vcHRzLnF1ZXJ5ID0gbnVsbFxuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjQuNFxuICAgIC8vIEluIGNhc2Ugb2YgSFRUUCAzMDMsIGFsd2F5cyByZXBsYWNlIG1ldGhvZCB0byBiZSBlaXRoZXIgSEVBRCBvciBHRVRcbiAgICBpZiAoc3RhdHVzQ29kZSA9PT0gMzAzICYmIHRoaXMub3B0cy5tZXRob2QgIT09ICdIRUFEJykge1xuICAgICAgdGhpcy5vcHRzLm1ldGhvZCA9ICdHRVQnXG4gICAgICB0aGlzLm9wdHMuYm9keSA9IG51bGxcbiAgICB9XG4gIH1cblxuICBvbkRhdGEgKGNodW5rKSB7XG4gICAgaWYgKHRoaXMubG9jYXRpb24pIHtcbiAgICAgIC8qXG4gICAgICAgIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi40XG5cbiAgICAgICAgVExEUjogdW5kaWNpIGFsd2F5cyBpZ25vcmVzIDN4eCByZXNwb25zZSBib2RpZXMuXG5cbiAgICAgICAgUmVkaXJlY3Rpb24gaXMgdXNlZCB0byBzZXJ2ZSB0aGUgcmVxdWVzdGVkIHJlc291cmNlIGZyb20gYW5vdGhlciBVUkwsIHNvIGl0IGlzIGFzc3VtZXMgdGhhdFxuICAgICAgICBubyBib2R5IGlzIGdlbmVyYXRlZCAoYW5kIHRodXMgY2FuIGJlIGlnbm9yZWQpLiBFdmVuIHRob3VnaCBnZW5lcmF0aW5nIGEgYm9keSBpcyBub3QgcHJvaGliaXRlZC5cblxuICAgICAgICBGb3Igc3RhdHVzIDMwMSwgMzAyLCAzMDMsIDMwNyBhbmQgMzA4ICh0aGUgbGF0dGVyIGZyb20gUkZDIDcyMzgpLCB0aGUgc3BlY3MgbWVudGlvbiB0aGF0IHRoZSBib2R5IHVzdWFsbHlcbiAgICAgICAgKHdoaWNoIG1lYW5zIGl0J3Mgb3B0aW9uYWwgYW5kIG5vdCBtYW5kYXRlZCkgY29udGFpbiBqdXN0IGFuIGh5cGVybGluayB0byB0aGUgdmFsdWUgb2ZcbiAgICAgICAgdGhlIExvY2F0aW9uIHJlc3BvbnNlIGhlYWRlciwgc28gdGhlIGJvZHkgY2FuIGJlIGlnbm9yZWQgc2FmZWx5LlxuXG4gICAgICAgIEZvciBzdGF0dXMgMzAwLCB3aGljaCBpcyBcIk11bHRpcGxlIENob2ljZXNcIiwgdGhlIHNwZWMgbWVudGlvbnMgYm90aCBnZW5lcmF0aW5nIGEgTG9jYXRpb25cbiAgICAgICAgcmVzcG9uc2UgaGVhZGVyIEFORCBhIHJlc3BvbnNlIGJvZHkgd2l0aCB0aGUgb3RoZXIgcG9zc2libGUgbG9jYXRpb24gdG8gZm9sbG93LlxuICAgICAgICBTaW5jZSB0aGUgc3BlYyBleHBsaWNpdGlseSBjaG9vc2VzIG5vdCB0byBzcGVjaWZ5IGEgZm9ybWF0IGZvciBzdWNoIGJvZHkgYW5kIGxlYXZlIGl0IHRvXG4gICAgICAgIHNlcnZlcnMgYW5kIGJyb3dzZXJzIGltcGxlbWVudG9ycywgd2UgaWdub3JlIHRoZSBib2R5IGFzIHRoZXJlIGlzIG5vIHNwZWNpZmllZCB3YXkgdG8gZXZlbnR1YWxseSBwYXJzZSBpdC5cbiAgICAgICovXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25EYXRhKGNodW5rKVxuICAgIH1cbiAgfVxuXG4gIG9uQ29tcGxldGUgKHRyYWlsZXJzKSB7XG4gICAgaWYgKHRoaXMubG9jYXRpb24pIHtcbiAgICAgIC8qXG4gICAgICAgIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi40XG5cbiAgICAgICAgVExEUjogdW5kaWNpIGFsd2F5cyBpZ25vcmVzIDN4eCByZXNwb25zZSB0cmFpbGVycyBhcyB0aGV5IGFyZSBub3QgZXhwZWN0ZWQgaW4gY2FzZSBvZiByZWRpcmVjdGlvbnNcbiAgICAgICAgYW5kIG5laXRoZXIgYXJlIHVzZWZ1bCBpZiBwcmVzZW50LlxuXG4gICAgICAgIFNlZSBjb21tZW50IG9uIG9uRGF0YSBtZXRob2QgYWJvdmUgZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb25zLlxuICAgICAgKi9cblxuICAgICAgdGhpcy5sb2NhdGlvbiA9IG51bGxcbiAgICAgIHRoaXMuYWJvcnQgPSBudWxsXG5cbiAgICAgIHRoaXMuZGlzcGF0Y2godGhpcy5vcHRzLCB0aGlzKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhbmRsZXIub25Db21wbGV0ZSh0cmFpbGVycylcbiAgICB9XG4gIH1cblxuICBvbkJvZHlTZW50IChjaHVuaykge1xuICAgIGlmICh0aGlzLmhhbmRsZXIub25Cb2R5U2VudCkge1xuICAgICAgdGhpcy5oYW5kbGVyLm9uQm9keVNlbnQoY2h1bmspXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlTG9jYXRpb24gKHN0YXR1c0NvZGUsIGhlYWRlcnMpIHtcbiAgaWYgKHJlZGlyZWN0YWJsZVN0YXR1c0NvZGVzLmluZGV4T2Yoc3RhdHVzQ29kZSkgPT09IC0xKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgIGlmIChoZWFkZXJzW2ldLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA9PT0gJ2xvY2F0aW9uJykge1xuICAgICAgcmV0dXJuIGhlYWRlcnNbaSArIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi40LjRcbmZ1bmN0aW9uIHNob3VsZFJlbW92ZUhlYWRlciAoaGVhZGVyLCByZW1vdmVDb250ZW50LCB1bmtub3duT3JpZ2luKSB7XG4gIHJldHVybiAoXG4gICAgKGhlYWRlci5sZW5ndGggPT09IDQgJiYgaGVhZGVyLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA9PT0gJ2hvc3QnKSB8fFxuICAgIChyZW1vdmVDb250ZW50ICYmIGhlYWRlci50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignY29udGVudC0nKSA9PT0gMCkgfHxcbiAgICAodW5rbm93bk9yaWdpbiAmJiBoZWFkZXIubGVuZ3RoID09PSAxMyAmJiBoZWFkZXIudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSAnYXV0aG9yaXphdGlvbicpIHx8XG4gICAgKHVua25vd25PcmlnaW4gJiYgaGVhZGVyLmxlbmd0aCA9PT0gNiAmJiBoZWFkZXIudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSAnY29va2llJylcbiAgKVxufVxuXG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNFxuZnVuY3Rpb24gY2xlYW5SZXF1ZXN0SGVhZGVycyAoaGVhZGVycywgcmVtb3ZlQ29udGVudCwgdW5rbm93bk9yaWdpbikge1xuICBjb25zdCByZXQgPSBbXVxuICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgaWYgKCFzaG91bGRSZW1vdmVIZWFkZXIoaGVhZGVyc1tpXSwgcmVtb3ZlQ29udGVudCwgdW5rbm93bk9yaWdpbikpIHtcbiAgICAgICAgcmV0LnB1c2goaGVhZGVyc1tpXSwgaGVhZGVyc1tpICsgMV0pXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGhlYWRlcnMgJiYgdHlwZW9mIGhlYWRlcnMgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcbiAgICAgIGlmICghc2hvdWxkUmVtb3ZlSGVhZGVyKGtleSwgcmVtb3ZlQ29udGVudCwgdW5rbm93bk9yaWdpbikpIHtcbiAgICAgICAgcmV0LnB1c2goa2V5LCBoZWFkZXJzW2tleV0pXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFzc2VydChoZWFkZXJzID09IG51bGwsICdoZWFkZXJzIG11c3QgYmUgYW4gb2JqZWN0IG9yIGFuIGFycmF5JylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVkaXJlY3RIYW5kbGVyXG4iXSwibmFtZXMiOlsidXRpbCIsInJlcXVpcmUiLCJrQm9keVVzZWQiLCJhc3NlcnQiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIkVFIiwicmVkaXJlY3RhYmxlU3RhdHVzQ29kZXMiLCJrQm9keSIsIlN5bWJvbCIsIkJvZHlBc3luY0l0ZXJhYmxlIiwiY29uc3RydWN0b3IiLCJib2R5IiwiYXN5bmNJdGVyYXRvciIsIlJlZGlyZWN0SGFuZGxlciIsImRpc3BhdGNoIiwibWF4UmVkaXJlY3Rpb25zIiwib3B0cyIsImhhbmRsZXIiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJ2YWxpZGF0ZUhhbmRsZXIiLCJtZXRob2QiLCJ1cGdyYWRlIiwibG9jYXRpb24iLCJhYm9ydCIsImhpc3RvcnkiLCJpc1N0cmVhbSIsImJvZHlMZW5ndGgiLCJvbiIsInJlYWRhYmxlRGlkUmVhZCIsInByb3RvdHlwZSIsImNhbGwiLCJwaXBlVG8iLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImlzSXRlcmFibGUiLCJvbkNvbm5lY3QiLCJvblVwZ3JhZGUiLCJzdGF0dXNDb2RlIiwiaGVhZGVycyIsInNvY2tldCIsIm9uRXJyb3IiLCJlcnJvciIsIm9uSGVhZGVycyIsInJlc3VtZSIsInN0YXR1c1RleHQiLCJsZW5ndGgiLCJpc0Rpc3R1cmJlZCIsInBhcnNlTG9jYXRpb24iLCJvcmlnaW4iLCJwdXNoIiwiVVJMIiwicGF0aCIsInBhdGhuYW1lIiwic2VhcmNoIiwicGFyc2VVUkwiLCJjbGVhblJlcXVlc3RIZWFkZXJzIiwicXVlcnkiLCJvbkRhdGEiLCJjaHVuayIsIm9uQ29tcGxldGUiLCJ0cmFpbGVycyIsIm9uQm9keVNlbnQiLCJpbmRleE9mIiwiaSIsInRvU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJzaG91bGRSZW1vdmVIZWFkZXIiLCJoZWFkZXIiLCJyZW1vdmVDb250ZW50IiwidW5rbm93bk9yaWdpbiIsInJldCIsIkFycmF5IiwiaXNBcnJheSIsImtleSIsIk9iamVjdCIsImtleXMiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/handler/RedirectHandler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/handler/RetryHandler.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/handler/RetryHandler.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { kRetryHandlerDefaultRetry } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\");\nconst { RequestRetryError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\nconst { isDisturbed, parseHeaders, parseRangeHeader } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nfunction calculateRetryAfterHeader(retryAfter) {\n    const current = Date.now();\n    const diff = new Date(retryAfter).getTime() - current;\n    return diff;\n}\nclass RetryHandler {\n    constructor(opts, handlers){\n        const { retryOptions, ...dispatchOpts } = opts;\n        const { // Retry scoped\n        retry: retryFn, maxRetries, maxTimeout, minTimeout, timeoutFactor, // Response scoped\n        methods, errorCodes, retryAfter, statusCodes } = retryOptions ?? {};\n        this.dispatch = handlers.dispatch;\n        this.handler = handlers.handler;\n        this.opts = dispatchOpts;\n        this.abort = null;\n        this.aborted = false;\n        this.retryOpts = {\n            retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],\n            retryAfter: retryAfter ?? true,\n            maxTimeout: maxTimeout ?? 30 * 1000,\n            timeout: minTimeout ?? 500,\n            timeoutFactor: timeoutFactor ?? 2,\n            maxRetries: maxRetries ?? 5,\n            // What errors we should retry\n            methods: methods ?? [\n                \"GET\",\n                \"HEAD\",\n                \"OPTIONS\",\n                \"PUT\",\n                \"DELETE\",\n                \"TRACE\"\n            ],\n            // Indicates which errors to retry\n            statusCodes: statusCodes ?? [\n                500,\n                502,\n                503,\n                504,\n                429\n            ],\n            // List of errors to retry\n            errorCodes: errorCodes ?? [\n                \"ECONNRESET\",\n                \"ECONNREFUSED\",\n                \"ENOTFOUND\",\n                \"ENETDOWN\",\n                \"ENETUNREACH\",\n                \"EHOSTDOWN\",\n                \"EHOSTUNREACH\",\n                \"EPIPE\"\n            ]\n        };\n        this.retryCount = 0;\n        this.start = 0;\n        this.end = null;\n        this.etag = null;\n        this.resume = null;\n        // Handle possible onConnect duplication\n        this.handler.onConnect((reason)=>{\n            this.aborted = true;\n            if (this.abort) {\n                this.abort(reason);\n            } else {\n                this.reason = reason;\n            }\n        });\n    }\n    onRequestSent() {\n        if (this.handler.onRequestSent) {\n            this.handler.onRequestSent();\n        }\n    }\n    onUpgrade(statusCode, headers, socket) {\n        if (this.handler.onUpgrade) {\n            this.handler.onUpgrade(statusCode, headers, socket);\n        }\n    }\n    onConnect(abort) {\n        if (this.aborted) {\n            abort(this.reason);\n        } else {\n            this.abort = abort;\n        }\n    }\n    onBodySent(chunk) {\n        if (this.handler.onBodySent) return this.handler.onBodySent(chunk);\n    }\n    static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {\n        const { statusCode, code, headers } = err;\n        const { method, retryOptions } = opts;\n        const { maxRetries, timeout, maxTimeout, timeoutFactor, statusCodes, errorCodes, methods } = retryOptions;\n        let { counter, currentTimeout } = state;\n        currentTimeout = currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout;\n        // Any code that is not a Undici's originated and allowed to retry\n        if (code && code !== \"UND_ERR_REQ_RETRY\" && code !== \"UND_ERR_SOCKET\" && !errorCodes.includes(code)) {\n            cb(err);\n            return;\n        }\n        // If a set of method are provided and the current method is not in the list\n        if (Array.isArray(methods) && !methods.includes(method)) {\n            cb(err);\n            return;\n        }\n        // If a set of status code are provided and the current status code is not in the list\n        if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {\n            cb(err);\n            return;\n        }\n        // If we reached the max number of retries\n        if (counter > maxRetries) {\n            cb(err);\n            return;\n        }\n        let retryAfterHeader = headers != null && headers[\"retry-after\"];\n        if (retryAfterHeader) {\n            retryAfterHeader = Number(retryAfterHeader);\n            retryAfterHeader = isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3 // Retry-After is in seconds\n            ;\n        }\n        const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);\n        state.currentTimeout = retryTimeout;\n        setTimeout(()=>cb(null), retryTimeout);\n    }\n    onHeaders(statusCode, rawHeaders, resume, statusMessage) {\n        const headers = parseHeaders(rawHeaders);\n        this.retryCount += 1;\n        if (statusCode >= 300) {\n            this.abort(new RequestRetryError(\"Request failed\", statusCode, {\n                headers,\n                count: this.retryCount\n            }));\n            return false;\n        }\n        // Checkpoint for resume from where we left it\n        if (this.resume != null) {\n            this.resume = null;\n            if (statusCode !== 206) {\n                return true;\n            }\n            const contentRange = parseRangeHeader(headers[\"content-range\"]);\n            // If no content range\n            if (!contentRange) {\n                this.abort(new RequestRetryError(\"Content-Range mismatch\", statusCode, {\n                    headers,\n                    count: this.retryCount\n                }));\n                return false;\n            }\n            // Let's start with a weak etag check\n            if (this.etag != null && this.etag !== headers.etag) {\n                this.abort(new RequestRetryError(\"ETag mismatch\", statusCode, {\n                    headers,\n                    count: this.retryCount\n                }));\n                return false;\n            }\n            const { start, size, end = size } = contentRange;\n            assert(this.start === start, \"content-range mismatch\");\n            assert(this.end == null || this.end === end, \"content-range mismatch\");\n            this.resume = resume;\n            return true;\n        }\n        if (this.end == null) {\n            if (statusCode === 206) {\n                // First time we receive 206\n                const range = parseRangeHeader(headers[\"content-range\"]);\n                if (range == null) {\n                    return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);\n                }\n                const { start, size, end = size } = range;\n                assert(start != null && Number.isFinite(start) && this.start !== start, \"content-range mismatch\");\n                assert(Number.isFinite(start));\n                assert(end != null && Number.isFinite(end) && this.end !== end, \"invalid content-length\");\n                this.start = start;\n                this.end = end;\n            }\n            // We make our best to checkpoint the body for further range headers\n            if (this.end == null) {\n                const contentLength = headers[\"content-length\"];\n                this.end = contentLength != null ? Number(contentLength) : null;\n            }\n            assert(Number.isFinite(this.start));\n            assert(this.end == null || Number.isFinite(this.end), \"invalid content-length\");\n            this.resume = resume;\n            this.etag = headers.etag != null ? headers.etag : null;\n            return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);\n        }\n        const err = new RequestRetryError(\"Request failed\", statusCode, {\n            headers,\n            count: this.retryCount\n        });\n        this.abort(err);\n        return false;\n    }\n    onData(chunk) {\n        this.start += chunk.length;\n        return this.handler.onData(chunk);\n    }\n    onComplete(rawTrailers) {\n        this.retryCount = 0;\n        return this.handler.onComplete(rawTrailers);\n    }\n    onError(err) {\n        if (this.aborted || isDisturbed(this.opts.body)) {\n            return this.handler.onError(err);\n        }\n        this.retryOpts.retry(err, {\n            state: {\n                counter: this.retryCount++,\n                currentTimeout: this.retryAfter\n            },\n            opts: {\n                retryOptions: this.retryOpts,\n                ...this.opts\n            }\n        }, onRetry.bind(this));\n        function onRetry(err) {\n            if (err != null || this.aborted || isDisturbed(this.opts.body)) {\n                return this.handler.onError(err);\n            }\n            if (this.start !== 0) {\n                this.opts = {\n                    ...this.opts,\n                    headers: {\n                        ...this.opts.headers,\n                        range: `bytes=${this.start}-${this.end ?? \"\"}`\n                    }\n                };\n            }\n            try {\n                this.dispatch(this.opts, this);\n            } catch (err) {\n                this.handler.onError(err);\n            }\n        }\n    }\n}\nmodule.exports = RetryHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaGFuZGxlci9SZXRyeUhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBRXZCLE1BQU0sRUFBRUMseUJBQXlCLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFDOUMsTUFBTSxFQUFFRSxpQkFBaUIsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUN0QyxNQUFNLEVBQUVHLFdBQVcsRUFBRUMsWUFBWSxFQUFFQyxnQkFBZ0IsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUVoRSxTQUFTTSwwQkFBMkJDLFVBQVU7SUFDNUMsTUFBTUMsVUFBVUMsS0FBS0MsR0FBRztJQUN4QixNQUFNQyxPQUFPLElBQUlGLEtBQUtGLFlBQVlLLE9BQU8sS0FBS0o7SUFFOUMsT0FBT0c7QUFDVDtBQUVBLE1BQU1FO0lBQ0pDLFlBQWFDLElBQUksRUFBRUMsUUFBUSxDQUFFO1FBQzNCLE1BQU0sRUFBRUMsWUFBWSxFQUFFLEdBQUdDLGNBQWMsR0FBR0g7UUFDMUMsTUFBTSxFQUNKLGVBQWU7UUFDZkksT0FBT0MsT0FBTyxFQUNkQyxVQUFVLEVBQ1ZDLFVBQVUsRUFDVkMsVUFBVSxFQUNWQyxhQUFhLEVBQ2Isa0JBQWtCO1FBQ2xCQyxPQUFPLEVBQ1BDLFVBQVUsRUFDVm5CLFVBQVUsRUFDVm9CLFdBQVcsRUFDWixHQUFHVixnQkFBZ0IsQ0FBQztRQUVyQixJQUFJLENBQUNXLFFBQVEsR0FBR1osU0FBU1ksUUFBUTtRQUNqQyxJQUFJLENBQUNDLE9BQU8sR0FBR2IsU0FBU2EsT0FBTztRQUMvQixJQUFJLENBQUNkLElBQUksR0FBR0c7UUFDWixJQUFJLENBQUNZLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDQyxTQUFTLEdBQUc7WUFDZmIsT0FBT0MsV0FBV1AsWUFBWSxDQUFDWiwwQkFBMEI7WUFDekRN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QU9pQyxLQUFLO2dCQUNaLElBQUksQ0FBQ25CLE9BQU8sQ0FBQ2lELE9BQU8sQ0FBQzlCO1lBQ3ZCO1FBQ0Y7SUFDRjtBQUNGO0FBRUFrQyxPQUFPQyxPQUFPLEdBQUd0RSIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2hhbmRsZXIvUmV0cnlIYW5kbGVyLmpzPzYwMDkiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcblxuY29uc3QgeyBrUmV0cnlIYW5kbGVyRGVmYXVsdFJldHJ5IH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgeyBSZXF1ZXN0UmV0cnlFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgeyBpc0Rpc3R1cmJlZCwgcGFyc2VIZWFkZXJzLCBwYXJzZVJhbmdlSGVhZGVyIH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVSZXRyeUFmdGVySGVhZGVyIChyZXRyeUFmdGVyKSB7XG4gIGNvbnN0IGN1cnJlbnQgPSBEYXRlLm5vdygpXG4gIGNvbnN0IGRpZmYgPSBuZXcgRGF0ZShyZXRyeUFmdGVyKS5nZXRUaW1lKCkgLSBjdXJyZW50XG5cbiAgcmV0dXJuIGRpZmZcbn1cblxuY2xhc3MgUmV0cnlIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIGhhbmRsZXJzKSB7XG4gICAgY29uc3QgeyByZXRyeU9wdGlvbnMsIC4uLmRpc3BhdGNoT3B0cyB9ID0gb3B0c1xuICAgIGNvbnN0IHtcbiAgICAgIC8vIFJldHJ5IHNjb3BlZFxuICAgICAgcmV0cnk6IHJldHJ5Rm4sXG4gICAgICBtYXhSZXRyaWVzLFxuICAgICAgbWF4VGltZW91dCxcbiAgICAgIG1pblRpbWVvdXQsXG4gICAgICB0aW1lb3V0RmFjdG9yLFxuICAgICAgLy8gUmVzcG9uc2Ugc2NvcGVkXG4gICAgICBtZXRob2RzLFxuICAgICAgZXJyb3JDb2RlcyxcbiAgICAgIHJldHJ5QWZ0ZXIsXG4gICAgICBzdGF0dXNDb2Rlc1xuICAgIH0gPSByZXRyeU9wdGlvbnMgPz8ge31cblxuICAgIHRoaXMuZGlzcGF0Y2ggPSBoYW5kbGVycy5kaXNwYXRjaFxuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXJzLmhhbmRsZXJcbiAgICB0aGlzLm9wdHMgPSBkaXNwYXRjaE9wdHNcbiAgICB0aGlzLmFib3J0ID0gbnVsbFxuICAgIHRoaXMuYWJvcnRlZCA9IGZhbHNlXG4gICAgdGhpcy5yZXRyeU9wdHMgPSB7XG4gICAgICByZXRyeTogcmV0cnlGbiA/PyBSZXRyeUhhbmRsZXJba1JldHJ5SGFuZGxlckRlZmF1bHRSZXRyeV0sXG4gICAgICByZXRyeUFmdGVyOiByZXRyeUFmdGVyID8/IHRydWUsXG4gICAgICBtYXhUaW1lb3V0OiBtYXhUaW1lb3V0ID8/IDMwICogMTAwMCwgLy8gMzBzLFxuICAgICAgdGltZW91dDogbWluVGltZW91dCA/PyA1MDAsIC8vIC41c1xuICAgICAgdGltZW91dEZhY3RvcjogdGltZW91dEZhY3RvciA/PyAyLFxuICAgICAgbWF4UmV0cmllczogbWF4UmV0cmllcyA/PyA1LFxuICAgICAgLy8gV2hhdCBlcnJvcnMgd2Ugc2hvdWxkIHJldHJ5XG4gICAgICBtZXRob2RzOiBtZXRob2RzID8/IFsnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQVVQnLCAnREVMRVRFJywgJ1RSQUNFJ10sXG4gICAgICAvLyBJbmRpY2F0ZXMgd2hpY2ggZXJyb3JzIHRvIHJldHJ5XG4gICAgICBzdGF0dXNDb2Rlczogc3RhdHVzQ29kZXMgPz8gWzUwMCwgNTAyLCA1MDMsIDUwNCwgNDI5XSxcbiAgICAgIC8vIExpc3Qgb2YgZXJyb3JzIHRvIHJldHJ5XG4gICAgICBlcnJvckNvZGVzOiBlcnJvckNvZGVzID8/IFtcbiAgICAgICAgJ0VDT05OUkVTRVQnLFxuICAgICAgICAnRUNPTk5SRUZVU0VEJyxcbiAgICAgICAgJ0VOT1RGT1VORCcsXG4gICAgICAgICdFTkVURE9XTicsXG4gICAgICAgICdFTkVUVU5SRUFDSCcsXG4gICAgICAgICdFSE9TVERPV04nLFxuICAgICAgICAnRUhPU1RVTlJFQUNIJyxcbiAgICAgICAgJ0VQSVBFJ1xuICAgICAgXVxuICAgIH1cblxuICAgIHRoaXMucmV0cnlDb3VudCA9IDBcbiAgICB0aGlzLnN0YXJ0ID0gMFxuICAgIHRoaXMuZW5kID0gbnVsbFxuICAgIHRoaXMuZXRhZyA9IG51bGxcbiAgICB0aGlzLnJlc3VtZSA9IG51bGxcblxuICAgIC8vIEhhbmRsZSBwb3NzaWJsZSBvbkNvbm5lY3QgZHVwbGljYXRpb25cbiAgICB0aGlzLmhhbmRsZXIub25Db25uZWN0KHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLmFib3J0ZWQgPSB0cnVlXG4gICAgICBpZiAodGhpcy5hYm9ydCkge1xuICAgICAgICB0aGlzLmFib3J0KHJlYXNvbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVhc29uID0gcmVhc29uXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIG9uUmVxdWVzdFNlbnQgKCkge1xuICAgIGlmICh0aGlzLmhhbmRsZXIub25SZXF1ZXN0U2VudCkge1xuICAgICAgdGhpcy5oYW5kbGVyLm9uUmVxdWVzdFNlbnQoKVxuICAgIH1cbiAgfVxuXG4gIG9uVXBncmFkZSAoc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlci5vblVwZ3JhZGUpIHtcbiAgICAgIHRoaXMuaGFuZGxlci5vblVwZ3JhZGUoc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KVxuICAgIH1cbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQpIHtcbiAgICBpZiAodGhpcy5hYm9ydGVkKSB7XG4gICAgICBhYm9ydCh0aGlzLnJlYXNvbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hYm9ydCA9IGFib3J0XG4gICAgfVxuICB9XG5cbiAgb25Cb2R5U2VudCAoY2h1bmspIHtcbiAgICBpZiAodGhpcy5oYW5kbGVyLm9uQm9keVNlbnQpIHJldHVybiB0aGlzLmhhbmRsZXIub25Cb2R5U2VudChjaHVuaylcbiAgfVxuXG4gIHN0YXRpYyBba1JldHJ5SGFuZGxlckRlZmF1bHRSZXRyeV0gKGVyciwgeyBzdGF0ZSwgb3B0cyB9LCBjYikge1xuICAgIGNvbnN0IHsgc3RhdHVzQ29kZSwgY29kZSwgaGVhZGVycyB9ID0gZXJyXG4gICAgY29uc3QgeyBtZXRob2QsIHJldHJ5T3B0aW9ucyB9ID0gb3B0c1xuICAgIGNvbnN0IHtcbiAgICAgIG1heFJldHJpZXMsXG4gICAgICB0aW1lb3V0LFxuICAgICAgbWF4VGltZW91dCxcbiAgICAgIHRpbWVvdXRGYWN0b3IsXG4gICAgICBzdGF0dXNDb2RlcyxcbiAgICAgIGVycm9yQ29kZXMsXG4gICAgICBtZXRob2RzXG4gICAgfSA9IHJldHJ5T3B0aW9uc1xuICAgIGxldCB7IGNvdW50ZXIsIGN1cnJlbnRUaW1lb3V0IH0gPSBzdGF0ZVxuXG4gICAgY3VycmVudFRpbWVvdXQgPVxuICAgICAgY3VycmVudFRpbWVvdXQgIT0gbnVsbCAmJiBjdXJyZW50VGltZW91dCA+IDAgPyBjdXJyZW50VGltZW91dCA6IHRpbWVvdXRcblxuICAgIC8vIEFueSBjb2RlIHRoYXQgaXMgbm90IGEgVW5kaWNpJ3Mgb3JpZ2luYXRlZCBhbmQgYWxsb3dlZCB0byByZXRyeVxuICAgIGlmIChcbiAgICAgIGNvZGUgJiZcbiAgICAgIGNvZGUgIT09ICdVTkRfRVJSX1JFUV9SRVRSWScgJiZcbiAgICAgIGNvZGUgIT09ICdVTkRfRVJSX1NPQ0tFVCcgJiZcbiAgICAgICFlcnJvckNvZGVzLmluY2x1ZGVzKGNvZGUpXG4gICAgKSB7XG4gICAgICBjYihlcnIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiBhIHNldCBvZiBtZXRob2QgYXJlIHByb3ZpZGVkIGFuZCB0aGUgY3VycmVudCBtZXRob2QgaXMgbm90IGluIHRoZSBsaXN0XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWV0aG9kcykgJiYgIW1ldGhvZHMuaW5jbHVkZXMobWV0aG9kKSkge1xuICAgICAgY2IoZXJyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgYSBzZXQgb2Ygc3RhdHVzIGNvZGUgYXJlIHByb3ZpZGVkIGFuZCB0aGUgY3VycmVudCBzdGF0dXMgY29kZSBpcyBub3QgaW4gdGhlIGxpc3RcbiAgICBpZiAoXG4gICAgICBzdGF0dXNDb2RlICE9IG51bGwgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkoc3RhdHVzQ29kZXMpICYmXG4gICAgICAhc3RhdHVzQ29kZXMuaW5jbHVkZXMoc3RhdHVzQ29kZSlcbiAgICApIHtcbiAgICAgIGNiKGVycilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIHdlIHJlYWNoZWQgdGhlIG1heCBudW1iZXIgb2YgcmV0cmllc1xuICAgIGlmIChjb3VudGVyID4gbWF4UmV0cmllcykge1xuICAgICAgY2IoZXJyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHJldHJ5QWZ0ZXJIZWFkZXIgPSBoZWFkZXJzICE9IG51bGwgJiYgaGVhZGVyc1sncmV0cnktYWZ0ZXInXVxuICAgIGlmIChyZXRyeUFmdGVySGVhZGVyKSB7XG4gICAgICByZXRyeUFmdGVySGVhZGVyID0gTnVtYmVyKHJldHJ5QWZ0ZXJIZWFkZXIpXG4gICAgICByZXRyeUFmdGVySGVhZGVyID0gaXNOYU4ocmV0cnlBZnRlckhlYWRlcilcbiAgICAgICAgPyBjYWxjdWxhdGVSZXRyeUFmdGVySGVhZGVyKHJldHJ5QWZ0ZXJIZWFkZXIpXG4gICAgICAgIDogcmV0cnlBZnRlckhlYWRlciAqIDFlMyAvLyBSZXRyeS1BZnRlciBpcyBpbiBzZWNvbmRzXG4gICAgfVxuXG4gICAgY29uc3QgcmV0cnlUaW1lb3V0ID1cbiAgICAgIHJldHJ5QWZ0ZXJIZWFkZXIgPiAwXG4gICAgICAgID8gTWF0aC5taW4ocmV0cnlBZnRlckhlYWRlciwgbWF4VGltZW91dClcbiAgICAgICAgOiBNYXRoLm1pbihjdXJyZW50VGltZW91dCAqIHRpbWVvdXRGYWN0b3IgKiogY291bnRlciwgbWF4VGltZW91dClcblxuICAgIHN0YXRlLmN1cnJlbnRUaW1lb3V0ID0gcmV0cnlUaW1lb3V0XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IGNiKG51bGwpLCByZXRyeVRpbWVvdXQpXG4gIH1cblxuICBvbkhlYWRlcnMgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHJlc3VtZSwgc3RhdHVzTWVzc2FnZSkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBwYXJzZUhlYWRlcnMocmF3SGVhZGVycylcblxuICAgIHRoaXMucmV0cnlDb3VudCArPSAxXG5cbiAgICBpZiAoc3RhdHVzQ29kZSA+PSAzMDApIHtcbiAgICAgIHRoaXMuYWJvcnQoXG4gICAgICAgIG5ldyBSZXF1ZXN0UmV0cnlFcnJvcignUmVxdWVzdCBmYWlsZWQnLCBzdGF0dXNDb2RlLCB7XG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBjb3VudDogdGhpcy5yZXRyeUNvdW50XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBDaGVja3BvaW50IGZvciByZXN1bWUgZnJvbSB3aGVyZSB3ZSBsZWZ0IGl0XG4gICAgaWYgKHRoaXMucmVzdW1lICE9IG51bGwpIHtcbiAgICAgIHRoaXMucmVzdW1lID0gbnVsbFxuXG4gICAgICBpZiAoc3RhdHVzQ29kZSAhPT0gMjA2KSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbnRlbnRSYW5nZSA9IHBhcnNlUmFuZ2VIZWFkZXIoaGVhZGVyc1snY29udGVudC1yYW5nZSddKVxuICAgICAgLy8gSWYgbm8gY29udGVudCByYW5nZVxuICAgICAgaWYgKCFjb250ZW50UmFuZ2UpIHtcbiAgICAgICAgdGhpcy5hYm9ydChcbiAgICAgICAgICBuZXcgUmVxdWVzdFJldHJ5RXJyb3IoJ0NvbnRlbnQtUmFuZ2UgbWlzbWF0Y2gnLCBzdGF0dXNDb2RlLCB7XG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgY291bnQ6IHRoaXMucmV0cnlDb3VudFxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIC8vIExldCdzIHN0YXJ0IHdpdGggYSB3ZWFrIGV0YWcgY2hlY2tcbiAgICAgIGlmICh0aGlzLmV0YWcgIT0gbnVsbCAmJiB0aGlzLmV0YWcgIT09IGhlYWRlcnMuZXRhZykge1xuICAgICAgICB0aGlzLmFib3J0KFxuICAgICAgICAgIG5ldyBSZXF1ZXN0UmV0cnlFcnJvcignRVRhZyBtaXNtYXRjaCcsIHN0YXR1c0NvZGUsIHtcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBjb3VudDogdGhpcy5yZXRyeUNvdW50XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBzdGFydCwgc2l6ZSwgZW5kID0gc2l6ZSB9ID0gY29udGVudFJhbmdlXG5cbiAgICAgIGFzc2VydCh0aGlzLnN0YXJ0ID09PSBzdGFydCwgJ2NvbnRlbnQtcmFuZ2UgbWlzbWF0Y2gnKVxuICAgICAgYXNzZXJ0KHRoaXMuZW5kID09IG51bGwgfHwgdGhpcy5lbmQgPT09IGVuZCwgJ2NvbnRlbnQtcmFuZ2UgbWlzbWF0Y2gnKVxuXG4gICAgICB0aGlzLnJlc3VtZSA9IHJlc3VtZVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lbmQgPT0gbnVsbCkge1xuICAgICAgaWYgKHN0YXR1c0NvZGUgPT09IDIwNikge1xuICAgICAgICAvLyBGaXJzdCB0aW1lIHdlIHJlY2VpdmUgMjA2XG4gICAgICAgIGNvbnN0IHJhbmdlID0gcGFyc2VSYW5nZUhlYWRlcihoZWFkZXJzWydjb250ZW50LXJhbmdlJ10pXG5cbiAgICAgICAgaWYgKHJhbmdlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uSGVhZGVycyhcbiAgICAgICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgICAgICByYXdIZWFkZXJzLFxuICAgICAgICAgICAgcmVzdW1lLFxuICAgICAgICAgICAgc3RhdHVzTWVzc2FnZVxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIHNpemUsIGVuZCA9IHNpemUgfSA9IHJhbmdlXG5cbiAgICAgICAgYXNzZXJ0KFxuICAgICAgICAgIHN0YXJ0ICE9IG51bGwgJiYgTnVtYmVyLmlzRmluaXRlKHN0YXJ0KSAmJiB0aGlzLnN0YXJ0ICE9PSBzdGFydCxcbiAgICAgICAgICAnY29udGVudC1yYW5nZSBtaXNtYXRjaCdcbiAgICAgICAgKVxuICAgICAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHN0YXJ0KSlcbiAgICAgICAgYXNzZXJ0KFxuICAgICAgICAgIGVuZCAhPSBudWxsICYmIE51bWJlci5pc0Zpbml0ZShlbmQpICYmIHRoaXMuZW5kICE9PSBlbmQsXG4gICAgICAgICAgJ2ludmFsaWQgY29udGVudC1sZW5ndGgnXG4gICAgICAgIClcblxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnRcbiAgICAgICAgdGhpcy5lbmQgPSBlbmRcbiAgICAgIH1cblxuICAgICAgLy8gV2UgbWFrZSBvdXIgYmVzdCB0byBjaGVja3BvaW50IHRoZSBib2R5IGZvciBmdXJ0aGVyIHJhbmdlIGhlYWRlcnNcbiAgICAgIGlmICh0aGlzLmVuZCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBoZWFkZXJzWydjb250ZW50LWxlbmd0aCddXG4gICAgICAgIHRoaXMuZW5kID0gY29udGVudExlbmd0aCAhPSBudWxsID8gTnVtYmVyKGNvbnRlbnRMZW5ndGgpIDogbnVsbFxuICAgICAgfVxuXG4gICAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHRoaXMuc3RhcnQpKVxuICAgICAgYXNzZXJ0KFxuICAgICAgICB0aGlzLmVuZCA9PSBudWxsIHx8IE51bWJlci5pc0Zpbml0ZSh0aGlzLmVuZCksXG4gICAgICAgICdpbnZhbGlkIGNvbnRlbnQtbGVuZ3RoJ1xuICAgICAgKVxuXG4gICAgICB0aGlzLnJlc3VtZSA9IHJlc3VtZVxuICAgICAgdGhpcy5ldGFnID0gaGVhZGVycy5ldGFnICE9IG51bGwgPyBoZWFkZXJzLmV0YWcgOiBudWxsXG5cbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25IZWFkZXJzKFxuICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICByYXdIZWFkZXJzLFxuICAgICAgICByZXN1bWUsXG4gICAgICAgIHN0YXR1c01lc3NhZ2VcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBlcnIgPSBuZXcgUmVxdWVzdFJldHJ5RXJyb3IoJ1JlcXVlc3QgZmFpbGVkJywgc3RhdHVzQ29kZSwge1xuICAgICAgaGVhZGVycyxcbiAgICAgIGNvdW50OiB0aGlzLnJldHJ5Q291bnRcbiAgICB9KVxuXG4gICAgdGhpcy5hYm9ydChlcnIpXG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIG9uRGF0YSAoY2h1bmspIHtcbiAgICB0aGlzLnN0YXJ0ICs9IGNodW5rLmxlbmd0aFxuXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkRhdGEoY2h1bmspXG4gIH1cblxuICBvbkNvbXBsZXRlIChyYXdUcmFpbGVycykge1xuICAgIHRoaXMucmV0cnlDb3VudCA9IDBcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uQ29tcGxldGUocmF3VHJhaWxlcnMpXG4gIH1cblxuICBvbkVycm9yIChlcnIpIHtcbiAgICBpZiAodGhpcy5hYm9ydGVkIHx8IGlzRGlzdHVyYmVkKHRoaXMub3B0cy5ib2R5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkVycm9yKGVycilcbiAgICB9XG5cbiAgICB0aGlzLnJldHJ5T3B0cy5yZXRyeShcbiAgICAgIGVycixcbiAgICAgIHtcbiAgICAgICAgc3RhdGU6IHsgY291bnRlcjogdGhpcy5yZXRyeUNvdW50KyssIGN1cnJlbnRUaW1lb3V0OiB0aGlzLnJldHJ5QWZ0ZXIgfSxcbiAgICAgICAgb3B0czogeyByZXRyeU9wdGlvbnM6IHRoaXMucmV0cnlPcHRzLCAuLi50aGlzLm9wdHMgfVxuICAgICAgfSxcbiAgICAgIG9uUmV0cnkuYmluZCh0aGlzKVxuICAgIClcblxuICAgIGZ1bmN0aW9uIG9uUmV0cnkgKGVycikge1xuICAgICAgaWYgKGVyciAhPSBudWxsIHx8IHRoaXMuYWJvcnRlZCB8fCBpc0Rpc3R1cmJlZCh0aGlzLm9wdHMuYm9keSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkVycm9yKGVycilcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc3RhcnQgIT09IDApIHtcbiAgICAgICAgdGhpcy5vcHRzID0ge1xuICAgICAgICAgIC4uLnRoaXMub3B0cyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAuLi50aGlzLm9wdHMuaGVhZGVycyxcbiAgICAgICAgICAgIHJhbmdlOiBgYnl0ZXM9JHt0aGlzLnN0YXJ0fS0ke3RoaXMuZW5kID8/ICcnfWBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh0aGlzLm9wdHMsIHRoaXMpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVyLm9uRXJyb3IoZXJyKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJldHJ5SGFuZGxlclxuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJrUmV0cnlIYW5kbGVyRGVmYXVsdFJldHJ5IiwiUmVxdWVzdFJldHJ5RXJyb3IiLCJpc0Rpc3R1cmJlZCIsInBhcnNlSGVhZGVycyIsInBhcnNlUmFuZ2VIZWFkZXIiLCJjYWxjdWxhdGVSZXRyeUFmdGVySGVhZGVyIiwicmV0cnlBZnRlciIsImN1cnJlbnQiLCJEYXRlIiwibm93IiwiZGlmZiIsImdldFRpbWUiLCJSZXRyeUhhbmRsZXIiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJoYW5kbGVycyIsInJldHJ5T3B0aW9ucyIsImRpc3BhdGNoT3B0cyIsInJldHJ5IiwicmV0cnlGbiIsIm1heFJldHJpZXMiLCJtYXhUaW1lb3V0IiwibWluVGltZW91dCIsInRpbWVvdXRGYWN0b3IiLCJtZXRob2RzIiwiZXJyb3JDb2RlcyIsInN0YXR1c0NvZGVzIiwiZGlzcGF0Y2giLCJoYW5kbGVyIiwiYWJvcnQiLCJhYm9ydGVkIiwicmV0cnlPcHRzIiwidGltZW91dCIsInJldHJ5Q291bnQiLCJzdGFydCIsImVuZCIsImV0YWciLCJyZXN1bWUiLCJvbkNvbm5lY3QiLCJyZWFzb24iLCJvblJlcXVlc3RTZW50Iiwib25VcGdyYWRlIiwic3RhdHVzQ29kZSIsImhlYWRlcnMiLCJzb2NrZXQiLCJvbkJvZHlTZW50IiwiY2h1bmsiLCJlcnIiLCJzdGF0ZSIsImNiIiwiY29kZSIsIm1ldGhvZCIsImNvdW50ZXIiLCJjdXJyZW50VGltZW91dCIsImluY2x1ZGVzIiwiQXJyYXkiLCJpc0FycmF5IiwicmV0cnlBZnRlckhlYWRlciIsIk51bWJlciIsImlzTmFOIiwicmV0cnlUaW1lb3V0IiwiTWF0aCIsIm1pbiIsInNldFRpbWVvdXQiLCJvbkhlYWRlcnMiLCJyYXdIZWFkZXJzIiwic3RhdHVzTWVzc2FnZSIsImNvdW50IiwiY29udGVudFJhbmdlIiwic2l6ZSIsInJhbmdlIiwiaXNGaW5pdGUiLCJjb250ZW50TGVuZ3RoIiwib25EYXRhIiwibGVuZ3RoIiwib25Db21wbGV0ZSIsInJhd1RyYWlsZXJzIiwib25FcnJvciIsImJvZHkiLCJvblJldHJ5IiwiYmluZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/handler/RetryHandler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/interceptor/redirectInterceptor.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/interceptor/redirectInterceptor.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst RedirectHandler = __webpack_require__(/*! ../handler/RedirectHandler */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/handler/RedirectHandler.js\");\nfunction createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {\n    return (dispatch)=>{\n        return function Intercept(opts, handler) {\n            const { maxRedirections = defaultMaxRedirections } = opts;\n            if (!maxRedirections) {\n                return dispatch(opts, handler);\n            }\n            const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);\n            opts = {\n                ...opts,\n                maxRedirections: 0\n            } // Stop sub dispatcher from also redirecting.\n            ;\n            return dispatch(opts, redirectHandler);\n        };\n    };\n}\nmodule.exports = createRedirectInterceptor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaW50ZXJjZXB0b3IvcmVkaXJlY3RJbnRlcmNlcHRvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLGtCQUFrQkMsbUJBQU9BLENBQUM7QUFFaEMsU0FBU0MsMEJBQTJCLEVBQUVDLGlCQUFpQkMsc0JBQXNCLEVBQUU7SUFDN0UsT0FBTyxDQUFDQztRQUNOLE9BQU8sU0FBU0MsVUFBV0MsSUFBSSxFQUFFQyxPQUFPO1lBQ3RDLE1BQU0sRUFBRUwsa0JBQWtCQyxzQkFBc0IsRUFBRSxHQUFHRztZQUVyRCxJQUFJLENBQUNKLGlCQUFpQjtnQkFDcEIsT0FBT0UsU0FBU0UsTUFBTUM7WUFDeEI7WUFFQSxNQUFNQyxrQkFBa0IsSUFBSVQsZ0JBQWdCSyxVQUFVRixpQkFBaUJJLE1BQU1DO1lBQzdFRCxPQUFPO2dCQUFFLEdBQUdBLElBQUk7Z0JBQUVKLGlCQUFpQjtZQUFFLEVBQUUsNkNBQTZDOztZQUNwRixPQUFPRSxTQUFTRSxNQUFNRTtRQUN4QjtJQUNGO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHVCIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ludGVyY2VwdG9yL3JlZGlyZWN0SW50ZXJjZXB0b3IuanM/MDI0NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgUmVkaXJlY3RIYW5kbGVyID0gcmVxdWlyZSgnLi4vaGFuZGxlci9SZWRpcmVjdEhhbmRsZXInKVxuXG5mdW5jdGlvbiBjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yICh7IG1heFJlZGlyZWN0aW9uczogZGVmYXVsdE1heFJlZGlyZWN0aW9ucyB9KSB7XG4gIHJldHVybiAoZGlzcGF0Y2gpID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gSW50ZXJjZXB0IChvcHRzLCBoYW5kbGVyKSB7XG4gICAgICBjb25zdCB7IG1heFJlZGlyZWN0aW9ucyA9IGRlZmF1bHRNYXhSZWRpcmVjdGlvbnMgfSA9IG9wdHNcblxuICAgICAgaWYgKCFtYXhSZWRpcmVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoKG9wdHMsIGhhbmRsZXIpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlZGlyZWN0SGFuZGxlciA9IG5ldyBSZWRpcmVjdEhhbmRsZXIoZGlzcGF0Y2gsIG1heFJlZGlyZWN0aW9ucywgb3B0cywgaGFuZGxlcilcbiAgICAgIG9wdHMgPSB7IC4uLm9wdHMsIG1heFJlZGlyZWN0aW9uczogMCB9IC8vIFN0b3Agc3ViIGRpc3BhdGNoZXIgZnJvbSBhbHNvIHJlZGlyZWN0aW5nLlxuICAgICAgcmV0dXJuIGRpc3BhdGNoKG9wdHMsIHJlZGlyZWN0SGFuZGxlcilcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yXG4iXSwibmFtZXMiOlsiUmVkaXJlY3RIYW5kbGVyIiwicmVxdWlyZSIsImNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IiLCJtYXhSZWRpcmVjdGlvbnMiLCJkZWZhdWx0TWF4UmVkaXJlY3Rpb25zIiwiZGlzcGF0Y2giLCJJbnRlcmNlcHQiLCJvcHRzIiwiaGFuZGxlciIsInJlZGlyZWN0SGFuZGxlciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/interceptor/redirectInterceptor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/llhttp/constants.js":
/*!***************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/llhttp/constants.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/llhttp/utils.js\");\n// C headers\nvar ERROR;\n(function(ERROR) {\n    ERROR[ERROR[\"OK\"] = 0] = \"OK\";\n    ERROR[ERROR[\"INTERNAL\"] = 1] = \"INTERNAL\";\n    ERROR[ERROR[\"STRICT\"] = 2] = \"STRICT\";\n    ERROR[ERROR[\"LF_EXPECTED\"] = 3] = \"LF_EXPECTED\";\n    ERROR[ERROR[\"UNEXPECTED_CONTENT_LENGTH\"] = 4] = \"UNEXPECTED_CONTENT_LENGTH\";\n    ERROR[ERROR[\"CLOSED_CONNECTION\"] = 5] = \"CLOSED_CONNECTION\";\n    ERROR[ERROR[\"INVALID_METHOD\"] = 6] = \"INVALID_METHOD\";\n    ERROR[ERROR[\"INVALID_URL\"] = 7] = \"INVALID_URL\";\n    ERROR[ERROR[\"INVALID_CONSTANT\"] = 8] = \"INVALID_CONSTANT\";\n    ERROR[ERROR[\"INVALID_VERSION\"] = 9] = \"INVALID_VERSION\";\n    ERROR[ERROR[\"INVALID_HEADER_TOKEN\"] = 10] = \"INVALID_HEADER_TOKEN\";\n    ERROR[ERROR[\"INVALID_CONTENT_LENGTH\"] = 11] = \"INVALID_CONTENT_LENGTH\";\n    ERROR[ERROR[\"INVALID_CHUNK_SIZE\"] = 12] = \"INVALID_CHUNK_SIZE\";\n    ERROR[ERROR[\"INVALID_STATUS\"] = 13] = \"INVALID_STATUS\";\n    ERROR[ERROR[\"INVALID_EOF_STATE\"] = 14] = \"INVALID_EOF_STATE\";\n    ERROR[ERROR[\"INVALID_TRANSFER_ENCODING\"] = 15] = \"INVALID_TRANSFER_ENCODING\";\n    ERROR[ERROR[\"CB_MESSAGE_BEGIN\"] = 16] = \"CB_MESSAGE_BEGIN\";\n    ERROR[ERROR[\"CB_HEADERS_COMPLETE\"] = 17] = \"CB_HEADERS_COMPLETE\";\n    ERROR[ERROR[\"CB_MESSAGE_COMPLETE\"] = 18] = \"CB_MESSAGE_COMPLETE\";\n    ERROR[ERROR[\"CB_CHUNK_HEADER\"] = 19] = \"CB_CHUNK_HEADER\";\n    ERROR[ERROR[\"CB_CHUNK_COMPLETE\"] = 20] = \"CB_CHUNK_COMPLETE\";\n    ERROR[ERROR[\"PAUSED\"] = 21] = \"PAUSED\";\n    ERROR[ERROR[\"PAUSED_UPGRADE\"] = 22] = \"PAUSED_UPGRADE\";\n    ERROR[ERROR[\"PAUSED_H2_UPGRADE\"] = 23] = \"PAUSED_H2_UPGRADE\";\n    ERROR[ERROR[\"USER\"] = 24] = \"USER\";\n})(ERROR = exports.ERROR || (exports.ERROR = {}));\nvar TYPE;\n(function(TYPE) {\n    TYPE[TYPE[\"BOTH\"] = 0] = \"BOTH\";\n    TYPE[TYPE[\"REQUEST\"] = 1] = \"REQUEST\";\n    TYPE[TYPE[\"RESPONSE\"] = 2] = \"RESPONSE\";\n})(TYPE = exports.TYPE || (exports.TYPE = {}));\nvar FLAGS;\n(function(FLAGS) {\n    FLAGS[FLAGS[\"CONNECTION_KEEP_ALIVE\"] = 1] = \"CONNECTION_KEEP_ALIVE\";\n    FLAGS[FLAGS[\"CONNECTION_CLOSE\"] = 2] = \"CONNECTION_CLOSE\";\n    FLAGS[FLAGS[\"CONNECTION_UPGRADE\"] = 4] = \"CONNECTION_UPGRADE\";\n    FLAGS[FLAGS[\"CHUNKED\"] = 8] = \"CHUNKED\";\n    FLAGS[FLAGS[\"UPGRADE\"] = 16] = \"UPGRADE\";\n    FLAGS[FLAGS[\"CONTENT_LENGTH\"] = 32] = \"CONTENT_LENGTH\";\n    FLAGS[FLAGS[\"SKIPBODY\"] = 64] = \"SKIPBODY\";\n    FLAGS[FLAGS[\"TRAILING\"] = 128] = \"TRAILING\";\n    // 1 << 8 is unused\n    FLAGS[FLAGS[\"TRANSFER_ENCODING\"] = 512] = \"TRANSFER_ENCODING\";\n})(FLAGS = exports.FLAGS || (exports.FLAGS = {}));\nvar LENIENT_FLAGS;\n(function(LENIENT_FLAGS) {\n    LENIENT_FLAGS[LENIENT_FLAGS[\"HEADERS\"] = 1] = \"HEADERS\";\n    LENIENT_FLAGS[LENIENT_FLAGS[\"CHUNKED_LENGTH\"] = 2] = \"CHUNKED_LENGTH\";\n    LENIENT_FLAGS[LENIENT_FLAGS[\"KEEP_ALIVE\"] = 4] = \"KEEP_ALIVE\";\n})(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));\nvar METHODS;\n(function(METHODS) {\n    METHODS[METHODS[\"DELETE\"] = 0] = \"DELETE\";\n    METHODS[METHODS[\"GET\"] = 1] = \"GET\";\n    METHODS[METHODS[\"HEAD\"] = 2] = \"HEAD\";\n    METHODS[METHODS[\"POST\"] = 3] = \"POST\";\n    METHODS[METHODS[\"PUT\"] = 4] = \"PUT\";\n    /* pathological */ METHODS[METHODS[\"CONNECT\"] = 5] = \"CONNECT\";\n    METHODS[METHODS[\"OPTIONS\"] = 6] = \"OPTIONS\";\n    METHODS[METHODS[\"TRACE\"] = 7] = \"TRACE\";\n    /* WebDAV */ METHODS[METHODS[\"COPY\"] = 8] = \"COPY\";\n    METHODS[METHODS[\"LOCK\"] = 9] = \"LOCK\";\n    METHODS[METHODS[\"MKCOL\"] = 10] = \"MKCOL\";\n    METHODS[METHODS[\"MOVE\"] = 11] = \"MOVE\";\n    METHODS[METHODS[\"PROPFIND\"] = 12] = \"PROPFIND\";\n    METHODS[METHODS[\"PROPPATCH\"] = 13] = \"PROPPATCH\";\n    METHODS[METHODS[\"SEARCH\"] = 14] = \"SEARCH\";\n    METHODS[METHODS[\"UNLOCK\"] = 15] = \"UNLOCK\";\n    METHODS[METHODS[\"BIND\"] = 16] = \"BIND\";\n    METHODS[METHODS[\"REBIND\"] = 17] = \"REBIND\";\n    METHODS[METHODS[\"UNBIND\"] = 18] = \"UNBIND\";\n    METHODS[METHODS[\"ACL\"] = 19] = \"ACL\";\n    /* subversion */ METHODS[METHODS[\"REPORT\"] = 20] = \"REPORT\";\n    METHODS[METHODS[\"MKACTIVITY\"] = 21] = \"MKACTIVITY\";\n    METHODS[METHODS[\"CHECKOUT\"] = 22] = \"CHECKOUT\";\n    METHODS[METHODS[\"MERGE\"] = 23] = \"MERGE\";\n    /* upnp */ METHODS[METHODS[\"M-SEARCH\"] = 24] = \"M-SEARCH\";\n    METHODS[METHODS[\"NOTIFY\"] = 25] = \"NOTIFY\";\n    METHODS[METHODS[\"SUBSCRIBE\"] = 26] = \"SUBSCRIBE\";\n    METHODS[METHODS[\"UNSUBSCRIBE\"] = 27] = \"UNSUBSCRIBE\";\n    /* RFC-5789 */ METHODS[METHODS[\"PATCH\"] = 28] = \"PATCH\";\n    METHODS[METHODS[\"PURGE\"] = 29] = \"PURGE\";\n    /* CalDAV */ METHODS[METHODS[\"MKCALENDAR\"] = 30] = \"MKCALENDAR\";\n    /* RFC-2068, section 19.6.1.2 */ METHODS[METHODS[\"LINK\"] = 31] = \"LINK\";\n    METHODS[METHODS[\"UNLINK\"] = 32] = \"UNLINK\";\n    /* icecast */ METHODS[METHODS[\"SOURCE\"] = 33] = \"SOURCE\";\n    /* RFC-7540, section 11.6 */ METHODS[METHODS[\"PRI\"] = 34] = \"PRI\";\n    /* RFC-2326 RTSP */ METHODS[METHODS[\"DESCRIBE\"] = 35] = \"DESCRIBE\";\n    METHODS[METHODS[\"ANNOUNCE\"] = 36] = \"ANNOUNCE\";\n    METHODS[METHODS[\"SETUP\"] = 37] = \"SETUP\";\n    METHODS[METHODS[\"PLAY\"] = 38] = \"PLAY\";\n    METHODS[METHODS[\"PAUSE\"] = 39] = \"PAUSE\";\n    METHODS[METHODS[\"TEARDOWN\"] = 40] = \"TEARDOWN\";\n    METHODS[METHODS[\"GET_PARAMETER\"] = 41] = \"GET_PARAMETER\";\n    METHODS[METHODS[\"SET_PARAMETER\"] = 42] = \"SET_PARAMETER\";\n    METHODS[METHODS[\"REDIRECT\"] = 43] = \"REDIRECT\";\n    METHODS[METHODS[\"RECORD\"] = 44] = \"RECORD\";\n    /* RAOP */ METHODS[METHODS[\"FLUSH\"] = 45] = \"FLUSH\";\n})(METHODS = exports.METHODS || (exports.METHODS = {}));\nexports.METHODS_HTTP = [\n    METHODS.DELETE,\n    METHODS.GET,\n    METHODS.HEAD,\n    METHODS.POST,\n    METHODS.PUT,\n    METHODS.CONNECT,\n    METHODS.OPTIONS,\n    METHODS.TRACE,\n    METHODS.COPY,\n    METHODS.LOCK,\n    METHODS.MKCOL,\n    METHODS.MOVE,\n    METHODS.PROPFIND,\n    METHODS.PROPPATCH,\n    METHODS.SEARCH,\n    METHODS.UNLOCK,\n    METHODS.BIND,\n    METHODS.REBIND,\n    METHODS.UNBIND,\n    METHODS.ACL,\n    METHODS.REPORT,\n    METHODS.MKACTIVITY,\n    METHODS.CHECKOUT,\n    METHODS.MERGE,\n    METHODS[\"M-SEARCH\"],\n    METHODS.NOTIFY,\n    METHODS.SUBSCRIBE,\n    METHODS.UNSUBSCRIBE,\n    METHODS.PATCH,\n    METHODS.PURGE,\n    METHODS.MKCALENDAR,\n    METHODS.LINK,\n    METHODS.UNLINK,\n    METHODS.PRI,\n    // TODO(indutny): should we allow it with HTTP?\n    METHODS.SOURCE\n];\nexports.METHODS_ICE = [\n    METHODS.SOURCE\n];\nexports.METHODS_RTSP = [\n    METHODS.OPTIONS,\n    METHODS.DESCRIBE,\n    METHODS.ANNOUNCE,\n    METHODS.SETUP,\n    METHODS.PLAY,\n    METHODS.PAUSE,\n    METHODS.TEARDOWN,\n    METHODS.GET_PARAMETER,\n    METHODS.SET_PARAMETER,\n    METHODS.REDIRECT,\n    METHODS.RECORD,\n    METHODS.FLUSH,\n    // For AirPlay\n    METHODS.GET,\n    METHODS.POST\n];\nexports.METHOD_MAP = utils_1.enumToMap(METHODS);\nexports.H_METHOD_MAP = {};\nObject.keys(exports.METHOD_MAP).forEach((key)=>{\n    if (/^H/.test(key)) {\n        exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];\n    }\n});\nvar FINISH;\n(function(FINISH) {\n    FINISH[FINISH[\"SAFE\"] = 0] = \"SAFE\";\n    FINISH[FINISH[\"SAFE_WITH_CB\"] = 1] = \"SAFE_WITH_CB\";\n    FINISH[FINISH[\"UNSAFE\"] = 2] = \"UNSAFE\";\n})(FINISH = exports.FINISH || (exports.FINISH = {}));\nexports.ALPHA = [];\nfor(let i = \"A\".charCodeAt(0); i <= \"Z\".charCodeAt(0); i++){\n    // Upper case\n    exports.ALPHA.push(String.fromCharCode(i));\n    // Lower case\n    exports.ALPHA.push(String.fromCharCode(i + 0x20));\n}\nexports.NUM_MAP = {\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 3,\n    4: 4,\n    5: 5,\n    6: 6,\n    7: 7,\n    8: 8,\n    9: 9\n};\nexports.HEX_MAP = {\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 3,\n    4: 4,\n    5: 5,\n    6: 6,\n    7: 7,\n    8: 8,\n    9: 9,\n    A: 0XA,\n    B: 0XB,\n    C: 0XC,\n    D: 0XD,\n    E: 0XE,\n    F: 0XF,\n    a: 0xa,\n    b: 0xb,\n    c: 0xc,\n    d: 0xd,\n    e: 0xe,\n    f: 0xf\n};\nexports.NUM = [\n    \"0\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"7\",\n    \"8\",\n    \"9\"\n];\nexports.ALPHANUM = exports.ALPHA.concat(exports.NUM);\nexports.MARK = [\n    \"-\",\n    \"_\",\n    \".\",\n    \"!\",\n    \"~\",\n    \"*\",\n    \"'\",\n    \"(\",\n    \")\"\n];\nexports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat([\n    \"%\",\n    \";\",\n    \":\",\n    \"&\",\n    \"=\",\n    \"+\",\n    \"$\",\n    \",\"\n]);\n// TODO(indutny): use RFC\nexports.STRICT_URL_CHAR = [\n    \"!\",\n    '\"',\n    \"$\",\n    \"%\",\n    \"&\",\n    \"'\",\n    \"(\",\n    \")\",\n    \"*\",\n    \"+\",\n    \",\",\n    \"-\",\n    \".\",\n    \"/\",\n    \":\",\n    \";\",\n    \"<\",\n    \"=\",\n    \">\",\n    \"@\",\n    \"[\",\n    \"\\\\\",\n    \"]\",\n    \"^\",\n    \"_\",\n    \"`\",\n    \"{\",\n    \"|\",\n    \"}\",\n    \"~\"\n].concat(exports.ALPHANUM);\nexports.URL_CHAR = exports.STRICT_URL_CHAR.concat([\n    \"\t\",\n    \"\\f\"\n]);\n// All characters with 0x80 bit set to 1\nfor(let i = 0x80; i <= 0xff; i++){\n    exports.URL_CHAR.push(i);\n}\nexports.HEX = exports.NUM.concat([\n    \"a\",\n    \"b\",\n    \"c\",\n    \"d\",\n    \"e\",\n    \"f\",\n    \"A\",\n    \"B\",\n    \"C\",\n    \"D\",\n    \"E\",\n    \"F\"\n]);\n/* Tokens as defined by rfc 2616. Also lowercases them.\n *        token       = 1*<any CHAR except CTLs or separators>\n *     separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n *                    | \",\" | \";\" | \":\" | \"\\\" | <\">\n *                    | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n *                    | \"{\" | \"}\" | SP | HT\n */ exports.STRICT_TOKEN = [\n    \"!\",\n    \"#\",\n    \"$\",\n    \"%\",\n    \"&\",\n    \"'\",\n    \"*\",\n    \"+\",\n    \"-\",\n    \".\",\n    \"^\",\n    \"_\",\n    \"`\",\n    \"|\",\n    \"~\"\n].concat(exports.ALPHANUM);\nexports.TOKEN = exports.STRICT_TOKEN.concat([\n    \" \"\n]);\n/*\n * Verify that a char is a valid visible (printable) US-ASCII\n * character or %x80-FF\n */ exports.HEADER_CHARS = [\n    \"\t\"\n];\nfor(let i = 32; i <= 255; i++){\n    if (i !== 127) {\n        exports.HEADER_CHARS.push(i);\n    }\n}\n// ',' = \\x44\nexports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c)=>c !== 44);\nexports.MAJOR = exports.NUM_MAP;\nexports.MINOR = exports.MAJOR;\nvar HEADER_STATE;\n(function(HEADER_STATE) {\n    HEADER_STATE[HEADER_STATE[\"GENERAL\"] = 0] = \"GENERAL\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION\"] = 1] = \"CONNECTION\";\n    HEADER_STATE[HEADER_STATE[\"CONTENT_LENGTH\"] = 2] = \"CONTENT_LENGTH\";\n    HEADER_STATE[HEADER_STATE[\"TRANSFER_ENCODING\"] = 3] = \"TRANSFER_ENCODING\";\n    HEADER_STATE[HEADER_STATE[\"UPGRADE\"] = 4] = \"UPGRADE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_KEEP_ALIVE\"] = 5] = \"CONNECTION_KEEP_ALIVE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_CLOSE\"] = 6] = \"CONNECTION_CLOSE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_UPGRADE\"] = 7] = \"CONNECTION_UPGRADE\";\n    HEADER_STATE[HEADER_STATE[\"TRANSFER_ENCODING_CHUNKED\"] = 8] = \"TRANSFER_ENCODING_CHUNKED\";\n})(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));\nexports.SPECIAL_HEADERS = {\n    \"connection\": HEADER_STATE.CONNECTION,\n    \"content-length\": HEADER_STATE.CONTENT_LENGTH,\n    \"proxy-connection\": HEADER_STATE.CONNECTION,\n    \"transfer-encoding\": HEADER_STATE.TRANSFER_ENCODING,\n    \"upgrade\": HEADER_STATE.UPGRADE\n}; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbGxodHRwL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsdUJBQXVCLEdBQUdBLG9CQUFvQixHQUFHQSxhQUFhLEdBQUdBLGFBQWEsR0FBR0EsOEJBQThCLEdBQUdBLG9CQUFvQixHQUFHQSxhQUFhLEdBQUdBLG9CQUFvQixHQUFHQSxXQUFXLEdBQUdBLGdCQUFnQixHQUFHQSx1QkFBdUIsR0FBR0Esc0JBQXNCLEdBQUdBLFlBQVksR0FBR0EsZ0JBQWdCLEdBQUdBLFdBQVcsR0FBR0EsZUFBZSxHQUFHQSxlQUFlLEdBQUdBLGFBQWEsR0FBR0EsY0FBYyxHQUFHQSxvQkFBb0IsR0FBR0Esa0JBQWtCLEdBQUdBLG9CQUFvQixHQUFHQSxtQkFBbUIsR0FBR0Esb0JBQW9CLEdBQUdBLGVBQWUsR0FBR0EscUJBQXFCLEdBQUdBLGFBQWEsR0FBR0EsWUFBWSxHQUFHQSxhQUFhLEdBQUcsS0FBSztBQUN2a0IsTUFBTStCLFVBQVVDLG1CQUFPQSxDQUFDLHNGQUFTO0FBQ2pDLFlBQVk7QUFDWixJQUFJRjtBQUNILFVBQVVBLEtBQUs7SUFDWkEsS0FBSyxDQUFDQSxLQUFLLENBQUMsS0FBSyxHQUFHLEVBQUUsR0FBRztJQUN6QkEsS0FBSyxDQUFDQSxLQUFLLENBQUMsV0FBVyxHQUFHLEVBQUUsR0FBRztJQUMvQkEsS0FBSyxDQUFDQSxLQUFLLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztJQUM3QkEsS0FBSyxDQUFDQSxLQUFLLENBQUMsY0FBYyxHQUFHLEVBQUUsR0FBRztJQUNsQ0EsS0FBSyxDQUFDQSxLQUFLLENBQUMsNEJBQTRCLEdBQUcsRUFBRSxHQUFHO0lBQ2hEQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxvQkFBb0IsR0FBRyxFQUFFLEdBQUc7SUFDeENBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLGlCQUFpQixHQUFHLEVBQUUsR0FBRztJQUNyQ0EsS0FBSyxDQUFDQSxLQUFLLENBQUMsY0FBYyxHQUFHLEVBQUUsR0FBRztJQUNsQ0EsS0FBSyxDQUFDQSxLQUFLLENBQUMsbUJBQW1CLEdBQUcsRUFBRSxHQUFHO0lBQ3ZDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxrQkFBa0IsR0FBRyxFQUFFLEdBQUc7SUFDdENBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLHVCQUF1QixHQUFHLEdBQUcsR0FBRztJQUM1Q0EsS0FBSyxDQUFDQSxLQUFLLENBQUMseUJBQXlCLEdBQUcsR0FBRyxHQUFHO0lBQzlDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxxQkFBcUIsR0FBRyxHQUFHLEdBQUc7SUFDMUNBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLGlCQUFpQixHQUFHLEdBQUcsR0FBRztJQUN0Q0EsS0FBSyxDQUFDQSxLQUFLLENBQUMsb0JBQW9CLEdBQUcsR0FBRyxHQUFHO0lBQ3pDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyw0QkFBNEIsR0FBRyxHQUFHLEdBQUc7SUFDakRBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLG1CQUFtQixHQUFHLEdBQUcsR0FBRztJQUN4Q0EsS0FBSyxDQUFDQSxLQUFLLENBQUMsc0JBQXNCLEdBQUcsR0FBRyxHQUFHO0lBQzNDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxzQkFBc0IsR0FBRyxHQUFHLEdBQUc7SUFDM0NBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLGtCQUFrQixHQUFHLEdBQUcsR0FBRztJQUN2Q0EsS0FBSyxDQUFDQSxLQUFLLENBQUMsb0JBQW9CLEdBQUcsR0FBRyxHQUFHO0lBQ3pDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxTQUFTLEdBQUcsR0FBRyxHQUFHO0lBQzlCQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxpQkFBaUIsR0FBRyxHQUFHLEdBQUc7SUFDdENBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLG9CQUFvQixHQUFHLEdBQUcsR0FBRztJQUN6Q0EsS0FBSyxDQUFDQSxLQUFLLENBQUMsT0FBTyxHQUFHLEdBQUcsR0FBRztBQUNoQyxHQUFHQSxRQUFROUIsUUFBUThCLEtBQUssSUFBSzlCLENBQUFBLGFBQWEsR0FBRyxDQUFDO0FBQzlDLElBQUk2QjtBQUNILFVBQVVBLElBQUk7SUFDWEEsSUFBSSxDQUFDQSxJQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUN6QkEsSUFBSSxDQUFDQSxJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUM1QkEsSUFBSSxDQUFDQSxJQUFJLENBQUMsV0FBVyxHQUFHLEVBQUUsR0FBRztBQUNqQyxHQUFHQSxPQUFPN0IsUUFBUTZCLElBQUksSUFBSzdCLENBQUFBLFlBQVksR0FBRyxDQUFDO0FBQzNDLElBQUk0QjtBQUNILFVBQVVBLEtBQUs7SUFDWkEsS0FBSyxDQUFDQSxLQUFLLENBQUMsd0JBQXdCLEdBQUcsRUFBRSxHQUFHO0lBQzVDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxtQkFBbUIsR0FBRyxFQUFFLEdBQUc7SUFDdkNBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLHFCQUFxQixHQUFHLEVBQUUsR0FBRztJQUN6Q0EsS0FBSyxDQUFDQSxLQUFLLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUM5QkEsS0FBSyxDQUFDQSxLQUFLLENBQUMsVUFBVSxHQUFHLEdBQUcsR0FBRztJQUMvQkEsS0FBSyxDQUFDQSxLQUFLLENBQUMsaUJBQWlCLEdBQUcsR0FBRyxHQUFHO0lBQ3RDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxXQUFXLEdBQUcsR0FBRyxHQUFHO0lBQ2hDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxXQUFXLEdBQUcsSUFBSSxHQUFHO0lBQ2pDLG1CQUFtQjtJQUNuQkEsS0FBSyxDQUFDQSxLQUFLLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxHQUFHO0FBQzlDLEdBQUdBLFFBQVE1QixRQUFRNEIsS0FBSyxJQUFLNUIsQ0FBQUEsYUFBYSxHQUFHLENBQUM7QUFDOUMsSUFBSTJCO0FBQ0gsVUFBVUEsYUFBYTtJQUNwQkEsYUFBYSxDQUFDQSxhQUFhLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUM5Q0EsYUFBYSxDQUFDQSxhQUFhLENBQUMsaUJBQWlCLEdBQUcsRUFBRSxHQUFHO0lBQ3JEQSxhQUFhLENBQUNBLGFBQWEsQ0FBQyxhQUFhLEdBQUcsRUFBRSxHQUFHO0FBQ3JELEdBQUdBLGdCQUFnQjNCLFFBQVEyQixhQUFhLElBQUszQixDQUFBQSxxQkFBcUIsR0FBRyxDQUFDO0FBQ3RFLElBQUkwQjtBQUNILFVBQVVBLE9BQU87SUFDZEEsT0FBTyxDQUFDQSxPQUFPLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztJQUNqQ0EsT0FBTyxDQUFDQSxPQUFPLENBQUMsTUFBTSxHQUFHLEVBQUUsR0FBRztJQUM5QkEsT0FBTyxDQUFDQSxPQUFPLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUMvQkEsT0FBTyxDQUFDQSxPQUFPLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUMvQkEsT0FBTyxDQUFDQSxPQUFPLENBQUMsTUFBTSxHQUFHLEVBQUUsR0FBRztJQUM5QixnQkFBZ0IsR0FDaEJBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDbENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDbENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDaEMsVUFBVSxHQUNWQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0lBQy9CQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0lBQy9CQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxRQUFRLEdBQUcsR0FBRyxHQUFHO0lBQ2pDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxPQUFPLEdBQUcsR0FBRyxHQUFHO0lBQ2hDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxXQUFXLEdBQUcsR0FBRyxHQUFHO0lBQ3BDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxZQUFZLEdBQUcsR0FBRyxHQUFHO0lBQ3JDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxTQUFTLEdBQUcsR0FBRyxHQUFHO0lBQ2xDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxTQUFTLEdBQUcsR0FBRyxHQUFHO0lBQ2xDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxPQUFPLEdBQUcsR0FBRyxHQUFHO0lBQ2hDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxTQUFTLEdBQUcsR0FBRyxHQUFHO0lBQ2xDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxTQUFTLEdBQUcsR0FBRyxHQUFHO0lBQ2xDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxNQUFNLEdBQUcsR0FBRyxHQUFHO0lBQy9CLGNBQWMsR0FDZEEsT0FBTyxDQUFDQSxPQUFPLENBQUMsU0FBUyxHQUFHLEdBQUcsR0FBRztJQUNsQ0EsT0FBTyxDQUFDQSxPQUFPLENBQUMsYUFBYSxHQUFHLEdBQUcsR0FBRztJQUN0Q0EsT0FBTyxDQUFDQSxPQUFPLENBQUMsV0FBVyxHQUFHLEdBQUcsR0FBRztJQUNwQ0EsT0FBTyxDQUFDQSxPQUFPLENBQUMsUUFBUSxHQUFHLEdBQUcsR0FBRztJQUNqQyxRQUFRLEdBQ1JBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFdBQVcsR0FBRyxHQUFHLEdBQUc7SUFDcENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFNBQVMsR0FBRyxHQUFHLEdBQUc7SUFDbENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFlBQVksR0FBRyxHQUFHLEdBQUc7SUFDckNBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLGNBQWMsR0FBRyxHQUFHLEdBQUc7SUFDdkMsWUFBWSxHQUNaQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxRQUFRLEdBQUcsR0FBRyxHQUFHO0lBQ2pDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxRQUFRLEdBQUcsR0FBRyxHQUFHO0lBQ2pDLFVBQVUsR0FDVkEsT0FBTyxDQUFDQSxPQUFPLENBQUMsYUFBYSxHQUFHLEdBQUcsR0FBRztJQUN0Qyw4QkFBOEIsR0FDOUJBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLE9BQU8sR0FBRyxHQUFHLEdBQUc7SUFDaENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFNBQVMsR0FBRyxHQUFHLEdBQUc7SUFDbEMsV0FBVyxHQUNYQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxTQUFTLEdBQUcsR0FBRyxHQUFHO0lBQ2xDLDBCQUEwQixHQUMxQkEsT0FBTyxDQUFDQSxPQUFPLENBQUMsTUFBTSxHQUFHLEdBQUcsR0FBRztJQUMvQixpQkFBaUIsR0FDakJBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFdBQVcsR0FBRyxHQUFHLEdBQUc7SUFDcENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFdBQVcsR0FBRyxHQUFHLEdBQUc7SUFDcENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFFBQVEsR0FBRyxHQUFHLEdBQUc7SUFDakNBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLE9BQU8sR0FBRyxHQUFHLEdBQUc7SUFDaENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFFBQVEsR0FBRyxHQUFHLEdBQUc7SUFDakNBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFdBQVcsR0FBRyxHQUFHLEdBQUc7SUFDcENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLGdCQUFnQixHQUFHLEdBQUcsR0FBRztJQUN6Q0EsT0FBTyxDQUFDQSxPQUFPLENBQUMsZ0JBQWdCLEdBQUcsR0FBRyxHQUFHO0lBQ3pDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxXQUFXLEdBQUcsR0FBRyxHQUFHO0lBQ3BDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxTQUFTLEdBQUcsR0FBRyxHQUFHO0lBQ2xDLFFBQVEsR0FDUkEsT0FBTyxDQUFDQSxPQUFPLENBQUMsUUFBUSxHQUFHLEdBQUcsR0FBRztBQUNyQyxHQUFHQSxVQUFVMUIsUUFBUTBCLE9BQU8sSUFBSzFCLENBQUFBLGVBQWUsR0FBRyxDQUFDO0FBQ3BEQSxvQkFBb0IsR0FBRztJQUNuQjBCLFFBQVFPLE1BQU07SUFDZFAsUUFBUVEsR0FBRztJQUNYUixRQUFRUyxJQUFJO0lBQ1pULFFBQVFVLElBQUk7SUFDWlYsUUFBUVcsR0FBRztJQUNYWCxRQUFRWSxPQUFPO0lBQ2ZaLFFBQVFhLE9BQU87SUFDZmIsUUFBUWMsS0FBSztJQUNiZCxRQUFRZSxJQUFJO0lBQ1pmLFFBQVFnQixJQUFJO0lBQ1poQixRQUFRaUIsS0FBSztJQUNiakIsUUFBUWtCLElBQUk7SUFDWmxCLFFBQVFtQixRQUFRO0lBQ2hCbkIsUUFBUW9CLFNBQVM7SUFDakJwQixRQUFRcUIsTUFBTTtJQUNkckIsUUFBUXNCLE1BQU07SUFDZHRCLFFBQVF1QixJQUFJO0lBQ1p2QixRQUFRd0IsTUFBTTtJQUNkeEIsUUFBUXlCLE1BQU07SUFDZHpCLFFBQVEwQixHQUFHO0lBQ1gxQixRQUFRMkIsTUFBTTtJQUNkM0IsUUFBUTRCLFVBQVU7SUFDbEI1QixRQUFRNkIsUUFBUTtJQUNoQjdCLFFBQVE4QixLQUFLO0lBQ2I5QixPQUFPLENBQUMsV0FBVztJQUNuQkEsUUFBUStCLE1BQU07SUFDZC9CLFFBQVFnQyxTQUFTO0lBQ2pCaEMsUUFBUWlDLFdBQVc7SUFDbkJqQyxRQUFRa0MsS0FBSztJQUNibEMsUUFBUW1DLEtBQUs7SUFDYm5DLFFBQVFvQyxVQUFVO0lBQ2xCcEMsUUFBUXFDLElBQUk7SUFDWnJDLFFBQVFzQyxNQUFNO0lBQ2R0QyxRQUFRdUMsR0FBRztJQUNYLCtDQUErQztJQUMvQ3ZDLFFBQVF3QyxNQUFNO0NBQ2pCO0FBQ0RsRSxtQkFBbUIsR0FBRztJQUNsQjBCLFFBQVF3QyxNQUFNO0NBQ2pCO0FBQ0RsRSxvQkFBb0IsR0FBRztJQUNuQjBCLFFBQVFhLE9BQU87SUFDZmIsUUFBUXlDLFFBQVE7SUFDaEJ6QyxRQUFRMEMsUUFBUTtJQUNoQjFDLFFBQVEyQyxLQUFLO0lBQ2IzQyxRQUFRNEMsSUFBSTtJQUNaNUMsUUFBUTZDLEtBQUs7SUFDYjdDLFFBQVE4QyxRQUFRO0lBQ2hCOUMsUUFBUStDLGFBQWE7SUFDckIvQyxRQUFRZ0QsYUFBYTtJQUNyQmhELFFBQVFpRCxRQUFRO0lBQ2hCakQsUUFBUWtELE1BQU07SUFDZGxELFFBQVFtRCxLQUFLO0lBQ2IsY0FBYztJQUNkbkQsUUFBUVEsR0FBRztJQUNYUixRQUFRVSxJQUFJO0NBQ2Y7QUFDRHBDLGtCQUFrQixHQUFHK0IsUUFBUStDLFNBQVMsQ0FBQ3BEO0FBQ3ZDMUIsb0JBQW9CLEdBQUcsQ0FBQztBQUN4QkYsT0FBT2lGLElBQUksQ0FBQy9FLFFBQVFzQixVQUFVLEVBQUUwRCxPQUFPLENBQUMsQ0FBQ0M7SUFDckMsSUFBSSxLQUFLQyxJQUFJLENBQUNELE1BQU07UUFDaEJqRixRQUFRcUIsWUFBWSxDQUFDNEQsSUFBSSxHQUFHakYsUUFBUXNCLFVBQVUsQ0FBQzJELElBQUk7SUFDdkQ7QUFDSjtBQUNBLElBQUk3RDtBQUNILFVBQVVBLE1BQU07SUFDYkEsTUFBTSxDQUFDQSxNQUFNLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUM3QkEsTUFBTSxDQUFDQSxNQUFNLENBQUMsZUFBZSxHQUFHLEVBQUUsR0FBRztJQUNyQ0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztBQUNuQyxHQUFHQSxTQUFTcEIsUUFBUW9CLE1BQU0sSUFBS3BCLENBQUFBLGNBQWMsR0FBRyxDQUFDO0FBQ2pEQSxhQUFhLEdBQUcsRUFBRTtBQUNsQixJQUFLLElBQUltRixJQUFJLElBQUlDLFVBQVUsQ0FBQyxJQUFJRCxLQUFLLElBQUlDLFVBQVUsQ0FBQyxJQUFJRCxJQUFLO0lBQ3pELGFBQWE7SUFDYm5GLFFBQVFtQixLQUFLLENBQUNrRSxJQUFJLENBQUNDLE9BQU9DLFlBQVksQ0FBQ0o7SUFDdkMsYUFBYTtJQUNibkYsUUFBUW1CLEtBQUssQ0FBQ2tFLElBQUksQ0FBQ0MsT0FBT0MsWUFBWSxDQUFDSixJQUFJO0FBQy9DO0FBQ0FuRixlQUFlLEdBQUc7SUFDZCxHQUFHO0lBQUcsR0FBRztJQUFHLEdBQUc7SUFBRyxHQUFHO0lBQUcsR0FBRztJQUMzQixHQUFHO0lBQUcsR0FBRztJQUFHLEdBQUc7SUFBRyxHQUFHO0lBQUcsR0FBRztBQUMvQjtBQUNBQSxlQUFlLEdBQUc7SUFDZCxHQUFHO0lBQUcsR0FBRztJQUFHLEdBQUc7SUFBRyxHQUFHO0lBQUcsR0FBRztJQUMzQixHQUFHO0lBQUcsR0FBRztJQUFHLEdBQUc7SUFBRyxHQUFHO0lBQUcsR0FBRztJQUMzQndGLEdBQUc7SUFBS0MsR0FBRztJQUFLQyxHQUFHO0lBQUtDLEdBQUc7SUFBS0MsR0FBRztJQUFLQyxHQUFHO0lBQzNDQyxHQUFHO0lBQUtDLEdBQUc7SUFBS0MsR0FBRztJQUFLQyxHQUFHO0lBQUtDLEdBQUc7SUFBS0MsR0FBRztBQUMvQztBQUNBbkcsV0FBVyxHQUFHO0lBQ1Y7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7Q0FDaEQ7QUFDREEsZ0JBQWdCLEdBQUdBLFFBQVFtQixLQUFLLENBQUNpRixNQUFNLENBQUNwRyxRQUFRZ0IsR0FBRztBQUNuRGhCLFlBQVksR0FBRztJQUFDO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQU07SUFBSztDQUFJO0FBQzdEQSxzQkFBc0IsR0FBR0EsUUFBUWUsUUFBUSxDQUNwQ3FGLE1BQU0sQ0FBQ3BHLFFBQVFjLElBQUksRUFDbkJzRixNQUFNLENBQUM7SUFBQztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0NBQUk7QUFDcEQseUJBQXlCO0FBQ3pCcEcsdUJBQXVCLEdBQUc7SUFDdEI7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQ3pCO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFDbkM7SUFBSztJQUFLO0lBQUs7SUFBSztJQUNwQjtJQUFLO0lBQUs7SUFBTTtJQUFLO0lBQUs7SUFDMUI7SUFDQTtJQUFLO0lBQUs7SUFBSztDQUNsQixDQUFDb0csTUFBTSxDQUFDcEcsUUFBUWUsUUFBUTtBQUN6QmYsZ0JBQWdCLEdBQUdBLFFBQVFZLGVBQWUsQ0FDckN3RixNQUFNLENBQUM7SUFBQztJQUFNO0NBQUs7QUFDeEIsd0NBQXdDO0FBQ3hDLElBQUssSUFBSWpCLElBQUksTUFBTUEsS0FBSyxNQUFNQSxJQUFLO0lBQy9CbkYsUUFBUVcsUUFBUSxDQUFDMEUsSUFBSSxDQUFDRjtBQUMxQjtBQUNBbkYsV0FBVyxHQUFHQSxRQUFRZ0IsR0FBRyxDQUFDb0YsTUFBTSxDQUFDO0lBQUM7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0NBQUk7QUFDN0Y7Ozs7OztDQU1DLEdBQ0RwRyxvQkFBb0IsR0FBRztJQUNuQjtJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFDekI7SUFBSztJQUFLO0lBQUs7SUFDZjtJQUFLO0lBQUs7SUFDVjtJQUFLO0NBQ1IsQ0FBQ29HLE1BQU0sQ0FBQ3BHLFFBQVFlLFFBQVE7QUFDekJmLGFBQWEsR0FBR0EsUUFBUVMsWUFBWSxDQUFDMkYsTUFBTSxDQUFDO0lBQUM7Q0FBSTtBQUNqRDs7O0NBR0MsR0FDRHBHLG9CQUFvQixHQUFHO0lBQUM7Q0FBSztBQUM3QixJQUFLLElBQUltRixJQUFJLElBQUlBLEtBQUssS0FBS0EsSUFBSztJQUM1QixJQUFJQSxNQUFNLEtBQUs7UUFDWG5GLFFBQVFPLFlBQVksQ0FBQzhFLElBQUksQ0FBQ0Y7SUFDOUI7QUFDSjtBQUNBLGFBQWE7QUFDYm5GLDhCQUE4QixHQUFHQSxRQUFRTyxZQUFZLENBQUM4RixNQUFNLENBQUMsQ0FBQ0wsSUFBTUEsTUFBTTtBQUMxRWhHLGFBQWEsR0FBR0EsUUFBUWtCLE9BQU87QUFDL0JsQixhQUFhLEdBQUdBLFFBQVFLLEtBQUs7QUFDN0IsSUFBSUY7QUFDSCxVQUFVQSxZQUFZO0lBQ25CQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQzVDQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxhQUFhLEdBQUcsRUFBRSxHQUFHO0lBQy9DQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxpQkFBaUIsR0FBRyxFQUFFLEdBQUc7SUFDbkRBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLG9CQUFvQixHQUFHLEVBQUUsR0FBRztJQUN0REEsWUFBWSxDQUFDQSxZQUFZLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUM1Q0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsd0JBQXdCLEdBQUcsRUFBRSxHQUFHO0lBQzFEQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxtQkFBbUIsR0FBRyxFQUFFLEdBQUc7SUFDckRBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLHFCQUFxQixHQUFHLEVBQUUsR0FBRztJQUN2REEsWUFBWSxDQUFDQSxZQUFZLENBQUMsNEJBQTRCLEdBQUcsRUFBRSxHQUFHO0FBQ2xFLEdBQUdBLGVBQWVILFFBQVFHLFlBQVksSUFBS0gsQ0FBQUEsb0JBQW9CLEdBQUcsQ0FBQztBQUNuRUEsdUJBQXVCLEdBQUc7SUFDdEIsY0FBY0csYUFBYW1HLFVBQVU7SUFDckMsa0JBQWtCbkcsYUFBYW9HLGNBQWM7SUFDN0Msb0JBQW9CcEcsYUFBYW1HLFVBQVU7SUFDM0MscUJBQXFCbkcsYUFBYXFHLGlCQUFpQjtJQUNuRCxXQUFXckcsYUFBYXNHLE9BQU87QUFDbkMsR0FDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvY29uc3RhbnRzLmpzP2VmZWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNQRUNJQUxfSEVBREVSUyA9IGV4cG9ydHMuSEVBREVSX1NUQVRFID0gZXhwb3J0cy5NSU5PUiA9IGV4cG9ydHMuTUFKT1IgPSBleHBvcnRzLkNPTk5FQ1RJT05fVE9LRU5fQ0hBUlMgPSBleHBvcnRzLkhFQURFUl9DSEFSUyA9IGV4cG9ydHMuVE9LRU4gPSBleHBvcnRzLlNUUklDVF9UT0tFTiA9IGV4cG9ydHMuSEVYID0gZXhwb3J0cy5VUkxfQ0hBUiA9IGV4cG9ydHMuU1RSSUNUX1VSTF9DSEFSID0gZXhwb3J0cy5VU0VSSU5GT19DSEFSUyA9IGV4cG9ydHMuTUFSSyA9IGV4cG9ydHMuQUxQSEFOVU0gPSBleHBvcnRzLk5VTSA9IGV4cG9ydHMuSEVYX01BUCA9IGV4cG9ydHMuTlVNX01BUCA9IGV4cG9ydHMuQUxQSEEgPSBleHBvcnRzLkZJTklTSCA9IGV4cG9ydHMuSF9NRVRIT0RfTUFQID0gZXhwb3J0cy5NRVRIT0RfTUFQID0gZXhwb3J0cy5NRVRIT0RTX1JUU1AgPSBleHBvcnRzLk1FVEhPRFNfSUNFID0gZXhwb3J0cy5NRVRIT0RTX0hUVFAgPSBleHBvcnRzLk1FVEhPRFMgPSBleHBvcnRzLkxFTklFTlRfRkxBR1MgPSBleHBvcnRzLkZMQUdTID0gZXhwb3J0cy5UWVBFID0gZXhwb3J0cy5FUlJPUiA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8vIEMgaGVhZGVyc1xudmFyIEVSUk9SO1xuKGZ1bmN0aW9uIChFUlJPUikge1xuICAgIEVSUk9SW0VSUk9SW1wiT0tcIl0gPSAwXSA9IFwiT0tcIjtcbiAgICBFUlJPUltFUlJPUltcIklOVEVSTkFMXCJdID0gMV0gPSBcIklOVEVSTkFMXCI7XG4gICAgRVJST1JbRVJST1JbXCJTVFJJQ1RcIl0gPSAyXSA9IFwiU1RSSUNUXCI7XG4gICAgRVJST1JbRVJST1JbXCJMRl9FWFBFQ1RFRFwiXSA9IDNdID0gXCJMRl9FWFBFQ1RFRFwiO1xuICAgIEVSUk9SW0VSUk9SW1wiVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSFwiXSA9IDRdID0gXCJVTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIXCI7XG4gICAgRVJST1JbRVJST1JbXCJDTE9TRURfQ09OTkVDVElPTlwiXSA9IDVdID0gXCJDTE9TRURfQ09OTkVDVElPTlwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9NRVRIT0RcIl0gPSA2XSA9IFwiSU5WQUxJRF9NRVRIT0RcIjtcbiAgICBFUlJPUltFUlJPUltcIklOVkFMSURfVVJMXCJdID0gN10gPSBcIklOVkFMSURfVVJMXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX0NPTlNUQU5UXCJdID0gOF0gPSBcIklOVkFMSURfQ09OU1RBTlRcIjtcbiAgICBFUlJPUltFUlJPUltcIklOVkFMSURfVkVSU0lPTlwiXSA9IDldID0gXCJJTlZBTElEX1ZFUlNJT05cIjtcbiAgICBFUlJPUltFUlJPUltcIklOVkFMSURfSEVBREVSX1RPS0VOXCJdID0gMTBdID0gXCJJTlZBTElEX0hFQURFUl9UT0tFTlwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9DT05URU5UX0xFTkdUSFwiXSA9IDExXSA9IFwiSU5WQUxJRF9DT05URU5UX0xFTkdUSFwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9DSFVOS19TSVpFXCJdID0gMTJdID0gXCJJTlZBTElEX0NIVU5LX1NJWkVcIjtcbiAgICBFUlJPUltFUlJPUltcIklOVkFMSURfU1RBVFVTXCJdID0gMTNdID0gXCJJTlZBTElEX1NUQVRVU1wiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9FT0ZfU1RBVEVcIl0gPSAxNF0gPSBcIklOVkFMSURfRU9GX1NUQVRFXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HXCJdID0gMTVdID0gXCJJTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HXCI7XG4gICAgRVJST1JbRVJST1JbXCJDQl9NRVNTQUdFX0JFR0lOXCJdID0gMTZdID0gXCJDQl9NRVNTQUdFX0JFR0lOXCI7XG4gICAgRVJST1JbRVJST1JbXCJDQl9IRUFERVJTX0NPTVBMRVRFXCJdID0gMTddID0gXCJDQl9IRUFERVJTX0NPTVBMRVRFXCI7XG4gICAgRVJST1JbRVJST1JbXCJDQl9NRVNTQUdFX0NPTVBMRVRFXCJdID0gMThdID0gXCJDQl9NRVNTQUdFX0NPTVBMRVRFXCI7XG4gICAgRVJST1JbRVJST1JbXCJDQl9DSFVOS19IRUFERVJcIl0gPSAxOV0gPSBcIkNCX0NIVU5LX0hFQURFUlwiO1xuICAgIEVSUk9SW0VSUk9SW1wiQ0JfQ0hVTktfQ09NUExFVEVcIl0gPSAyMF0gPSBcIkNCX0NIVU5LX0NPTVBMRVRFXCI7XG4gICAgRVJST1JbRVJST1JbXCJQQVVTRURcIl0gPSAyMV0gPSBcIlBBVVNFRFwiO1xuICAgIEVSUk9SW0VSUk9SW1wiUEFVU0VEX1VQR1JBREVcIl0gPSAyMl0gPSBcIlBBVVNFRF9VUEdSQURFXCI7XG4gICAgRVJST1JbRVJST1JbXCJQQVVTRURfSDJfVVBHUkFERVwiXSA9IDIzXSA9IFwiUEFVU0VEX0gyX1VQR1JBREVcIjtcbiAgICBFUlJPUltFUlJPUltcIlVTRVJcIl0gPSAyNF0gPSBcIlVTRVJcIjtcbn0pKEVSUk9SID0gZXhwb3J0cy5FUlJPUiB8fCAoZXhwb3J0cy5FUlJPUiA9IHt9KSk7XG52YXIgVFlQRTtcbihmdW5jdGlvbiAoVFlQRSkge1xuICAgIFRZUEVbVFlQRVtcIkJPVEhcIl0gPSAwXSA9IFwiQk9USFwiO1xuICAgIFRZUEVbVFlQRVtcIlJFUVVFU1RcIl0gPSAxXSA9IFwiUkVRVUVTVFwiO1xuICAgIFRZUEVbVFlQRVtcIlJFU1BPTlNFXCJdID0gMl0gPSBcIlJFU1BPTlNFXCI7XG59KShUWVBFID0gZXhwb3J0cy5UWVBFIHx8IChleHBvcnRzLlRZUEUgPSB7fSkpO1xudmFyIEZMQUdTO1xuKGZ1bmN0aW9uIChGTEFHUykge1xuICAgIEZMQUdTW0ZMQUdTW1wiQ09OTkVDVElPTl9LRUVQX0FMSVZFXCJdID0gMV0gPSBcIkNPTk5FQ1RJT05fS0VFUF9BTElWRVwiO1xuICAgIEZMQUdTW0ZMQUdTW1wiQ09OTkVDVElPTl9DTE9TRVwiXSA9IDJdID0gXCJDT05ORUNUSU9OX0NMT1NFXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJDT05ORUNUSU9OX1VQR1JBREVcIl0gPSA0XSA9IFwiQ09OTkVDVElPTl9VUEdSQURFXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJDSFVOS0VEXCJdID0gOF0gPSBcIkNIVU5LRURcIjtcbiAgICBGTEFHU1tGTEFHU1tcIlVQR1JBREVcIl0gPSAxNl0gPSBcIlVQR1JBREVcIjtcbiAgICBGTEFHU1tGTEFHU1tcIkNPTlRFTlRfTEVOR1RIXCJdID0gMzJdID0gXCJDT05URU5UX0xFTkdUSFwiO1xuICAgIEZMQUdTW0ZMQUdTW1wiU0tJUEJPRFlcIl0gPSA2NF0gPSBcIlNLSVBCT0RZXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJUUkFJTElOR1wiXSA9IDEyOF0gPSBcIlRSQUlMSU5HXCI7XG4gICAgLy8gMSA8PCA4IGlzIHVudXNlZFxuICAgIEZMQUdTW0ZMQUdTW1wiVFJBTlNGRVJfRU5DT0RJTkdcIl0gPSA1MTJdID0gXCJUUkFOU0ZFUl9FTkNPRElOR1wiO1xufSkoRkxBR1MgPSBleHBvcnRzLkZMQUdTIHx8IChleHBvcnRzLkZMQUdTID0ge30pKTtcbnZhciBMRU5JRU5UX0ZMQUdTO1xuKGZ1bmN0aW9uIChMRU5JRU5UX0ZMQUdTKSB7XG4gICAgTEVOSUVOVF9GTEFHU1tMRU5JRU5UX0ZMQUdTW1wiSEVBREVSU1wiXSA9IDFdID0gXCJIRUFERVJTXCI7XG4gICAgTEVOSUVOVF9GTEFHU1tMRU5JRU5UX0ZMQUdTW1wiQ0hVTktFRF9MRU5HVEhcIl0gPSAyXSA9IFwiQ0hVTktFRF9MRU5HVEhcIjtcbiAgICBMRU5JRU5UX0ZMQUdTW0xFTklFTlRfRkxBR1NbXCJLRUVQX0FMSVZFXCJdID0gNF0gPSBcIktFRVBfQUxJVkVcIjtcbn0pKExFTklFTlRfRkxBR1MgPSBleHBvcnRzLkxFTklFTlRfRkxBR1MgfHwgKGV4cG9ydHMuTEVOSUVOVF9GTEFHUyA9IHt9KSk7XG52YXIgTUVUSE9EUztcbihmdW5jdGlvbiAoTUVUSE9EUykge1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkRFTEVURVwiXSA9IDBdID0gXCJERUxFVEVcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJHRVRcIl0gPSAxXSA9IFwiR0VUXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiSEVBRFwiXSA9IDJdID0gXCJIRUFEXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUE9TVFwiXSA9IDNdID0gXCJQT1NUXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUFVUXCJdID0gNF0gPSBcIlBVVFwiO1xuICAgIC8qIHBhdGhvbG9naWNhbCAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkNPTk5FQ1RcIl0gPSA1XSA9IFwiQ09OTkVDVFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIk9QVElPTlNcIl0gPSA2XSA9IFwiT1BUSU9OU1wiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlRSQUNFXCJdID0gN10gPSBcIlRSQUNFXCI7XG4gICAgLyogV2ViREFWICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiQ09QWVwiXSA9IDhdID0gXCJDT1BZXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiTE9DS1wiXSA9IDldID0gXCJMT0NLXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiTUtDT0xcIl0gPSAxMF0gPSBcIk1LQ09MXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiTU9WRVwiXSA9IDExXSA9IFwiTU9WRVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlBST1BGSU5EXCJdID0gMTJdID0gXCJQUk9QRklORFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlBST1BQQVRDSFwiXSA9IDEzXSA9IFwiUFJPUFBBVENIXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiU0VBUkNIXCJdID0gMTRdID0gXCJTRUFSQ0hcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJVTkxPQ0tcIl0gPSAxNV0gPSBcIlVOTE9DS1wiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkJJTkRcIl0gPSAxNl0gPSBcIkJJTkRcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJSRUJJTkRcIl0gPSAxN10gPSBcIlJFQklORFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlVOQklORFwiXSA9IDE4XSA9IFwiVU5CSU5EXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiQUNMXCJdID0gMTldID0gXCJBQ0xcIjtcbiAgICAvKiBzdWJ2ZXJzaW9uICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUkVQT1JUXCJdID0gMjBdID0gXCJSRVBPUlRcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJNS0FDVElWSVRZXCJdID0gMjFdID0gXCJNS0FDVElWSVRZXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiQ0hFQ0tPVVRcIl0gPSAyMl0gPSBcIkNIRUNLT1VUXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiTUVSR0VcIl0gPSAyM10gPSBcIk1FUkdFXCI7XG4gICAgLyogdXBucCAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIk0tU0VBUkNIXCJdID0gMjRdID0gXCJNLVNFQVJDSFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIk5PVElGWVwiXSA9IDI1XSA9IFwiTk9USUZZXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiU1VCU0NSSUJFXCJdID0gMjZdID0gXCJTVUJTQ1JJQkVcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJVTlNVQlNDUklCRVwiXSA9IDI3XSA9IFwiVU5TVUJTQ1JJQkVcIjtcbiAgICAvKiBSRkMtNTc4OSAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlBBVENIXCJdID0gMjhdID0gXCJQQVRDSFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlBVUkdFXCJdID0gMjldID0gXCJQVVJHRVwiO1xuICAgIC8qIENhbERBViAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIk1LQ0FMRU5EQVJcIl0gPSAzMF0gPSBcIk1LQ0FMRU5EQVJcIjtcbiAgICAvKiBSRkMtMjA2OCwgc2VjdGlvbiAxOS42LjEuMiAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkxJTktcIl0gPSAzMV0gPSBcIkxJTktcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJVTkxJTktcIl0gPSAzMl0gPSBcIlVOTElOS1wiO1xuICAgIC8qIGljZWNhc3QgKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJTT1VSQ0VcIl0gPSAzM10gPSBcIlNPVVJDRVwiO1xuICAgIC8qIFJGQy03NTQwLCBzZWN0aW9uIDExLjYgKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQUklcIl0gPSAzNF0gPSBcIlBSSVwiO1xuICAgIC8qIFJGQy0yMzI2IFJUU1AgKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJERVNDUklCRVwiXSA9IDM1XSA9IFwiREVTQ1JJQkVcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJBTk5PVU5DRVwiXSA9IDM2XSA9IFwiQU5OT1VOQ0VcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJTRVRVUFwiXSA9IDM3XSA9IFwiU0VUVVBcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQTEFZXCJdID0gMzhdID0gXCJQTEFZXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUEFVU0VcIl0gPSAzOV0gPSBcIlBBVVNFXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiVEVBUkRPV05cIl0gPSA0MF0gPSBcIlRFQVJET1dOXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiR0VUX1BBUkFNRVRFUlwiXSA9IDQxXSA9IFwiR0VUX1BBUkFNRVRFUlwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlNFVF9QQVJBTUVURVJcIl0gPSA0Ml0gPSBcIlNFVF9QQVJBTUVURVJcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJSRURJUkVDVFwiXSA9IDQzXSA9IFwiUkVESVJFQ1RcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJSRUNPUkRcIl0gPSA0NF0gPSBcIlJFQ09SRFwiO1xuICAgIC8qIFJBT1AgKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJGTFVTSFwiXSA9IDQ1XSA9IFwiRkxVU0hcIjtcbn0pKE1FVEhPRFMgPSBleHBvcnRzLk1FVEhPRFMgfHwgKGV4cG9ydHMuTUVUSE9EUyA9IHt9KSk7XG5leHBvcnRzLk1FVEhPRFNfSFRUUCA9IFtcbiAgICBNRVRIT0RTLkRFTEVURSxcbiAgICBNRVRIT0RTLkdFVCxcbiAgICBNRVRIT0RTLkhFQUQsXG4gICAgTUVUSE9EUy5QT1NULFxuICAgIE1FVEhPRFMuUFVULFxuICAgIE1FVEhPRFMuQ09OTkVDVCxcbiAgICBNRVRIT0RTLk9QVElPTlMsXG4gICAgTUVUSE9EUy5UUkFDRSxcbiAgICBNRVRIT0RTLkNPUFksXG4gICAgTUVUSE9EUy5MT0NLLFxuICAgIE1FVEhPRFMuTUtDT0wsXG4gICAgTUVUSE9EUy5NT1ZFLFxuICAgIE1FVEhPRFMuUFJPUEZJTkQsXG4gICAgTUVUSE9EUy5QUk9QUEFUQ0gsXG4gICAgTUVUSE9EUy5TRUFSQ0gsXG4gICAgTUVUSE9EUy5VTkxPQ0ssXG4gICAgTUVUSE9EUy5CSU5ELFxuICAgIE1FVEhPRFMuUkVCSU5ELFxuICAgIE1FVEhPRFMuVU5CSU5ELFxuICAgIE1FVEhPRFMuQUNMLFxuICAgIE1FVEhPRFMuUkVQT1JULFxuICAgIE1FVEhPRFMuTUtBQ1RJVklUWSxcbiAgICBNRVRIT0RTLkNIRUNLT1VULFxuICAgIE1FVEhPRFMuTUVSR0UsXG4gICAgTUVUSE9EU1snTS1TRUFSQ0gnXSxcbiAgICBNRVRIT0RTLk5PVElGWSxcbiAgICBNRVRIT0RTLlNVQlNDUklCRSxcbiAgICBNRVRIT0RTLlVOU1VCU0NSSUJFLFxuICAgIE1FVEhPRFMuUEFUQ0gsXG4gICAgTUVUSE9EUy5QVVJHRSxcbiAgICBNRVRIT0RTLk1LQ0FMRU5EQVIsXG4gICAgTUVUSE9EUy5MSU5LLFxuICAgIE1FVEhPRFMuVU5MSU5LLFxuICAgIE1FVEhPRFMuUFJJLFxuICAgIC8vIFRPRE8oaW5kdXRueSk6IHNob3VsZCB3ZSBhbGxvdyBpdCB3aXRoIEhUVFA/XG4gICAgTUVUSE9EUy5TT1VSQ0UsXG5dO1xuZXhwb3J0cy5NRVRIT0RTX0lDRSA9IFtcbiAgICBNRVRIT0RTLlNPVVJDRSxcbl07XG5leHBvcnRzLk1FVEhPRFNfUlRTUCA9IFtcbiAgICBNRVRIT0RTLk9QVElPTlMsXG4gICAgTUVUSE9EUy5ERVNDUklCRSxcbiAgICBNRVRIT0RTLkFOTk9VTkNFLFxuICAgIE1FVEhPRFMuU0VUVVAsXG4gICAgTUVUSE9EUy5QTEFZLFxuICAgIE1FVEhPRFMuUEFVU0UsXG4gICAgTUVUSE9EUy5URUFSRE9XTixcbiAgICBNRVRIT0RTLkdFVF9QQVJBTUVURVIsXG4gICAgTUVUSE9EUy5TRVRfUEFSQU1FVEVSLFxuICAgIE1FVEhPRFMuUkVESVJFQ1QsXG4gICAgTUVUSE9EUy5SRUNPUkQsXG4gICAgTUVUSE9EUy5GTFVTSCxcbiAgICAvLyBGb3IgQWlyUGxheVxuICAgIE1FVEhPRFMuR0VULFxuICAgIE1FVEhPRFMuUE9TVCxcbl07XG5leHBvcnRzLk1FVEhPRF9NQVAgPSB1dGlsc18xLmVudW1Ub01hcChNRVRIT0RTKTtcbmV4cG9ydHMuSF9NRVRIT0RfTUFQID0ge307XG5PYmplY3Qua2V5cyhleHBvcnRzLk1FVEhPRF9NQVApLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmICgvXkgvLnRlc3Qoa2V5KSkge1xuICAgICAgICBleHBvcnRzLkhfTUVUSE9EX01BUFtrZXldID0gZXhwb3J0cy5NRVRIT0RfTUFQW2tleV07XG4gICAgfVxufSk7XG52YXIgRklOSVNIO1xuKGZ1bmN0aW9uIChGSU5JU0gpIHtcbiAgICBGSU5JU0hbRklOSVNIW1wiU0FGRVwiXSA9IDBdID0gXCJTQUZFXCI7XG4gICAgRklOSVNIW0ZJTklTSFtcIlNBRkVfV0lUSF9DQlwiXSA9IDFdID0gXCJTQUZFX1dJVEhfQ0JcIjtcbiAgICBGSU5JU0hbRklOSVNIW1wiVU5TQUZFXCJdID0gMl0gPSBcIlVOU0FGRVwiO1xufSkoRklOSVNIID0gZXhwb3J0cy5GSU5JU0ggfHwgKGV4cG9ydHMuRklOSVNIID0ge30pKTtcbmV4cG9ydHMuQUxQSEEgPSBbXTtcbmZvciAobGV0IGkgPSAnQScuY2hhckNvZGVBdCgwKTsgaSA8PSAnWicuY2hhckNvZGVBdCgwKTsgaSsrKSB7XG4gICAgLy8gVXBwZXIgY2FzZVxuICAgIGV4cG9ydHMuQUxQSEEucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGkpKTtcbiAgICAvLyBMb3dlciBjYXNlXG4gICAgZXhwb3J0cy5BTFBIQS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaSArIDB4MjApKTtcbn1cbmV4cG9ydHMuTlVNX01BUCA9IHtcbiAgICAwOiAwLCAxOiAxLCAyOiAyLCAzOiAzLCA0OiA0LFxuICAgIDU6IDUsIDY6IDYsIDc6IDcsIDg6IDgsIDk6IDksXG59O1xuZXhwb3J0cy5IRVhfTUFQID0ge1xuICAgIDA6IDAsIDE6IDEsIDI6IDIsIDM6IDMsIDQ6IDQsXG4gICAgNTogNSwgNjogNiwgNzogNywgODogOCwgOTogOSxcbiAgICBBOiAwWEEsIEI6IDBYQiwgQzogMFhDLCBEOiAwWEQsIEU6IDBYRSwgRjogMFhGLFxuICAgIGE6IDB4YSwgYjogMHhiLCBjOiAweGMsIGQ6IDB4ZCwgZTogMHhlLCBmOiAweGYsXG59O1xuZXhwb3J0cy5OVU0gPSBbXG4gICAgJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLFxuXTtcbmV4cG9ydHMuQUxQSEFOVU0gPSBleHBvcnRzLkFMUEhBLmNvbmNhdChleHBvcnRzLk5VTSk7XG5leHBvcnRzLk1BUksgPSBbJy0nLCAnXycsICcuJywgJyEnLCAnficsICcqJywgJ1xcJycsICcoJywgJyknXTtcbmV4cG9ydHMuVVNFUklORk9fQ0hBUlMgPSBleHBvcnRzLkFMUEhBTlVNXG4gICAgLmNvbmNhdChleHBvcnRzLk1BUkspXG4gICAgLmNvbmNhdChbJyUnLCAnOycsICc6JywgJyYnLCAnPScsICcrJywgJyQnLCAnLCddKTtcbi8vIFRPRE8oaW5kdXRueSk6IHVzZSBSRkNcbmV4cG9ydHMuU1RSSUNUX1VSTF9DSEFSID0gW1xuICAgICchJywgJ1wiJywgJyQnLCAnJScsICcmJywgJ1xcJycsXG4gICAgJygnLCAnKScsICcqJywgJysnLCAnLCcsICctJywgJy4nLCAnLycsXG4gICAgJzonLCAnOycsICc8JywgJz0nLCAnPicsXG4gICAgJ0AnLCAnWycsICdcXFxcJywgJ10nLCAnXicsICdfJyxcbiAgICAnYCcsXG4gICAgJ3snLCAnfCcsICd9JywgJ34nLFxuXS5jb25jYXQoZXhwb3J0cy5BTFBIQU5VTSk7XG5leHBvcnRzLlVSTF9DSEFSID0gZXhwb3J0cy5TVFJJQ1RfVVJMX0NIQVJcbiAgICAuY29uY2F0KFsnXFx0JywgJ1xcZiddKTtcbi8vIEFsbCBjaGFyYWN0ZXJzIHdpdGggMHg4MCBiaXQgc2V0IHRvIDFcbmZvciAobGV0IGkgPSAweDgwOyBpIDw9IDB4ZmY7IGkrKykge1xuICAgIGV4cG9ydHMuVVJMX0NIQVIucHVzaChpKTtcbn1cbmV4cG9ydHMuSEVYID0gZXhwb3J0cy5OVU0uY29uY2F0KFsnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnXSk7XG4vKiBUb2tlbnMgYXMgZGVmaW5lZCBieSByZmMgMjYxNi4gQWxzbyBsb3dlcmNhc2VzIHRoZW0uXG4gKiAgICAgICAgdG9rZW4gICAgICAgPSAxKjxhbnkgQ0hBUiBleGNlcHQgQ1RMcyBvciBzZXBhcmF0b3JzPlxuICogICAgIHNlcGFyYXRvcnMgICAgID0gXCIoXCIgfCBcIilcIiB8IFwiPFwiIHwgXCI+XCIgfCBcIkBcIlxuICogICAgICAgICAgICAgICAgICAgIHwgXCIsXCIgfCBcIjtcIiB8IFwiOlwiIHwgXCJcXFwiIHwgPFwiPlxuICogICAgICAgICAgICAgICAgICAgIHwgXCIvXCIgfCBcIltcIiB8IFwiXVwiIHwgXCI/XCIgfCBcIj1cIlxuICogICAgICAgICAgICAgICAgICAgIHwgXCJ7XCIgfCBcIn1cIiB8IFNQIHwgSFRcbiAqL1xuZXhwb3J0cy5TVFJJQ1RfVE9LRU4gPSBbXG4gICAgJyEnLCAnIycsICckJywgJyUnLCAnJicsICdcXCcnLFxuICAgICcqJywgJysnLCAnLScsICcuJyxcbiAgICAnXicsICdfJywgJ2AnLFxuICAgICd8JywgJ34nLFxuXS5jb25jYXQoZXhwb3J0cy5BTFBIQU5VTSk7XG5leHBvcnRzLlRPS0VOID0gZXhwb3J0cy5TVFJJQ1RfVE9LRU4uY29uY2F0KFsnICddKTtcbi8qXG4gKiBWZXJpZnkgdGhhdCBhIGNoYXIgaXMgYSB2YWxpZCB2aXNpYmxlIChwcmludGFibGUpIFVTLUFTQ0lJXG4gKiBjaGFyYWN0ZXIgb3IgJXg4MC1GRlxuICovXG5leHBvcnRzLkhFQURFUl9DSEFSUyA9IFsnXFx0J107XG5mb3IgKGxldCBpID0gMzI7IGkgPD0gMjU1OyBpKyspIHtcbiAgICBpZiAoaSAhPT0gMTI3KSB7XG4gICAgICAgIGV4cG9ydHMuSEVBREVSX0NIQVJTLnB1c2goaSk7XG4gICAgfVxufVxuLy8gJywnID0gXFx4NDRcbmV4cG9ydHMuQ09OTkVDVElPTl9UT0tFTl9DSEFSUyA9IGV4cG9ydHMuSEVBREVSX0NIQVJTLmZpbHRlcigoYykgPT4gYyAhPT0gNDQpO1xuZXhwb3J0cy5NQUpPUiA9IGV4cG9ydHMuTlVNX01BUDtcbmV4cG9ydHMuTUlOT1IgPSBleHBvcnRzLk1BSk9SO1xudmFyIEhFQURFUl9TVEFURTtcbihmdW5jdGlvbiAoSEVBREVSX1NUQVRFKSB7XG4gICAgSEVBREVSX1NUQVRFW0hFQURFUl9TVEFURVtcIkdFTkVSQUxcIl0gPSAwXSA9IFwiR0VORVJBTFwiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJDT05ORUNUSU9OXCJdID0gMV0gPSBcIkNPTk5FQ1RJT05cIjtcbiAgICBIRUFERVJfU1RBVEVbSEVBREVSX1NUQVRFW1wiQ09OVEVOVF9MRU5HVEhcIl0gPSAyXSA9IFwiQ09OVEVOVF9MRU5HVEhcIjtcbiAgICBIRUFERVJfU1RBVEVbSEVBREVSX1NUQVRFW1wiVFJBTlNGRVJfRU5DT0RJTkdcIl0gPSAzXSA9IFwiVFJBTlNGRVJfRU5DT0RJTkdcIjtcbiAgICBIRUFERVJfU1RBVEVbSEVBREVSX1NUQVRFW1wiVVBHUkFERVwiXSA9IDRdID0gXCJVUEdSQURFXCI7XG4gICAgSEVBREVSX1NUQVRFW0hFQURFUl9TVEFURVtcIkNPTk5FQ1RJT05fS0VFUF9BTElWRVwiXSA9IDVdID0gXCJDT05ORUNUSU9OX0tFRVBfQUxJVkVcIjtcbiAgICBIRUFERVJfU1RBVEVbSEVBREVSX1NUQVRFW1wiQ09OTkVDVElPTl9DTE9TRVwiXSA9IDZdID0gXCJDT05ORUNUSU9OX0NMT1NFXCI7XG4gICAgSEVBREVSX1NUQVRFW0hFQURFUl9TVEFURVtcIkNPTk5FQ1RJT05fVVBHUkFERVwiXSA9IDddID0gXCJDT05ORUNUSU9OX1VQR1JBREVcIjtcbiAgICBIRUFERVJfU1RBVEVbSEVBREVSX1NUQVRFW1wiVFJBTlNGRVJfRU5DT0RJTkdfQ0hVTktFRFwiXSA9IDhdID0gXCJUUkFOU0ZFUl9FTkNPRElOR19DSFVOS0VEXCI7XG59KShIRUFERVJfU1RBVEUgPSBleHBvcnRzLkhFQURFUl9TVEFURSB8fCAoZXhwb3J0cy5IRUFERVJfU1RBVEUgPSB7fSkpO1xuZXhwb3J0cy5TUEVDSUFMX0hFQURFUlMgPSB7XG4gICAgJ2Nvbm5lY3Rpb24nOiBIRUFERVJfU1RBVEUuQ09OTkVDVElPTixcbiAgICAnY29udGVudC1sZW5ndGgnOiBIRUFERVJfU1RBVEUuQ09OVEVOVF9MRU5HVEgsXG4gICAgJ3Byb3h5LWNvbm5lY3Rpb24nOiBIRUFERVJfU1RBVEUuQ09OTkVDVElPTixcbiAgICAndHJhbnNmZXItZW5jb2RpbmcnOiBIRUFERVJfU1RBVEUuVFJBTlNGRVJfRU5DT0RJTkcsXG4gICAgJ3VwZ3JhZGUnOiBIRUFERVJfU1RBVEUuVVBHUkFERSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU1BFQ0lBTF9IRUFERVJTIiwiSEVBREVSX1NUQVRFIiwiTUlOT1IiLCJNQUpPUiIsIkNPTk5FQ1RJT05fVE9LRU5fQ0hBUlMiLCJIRUFERVJfQ0hBUlMiLCJUT0tFTiIsIlNUUklDVF9UT0tFTiIsIkhFWCIsIlVSTF9DSEFSIiwiU1RSSUNUX1VSTF9DSEFSIiwiVVNFUklORk9fQ0hBUlMiLCJNQVJLIiwiQUxQSEFOVU0iLCJOVU0iLCJIRVhfTUFQIiwiTlVNX01BUCIsIkFMUEhBIiwiRklOSVNIIiwiSF9NRVRIT0RfTUFQIiwiTUVUSE9EX01BUCIsIk1FVEhPRFNfUlRTUCIsIk1FVEhPRFNfSUNFIiwiTUVUSE9EU19IVFRQIiwiTUVUSE9EUyIsIkxFTklFTlRfRkxBR1MiLCJGTEFHUyIsIlRZUEUiLCJFUlJPUiIsInV0aWxzXzEiLCJyZXF1aXJlIiwiREVMRVRFIiwiR0VUIiwiSEVBRCIsIlBPU1QiLCJQVVQiLCJDT05ORUNUIiwiT1BUSU9OUyIsIlRSQUNFIiwiQ09QWSIsIkxPQ0siLCJNS0NPTCIsIk1PVkUiLCJQUk9QRklORCIsIlBST1BQQVRDSCIsIlNFQVJDSCIsIlVOTE9DSyIsIkJJTkQiLCJSRUJJTkQiLCJVTkJJTkQiLCJBQ0wiLCJSRVBPUlQiLCJNS0FDVElWSVRZIiwiQ0hFQ0tPVVQiLCJNRVJHRSIsIk5PVElGWSIsIlNVQlNDUklCRSIsIlVOU1VCU0NSSUJFIiwiUEFUQ0giLCJQVVJHRSIsIk1LQ0FMRU5EQVIiLCJMSU5LIiwiVU5MSU5LIiwiUFJJIiwiU09VUkNFIiwiREVTQ1JJQkUiLCJBTk5PVU5DRSIsIlNFVFVQIiwiUExBWSIsIlBBVVNFIiwiVEVBUkRPV04iLCJHRVRfUEFSQU1FVEVSIiwiU0VUX1BBUkFNRVRFUiIsIlJFRElSRUNUIiwiUkVDT1JEIiwiRkxVU0giLCJlbnVtVG9NYXAiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsInRlc3QiLCJpIiwiY2hhckNvZGVBdCIsInB1c2giLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJhIiwiYiIsImMiLCJkIiwiZSIsImYiLCJjb25jYXQiLCJmaWx0ZXIiLCJDT05ORUNUSU9OIiwiQ09OVEVOVF9MRU5HVEgiLCJUUkFOU0ZFUl9FTkNPRElORyIsIlVQR1JBREUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/llhttp/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/llhttp/llhttp-wasm.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/llhttp/llhttp-wasm.js ***!
  \*****************************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = \"AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbGxodHRwL2xsaHR0cC13YXNtLmpzIiwibWFwcGluZ3MiOiI7QUFBQUEsT0FBT0MsT0FBTyxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1maWdodGVyLWFjYWRlbXkvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbGxodHRwL2xsaHR0cC13YXNtLmpzPzUzZjciXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSAnQUdGemJRRUFBQUFCTUFoZ0FYOEJmMkFEZjM5L0FYOWdCSDkvZjM4QmYyQUFBR0FEZjM5L0FHQUJmd0JnQW45L0FHQUdmMzkvZjM5L0FBTExBUWdEWlc1MkdIZGhjMjFmYjI1ZmFHVmhaR1Z5YzE5amIyMXdiR1YwWlFBQ0EyVnVkaFYzWVhOdFgyOXVYMjFsYzNOaFoyVmZZbVZuYVc0QUFBTmxibllMZDJGemJWOXZibDkxY213QUFRTmxibllPZDJGemJWOXZibDl6ZEdGMGRYTUFBUU5sYm5ZVWQyRnpiVjl2Ymw5b1pXRmtaWEpmWm1sbGJHUUFBUU5sYm5ZVWQyRnpiVjl2Ymw5b1pXRmtaWEpmZG1Gc2RXVUFBUU5sYm5ZTWQyRnpiVjl2Ymw5aWIyUjVBQUVEWlc1MkdIZGhjMjFmYjI1ZmJXVnpjMkZuWlY5amIyMXdiR1YwWlFBQUEwWkZBd01FQUFBRkFBQUFBQUFBQlFFRkFBVUZCUUFBQmdBQUFBQUdCZ1lHQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQUFBQkFRY0FBQVVGQXdBQkJBVUJjQUVTRWdVREFRQUNCZ2dCZndGQmdOUUVDd2ZSQlNJR2JXVnRiM0o1QWdBTFgybHVhWFJwWVd4cGVtVUFDUmxmWDJsdVpHbHlaV04wWDJaMWJtTjBhVzl1WDNSaFlteGxBUUFMYkd4b2RIUndYMmx1YVhRQUNoaHNiR2gwZEhCZmMyaHZkV3hrWDJ0bFpYQmZZV3hwZG1VQVFReHNiR2gwZEhCZllXeHNiMk1BREFadFlXeHNiMk1BUmd0c2JHaDBkSEJmWm5KbFpRQU5CR1p5WldVQVNBOXNiR2gwZEhCZloyVjBYM1I1Y0dVQURoVnNiR2gwZEhCZloyVjBYMmgwZEhCZmJXRnFiM0lBRHhWc2JHaDBkSEJmWjJWMFgyaDBkSEJmYldsdWIzSUFFQkZzYkdoMGRIQmZaMlYwWDIxbGRHaHZaQUFSRm14c2FIUjBjRjluWlhSZmMzUmhkSFZ6WDJOdlpHVUFFaEpzYkdoMGRIQmZaMlYwWDNWd1ozSmhaR1VBRXd4c2JHaDBkSEJmY21WelpYUUFGQTVzYkdoMGRIQmZaWGhsWTNWMFpRQVZGR3hzYUhSMGNGOXpaWFIwYVc1bmMxOXBibWwwQUJZTmJHeG9kSFJ3WDJacGJtbHphQUFYREd4c2FIUjBjRjl3WVhWelpRQVlEV3hzYUhSMGNGOXlaWE4xYldVQUdSdHNiR2gwZEhCZmNtVnpkVzFsWDJGbWRHVnlYM1Z3WjNKaFpHVUFHaEJzYkdoMGRIQmZaMlYwWDJWeWNtNXZBQnNYYkd4b2RIUndYMmRsZEY5bGNuSnZjbDl5WldGemIyNEFIQmRzYkdoMGRIQmZjMlYwWDJWeWNtOXlYM0psWVhOdmJnQWRGR3hzYUhSMGNGOW5aWFJmWlhKeWIzSmZjRzl6QUI0UmJHeG9kSFJ3WDJWeWNtNXZYMjVoYldVQUh4SnNiR2gwZEhCZmJXVjBhRzlrWDI1aGJXVUFJQkpzYkdoMGRIQmZjM1JoZEhWelgyNWhiV1VBSVJwc2JHaDBkSEJmYzJWMFgyeGxibWxsYm5SZmFHVmhaR1Z5Y3dBaUlXeHNhSFIwY0Y5elpYUmZiR1Z1YVdWdWRGOWphSFZ1YTJWa1gyeGxibWQwYUFBakhXeHNhSFIwY0Y5elpYUmZiR1Z1YVdWdWRGOXJaV1Z3WDJGc2FYWmxBQ1FrYkd4b2RIUndYM05sZEY5c1pXNXBaVzUwWDNSeVlXNXpabVZ5WDJWdVkyOWthVzVuQUNVWWJHeG9kSFJ3WDIxbGMzTmhaMlZmYm1WbFpITmZaVzltQUQ4SkZ3RUFRUUVMRVFFQ0F3UUZDd1lITlRrM01TOHRKeXNwQ3NMZ0FrVUNBQXNJQUJDSWdJQ0FBQXNaQUNBQUVNS0FnSUFBR2lBQUlBSTJBamdnQUNBQk9nQW9DeHdBSUFBZ0FDOEJNaUFBTFFBdUlBQVF3WUNBZ0FBUWdJQ0FnQUFMS2dFQmYwSEFBQkRHZ0lDQUFDSUJFTUtBZ0lBQUdpQUJRWUNJZ0lBQU5nSTRJQUVnQURvQUtDQUJDd29BSUFBUXlJQ0FnQUFMQndBZ0FDMEFLQXNIQUNBQUxRQXFDd2NBSUFBdEFDc0xCd0FnQUMwQUtRc0hBQ0FBTHdFeUN3Y0FJQUF0QUM0TFJRRUVmeUFBS0FJWUlRRWdBQzBBTFNFQ0lBQXRBQ2doQXlBQUtBSTRJUVFnQUJEQ2dJQ0FBQm9nQUNBRU5nSTRJQUFnQXpvQUtDQUFJQUk2QUMwZ0FDQUJOZ0lZQ3hFQUlBQWdBU0FCSUFKcUVNT0FnSUFBQ3hBQUlBQkJBRUhjQUJETWdJQ0FBQm9MWndFQmYwRUFJUUVDUUNBQUtBSU1EUUFDUUFKQUFrQUNRQ0FBTFFBdkRnTUJBQU1DQ3lBQUtBSTRJZ0ZGRFFBZ0FTZ0NMQ0lCUlEwQUlBQWdBUkdBZ0lDQUFBQWlBUTBEQzBFQUR3c1F5b0NBZ0FBQUN5QUFRY09XZ0lBQU5nSVFRUTRoQVFzZ0FRc2VBQUpBSUFBb0Fnd05BQ0FBUWRHYmdJQUFOZ0lRSUFCQkZUWUNEQXNMRmdBQ1FDQUFLQUlNUVJWSERRQWdBRUVBTmdJTUN3c1dBQUpBSUFBb0FneEJGa2NOQUNBQVFRQTJBZ3dMQ3djQUlBQW9BZ3dMQndBZ0FDZ0NFQXNKQUNBQUlBRTJBaEFMQndBZ0FDZ0NGQXNpQUFKQUlBQkJKRWtOQUJES2dJQ0FBQUFMSUFCQkFuUkJvTE9BZ0FCcUtBSUFDeUlBQWtBZ0FFRXVTUTBBRU1xQWdJQUFBQXNnQUVFQ2RFR3d0SUNBQUdvb0FnQUw3Z3NCQVg5QjY2aUFnQUFoQVFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBQkJuSDlxRHZRRFkySUFBV0ZoWVdGaFlRSURCQVZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaEJnY0lDUW9MREEwT0QyRmhZV0ZoRUdGaFlXRmhZV0ZoWVdGaEVXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlSSVRGQlVXRnhnWkdodGhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhIQjBlSHlBaElpTWtKU1luS0NrcUt5d3RMaTh3TVRJek5EVTJZVGM0T1RwaFlXRmhZV0ZoWVR0aFlXRThZV0ZoWVQwK1AyRmhZV0ZoWVdGaFFHRmhRV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVVKRFJFVkdSMGhKU2t0TVRVNVBVRkZTVTJGaFlXRmhZV0ZoVkZWV1YxaFpXbHRoWEYxaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmVZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhYMkJoQzBIaHA0Q0FBQThMUWFTaGdJQUFEd3RCeTZ5QWdBQVBDMEgrc1lDQUFBOExRY0NrZ0lBQUR3dEJxNlNBZ0FBUEMwR05xSUNBQUE4TFFlS21nSUFBRHd0QmdMQ0FnQUFQQzBHNXI0Q0FBQThMUWRla2dJQUFEd3RCNzUrQWdBQVBDMEhobjRDQUFBOExRZnFmZ0lBQUR3dEI4cUNBZ0FBUEMwR29yNENBQUE4TFFhNnlnSUFBRHd0QmlMQ0FnQUFQQzBIc3A0Q0FBQThMUVlLaWdJQUFEd3RCanAyQWdBQVBDMEhRcm9DQUFBOExRY3FqZ0lBQUR3dEJ4YktBZ0FBUEMwSGZuSUNBQUE4TFFkS2NnSUFBRHd0QnhLQ0FnQUFQQzBIWG9JQ0FBQThMUWFLZmdJQUFEd3RCN2E2QWdBQVBDMEdyc0lDQUFBOExRZFNsZ0lBQUR3dEJ6SzZBZ0FBUEMwSDZyb0NBQUE4TFFmeXJnSUFBRHd0QjByQ0FnQUFQQzBIeG5ZQ0FBQThMUWJ1Z2dJQUFEd3RCOTZ1QWdBQVBDMEdRc1lDQUFBOExRZGV4Z0lBQUR3dEJvcTJBZ0FBUEMwSFVwNENBQUE4TFFlQ3JnSUFBRHd0Qm42eUFnQUFQQzBIcnNZQ0FBQThMUWRXZmdJQUFEd3RCeXJHQWdBQVBDMEhlcFlDQUFBOExRZFNlZ0lBQUR3dEI5SnlBZ0FBUEMwR25zb0NBQUE4TFFiR2RnSUFBRHd0Qm9KMkFnQUFQQzBHNXNZQ0FBQThMUWJ5d2dJQUFEd3RCa3FHQWdBQVBDMEd6cG9DQUFBOExRZW1zZ0lBQUR3dEJySjZBZ0FBUEMwSFVxNENBQUE4TFFmZW1nSUFBRHd0QmdLYUFnQUFQQzBHd29ZQ0FBQThMUWY2ZWdJQUFEd3RCamFPQWdBQVBDMEdKcllDQUFBOExRZmVpZ0lBQUR3dEJvTEdBZ0FBUEMwR3VuNENBQUE4TFFjYWxnSUFBRHd0QjZKNkFnQUFQQzBHVG9vQ0FBQThMUWNLdmdJQUFEd3RCdzUyQWdBQVBDMEdMcklDQUFBOExRZUdkZ0lBQUR3dEJqYStBZ0FBUEMwSHFvWUNBQUE4TFFiU3RnSUFBRHd0QjBxK0FnQUFQQzBIZnNvQ0FBQThMUWRLeWdJQUFEd3RCOExDQWdBQVBDMEdwb29DQUFBOExRZm1qZ0lBQUR3dEJtWjZBZ0FBUEMwRzFySUNBQUE4TFFadXdnSUFBRHd0QmtyS0FnQUFQQzBHMnE0Q0FBQThMUWNLaWdJQUFEd3RCK0xLQWdBQVBDMEdlcFlDQUFBOExRZENpZ0lBQUR3dEJ1cDZBZ0FBUEMwR0Jub0NBQUE4TEVNcUFnSUFBQUF0QjFxR0FnQUFoQVFzZ0FRc1dBQ0FBSUFBdEFDMUIvZ0Z4SUFGQkFFZHlPZ0F0Q3hrQUlBQWdBQzBBTFVIOUFYRWdBVUVBUjBFQmRISTZBQzBMR1FBZ0FDQUFMUUF0UWZzQmNTQUJRUUJIUVFKMGNqb0FMUXNaQUNBQUlBQXRBQzFCOXdGeElBRkJBRWRCQTNSeU9nQXRDeTRCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FnQWlCRVVOQUNBQUlBUVJnSUNBZ0FBQUlRTUxJQU1MU1FFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NCQ0lFUlEwQUlBQWdBU0FDSUFGcklBUVJnWUNBZ0FBQUlnTkJmMGNOQUNBQVFjYVJnSUFBTmdJUVFSZ2hBd3NnQXdzdUFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUl3SWdSRkRRQWdBQ0FFRVlDQWdJQUFBQ0VEQ3lBREMwa0JBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWdnaUJFVU5BQ0FBSUFFZ0FpQUJheUFFRVlHQWdJQUFBQ0lEUVg5SERRQWdBRUgyaW9DQUFEWUNFRUVZSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ05DSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3RKQVFKL1FRQWhBd0pBSUFBb0FqZ2lCRVVOQUNBRUtBSU1JZ1JGRFFBZ0FDQUJJQUlnQVdzZ0JCR0JnSUNBQUFBaUEwRi9SdzBBSUFCQjdacUFnQUEyQWhCQkdDRURDeUFEQ3k0QkFuOUJBQ0VEQWtBZ0FDZ0NPQ0lFUlEwQUlBUW9BamdpQkVVTkFDQUFJQVFSZ0lDQWdBQUFJUU1MSUFNTFNRRUNmMEVBSVFNQ1FDQUFLQUk0SWdSRkRRQWdCQ2dDRUNJRVJRMEFJQUFnQVNBQ0lBRnJJQVFSZ1lDQWdBQUFJZ05CZjBjTkFDQUFRWldRZ0lBQU5nSVFRUmdoQXdzZ0F3c3VBUUovUVFBaEF3SkFJQUFvQWpnaUJFVU5BQ0FFS0FJOElnUkZEUUFnQUNBRUVZQ0FnSUFBQUNFREN5QURDMGtCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FoUWlCRVVOQUNBQUlBRWdBaUFCYXlBRUVZR0FnSUFBQUNJRFFYOUhEUUFnQUVHcW00Q0FBRFlDRUVFWUlRTUxJQU1MTGdFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NRQ0lFUlEwQUlBQWdCQkdBZ0lDQUFBQWhBd3NnQXd0SkFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUlZSWdSRkRRQWdBQ0FCSUFJZ0FXc2dCQkdCZ0lDQUFBQWlBMEYvUncwQUlBQkI3Wk9BZ0FBMkFoQkJHQ0VEQ3lBREN5NEJBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWtRaUJFVU5BQ0FBSUFRUmdJQ0FnQUFBSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ0pDSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3N1QVFKL1FRQWhBd0pBSUFBb0FqZ2lCRVVOQUNBRUtBSXNJZ1JGRFFBZ0FDQUVFWUNBZ0lBQUFDRURDeUFEQzBrQkFuOUJBQ0VEQWtBZ0FDZ0NPQ0lFUlEwQUlBUW9BaWdpQkVVTkFDQUFJQUVnQWlBQmF5QUVFWUdBZ0lBQUFDSURRWDlIRFFBZ0FFSDJpSUNBQURZQ0VFRVlJUU1MSUFNTExnRUNmMEVBSVFNQ1FDQUFLQUk0SWdSRkRRQWdCQ2dDVUNJRVJRMEFJQUFnQkJHQWdJQ0FBQUFoQXdzZ0F3dEpBUUovUVFBaEF3SkFJQUFvQWpnaUJFVU5BQ0FFS0FJY0lnUkZEUUFnQUNBQklBSWdBV3NnQkJHQmdJQ0FBQUFpQTBGL1J3MEFJQUJCd3BtQWdBQTJBaEJCR0NFREN5QURDeTRCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FrZ2lCRVVOQUNBQUlBUVJnSUNBZ0FBQUlRTUxJQU1MU1FFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NJQ0lFUlEwQUlBQWdBU0FDSUFGcklBUVJnWUNBZ0FBQUlnTkJmMGNOQUNBQVFaU1VnSUFBTmdJUVFSZ2hBd3NnQXdzdUFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUpNSWdSRkRRQWdBQ0FFRVlDQWdJQUFBQ0VEQ3lBREN5NEJBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWxRaUJFVU5BQ0FBSUFRUmdJQ0FnQUFBSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ1dDSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3RGQVFGL0FrQUNRQ0FBTHdFd1FSUnhRUlJIRFFCQkFTRURJQUF0QUNoQkFVWU5BU0FBTHdFeVFlVUFSaUVEREFFTElBQXRBQ2xCQlVZaEF3c2dBQ0FET2dBdVFRQUwvZ0VCQTM5QkFTRURBa0FnQUM4Qk1DSUVRUWh4RFFBZ0FDa0RJRUlBVWlFREN3SkFBa0FnQUMwQUxrVU5BRUVCSVFVZ0FDMEFLVUVGUmcwQlFRRWhCU0FFUWNBQWNVVWdBM0ZCQVVjTkFRdEJBQ0VGSUFSQndBQnhEUUJCQWlFRklBUkIvLzhEY1NJRFFRaHhEUUFDUUNBRFFZQUVjVVVOQUFKQUlBQXRBQ2hCQVVjTkFDQUFMUUF0UVFweERRQkJCUThMUVFRUEN3SkFJQU5CSUhFTkFBSkFJQUF0QUNoQkFVWU5BQ0FBTHdFeVFmLy9BM0VpQUVHY2YycEI1QUJKRFFBZ0FFSE1BVVlOQUNBQVFiQUNSZzBBUVFRaEJTQUVRU2h4UlEwQ0lBTkJpQVJ4UVlBRVJnMENDMEVBRHd0QkFFRURJQUFwQXlCUUd5RUZDeUFGQzJJQkFuOUJBQ0VCQWtBZ0FDMEFLRUVCUmcwQUlBQXZBVEpCLy84RGNTSUNRWngvYWtIa0FFa05BQ0FDUWN3QlJnMEFJQUpCc0FKR0RRQWdBQzhCTUNJQVFjQUFjUTBBUVFFaEFTQUFRWWdFY1VHQUJFWU5BQ0FBUVNoeFJTRUJDeUFCQzZjQkFRTi9Ba0FDUUFKQUlBQXRBQ3BGRFFBZ0FDMEFLMFVOQUVFQUlRTWdBQzhCTUNJRVFRSnhSUTBCREFJTFFRQWhBeUFBTHdFd0lnUkJBWEZGRFFFTFFRRWhBeUFBTFFBb1FRRkdEUUFnQUM4Qk1rSC8vd054SWdWQm5IOXFRZVFBU1EwQUlBVkJ6QUZHRFFBZ0JVR3dBa1lOQUNBRVFjQUFjUTBBUVFBaEF5QUVRWWdFY1VHQUJFWU5BQ0FFUVNoeFFRQkhJUU1MSUFCQkFEc0JNQ0FBUVFBNkFDOGdBd3VaQVFFQ2Z3SkFBa0FDUUNBQUxRQXFSUTBBSUFBdEFDdEZEUUJCQUNFQklBQXZBVEFpQWtFQ2NVVU5BUXdDQzBFQUlRRWdBQzhCTUNJQ1FRRnhSUTBCQzBFQklRRWdBQzBBS0VFQlJnMEFJQUF2QVRKQi8vOERjU0lBUVp4L2FrSGtBRWtOQUNBQVFjd0JSZzBBSUFCQnNBSkdEUUFnQWtIQUFIRU5BRUVBSVFFZ0FrR0lCSEZCZ0FSR0RRQWdBa0VvY1VFQVJ5RUJDeUFCQzFrQUlBQkJHR3BDQURjREFDQUFRZ0EzQXdBZ0FFRTRha0lBTndNQUlBQkJNR3BDQURjREFDQUFRU2hxUWdBM0F3QWdBRUVnYWtJQU53TUFJQUJCRUdwQ0FEY0RBQ0FBUVFocVFnQTNBd0FnQUVIZEFUWUNIRUVBQzNzQkFYOENRQ0FBS0FJTUlnTU5BQUpBSUFBb0FnUkZEUUFnQUNBQk5nSUVDd0pBSUFBZ0FTQUNFTVNBZ0lBQUlnTU5BQ0FBS0FJTUR3c2dBQ0FETmdJY1FRQWhBeUFBS0FJRUlnRkZEUUFnQUNBQklBSWdBQ2dDQ0JHQmdJQ0FBQUFpQVVVTkFDQUFJQUkyQWhRZ0FDQUJOZ0lNSUFFaEF3c2dBd3ZrOHdFRERuOERmZ1IvSTRDQWdJQUFRUkJySWdNa2dJQ0FnQUFnQVNFRUlBRWhCU0FCSVFZZ0FTRUhJQUVoQ0NBQklRa2dBU0VLSUFFaEN5QUJJUXdnQVNFTklBRWhEaUFCSVE4Q1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FDZ0NIQ0lRUVg5cUR0MEIyZ0VCMlFFQ0F3UUZCZ2NJQ1FvTERBME8yQUVQRU5jQkVSTFdBUk1VRlJZWEdCa2FHK0FCM3dFY0hSN1ZBUjhnSVNJakpDWFVBU1luS0NrcUt5elRBZElCTFM3UkFkQUJMekF4TWpNME5UWTNPRGs2T3p3OVBqOUFRVUpEUkVWRzJ3RkhTRWxLendIT0FVdk5BVXpNQVUxT1QxQlJVbE5VVlZaWFdGbGFXMXhkWGw5Z1lXSmpaR1ZtWjJocGFtdHNiVzV2Y0hGeWMzUjFkbmQ0ZVhwN2ZIMStmNEFCZ1FHQ0FZTUJoQUdGQVlZQmh3R0lBWWtCaWdHTEFZd0JqUUdPQVk4QmtBR1JBWklCa3dHVUFaVUJsZ0dYQVpnQm1RR2FBWnNCbkFHZEFaNEJud0dnQWFFQm9nR2pBYVFCcFFHbUFhY0JxQUdwQWFvQnF3R3NBYTBCcmdHdkFiQUJzUUd5QWJNQnRBRzFBYllCdHdITEFjb0J1QUhKQWJrQnlBRzZBYnNCdkFHOUFiNEJ2d0hBQWNFQndnSERBY1FCeFFIR0FRRGNBUXRCQUNFUURNWUJDMEVPSVJBTXhRRUxRUTBoRUF6RUFRdEJEeUVRRE1NQkMwRVFJUkFNd2dFTFFSTWhFQXpCQVF0QkZDRVFETUFCQzBFVklSQU12d0VMUVJZaEVBeStBUXRCRnlFUURMMEJDMEVZSVJBTXZBRUxRUmtoRUF5N0FRdEJHaUVRRExvQkMwRWJJUkFNdVFFTFFSd2hFQXk0QVF0QkNDRVFETGNCQzBFZElSQU10Z0VMUVNBaEVBeTFBUXRCSHlFUURMUUJDMEVISVJBTXN3RUxRU0VoRUF5eUFRdEJJaUVRRExFQkMwRWVJUkFNc0FFTFFTTWhFQXl2QVF0QkVpRVFESzRCQzBFUklSQU1yUUVMUVNRaEVBeXNBUXRCSlNFUURLc0JDMEVtSVJBTXFnRUxRU2NoRUF5cEFRdEJ3d0VoRUF5b0FRdEJLU0VRREtjQkMwRXJJUkFNcGdFTFFTd2hFQXlsQVF0QkxTRVFES1FCQzBFdUlSQU1vd0VMUVM4aEVBeWlBUXRCeEFFaEVBeWhBUXRCTUNFUURLQUJDMEUwSVJBTW53RUxRUXdoRUF5ZUFRdEJNU0VRREowQkMwRXlJUkFNbkFFTFFUTWhFQXliQVF0Qk9TRVFESm9CQzBFMUlSQU1tUUVMUWNVQklSQU1tQUVMUVFzaEVBeVhBUXRCT2lFUURKWUJDMEUySVJBTWxRRUxRUW9oRUF5VUFRdEJOeUVRREpNQkMwRTRJUkFNa2dFTFFUd2hFQXlSQVF0Qk95RVFESkFCQzBFOUlSQU1qd0VMUVFraEVBeU9BUXRCS0NFUURJMEJDMEUrSVJBTWpBRUxRVDhoRUF5TEFRdEJ3QUFoRUF5S0FRdEJ3UUFoRUF5SkFRdEJ3Z0FoRUF5SUFRdEJ3d0FoRUF5SEFRdEJ4QUFoRUF5R0FRdEJ4UUFoRUF5RkFRdEJ4Z0FoRUF5RUFRdEJLaUVRRElNQkMwSEhBQ0VRRElJQkMwSElBQ0VRRElFQkMwSEpBQ0VRRElBQkMwSEtBQ0VRREg4TFFjc0FJUkFNZmd0QnpRQWhFQXg5QzBITUFDRVFESHdMUWM0QUlSQU1ld3RCendBaEVBeDZDMEhRQUNFUURIa0xRZEVBSVJBTWVBdEIwZ0FoRUF4M0MwSFRBQ0VRREhZTFFkUUFJUkFNZFF0QjFnQWhFQXgwQzBIVkFDRVFESE1MUVFZaEVBeHlDMEhYQUNFUURIRUxRUVVoRUF4d0MwSFlBQ0VRREc4TFFRUWhFQXh1QzBIWkFDRVFERzBMUWRvQUlSQU1iQXRCMndBaEVBeHJDMEhjQUNFUURHb0xRUU1oRUF4cEMwSGRBQ0VRREdnTFFkNEFJUkFNWnd0QjN3QWhFQXhtQzBIaEFDRVFER1VMUWVBQUlSQU1aQXRCNGdBaEVBeGpDMEhqQUNFUURHSUxRUUloRUF4aEMwSGtBQ0VRREdBTFFlVUFJUkFNWHd0QjVnQWhFQXhlQzBIbkFDRVFERjBMUWVnQUlSQU1YQXRCNlFBaEVBeGJDMEhxQUNFUURGb0xRZXNBSVJBTVdRdEI3QUFoRUF4WUMwSHRBQ0VRREZjTFFlNEFJUkFNVmd0Qjd3QWhFQXhWQzBId0FDRVFERlFMUWZFQUlSQU1Vd3RCOGdBaEVBeFNDMEh6QUNFUURGRUxRZlFBSVJBTVVBdEI5UUFoRUF4UEMwSDJBQ0VRREU0TFFmY0FJUkFNVFF0QitBQWhFQXhNQzBINUFDRVFERXNMUWZvQUlSQU1TZ3RCK3dBaEVBeEpDMEg4QUNFUURFZ0xRZjBBSVJBTVJ3dEIvZ0FoRUF4R0MwSC9BQ0VRREVVTFFZQUJJUkFNUkF0QmdRRWhFQXhEQzBHQ0FTRVFERUlMUVlNQklSQU1RUXRCaEFFaEVBeEFDMEdGQVNFUUREOExRWVlCSVJBTVBndEJod0VoRUF3OUMwR0lBU0VRRER3TFFZa0JJUkFNT3d0QmlnRWhFQXc2QzBHTEFTRVFERGtMUVl3QklSQU1PQXRCalFFaEVBdzNDMEdPQVNFUUREWUxRWThCSVJBTU5RdEJrQUVoRUF3MEMwR1JBU0VRRERNTFFaSUJJUkFNTWd0Qmt3RWhFQXd4QzBHVUFTRVFEREFMUVpVQklSQU1Md3RCbGdFaEVBd3VDMEdYQVNFUURDMExRWmdCSVJBTUxBdEJtUUVoRUF3ckMwR2FBU0VRRENvTFFac0JJUkFNS1F0Qm5BRWhFQXdvQzBHZEFTRVFEQ2NMUVo0QklSQU1KZ3RCbndFaEVBd2xDMEdnQVNFUURDUUxRYUVCSVJBTUl3dEJvZ0VoRUF3aUMwR2pBU0VRRENFTFFhUUJJUkFNSUF0QnBRRWhFQXdmQzBHbUFTRVFEQjRMUWFjQklSQU1IUXRCcUFFaEVBd2NDMEdwQVNFUURCc0xRYW9CSVJBTUdndEJxd0VoRUF3WkMwR3NBU0VRREJnTFFhMEJJUkFNRnd0QnJnRWhFQXdXQzBFQklSQU1GUXRCcndFaEVBd1VDMEd3QVNFUURCTUxRYkVCSVJBTUVndEJzd0VoRUF3UkMwR3lBU0VRREJBTFFiUUJJUkFNRHd0QnRRRWhFQXdPQzBHMkFTRVFEQTBMUWJjQklSQU1EQXRCdUFFaEVBd0xDMEc1QVNFUURBb0xRYm9CSVJBTUNRdEJ1d0VoRUF3SUMwSEdBU0VRREFjTFFid0JJUkFNQmd0QnZRRWhFQXdGQzBHK0FTRVFEQVFMUWI4QklSQU1Bd3RCd0FFaEVBd0NDMEhDQVNFUURBRUxRY0VCSVJBTEEwQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FRRHNjQkFBRUNBd1FGQmdjSUNRb0xEQTBPRHhBUkVoTVVGUllYR0JrYUd4d2VIeUFoSXlVb1AwQkJSRVZHUjBoSlNrdE1UVTlRVVZKVDNnTlhXVnRjWFdCaVpXWm5hR2xxYTJ4dGIzQnhjbk4wZFhaM2VIbDZlM3g5Zm9BQmdnR0ZBWVlCaHdHSkFZc0JqQUdOQVk0Qmp3R1FBWkVCbEFHVkFaWUJsd0dZQVprQm1nR2JBWndCblFHZUFaOEJvQUdoQWFJQm93R2tBYVVCcGdHbkFhZ0JxUUdxQWFzQnJBR3RBYTRCcndHd0FiRUJzZ0d6QWJRQnRRRzJBYmNCdUFHNUFib0J1d0c4QWIwQnZnRy9BY0FCd1FIQ0FjTUJ4QUhGQWNZQnh3SElBY2tCeWdITEFjd0J6UUhPQWM4QjBBSFJBZElCMHdIVUFkVUIxZ0hYQWRnQjJRSGFBZHNCM0FIZEFkNEI0QUhoQWVJQjR3SGtBZVVCNWdIbkFlZ0I2UUhxQWVzQjdBSHRBZTRCN3dId0FmRUI4Z0h6QVprQ3BBS3dBdjRDL2dJTElBRWlCQ0FDUnczekFVSGRBU0VRRFA4REN5QUJJaEFnQWtjTjNRRkJ3d0VoRUF6K0F3c2dBU0lCSUFKSERaQUJRZmNBSVJBTS9RTUxJQUVpQVNBQ1J3MkdBVUh2QUNFUURQd0RDeUFCSWdFZ0FrY05mMEhxQUNFUURQc0RDeUFCSWdFZ0FrY05lMEhvQUNFUURQb0RDeUFCSWdFZ0FrY05lRUhtQUNFUURQa0RDeUFCSWdFZ0FrY05Ha0VZSVJBTStBTUxJQUVpQVNBQ1J3MFVRUkloRUF6M0F3c2dBU0lCSUFKSERWbEJ4UUFoRUF6MkF3c2dBU0lCSUFKSERVcEJQeUVRRFBVREN5QUJJZ0VnQWtjTlNFRThJUkFNOUFNTElBRWlBU0FDUncxQlFURWhFQXp6QXdzZ0FDMEFMa0VCUmczckF3eUhBZ3NnQUNBQklnRWdBaERBZ0lDQUFFRUJSdzNtQVNBQVFnQTNBeUFNNXdFTElBQWdBU0lCSUFJUXRJQ0FnQUFpRUEzbkFTQUJJUUVNOVFJTEFrQWdBU0lCSUFKSERRQkJCaUVRRFBBREN5QUFJQUZCQVdvaUFTQUNFTHVBZ0lBQUloQU42QUVnQVNFQkRERUxJQUJDQURjRElFRVNJUkFNMVFNTElBRWlFQ0FDUncwclFSMGhFQXp0QXdzQ1FDQUJJZ0VnQWtZTkFDQUJRUUZxSVFGQkVDRVFETlFEQzBFSElSQU03QU1MSUFCQ0FDQUFLUU1nSWhFZ0FpQUJJaEJyclNJU2ZTSVRJQk1nRVZZYk53TWdJQkVnRWxZaUZFVU41UUZCQ0NFUURPc0RDd0pBSUFFaUFTQUNSZzBBSUFCQmlZQ0FnQUEyQWdnZ0FDQUJOZ0lFSUFFaEFVRVVJUkFNMGdNTFFRa2hFQXpxQXdzZ0FTRUJJQUFwQXlCUURlUUJJQUVoQVF6eUFnc0NRQ0FCSWdFZ0FrY05BRUVMSVJBTTZRTUxJQUFnQVVFQmFpSUJJQUlRdG9DQWdBQWlFQTNsQVNBQklRRU04Z0lMSUFBZ0FTSUJJQUlRdUlDQWdBQWlFQTNsQVNBQklRRU04Z0lMSUFBZ0FTSUJJQUlRdUlDQWdBQWlFQTNtQVNBQklRRU1EUXNnQUNBQklnRWdBaEM2Z0lDQUFDSVFEZWNCSUFFaEFRendBZ3NDUUNBQklnRWdBa2NOQUVFUElSQU01UU1MSUFFdEFBQWlFRUU3UmcwSUlCQkJEVWNONkFFZ0FVRUJhaUVCRE84Q0N5QUFJQUVpQVNBQ0VMcUFnSUFBSWhBTjZBRWdBU0VCRFBJQ0N3TkFBa0FnQVMwQUFFSHd0WUNBQUdvdEFBQWlFRUVCUmcwQUlCQkJBa2NONndFZ0FDZ0NCQ0VRSUFCQkFEWUNCQ0FBSUJBZ0FVRUJhaUlCRUxtQWdJQUFJaEFONmdFZ0FTRUJEUFFDQ3lBQlFRRnFJZ0VnQWtjTkFBdEJFaUVRRE9JREN5QUFJQUVpQVNBQ0VMcUFnSUFBSWhBTjZRRWdBU0VCREFvTElBRWlBU0FDUncwR1FSc2hFQXpnQXdzQ1FDQUJJZ0VnQWtjTkFFRVdJUkFNNEFNTElBQkJpb0NBZ0FBMkFnZ2dBQ0FCTmdJRUlBQWdBU0FDRUxpQWdJQUFJaEFONmdFZ0FTRUJRU0FoRUF6R0F3c0NRQ0FCSWdFZ0FrWU5BQU5BQWtBZ0FTMEFBRUh3dDRDQUFHb3RBQUFpRUVFQ1JnMEFBa0FnRUVGL2FnNEU1UUhzQVFEckFld0JDeUFCUVFGcUlRRkJDQ0VRRE1nREN5QUJRUUZxSWdFZ0FrY05BQXRCRlNFUUROOERDMEVWSVJBTTNnTUxBMEFDUUNBQkxRQUFRZkM1Z0lBQWFpMEFBQ0lRUVFKR0RRQWdFRUYvYWc0RTNnSHNBZUFCNndIc0FRc2dBVUVCYWlJQklBSkhEUUFMUVJnaEVBemRBd3NDUUNBQklnRWdBa1lOQUNBQVFZdUFnSUFBTmdJSUlBQWdBVFlDQkNBQklRRkJCeUVRRE1RREMwRVpJUkFNM0FNTElBRkJBV29oQVF3Q0N3SkFJQUVpRkNBQ1J3MEFRUm9oRUF6YkF3c2dGQ0VCQWtBZ0ZDMEFBRUZ6YWc0VTNRTHVBdTRDN2dMdUF1NEM3Z0x1QXU0QzdnTHVBdTRDN2dMdUF1NEM3Z0x1QXU0QzdnSUE3Z0lMUVFBaEVDQUFRUUEyQWh3Z0FFR3ZpNENBQURZQ0VDQUFRUUkyQWd3Z0FDQVVRUUZxTmdJVUROb0RDd0pBSUFFdEFBQWlFRUU3UmcwQUlCQkJEVWNONkFFZ0FVRUJhaUVCRE9VQ0N5QUJRUUZxSVFFTFFTSWhFQXkvQXdzQ1FDQUJJaEFnQWtjTkFFRWNJUkFNMkFNTFFnQWhFU0FRSVFFZ0VDMEFBRUZRYWc0MzV3SG1BUUVDQXdRRkJnY0lBQUFBQUFBQUFBa0tDd3dORGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRHhBUkVoTVVBQXRCSGlFUURMMERDMElDSVJFTTVRRUxRZ01oRVF6a0FRdENCQ0VSRE9NQkMwSUZJUkVNNGdFTFFnWWhFUXpoQVF0Q0J5RVJET0FCQzBJSUlSRU0zd0VMUWdraEVRemVBUXRDQ2lFUkROMEJDMElMSVJFTTNBRUxRZ3doRVF6YkFRdENEU0VSRE5vQkMwSU9JUkVNMlFFTFFnOGhFUXpZQVF0Q0NpRVJETmNCQzBJTElSRU0xZ0VMUWd3aEVRelZBUXRDRFNFUkROUUJDMElPSVJFTTB3RUxRZzhoRVF6U0FRdENBQ0VSQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQVFMUUFBUVZCcURqZmxBZVFCQUFFQ0F3UUZCZ2ZtQWVZQjVnSG1BZVlCNWdIbUFRZ0pDZ3NNRGVZQjVnSG1BZVlCNWdIbUFlWUI1Z0htQWVZQjVnSG1BZVlCNWdIbUFlWUI1Z0htQWVZQjVnSG1BZVlCNWdIbUFlWUI1Z0VPRHhBUkVoUG1BUXRDQWlFUkRPUUJDMElESVJFTTR3RUxRZ1FoRVF6aUFRdENCU0VSRE9FQkMwSUdJUkVNNEFFTFFnY2hFUXpmQVF0Q0NDRVJETjRCQzBJSklSRU0zUUVMUWdvaEVRemNBUXRDQ3lFUkROc0JDMElNSVJFTTJnRUxRZzBoRVF6WkFRdENEaUVSRE5nQkMwSVBJUkVNMXdFTFFnb2hFUXpXQVF0Q0N5RVJETlVCQzBJTUlSRU0xQUVMUWcwaEVRelRBUXRDRGlFUkROSUJDMElQSVJFTTBRRUxJQUJDQUNBQUtRTWdJaEVnQWlBQkloQnJyU0lTZlNJVElCTWdFVlliTndNZ0lCRWdFbFlpRkVVTjBnRkJIeUVRRE1BREN3SkFJQUVpQVNBQ1JnMEFJQUJCaVlDQWdBQTJBZ2dnQUNBQk5nSUVJQUVoQVVFa0lSQU1wd01MUVNBaEVBeS9Bd3NnQUNBQkloQWdBaEMrZ0lDQUFFRi9hZzRGdGdFQXhRSUIwUUhTQVF0QkVTRVFES1FEQ3lBQVFRRTZBQzhnRUNFQkRMc0RDeUFCSWdFZ0FrY04wZ0ZCSkNFUURMc0RDeUFCSWcwZ0FrY05Ia0hHQUNFUURMb0RDeUFBSUFFaUFTQUNFTEtBZ0lBQUloQU4xQUVnQVNFQkRMVUJDeUFCSWhBZ0FrY05Ka0hRQUNFUURMZ0RDd0pBSUFFaUFTQUNSdzBBUVNnaEVBeTRBd3NnQUVFQU5nSUVJQUJCaklDQWdBQTJBZ2dnQUNBQklBRVFzWUNBZ0FBaUVBM1RBU0FCSVFFTTJBRUxBa0FnQVNJUUlBSkhEUUJCS1NFUURMY0RDeUFRTFFBQUlnRkJJRVlORkNBQlFRbEhEZE1CSUJCQkFXb2hBUXdWQ3dKQUlBRWlBU0FDUmcwQUlBRkJBV29oQVF3WEMwRXFJUkFNdFFNTEFrQWdBU0lRSUFKSERRQkJLeUVRRExVREN3SkFJQkF0QUFBaUFVRUpSZzBBSUFGQklFY04xUUVMSUFBdEFDeEJDRVlOMHdFZ0VDRUJESkVEQ3dKQUlBRWlBU0FDUncwQVFTd2hFQXkwQXdzZ0FTMEFBRUVLUnczVkFTQUJRUUZxSVFFTXlRSUxJQUVpRGlBQ1J3M1ZBVUV2SVJBTXNnTUxBMEFDUUNBQkxRQUFJaEJCSUVZTkFBSkFJQkJCZG1vT0JBRGNBZHdCQU5vQkN5QUJJUUVNNEFFTElBRkJBV29pQVNBQ1J3MEFDMEV4SVJBTXNRTUxRVEloRUNBQkloUWdBa1lOc0FNZ0FpQVVheUFBS0FJQUlnRnFJUlVnRkNBQmEwRURhaUVXQWtBRFFDQVVMUUFBSWhkQklISWdGeUFYUWI5L2FrSC9BWEZCR2trYlFmOEJjU0FCUWZDN2dJQUFhaTBBQUVjTkFRSkFJQUZCQTBjTkFFRUdJUUVNbGdNTElBRkJBV29oQVNBVVFRRnFJaFFnQWtjTkFBc2dBQ0FWTmdJQURMRURDeUFBUVFBMkFnQWdGQ0VCRE5rQkMwRXpJUkFnQVNJVUlBSkdEYThESUFJZ0ZHc2dBQ2dDQUNJQmFpRVZJQlFnQVd0QkNHb2hGZ0pBQTBBZ0ZDMEFBQ0lYUVNCeUlCY2dGMEcvZjJwQi93RnhRUnBKRzBIL0FYRWdBVUgwdTRDQUFHb3RBQUJIRFFFQ1FDQUJRUWhIRFFCQkJTRUJESlVEQ3lBQlFRRnFJUUVnRkVFQmFpSVVJQUpIRFFBTElBQWdGVFlDQUF5d0F3c2dBRUVBTmdJQUlCUWhBUXpZQVF0Qk5DRVFJQUVpRkNBQ1JnMnVBeUFDSUJScklBQW9BZ0FpQVdvaEZTQVVJQUZyUVFWcUlSWUNRQU5BSUJRdEFBQWlGMEVnY2lBWElCZEJ2MzlxUWY4QmNVRWFTUnRCL3dGeElBRkIwTUtBZ0FCcUxRQUFSdzBCQWtBZ0FVRUZSdzBBUVFjaEFReVVBd3NnQVVFQmFpRUJJQlJCQVdvaUZDQUNSdzBBQ3lBQUlCVTJBZ0FNcndNTElBQkJBRFlDQUNBVUlRRU0xd0VMQWtBZ0FTSUJJQUpHRFFBRFFBSkFJQUV0QUFCQmdMNkFnQUJxTFFBQUloQkJBVVlOQUNBUVFRSkdEUW9nQVNFQkROMEJDeUFCUVFGcUlnRWdBa2NOQUF0Qk1DRVFESzREQzBFd0lSQU1yUU1MQWtBZ0FTSUJJQUpHRFFBRFFBSkFJQUV0QUFBaUVFRWdSZzBBSUJCQmRtb09CTmtCMmdIYUFka0IyZ0VMSUFGQkFXb2lBU0FDUncwQUMwRTRJUkFNclFNTFFUZ2hFQXlzQXdzRFFBSkFJQUV0QUFBaUVFRWdSZzBBSUJCQkNVY05Bd3NnQVVFQmFpSUJJQUpIRFFBTFFUd2hFQXlyQXdzRFFBSkFJQUV0QUFBaUVFRWdSZzBBQWtBQ1FDQVFRWFpxRGdUYUFRRUIyZ0VBQ3lBUVFTeEdEZHNCQ3lBQklRRU1CQXNnQVVFQmFpSUJJQUpIRFFBTFFUOGhFQXlxQXdzZ0FTRUJETnNCQzBIQUFDRVFJQUVpRkNBQ1JnMm9BeUFDSUJScklBQW9BZ0FpQVdvaEZpQVVJQUZyUVFacUlSY0NRQU5BSUJRdEFBQkJJSElnQVVHQXdJQ0FBR290QUFCSERRRWdBVUVHUmcyT0F5QUJRUUZxSVFFZ0ZFRUJhaUlVSUFKSERRQUxJQUFnRmpZQ0FBeXBBd3NnQUVFQU5nSUFJQlFoQVF0Qk5pRVFESTREQ3dKQUlBRWlEeUFDUncwQVFjRUFJUkFNcHdNTElBQkJqSUNBZ0FBMkFnZ2dBQ0FQTmdJRUlBOGhBU0FBTFFBc1FYOXFEZ1ROQWRVQjF3SFpBWWNEQ3lBQlFRRnFJUUVNekFFTEFrQWdBU0lCSUFKR0RRQURRQUpBSUFFdEFBQWlFRUVnY2lBUUlCQkJ2MzlxUWY4QmNVRWFTUnRCL3dGeEloQkJDVVlOQUNBUVFTQkdEUUFDUUFKQUFrQUNRQ0FRUVoxL2FnNFRBQU1EQXdNREF3TUJBd01EQXdNREF3TURBZ01MSUFGQkFXb2hBVUV4SVJBTWtRTUxJQUZCQVdvaEFVRXlJUkFNa0FNTElBRkJBV29oQVVFeklSQU1qd01MSUFFaEFRelFBUXNnQVVFQmFpSUJJQUpIRFFBTFFUVWhFQXlsQXd0Qk5TRVFES1FEQ3dKQUlBRWlBU0FDUmcwQUEwQUNRQ0FCTFFBQVFZQzhnSUFBYWkwQUFFRUJSZzBBSUFFaEFRelRBUXNnQVVFQmFpSUJJQUpIRFFBTFFUMGhFQXlrQXd0QlBTRVFES01EQ3lBQUlBRWlBU0FDRUxDQWdJQUFJaEFOMWdFZ0FTRUJEQUVMSUJCQkFXb2hBUXRCUENFUURJY0RDd0pBSUFFaUFTQUNSdzBBUWNJQUlSQU1vQU1MQWtBRFFBSkFJQUV0QUFCQmQyb09HQUFDL2dMK0FvUUQvZ0wrQXY0Qy9nTCtBdjRDL2dMK0F2NEMvZ0wrQXY0Qy9nTCtBdjRDL2dMK0F2NENBUDRDQ3lBQlFRRnFJZ0VnQWtjTkFBdEJ3Z0FoRUF5Z0F3c2dBVUVCYWlFQklBQXRBQzFCQVhGRkRiMEJJQUVoQVF0QkxDRVFESVVEQ3lBQklnRWdBa2NOMHdGQnhBQWhFQXlkQXdzRFFBSkFJQUV0QUFCQmtNQ0FnQUJxTFFBQVFRRkdEUUFnQVNFQkRMY0NDeUFCUVFGcUlnRWdBa2NOQUF0QnhRQWhFQXljQXdzZ0RTMEFBQ0lRUVNCR0RiTUJJQkJCT2tjTmdRTWdBQ2dDQkNFQklBQkJBRFlDQkNBQUlBRWdEUkN2Z0lDQUFDSUJEZEFCSUExQkFXb2hBUXl6QWd0Qnh3QWhFQ0FCSWcwZ0FrWU5tZ01nQWlBTmF5QUFLQUlBSWdGcUlSWWdEU0FCYTBFRmFpRVhBMEFnRFMwQUFDSVVRU0J5SUJRZ0ZFRy9mMnBCL3dGeFFScEpHMEgvQVhFZ0FVR1F3b0NBQUdvdEFBQkhEWUFESUFGQkJVWU45QUlnQVVFQmFpRUJJQTFCQVdvaURTQUNSdzBBQ3lBQUlCWTJBZ0FNbWdNTFFjZ0FJUkFnQVNJTklBSkdEWmtESUFJZ0RXc2dBQ2dDQUNJQmFpRVdJQTBnQVd0QkNXb2hGd05BSUEwdEFBQWlGRUVnY2lBVUlCUkJ2MzlxUWY4QmNVRWFTUnRCL3dGeElBRkJsc0tBZ0FCcUxRQUFSdzMvQWdKQUlBRkJDVWNOQUVFQ0lRRU05UUlMSUFGQkFXb2hBU0FOUVFGcUlnMGdBa2NOQUFzZ0FDQVdOZ0lBREprREN3SkFJQUVpRFNBQ1J3MEFRY2tBSVJBTW1RTUxBa0FDUUNBTkxRQUFJZ0ZCSUhJZ0FTQUJRYjkvYWtIL0FYRkJHa2tiUWY4QmNVR1NmMm9PQndDQUE0QURnQU9BQTRBREFZQURDeUFOUVFGcUlRRkJQaUVRRElBREN5QU5RUUZxSVFGQlB5RVFEUDhDQzBIS0FDRVFJQUVpRFNBQ1JnMlhBeUFDSUExcklBQW9BZ0FpQVdvaEZpQU5JQUZyUVFGcUlSY0RRQ0FOTFFBQUloUkJJSElnRkNBVVFiOS9ha0gvQVhGQkdra2JRZjhCY1NBQlFhRENnSUFBYWkwQUFFY04vUUlnQVVFQlJnM3dBaUFCUVFGcUlRRWdEVUVCYWlJTklBSkhEUUFMSUFBZ0ZqWUNBQXlYQXd0Qnl3QWhFQ0FCSWcwZ0FrWU5sZ01nQWlBTmF5QUFLQUlBSWdGcUlSWWdEU0FCYTBFT2FpRVhBMEFnRFMwQUFDSVVRU0J5SUJRZ0ZFRy9mMnBCL3dGeFFScEpHMEgvQVhFZ0FVR2l3b0NBQUdvdEFBQkhEZndDSUFGQkRrWU44QUlnQVVFQmFpRUJJQTFCQVdvaURTQUNSdzBBQ3lBQUlCWTJBZ0FNbGdNTFFjd0FJUkFnQVNJTklBSkdEWlVESUFJZ0RXc2dBQ2dDQUNJQmFpRVdJQTBnQVd0QkQyb2hGd05BSUEwdEFBQWlGRUVnY2lBVUlCUkJ2MzlxUWY4QmNVRWFTUnRCL3dGeElBRkJ3TUtBZ0FCcUxRQUFSdzM3QWdKQUlBRkJEMGNOQUVFRElRRU04UUlMSUFGQkFXb2hBU0FOUVFGcUlnMGdBa2NOQUFzZ0FDQVdOZ0lBREpVREMwSE5BQ0VRSUFFaURTQUNSZzJVQXlBQ0lBMXJJQUFvQWdBaUFXb2hGaUFOSUFGclFRVnFJUmNEUUNBTkxRQUFJaFJCSUhJZ0ZDQVVRYjkvYWtIL0FYRkJHa2tiUWY4QmNTQUJRZERDZ0lBQWFpMEFBRWNOK2dJQ1FDQUJRUVZIRFFCQkJDRUJEUEFDQ3lBQlFRRnFJUUVnRFVFQmFpSU5JQUpIRFFBTElBQWdGallDQUF5VUF3c0NRQ0FCSWcwZ0FrY05BRUhPQUNFUURKUURDd0pBQWtBQ1FBSkFJQTB0QUFBaUFVRWdjaUFCSUFGQnYzOXFRZjhCY1VFYVNSdEIvd0Z4UVoxL2FnNFRBUDBDL1FMOUF2MEMvUUw5QXYwQy9RTDlBdjBDL1FMOUFnSDlBdjBDL1FJQ0EvMENDeUFOUVFGcUlRRkJ3UUFoRUF6OUFnc2dEVUVCYWlFQlFjSUFJUkFNL0FJTElBMUJBV29oQVVIREFDRVFEUHNDQ3lBTlFRRnFJUUZCeEFBaEVBejZBZ3NDUUNBQklnRWdBa1lOQUNBQVFZMkFnSUFBTmdJSUlBQWdBVFlDQkNBQklRRkJ4UUFoRUF6NkFndEJ6d0FoRUF5U0F3c2dFQ0VCQWtBQ1FDQVFMUUFBUVhacURnUUJxQUtvQWdDb0Fnc2dFRUVCYWlFQkMwRW5JUkFNK0FJTEFrQWdBU0lCSUFKSERRQkIwUUFoRUF5UkF3c0NRQ0FCTFFBQVFTQkdEUUFnQVNFQkRJMEJDeUFCUVFGcUlRRWdBQzBBTFVFQmNVVU54d0VnQVNFQkRJd0JDeUFCSWhjZ0FrY055QUZCMGdBaEVBeVBBd3RCMHdBaEVDQUJJaFFnQWtZTmpnTWdBaUFVYXlBQUtBSUFJZ0ZxSVJZZ0ZDQUJhMEVCYWlFWEEwQWdGQzBBQUNBQlFkYkNnSUFBYWkwQUFFY056QUVnQVVFQlJnM0hBU0FCUVFGcUlRRWdGRUVCYWlJVUlBSkhEUUFMSUFBZ0ZqWUNBQXlPQXdzQ1FDQUJJZ0VnQWtjTkFFSFZBQ0VRREk0REN5QUJMUUFBUVFwSERjd0JJQUZCQVdvaEFRekhBUXNDUUNBQklnRWdBa2NOQUVIV0FDRVFESTBEQ3dKQUFrQWdBUzBBQUVGMmFnNEVBTTBCelFFQnpRRUxJQUZCQVdvaEFRekhBUXNnQVVFQmFpRUJRY29BSVJBTTh3SUxJQUFnQVNJQklBSVFyb0NBZ0FBaUVBM0xBU0FCSVFGQnpRQWhFQXp5QWdzZ0FDMEFLVUVpUmcyRkF3eW1BZ3NDUUNBQklnRWdBa2NOQUVIYkFDRVFESW9EQzBFQUlSUkJBU0VYUVFFaEZrRUFJUkFDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQVMwQUFFRlFhZzRLMUFIVEFRQUJBZ01FQlFZSTFRRUxRUUloRUF3R0MwRURJUkFNQlF0QkJDRVFEQVFMUVFVaEVBd0RDMEVHSVJBTUFndEJCeUVRREFFTFFRZ2hFQXRCQUNFWFFRQWhGa0VBSVJRTXpBRUxRUWtoRUVFQklSUkJBQ0VYUVFBaEZnekxBUXNDUUNBQklnRWdBa2NOQUVIZEFDRVFESWtEQ3lBQkxRQUFRUzVIRGN3QklBRkJBV29oQVF5bUFnc2dBU0lCSUFKSERjd0JRZDhBSVJBTWh3TUxBa0FnQVNJQklBSkdEUUFnQUVHT2dJQ0FBRFlDQ0NBQUlBRTJBZ1FnQVNFQlFkQUFJUkFNN2dJTFFlQUFJUkFNaGdNTFFlRUFJUkFnQVNJQklBSkdEWVVESUFJZ0FXc2dBQ2dDQUNJVWFpRVdJQUVnRkd0QkEyb2hGd05BSUFFdEFBQWdGRUhpd29DQUFHb3RBQUJIRGMwQklCUkJBMFlOekFFZ0ZFRUJhaUVVSUFGQkFXb2lBU0FDUncwQUN5QUFJQlkyQWdBTWhRTUxRZUlBSVJBZ0FTSUJJQUpHRFlRRElBSWdBV3NnQUNnQ0FDSVVhaUVXSUFFZ0ZHdEJBbW9oRndOQUlBRXRBQUFnRkVIbXdvQ0FBR290QUFCSERjd0JJQlJCQWtZTnpnRWdGRUVCYWlFVUlBRkJBV29pQVNBQ1J3MEFDeUFBSUJZMkFnQU1oQU1MUWVNQUlSQWdBU0lCSUFKR0RZTURJQUlnQVdzZ0FDZ0NBQ0lVYWlFV0lBRWdGR3RCQTJvaEZ3TkFJQUV0QUFBZ0ZFSHB3b0NBQUdvdEFBQkhEY3NCSUJSQkEwWU56Z0VnRkVFQmFpRVVJQUZCQVdvaUFTQUNSdzBBQ3lBQUlCWTJBZ0FNZ3dNTEFrQWdBU0lCSUFKSERRQkI1UUFoRUF5REF3c2dBQ0FCUVFGcUlnRWdBaENvZ0lDQUFDSVFEYzBCSUFFaEFVSFdBQ0VRRE9rQ0N3SkFJQUVpQVNBQ1JnMEFBMEFDUUNBQkxRQUFJaEJCSUVZTkFBSkFBa0FDUUNBUVFiaC9hZzRMQUFIUEFjOEJ6d0hQQWM4Qnp3SFBBYzhCQXM4QkN5QUJRUUZxSVFGQjBnQWhFQXp0QWdzZ0FVRUJhaUVCUWRNQUlSQU03QUlMSUFGQkFXb2hBVUhVQUNFUURPc0NDeUFCUVFGcUlnRWdBa2NOQUF0QjVBQWhFQXlDQXd0QjVBQWhFQXlCQXdzRFFBSkFJQUV0QUFCQjhNS0FnQUJxTFFBQUloQkJBVVlOQUNBUVFYNXFEZ1BQQWRBQjBRSFNBUXNnQVVFQmFpSUJJQUpIRFFBTFFlWUFJUkFNZ0FNTEFrQWdBU0lCSUFKR0RRQWdBVUVCYWlFQkRBTUxRZWNBSVJBTS93SUxBMEFDUUNBQkxRQUFRZkRFZ0lBQWFpMEFBQ0lRUVFGR0RRQUNRQ0FRUVg1cURnVFNBZE1CMUFFQTFRRUxJQUVoQVVIWEFDRVFET2NDQ3lBQlFRRnFJZ0VnQWtjTkFBdEI2QUFoRUF6K0Fnc0NRQ0FCSWdFZ0FrY05BRUhwQUNFUURQNENDd0pBSUFFdEFBQWlFRUYyYWc0YXVnSFZBZFVCdkFIVkFkVUIxUUhWQWRVQjFRSFZBZFVCMVFIVkFkVUIxUUhWQWRVQjFRSFZBZFVCMVFIS0FkVUIxUUVBMHdFTElBRkJBV29oQVF0QkJpRVFET01DQ3dOQUFrQWdBUzBBQUVId3hvQ0FBR290QUFCQkFVWU5BQ0FCSVFFTW5nSUxJQUZCQVdvaUFTQUNSdzBBQzBIcUFDRVFEUHNDQ3dKQUlBRWlBU0FDUmcwQUlBRkJBV29oQVF3REMwSHJBQ0VRRFBvQ0N3SkFJQUVpQVNBQ1J3MEFRZXdBSVJBTStnSUxJQUZCQVdvaEFRd0JDd0pBSUFFaUFTQUNSdzBBUWUwQUlSQU0rUUlMSUFGQkFXb2hBUXRCQkNFUURONENDd0pBSUFFaUZDQUNSdzBBUWU0QUlSQU05d0lMSUJRaEFRSkFBa0FDUUNBVUxRQUFRZkRJZ0lBQWFpMEFBRUYvYWc0SDFBSFZBZFlCQUp3Q0FRTFhBUXNnRkVFQmFpRUJEQW9MSUJSQkFXb2hBUXpOQVF0QkFDRVFJQUJCQURZQ0hDQUFRWnVTZ0lBQU5nSVFJQUJCQnpZQ0RDQUFJQlJCQVdvMkFoUU05Z0lMQWtBRFFBSkFJQUV0QUFCQjhNaUFnQUJxTFFBQUloQkJCRVlOQUFKQUFrQWdFRUYvYWc0SDBnSFRBZFFCMlFFQUJBSFpBUXNnQVNFQlFkb0FJUkFNNEFJTElBRkJBV29oQVVIY0FDRVFETjhDQ3lBQlFRRnFJZ0VnQWtjTkFBdEI3d0FoRUF6MkFnc2dBVUVCYWlFQkRNc0JDd0pBSUFFaUZDQUNSdzBBUWZBQUlSQU05UUlMSUJRdEFBQkJMMGNOMUFFZ0ZFRUJhaUVCREFZTEFrQWdBU0lVSUFKSERRQkI4UUFoRUF6MEFnc0NRQ0FVTFFBQUlnRkJMMGNOQUNBVVFRRnFJUUZCM1FBaEVBemJBZ3NnQVVGMmFpSUVRUlpMRGRNQlFRRWdCSFJCaVlDQUFuRkZEZE1CRE1vQ0N3SkFJQUVpQVNBQ1JnMEFJQUZCQVdvaEFVSGVBQ0VRRE5vQ0MwSHlBQ0VRRFBJQ0N3SkFJQUVpRkNBQ1J3MEFRZlFBSVJBTThnSUxJQlFoQVFKQUlCUXRBQUJCOE15QWdBQnFMUUFBUVg5cURnUEpBcFFDQU5RQkMwSGhBQ0VRRE5nQ0N3SkFJQUVpRkNBQ1JnMEFBMEFDUUNBVUxRQUFRZkRLZ0lBQWFpMEFBQ0lCUVFOR0RRQUNRQ0FCUVg5cURnTExBZ0RWQVFzZ0ZDRUJRZDhBSVJBTTJnSUxJQlJCQVdvaUZDQUNSdzBBQzBIekFDRVFEUEVDQzBIekFDRVFEUEFDQ3dKQUlBRWlBU0FDUmcwQUlBQkJqNENBZ0FBMkFnZ2dBQ0FCTmdJRUlBRWhBVUhnQUNFUUROY0NDMEgxQUNFUURPOENDd0pBSUFFaUFTQUNSdzBBUWZZQUlSQU03d0lMSUFCQmo0Q0FnQUEyQWdnZ0FDQUJOZ0lFSUFFaEFRdEJBeUVRRE5RQ0N3TkFJQUV0QUFCQklFY053d0lnQVVFQmFpSUJJQUpIRFFBTFFmY0FJUkFNN0FJTEFrQWdBU0lCSUFKSERRQkIrQUFoRUF6c0Fnc2dBUzBBQUVFZ1J3M09BU0FCUVFGcUlRRU03d0VMSUFBZ0FTSUJJQUlRcklDQWdBQWlFQTNPQVNBQklRRU1qZ0lMQWtBZ0FTSUVJQUpIRFFCQitnQWhFQXpxQWdzZ0JDMEFBRUhNQUVjTjBRRWdCRUVCYWlFQlFSTWhFQXpQQVFzQ1FDQUJJZ1FnQWtjTkFFSDdBQ0VRRE9rQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUVZxSVJBRFFDQUVMUUFBSUFGQjhNNkFnQUJxTFFBQVJ3M1FBU0FCUVFWR0RjNEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRZnNBSVJBTTZBSUxBa0FnQVNJRUlBSkhEUUJCL0FBaEVBem9BZ3NDUUFKQUlBUXRBQUJCdlg5cURnd0EwUUhSQWRFQjBRSFJBZEVCMFFIUkFkRUIwUUVCMFFFTElBUkJBV29oQVVIbUFDRVFETThDQ3lBRVFRRnFJUUZCNXdBaEVBek9BZ3NDUUNBQklnUWdBa2NOQUVIOUFDRVFET2NDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRSnFJUkFDUUFOQUlBUXRBQUFnQVVIdHo0Q0FBR290QUFCSERjOEJJQUZCQWtZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFSDlBQ0VRRE9jQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVJBaEVBek1BUXNDUUNBQklnUWdBa2NOQUVIK0FDRVFET1lDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRVnFJUkFDUUFOQUlBUXRBQUFnQVVIMnpvQ0FBR290QUFCSERjNEJJQUZCQlVZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFSCtBQ0VRRE9ZQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVJZaEVBekxBUXNDUUNBQklnUWdBa2NOQUVIL0FDRVFET1VDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRTnFJUkFDUUFOQUlBUXRBQUFnQVVIOHpvQ0FBR290QUFCSERjMEJJQUZCQTBZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFSC9BQ0VRRE9VQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVFVaEVBektBUXNDUUNBQklnUWdBa2NOQUVHQUFTRVFET1FDQ3lBRUxRQUFRZGtBUnczTEFTQUVRUUZxSVFGQkNDRVFETWtCQ3dKQUlBRWlCQ0FDUncwQVFZRUJJUkFNNHdJTEFrQUNRQ0FFTFFBQVFiSi9hZzREQU13QkFjd0JDeUFFUVFGcUlRRkI2d0FoRUF6S0Fnc2dCRUVCYWlFQlFld0FJUkFNeVFJTEFrQWdBU0lFSUFKSERRQkJnZ0VoRUF6aUFnc0NRQUpBSUFRdEFBQkJ1SDlxRGdnQXl3SExBY3NCeXdITEFjc0JBY3NCQ3lBRVFRRnFJUUZCNmdBaEVBekpBZ3NnQkVFQmFpRUJRZTBBSVJBTXlBSUxBa0FnQVNJRUlBSkhEUUJCZ3dFaEVBemhBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSQWdCQ0FCYTBFQ2FpRVVBa0FEUUNBRUxRQUFJQUZCZ00rQWdBQnFMUUFBUnczSkFTQUJRUUpHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQkEyQWdCQmd3RWhFQXpoQWd0QkFDRVFJQUJCQURZQ0FDQVVRUUZxSVFFTXhnRUxBa0FnQVNJRUlBSkhEUUJCaEFFaEVBemdBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFRWFpRVFBa0FEUUNBRUxRQUFJQUZCZzgrQWdBQnFMUUFBUnczSUFTQUJRUVJHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQmhBRWhFQXpnQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVqSVJBTXhRRUxBa0FnQVNJRUlBSkhEUUJCaFFFaEVBemZBZ3NDUUFKQUlBUXRBQUJCdEg5cURnZ0F5QUhJQWNnQnlBSElBY2dCQWNnQkN5QUVRUUZxSVFGQjd3QWhFQXpHQWdzZ0JFRUJhaUVCUWZBQUlSQU14UUlMQWtBZ0FTSUVJQUpIRFFCQmhnRWhFQXplQWdzZ0JDMEFBRUhGQUVjTnhRRWdCRUVCYWlFQkRJTUNDd0pBSUFFaUJDQUNSdzBBUVljQklSQU0zUUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkEyb2hFQUpBQTBBZ0JDMEFBQ0FCUVlqUGdJQUFhaTBBQUVjTnhRRWdBVUVEUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFZY0JJUkFNM1FJTElBQkJBRFlDQUNBUVFRRnFJUUZCTFNFUURNSUJDd0pBSUFFaUJDQUNSdzBBUVlnQklSQU0zQUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkNHb2hFQUpBQTBBZ0JDMEFBQ0FCUWREUGdJQUFhaTBBQUVjTnhBRWdBVUVJUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFZZ0JJUkFNM0FJTElBQkJBRFlDQUNBUVFRRnFJUUZCS1NFUURNRUJDd0pBSUFFaUFTQUNSdzBBUVlrQklSQU0yd0lMUVFFaEVDQUJMUUFBUWQ4QVJ3M0FBU0FCUVFGcUlRRU1nUUlMQWtBZ0FTSUVJQUpIRFFCQmlnRWhFQXphQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUJhaUVRQTBBZ0JDMEFBQ0FCUVl6UGdJQUFhaTBBQUVjTndRRWdBVUVCUmcydkFpQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR0tBU0VRRE5rQ0N3SkFJQUVpQkNBQ1J3MEFRWXNCSVJBTTJRSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQW1vaEVBSkFBMEFnQkMwQUFDQUJRWTdQZ0lBQWFpMEFBRWNOd1FFZ0FVRUNSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUVlzQklSQU0yUUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJBaUVRREw0QkN3SkFJQUVpQkNBQ1J3MEFRWXdCSVJBTTJBSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQVdvaEVBSkFBMEFnQkMwQUFDQUJRZkRQZ0lBQWFpMEFBRWNOd0FFZ0FVRUJSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUVl3QklSQU0yQUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJIeUVRREwwQkN3SkFJQUVpQkNBQ1J3MEFRWTBCSVJBTTF3SUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQVdvaEVBSkFBMEFnQkMwQUFDQUJRZkxQZ0lBQWFpMEFBRWNOdndFZ0FVRUJSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUVkwQklSQU0xd0lMSUFCQkFEWUNBQ0FRUVFGcUlRRkJDU0VRREx3QkN3SkFJQUVpQkNBQ1J3MEFRWTRCSVJBTTFnSUxBa0FDUUNBRUxRQUFRYmQvYWc0SEFMOEJ2d0cvQWI4QnZ3RUJ2d0VMSUFSQkFXb2hBVUg0QUNFUURMMENDeUFFUVFGcUlRRkIrUUFoRUF5OEFnc0NRQ0FCSWdRZ0FrY05BRUdQQVNFUUROVUNDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFWcUlSQUNRQU5BSUFRdEFBQWdBVUdSejRDQUFHb3RBQUJIRGIwQklBRkJCVVlOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHUEFTRVFETlVDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUmdoRUF5NkFRc0NRQ0FCSWdRZ0FrY05BRUdRQVNFUUROUUNDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFKcUlSQUNRQU5BSUFRdEFBQWdBVUdYejRDQUFHb3RBQUJIRGJ3QklBRkJBa1lOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHUUFTRVFETlFDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUmNoRUF5NUFRc0NRQ0FCSWdRZ0FrY05BRUdSQVNFUUROTUNDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFacUlSQUNRQU5BSUFRdEFBQWdBVUdhejRDQUFHb3RBQUJIRGJzQklBRkJCa1lOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHUkFTRVFETk1DQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUlVoRUF5NEFRc0NRQ0FCSWdRZ0FrY05BRUdTQVNFUUROSUNDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFWcUlSQUNRQU5BSUFRdEFBQWdBVUdoejRDQUFHb3RBQUJIRGJvQklBRkJCVVlOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHU0FTRVFETklDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUjRoRUF5M0FRc0NRQ0FCSWdRZ0FrY05BRUdUQVNFUURORUNDeUFFTFFBQVFjd0FSdzI0QVNBRVFRRnFJUUZCQ2lFUURMWUJDd0pBSUFRZ0FrY05BRUdVQVNFUUROQUNDd0pBQWtBZ0JDMEFBRUcvZjJvT0R3QzVBYmtCdVFHNUFia0J1UUc1QWJrQnVRRzVBYmtCdVFHNUFRRzVBUXNnQkVFQmFpRUJRZjRBSVJBTXR3SUxJQVJCQVdvaEFVSC9BQ0VRRExZQ0N3SkFJQVFnQWtjTkFFR1ZBU0VRRE04Q0N3SkFBa0FnQkMwQUFFRy9mMm9PQXdDNEFRRzRBUXNnQkVFQmFpRUJRZjBBSVJBTXRnSUxJQVJCQVdvaEJFR0FBU0VRRExVQ0N3SkFJQVFnQWtjTkFFR1dBU0VRRE00Q0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUZxSVJBQ1FBTkFJQVF0QUFBZ0FVR256NENBQUdvdEFBQkhEYllCSUFGQkFVWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUdXQVNFUURNNENDeUFBUVFBMkFnQWdFRUVCYWlFQlFRc2hFQXl6QVFzQ1FDQUVJQUpIRFFCQmx3RWhFQXpOQWdzQ1FBSkFBa0FDUUNBRUxRQUFRVk5xRGlNQXVBRzRBYmdCdUFHNEFiZ0J1QUc0QWJnQnVBRzRBYmdCdUFHNEFiZ0J1QUc0QWJnQnVBRzRBYmdCdUFHNEFRRzRBYmdCdUFHNEFiZ0JBcmdCdUFHNEFRTzRBUXNnQkVFQmFpRUJRZnNBSVJBTXRnSUxJQVJCQVdvaEFVSDhBQ0VRRExVQ0N5QUVRUUZxSVFSQmdRRWhFQXkwQWdzZ0JFRUJhaUVFUVlJQklSQU1zd0lMQWtBZ0JDQUNSdzBBUVpnQklSQU16QUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkJHb2hFQUpBQTBBZ0JDMEFBQ0FCUWFuUGdJQUFhaTBBQUVjTnRBRWdBVUVFUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFaZ0JJUkFNekFJTElBQkJBRFlDQUNBUVFRRnFJUUZCR1NFUURMRUJDd0pBSUFRZ0FrY05BRUdaQVNFUURNc0NDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFWcUlSQUNRQU5BSUFRdEFBQWdBVUd1ejRDQUFHb3RBQUJIRGJNQklBRkJCVVlOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHWkFTRVFETXNDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUVloRUF5d0FRc0NRQ0FFSUFKSERRQkJtZ0VoRUF6S0Fnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVCYWlFUUFrQURRQ0FFTFFBQUlBRkJ0TStBZ0FCcUxRQUFSdzJ5QVNBQlFRRkdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCbWdFaEVBektBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRWNJUkFNcndFTEFrQWdCQ0FDUncwQVFac0JJUkFNeVFJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBV29oRUFKQUEwQWdCQzBBQUNBQlFiYlBnSUFBYWkwQUFFY05zUUVnQVVFQlJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRWnNCSVJBTXlRSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkp5RVFESzRCQ3dKQUlBUWdBa2NOQUVHY0FTRVFETWdDQ3dKQUFrQWdCQzBBQUVHc2Yyb09BZ0FCc1FFTElBUkJBV29oQkVHR0FTRVFESzhDQ3lBRVFRRnFJUVJCaHdFaEVBeXVBZ3NDUUNBRUlBSkhEUUJCblFFaEVBekhBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQmFpRVFBa0FEUUNBRUxRQUFJQUZCdU0rQWdBQnFMUUFBUncydkFTQUJRUUZHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQm5RRWhFQXpIQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVtSVJBTXJBRUxBa0FnQkNBQ1J3MEFRWjRCSVJBTXhnSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQVdvaEVBSkFBMEFnQkMwQUFDQUJRYnJQZ0lBQWFpMEFBRWNOcmdFZ0FVRUJSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUVo0QklSQU14Z0lMSUFCQkFEWUNBQ0FRUVFGcUlRRkJBeUVRREtzQkN3SkFJQVFnQWtjTkFFR2ZBU0VRRE1VQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUpxSVJBQ1FBTkFJQVF0QUFBZ0FVSHR6NENBQUdvdEFBQkhEYTBCSUFGQkFrWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUdmQVNFUURNVUNDeUFBUVFBMkFnQWdFRUVCYWlFQlFRd2hFQXlxQVFzQ1FDQUVJQUpIRFFCQm9BRWhFQXpFQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRURhaUVRQWtBRFFDQUVMUUFBSUFGQnZNK0FnQUJxTFFBQVJ3MnNBU0FCUVFOR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJvQUVoRUF6RUFnc2dBRUVBTmdJQUlCQkJBV29oQVVFTklSQU1xUUVMQWtBZ0JDQUNSdzBBUWFFQklSQU13d0lMQWtBQ1FDQUVMUUFBUWJwL2FnNExBS3dCckFHc0Fhd0JyQUdzQWF3QnJBR3NBUUdzQVFzZ0JFRUJhaUVFUVlzQklSQU1xZ0lMSUFSQkFXb2hCRUdNQVNFUURLa0NDd0pBSUFRZ0FrY05BRUdpQVNFUURNSUNDeUFFTFFBQVFkQUFSdzJwQVNBRVFRRnFJUVFNNlFFTEFrQWdCQ0FDUncwQVFhTUJJUkFNd1FJTEFrQUNRQ0FFTFFBQVFiZC9hZzRIQWFvQnFnR3FBYW9CcWdFQXFnRUxJQVJCQVdvaEJFR09BU0VRREtnQ0N5QUVRUUZxSVFGQklpRVFES1lCQ3dKQUlBUWdBa2NOQUVHa0FTRVFETUFDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRRnFJUkFDUUFOQUlBUXRBQUFnQVVIQXo0Q0FBR290QUFCSERhZ0JJQUZCQVVZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR2tBU0VRRE1BQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVIwaEVBeWxBUXNDUUNBRUlBSkhEUUJCcFFFaEVBeS9BZ3NDUUFKQUlBUXRBQUJCcm45cURnTUFxQUVCcUFFTElBUkJBV29oQkVHUUFTRVFES1lDQ3lBRVFRRnFJUUZCQkNFUURLUUJDd0pBSUFRZ0FrY05BRUdtQVNFUURMNENDd0pBQWtBQ1FBSkFBa0FnQkMwQUFFRy9mMm9PRlFDcUFhb0JxZ0dxQWFvQnFnR3FBYW9CcWdHcUFRR3FBYW9CQXFvQnFnRURxZ0dxQVFTcUFRc2dCRUVCYWlFRVFZZ0JJUkFNcUFJTElBUkJBV29oQkVHSkFTRVFES2NDQ3lBRVFRRnFJUVJCaWdFaEVBeW1BZ3NnQkVFQmFpRUVRWThCSVJBTXBRSUxJQVJCQVdvaEJFR1JBU0VRREtRQ0N3SkFJQVFnQWtjTkFFR25BU0VRREwwQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUpxSVJBQ1FBTkFJQVF0QUFBZ0FVSHR6NENBQUdvdEFBQkhEYVVCSUFGQkFrWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUduQVNFUURMMENDeUFBUVFBMkFnQWdFRUVCYWlFQlFSRWhFQXlpQVFzQ1FDQUVJQUpIRFFCQnFBRWhFQXk4QWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUNhaUVRQWtBRFFDQUVMUUFBSUFGQndzK0FnQUJxTFFBQVJ3MmtBU0FCUVFKR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJxQUVoRUF5OEFnc2dBRUVBTmdJQUlCQkJBV29oQVVFc0lSQU1vUUVMQWtBZ0JDQUNSdzBBUWFrQklSQU11d0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkJHb2hFQUpBQTBBZ0JDMEFBQ0FCUWNYUGdJQUFhaTBBQUVjTm93RWdBVUVFUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFha0JJUkFNdXdJTElBQkJBRFlDQUNBUVFRRnFJUUZCS3lFUURLQUJDd0pBSUFRZ0FrY05BRUdxQVNFUURMb0NDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFKcUlSQUNRQU5BSUFRdEFBQWdBVUhLejRDQUFHb3RBQUJIRGFJQklBRkJBa1lOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHcUFTRVFETG9DQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUlFoRUF5ZkFRc0NRQ0FFSUFKSERRQkJxd0VoRUF5NUFnc0NRQUpBQWtBQ1FDQUVMUUFBUWI1L2FnNFBBQUVDcEFHa0FhUUJwQUdrQWFRQnBBR2tBYVFCcEFHa0FRT2tBUXNnQkVFQmFpRUVRWk1CSVJBTW9nSUxJQVJCQVdvaEJFR1VBU0VRREtFQ0N5QUVRUUZxSVFSQmxRRWhFQXlnQWdzZ0JFRUJhaUVFUVpZQklSQU1ud0lMQWtBZ0JDQUNSdzBBUWF3QklSQU11QUlMSUFRdEFBQkJ4UUJIRFo4QklBUkJBV29oQkF6Z0FRc0NRQ0FFSUFKSERRQkJyUUVoRUF5M0Fnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVDYWlFUUFrQURRQ0FFTFFBQUlBRkJ6YytBZ0FCcUxRQUFSdzJmQVNBQlFRSkdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCclFFaEVBeTNBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRU9JUkFNbkFFTEFrQWdCQ0FDUncwQVFhNEJJUkFNdGdJTElBUXRBQUJCMEFCSERaMEJJQVJCQVdvaEFVRWxJUkFNbXdFTEFrQWdCQ0FDUncwQVFhOEJJUkFNdFFJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJDR29oRUFKQUEwQWdCQzBBQUNBQlFkRFBnSUFBYWkwQUFFY05uUUVnQVVFSVJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRYThCSVJBTXRRSUxJQUJCQURZQ0FDQVFRUUZxSVFGQktpRVFESm9CQ3dKQUlBUWdBa2NOQUVHd0FTRVFETFFDQ3dKQUFrQWdCQzBBQUVHcmYyb09Dd0NkQVowQm5RR2RBWjBCblFHZEFaMEJuUUVCblFFTElBUkJBV29oQkVHYUFTRVFESnNDQ3lBRVFRRnFJUVJCbXdFaEVBeWFBZ3NDUUNBRUlBSkhEUUJCc1FFaEVBeXpBZ3NDUUFKQUlBUXRBQUJCdjM5cURoUUFuQUdjQVp3Qm5BR2NBWndCbkFHY0Fad0JuQUdjQVp3Qm5BR2NBWndCbkFHY0Fad0JBWndCQ3lBRVFRRnFJUVJCbVFFaEVBeWFBZ3NnQkVFQmFpRUVRWndCSVJBTW1RSUxBa0FnQkNBQ1J3MEFRYklCSVJBTXNnSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQTJvaEVBSkFBMEFnQkMwQUFDQUJRZG5QZ0lBQWFpMEFBRWNObWdFZ0FVRURSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWJJQklSQU1zZ0lMSUFCQkFEWUNBQ0FRUVFGcUlRRkJJU0VRREpjQkN3SkFJQVFnQWtjTkFFR3pBU0VRRExFQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUVpxSVJBQ1FBTkFJQVF0QUFBZ0FVSGR6NENBQUdvdEFBQkhEWmtCSUFGQkJrWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUd6QVNFUURMRUNDeUFBUVFBMkFnQWdFRUVCYWlFQlFSb2hFQXlXQVFzQ1FDQUVJQUpIRFFCQnRBRWhFQXl3QWdzQ1FBSkFBa0FnQkMwQUFFRzdmMm9PRVFDYUFab0JtZ0dhQVpvQm1nR2FBWm9CbWdFQm1nR2FBWm9CbWdHYUFRS2FBUXNnQkVFQmFpRUVRWjBCSVJBTW1BSUxJQVJCQVdvaEJFR2VBU0VRREpjQ0N5QUVRUUZxSVFSQm53RWhFQXlXQWdzQ1FDQUVJQUpIRFFCQnRRRWhFQXl2QWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUZhaUVRQWtBRFFDQUVMUUFBSUFGQjVNK0FnQUJxTFFBQVJ3MlhBU0FCUVFWR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJ0UUVoRUF5dkFnc2dBRUVBTmdJQUlCQkJBV29oQVVFb0lSQU1sQUVMQWtBZ0JDQUNSdzBBUWJZQklSQU1yZ0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFtb2hFQUpBQTBBZ0JDMEFBQ0FCUWVyUGdJQUFhaTBBQUVjTmxnRWdBVUVDUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFiWUJJUkFNcmdJTElBQkJBRFlDQUNBUVFRRnFJUUZCQnlFUURKTUJDd0pBSUFRZ0FrY05BRUczQVNFUURLMENDd0pBQWtBZ0JDMEFBRUc3ZjJvT0RnQ1dBWllCbGdHV0FaWUJsZ0dXQVpZQmxnR1dBWllCbGdFQmxnRUxJQVJCQVdvaEJFR2hBU0VRREpRQ0N5QUVRUUZxSVFSQm9nRWhFQXlUQWdzQ1FDQUVJQUpIRFFCQnVBRWhFQXlzQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUNhaUVRQWtBRFFDQUVMUUFBSUFGQjdjK0FnQUJxTFFBQVJ3MlVBU0FCUVFKR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJ1QUVoRUF5c0Fnc2dBRUVBTmdJQUlCQkJBV29oQVVFU0lSQU1rUUVMQWtBZ0JDQUNSdzBBUWJrQklSQU1xd0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFXb2hFQUpBQTBBZ0JDMEFBQ0FCUWZEUGdJQUFhaTBBQUVjTmt3RWdBVUVCUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFia0JJUkFNcXdJTElBQkJBRFlDQUNBUVFRRnFJUUZCSUNFUURKQUJDd0pBSUFRZ0FrY05BRUc2QVNFUURLb0NDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFGcUlSQUNRQU5BSUFRdEFBQWdBVUh5ejRDQUFHb3RBQUJIRFpJQklBRkJBVVlOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHNkFTRVFES29DQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUThoRUF5UEFRc0NRQ0FFSUFKSERRQkJ1d0VoRUF5cEFnc0NRQUpBSUFRdEFBQkJ0MzlxRGdjQWtnR1NBWklCa2dHU0FRR1NBUXNnQkVFQmFpRUVRYVVCSVJBTWtBSUxJQVJCQVdvaEJFR21BU0VRREk4Q0N3SkFJQVFnQWtjTkFFRzhBU0VRREtnQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUWRxSVJBQ1FBTkFJQVF0QUFBZ0FVSDB6NENBQUdvdEFBQkhEWkFCSUFGQkIwWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUc4QVNFUURLZ0NDeUFBUVFBMkFnQWdFRUVCYWlFQlFSc2hFQXlOQVFzQ1FDQUVJQUpIRFFCQnZRRWhFQXluQWdzQ1FBSkFBa0FnQkMwQUFFRytmMm9PRWdDUkFaRUJrUUdSQVpFQmtRR1JBWkVCa1FFQmtRR1JBWkVCa1FHUkFaRUJBcEVCQ3lBRVFRRnFJUVJCcEFFaEVBeVBBZ3NnQkVFQmFpRUVRYWNCSVJBTWpnSUxJQVJCQVdvaEJFR29BU0VRREkwQ0N3SkFJQVFnQWtjTkFFRytBU0VRREtZQ0N5QUVMUUFBUWM0QVJ3Mk5BU0FFUVFGcUlRUU16d0VMQWtBZ0JDQUNSdzBBUWI4QklSQU1wUUlMQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdCQzBBQUVHL2Yyb09GUUFCQWdPY0FRUUZCcHdCbkFHY0FRY0lDUW9MbkFFTURRNFBuQUVMSUFSQkFXb2hBVUhvQUNFUURKb0NDeUFFUVFGcUlRRkI2UUFoRUF5WkFnc2dCRUVCYWlFQlFlNEFJUkFNbUFJTElBUkJBV29oQVVIeUFDRVFESmNDQ3lBRVFRRnFJUUZCOHdBaEVBeVdBZ3NnQkVFQmFpRUJRZllBSVJBTWxRSUxJQVJCQVdvaEFVSDNBQ0VRREpRQ0N5QUVRUUZxSVFGQitnQWhFQXlUQWdzZ0JFRUJhaUVFUVlNQklSQU1rZ0lMSUFSQkFXb2hCRUdFQVNFUURKRUNDeUFFUVFGcUlRUkJoUUVoRUF5UUFnc2dCRUVCYWlFRVFaSUJJUkFNandJTElBUkJBV29oQkVHWUFTRVFESTRDQ3lBRVFRRnFJUVJCb0FFaEVBeU5BZ3NnQkVFQmFpRUVRYU1CSVJBTWpBSUxJQVJCQVdvaEJFR3FBU0VRRElzQ0N3SkFJQVFnQWtZTkFDQUFRWkNBZ0lBQU5nSUlJQUFnQkRZQ0JFR3JBU0VRRElzQ0MwSEFBU0VRREtNQ0N5QUFJQVVnQWhDcWdJQ0FBQ0lCRFlzQklBVWhBUXhjQ3dKQUlBWWdBa1lOQUNBR1FRRnFJUVVNalFFTFFjSUJJUkFNb1FJTEEwQUNRQ0FRTFFBQVFYWnFEZ1NNQVFBQWp3RUFDeUFRUVFGcUloQWdBa2NOQUF0Qnd3RWhFQXlnQWdzQ1FDQUhJQUpHRFFBZ0FFR1JnSUNBQURZQ0NDQUFJQWMyQWdRZ0J5RUJRUUVoRUF5SEFndEJ4QUVoRUF5ZkFnc0NRQ0FISUFKSERRQkJ4UUVoRUF5ZkFnc0NRQUpBSUFjdEFBQkJkbW9PQkFIT0FjNEJBTTRCQ3lBSFFRRnFJUVlNalFFTElBZEJBV29oQlF5SkFRc0NRQ0FISUFKSERRQkJ4Z0VoRUF5ZUFnc0NRQUpBSUFjdEFBQkJkbW9PRndHUEFZOEJBWThCandHUEFZOEJqd0dQQVk4Qmp3R1BBWThCandHUEFZOEJqd0dQQVk4Qmp3R1BBUUNQQVFzZ0IwRUJhaUVIQzBHd0FTRVFESVFDQ3dKQUlBZ2dBa2NOQUVISUFTRVFESjBDQ3lBSUxRQUFRU0JIRFkwQklBQkJBRHNCTWlBSVFRRnFJUUZCc3dFaEVBeURBZ3NnQVNFWEFrQURRQ0FYSWdjZ0FrWU5BU0FITFFBQVFWQnFRZjhCY1NJUVFRcFBEY3dCQWtBZ0FDOEJNaUlVUVprelN3MEFJQUFnRkVFS2JDSVVPd0V5SUJCQi8vOERjeUFVUWY3L0EzRkpEUUFnQjBFQmFpRVhJQUFnRkNBUWFpSVFPd0V5SUJCQi8vOERjVUhvQjBrTkFRc0xRUUFoRUNBQVFRQTJBaHdnQUVIQmlZQ0FBRFlDRUNBQVFRMDJBZ3dnQUNBSFFRRnFOZ0lVREp3Q0MwSEhBU0VRREpzQ0N5QUFJQWdnQWhDdWdJQ0FBQ0lRUlEzS0FTQVFRUlZIRFl3QklBQkJ5QUUyQWh3Z0FDQUlOZ0lVSUFCQnlaZUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBeWFBZ3NDUUNBSklBSkhEUUJCekFFaEVBeWFBZ3RCQUNFVVFRRWhGMEVCSVJaQkFDRVFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQWt0QUFCQlVHb09DcFlCbFFFQUFRSURCQVVHQ0pjQkMwRUNJUkFNQmd0QkF5RVFEQVVMUVFRaEVBd0VDMEVGSVJBTUF3dEJCaUVRREFJTFFRY2hFQXdCQzBFSUlSQUxRUUFoRjBFQUlSWkJBQ0VVREk0QkMwRUpJUkJCQVNFVVFRQWhGMEVBSVJZTWpRRUxBa0FnQ2lBQ1J3MEFRYzRCSVJBTW1RSUxJQW90QUFCQkxrY05qZ0VnQ2tFQmFpRUpETW9CQ3lBTElBSkhEWTRCUWRBQklSQU1sd0lMQWtBZ0N5QUNSZzBBSUFCQmpvQ0FnQUEyQWdnZ0FDQUxOZ0lFUWJjQklSQU0vZ0VMUWRFQklSQU1sZ0lMQWtBZ0JDQUNSdzBBUWRJQklSQU1sZ0lMSUFJZ0JHc2dBQ2dDQUNJUWFpRVVJQVFnRUd0QkJHb2hDd05BSUFRdEFBQWdFRUg4ejRDQUFHb3RBQUJIRFk0QklCQkJCRVlONlFFZ0VFRUJhaUVRSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQjBnRWhFQXlWQWdzZ0FDQU1JQUlRcklDQWdBQWlBUTJOQVNBTUlRRU11QUVMQWtBZ0JDQUNSdzBBUWRRQklSQU1sQUlMSUFJZ0JHc2dBQ2dDQUNJUWFpRVVJQVFnRUd0QkFXb2hEQU5BSUFRdEFBQWdFRUdCMElDQUFHb3RBQUJIRFk4QklCQkJBVVlOamdFZ0VFRUJhaUVRSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQjFBRWhFQXlUQWdzQ1FDQUVJQUpIRFFCQjFnRWhFQXlUQWdzZ0FpQUVheUFBS0FJQUloQnFJUlFnQkNBUWEwRUNhaUVMQTBBZ0JDMEFBQ0FRUVlQUWdJQUFhaTBBQUVjTmpnRWdFRUVDUmcyUUFTQVFRUUZxSVJBZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFSFdBU0VRREpJQ0N3SkFJQVFnQWtjTkFFSFhBU0VRREpJQ0N3SkFBa0FnQkMwQUFFRzdmMm9PRUFDUEFZOEJqd0dQQVk4Qmp3R1BBWThCandHUEFZOEJqd0dQQVk4QkFZOEJDeUFFUVFGcUlRUkJ1d0VoRUF6NUFRc2dCRUVCYWlFRVFid0JJUkFNK0FFTEFrQWdCQ0FDUncwQVFkZ0JJUkFNa1FJTElBUXRBQUJCeUFCSERZd0JJQVJCQVdvaEJBekVBUXNDUUNBRUlBSkdEUUFnQUVHUWdJQ0FBRFlDQ0NBQUlBUTJBZ1JCdmdFaEVBejNBUXRCMlFFaEVBeVBBZ3NDUUNBRUlBSkhEUUJCMmdFaEVBeVBBZ3NnQkMwQUFFSElBRVlOd3dFZ0FFRUJPZ0FvRExrQkN5QUFRUUk2QUM4Z0FDQUVJQUlRcG9DQWdBQWlFQTJOQVVIQ0FTRVFEUFFCQ3lBQUxRQW9RWDlxRGdLM0Fia0J1QUVMQTBBQ1FDQUVMUUFBUVhacURnUUFqZ0dPQVFDT0FRc2dCRUVCYWlJRUlBSkhEUUFMUWQwQklSQU1pd0lMSUFCQkFEb0FMeUFBTFFBdFFRUnhSUTJFQWdzZ0FFRUFPZ0F2SUFCQkFUb0FOQ0FCSVFFTWpBRUxJQkJCRlVZTjJnRWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFhZU9nSUFBTmdJUUlBQkJFallDREVFQUlSQU1pQUlMQWtBZ0FDQVFJQUlRdElDQWdBQWlCQTBBSUJBaEFReUJBZ3NDUUNBRVFSVkhEUUFnQUVFRE5nSWNJQUFnRURZQ0ZDQUFRYkNZZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNaUFJTElBQkJBRFlDSENBQUlCQTJBaFFnQUVHbmpvQ0FBRFlDRUNBQVFSSTJBZ3hCQUNFUURJY0NDeUFRUVJWR0RkWUJJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSGFqWUNBQURZQ0VDQUFRUlEyQWd4QkFDRVFESVlDQ3lBQUtBSUVJUmNnQUVFQU5nSUVJQkFnRWFkcUloWWhBU0FBSUJjZ0VDQVdJQlFiSWhBUXRZQ0FnQUFpRkVVTmpRRWdBRUVITmdJY0lBQWdFRFlDRkNBQUlCUTJBZ3hCQUNFUURJVUNDeUFBSUFBdkFUQkJnQUZ5T3dFd0lBRWhBUXRCS2lFUURPb0JDeUFRUVJWR0RkRUJJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR0RqSUNBQURZQ0VDQUFRUk0yQWd4QkFDRVFESUlDQ3lBUVFSVkdEYzhCSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUdhajRDQUFEWUNFQ0FBUVNJMkFneEJBQ0VRRElFQ0N5QUFLQUlFSVJBZ0FFRUFOZ0lFQWtBZ0FDQVFJQUVRdDRDQWdBQWlFQTBBSUFGQkFXb2hBUXlOQVFzZ0FFRU1OZ0ljSUFBZ0VEWUNEQ0FBSUFGQkFXbzJBaFJCQUNFUURJQUNDeUFRUVJWR0Rjd0JJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR2FqNENBQURZQ0VDQUFRU0kyQWd4QkFDRVFEUDhCQ3lBQUtBSUVJUkFnQUVFQU5nSUVBa0FnQUNBUUlBRVF0NENBZ0FBaUVBMEFJQUZCQVdvaEFReU1BUXNnQUVFTk5nSWNJQUFnRURZQ0RDQUFJQUZCQVdvMkFoUkJBQ0VRRFA0QkN5QVFRUlZHRGNrQklBQkJBRFlDSENBQUlBRTJBaFFnQUVIR2pJQ0FBRFlDRUNBQVFTTTJBZ3hCQUNFUURQMEJDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXVZQ0FnQUFpRUEwQUlBRkJBV29oQVF5TEFRc2dBRUVPTmdJY0lBQWdFRFlDRENBQUlBRkJBV28yQWhSQkFDRVFEUHdCQ3lBQVFRQTJBaHdnQUNBQk5nSVVJQUJCd0pXQWdBQTJBaEFnQUVFQ05nSU1RUUFoRUF6N0FRc2dFRUVWUmczRkFTQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQnhveUFnQUEyQWhBZ0FFRWpOZ0lNUVFBaEVBejZBUXNnQUVFUU5nSWNJQUFnQVRZQ0ZDQUFJQkEyQWd4QkFDRVFEUGtCQ3lBQUtBSUVJUVFnQUVFQU5nSUVBa0FnQUNBRUlBRVF1WUNBZ0FBaUJBMEFJQUZCQVdvaEFRenhBUXNnQUVFUk5nSWNJQUFnQkRZQ0RDQUFJQUZCQVdvMkFoUkJBQ0VRRFBnQkN5QVFRUlZHRGNFQklBQkJBRFlDSENBQUlBRTJBaFFnQUVIR2pJQ0FBRFlDRUNBQVFTTTJBZ3hCQUNFUURQY0JDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXVZQ0FnQUFpRUEwQUlBRkJBV29oQVF5SUFRc2dBRUVUTmdJY0lBQWdFRFlDRENBQUlBRkJBV28yQWhSQkFDRVFEUFlCQ3lBQUtBSUVJUVFnQUVFQU5nSUVBa0FnQUNBRUlBRVF1WUNBZ0FBaUJBMEFJQUZCQVdvaEFRenRBUXNnQUVFVU5nSWNJQUFnQkRZQ0RDQUFJQUZCQVdvMkFoUkJBQ0VRRFBVQkN5QVFRUlZHRGIwQklBQkJBRFlDSENBQUlBRTJBaFFnQUVHYWo0Q0FBRFlDRUNBQVFTSTJBZ3hCQUNFUURQUUJDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXQ0Q0FnQUFpRUEwQUlBRkJBV29oQVF5R0FRc2dBRUVXTmdJY0lBQWdFRFlDRENBQUlBRkJBV28yQWhSQkFDRVFEUE1CQ3lBQUtBSUVJUVFnQUVFQU5nSUVBa0FnQUNBRUlBRVF0NENBZ0FBaUJBMEFJQUZCQVdvaEFRenBBUXNnQUVFWE5nSWNJQUFnQkRZQ0RDQUFJQUZCQVdvMkFoUkJBQ0VRRFBJQkN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQnpaT0FnQUEyQWhBZ0FFRU1OZ0lNUVFBaEVBenhBUXRDQVNFUkN5QVFRUUZxSVFFQ1FDQUFLUU1nSWhKQy8vLy8vLy8vLy84UFZnMEFJQUFnRWtJRWhpQVJoRGNESUNBQklRRU1oQUVMSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUd0aVlDQUFEWUNFQ0FBUVF3MkFneEJBQ0VRRE84QkN5QUFRUUEyQWh3Z0FDQVFOZ0lVSUFCQnpaT0FnQUEyQWhBZ0FFRU1OZ0lNUVFBaEVBenVBUXNnQUNnQ0JDRVhJQUJCQURZQ0JDQVFJQkduYWlJV0lRRWdBQ0FYSUJBZ0ZpQVVHeUlRRUxXQWdJQUFJaFJGRFhNZ0FFRUZOZ0ljSUFBZ0VEWUNGQ0FBSUJRMkFneEJBQ0VRRE8wQkN5QUFRUUEyQWh3Z0FDQVFOZ0lVSUFCQnFweUFnQUEyQWhBZ0FFRVBOZ0lNUVFBaEVBenNBUXNnQUNBUUlBSVF0SUNBZ0FBaUFRMEJJQkFoQVF0QkRpRVFETkVCQ3dKQUlBRkJGVWNOQUNBQVFRSTJBaHdnQUNBUU5nSVVJQUJCc0ppQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF6cUFRc2dBRUVBTmdJY0lBQWdFRFlDRkNBQVFhZU9nSUFBTmdJUUlBQkJFallDREVFQUlSQU02UUVMSUFGQkFXb2hFQUpBSUFBdkFUQWlBVUdBQVhGRkRRQUNRQ0FBSUJBZ0FoQzdnSUNBQUNJQkRRQWdFQ0VCREhBTElBRkJGVWNOdWdFZ0FFRUZOZ0ljSUFBZ0VEWUNGQ0FBUWZtWGdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTTZRRUxBa0FnQVVHZ0JIRkJvQVJIRFFBZ0FDMEFMVUVDY1EwQUlBQkJBRFlDSENBQUlCQTJBaFFnQUVHV2s0Q0FBRFlDRUNBQVFRUTJBZ3hCQUNFUURPa0JDeUFBSUJBZ0FoQzlnSUNBQUJvZ0VDRUJBa0FDUUFKQUFrQUNRQ0FBSUJBZ0FoQ3pnSUNBQUE0V0FnRUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBd1FMSUFCQkFUb0FMZ3NnQUNBQUx3RXdRY0FBY2pzQk1DQVFJUUVMUVNZaEVBelJBUXNnQUVFak5nSWNJQUFnRURZQ0ZDQUFRYVdXZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNNlFFTElBQkJBRFlDSENBQUlCQTJBaFFnQUVIVmk0Q0FBRFlDRUNBQVFSRTJBZ3hCQUNFUURPZ0JDeUFBTFFBdFFRRnhSUTBCUWNNQklSQU16Z0VMQWtBZ0RTQUNSZzBBQTBBQ1FDQU5MUUFBUVNCR0RRQWdEU0VCRE1RQkN5QU5RUUZxSWcwZ0FrY05BQXRCSlNFUURPY0JDMEVsSVJBTTVnRUxJQUFvQWdRaEJDQUFRUUEyQWdRZ0FDQUVJQTBRcjRDQWdBQWlCRVVOclFFZ0FFRW1OZ0ljSUFBZ0JEWUNEQ0FBSUExQkFXbzJBaFJCQUNFUURPVUJDeUFRUVJWR0Rhc0JJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSDlqWUNBQURZQ0VDQUFRUjAyQWd4QkFDRVFET1FCQ3lBQVFTYzJBaHdnQUNBQk5nSVVJQUFnRURZQ0RFRUFJUkFNNHdFTElCQWhBVUVCSVJRQ1FBSkFBa0FDUUFKQUFrQUNRQ0FBTFFBc1FYNXFEZ2NHQlFVREFRSUFCUXNnQUNBQUx3RXdRUWh5T3dFd0RBTUxRUUloRkF3QkMwRUVJUlFMSUFCQkFUb0FMQ0FBSUFBdkFUQWdGSEk3QVRBTElCQWhBUXRCS3lFUURNb0JDeUFBUVFBMkFod2dBQ0FRTmdJVUlBQkJxNUtBZ0FBMkFoQWdBRUVMTmdJTVFRQWhFQXppQVFzZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWVHUGdJQUFOZ0lRSUFCQkNqWUNERUVBSVJBTTRRRUxJQUJCQURvQUxDQVFJUUVNdlFFTElCQWhBVUVCSVJRQ1FBSkFBa0FDUUFKQUlBQXRBQ3hCZTJvT0JBTUJBZ0FGQ3lBQUlBQXZBVEJCQ0hJN0FUQU1Bd3RCQWlFVURBRUxRUVFoRkFzZ0FFRUJPZ0FzSUFBZ0FDOEJNQ0FVY2pzQk1Bc2dFQ0VCQzBFcElSQU14UUVMSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUh3bElDQUFEWUNFQ0FBUVFNMkFneEJBQ0VRRE4wQkN3SkFJQTR0QUFCQkRVY05BQ0FBS0FJRUlRRWdBRUVBTmdJRUFrQWdBQ0FCSUE0UXNZQ0FnQUFpQVEwQUlBNUJBV29oQVF4MUN5QUFRU3cyQWh3Z0FDQUJOZ0lNSUFBZ0RrRUJhallDRkVFQUlSQU0zUUVMSUFBdEFDMUJBWEZGRFFGQnhBRWhFQXpEQVFzQ1FDQU9JQUpIRFFCQkxTRVFETndCQ3dKQUFrQURRQUpBSUE0dEFBQkJkbW9PQkFJQUFBTUFDeUFPUVFGcUlnNGdBa2NOQUF0QkxTRVFETjBCQ3lBQUtBSUVJUUVnQUVFQU5nSUVBa0FnQUNBQklBNFFzWUNBZ0FBaUFRMEFJQTRoQVF4MEN5QUFRU3cyQWh3Z0FDQU9OZ0lVSUFBZ0FUWUNERUVBSVJBTTNBRUxJQUFvQWdRaEFTQUFRUUEyQWdRQ1FDQUFJQUVnRGhDeGdJQ0FBQ0lCRFFBZ0RrRUJhaUVCREhNTElBQkJMRFlDSENBQUlBRTJBZ3dnQUNBT1FRRnFOZ0lVUVFBaEVBemJBUXNnQUNnQ0JDRUVJQUJCQURZQ0JDQUFJQVFnRGhDeGdJQ0FBQ0lFRGFBQklBNGhBUXpPQVFzZ0VFRXNSdzBCSUFGQkFXb2hFRUVCSVFFQ1FBSkFBa0FDUUFKQUlBQXRBQ3hCZTJvT0JBTUJBZ1FBQ3lBUUlRRU1CQXRCQWlFQkRBRUxRUVFoQVFzZ0FFRUJPZ0FzSUFBZ0FDOEJNQ0FCY2pzQk1DQVFJUUVNQVFzZ0FDQUFMd0V3UVFoeU93RXdJQkFoQVF0Qk9TRVFETDhCQ3lBQVFRQTZBQ3dnQVNFQkMwRTBJUkFNdlFFTElBQWdBQzhCTUVFZ2Nqc0JNQ0FCSVFFTUFnc2dBQ2dDQkNFRUlBQkJBRFlDQkFKQUlBQWdCQ0FCRUxHQWdJQUFJZ1FOQUNBQklRRU14d0VMSUFCQk56WUNIQ0FBSUFFMkFoUWdBQ0FFTmdJTVFRQWhFQXpVQVFzZ0FFRUlPZ0FzSUFFaEFRdEJNQ0VRRExrQkN3SkFJQUF0QUNoQkFVWU5BQ0FCSVFFTUJBc2dBQzBBTFVFSWNVVU5rd0VnQVNFQkRBTUxJQUF0QURCQklIRU5sQUZCeFFFaEVBeTNBUXNDUUNBUElBSkdEUUFDUUFOQUFrQWdEeTBBQUVGUWFpSUJRZjhCY1VFS1NRMEFJQThoQVVFMUlSQU11Z0VMSUFBcEF5QWlFVUtacytiTW1iUG16QmxXRFFFZ0FDQVJRZ3ArSWhFM0F5QWdFU0FCclVML0FZTWlFa0ovaFZZTkFTQUFJQkVnRW53M0F5QWdEMEVCYWlJUElBSkhEUUFMUVRraEVBelJBUXNnQUNnQ0JDRUNJQUJCQURZQ0JDQUFJQUlnRDBFQmFpSUVFTEdBZ0lBQUlnSU5sUUVnQkNFQkRNTUJDMEU1SVJBTXp3RUxBa0FnQUM4Qk1DSUJRUWh4UlEwQUlBQXRBQ2hCQVVjTkFDQUFMUUF0UVFoeFJRMlFBUXNnQUNBQlFmZjdBM0ZCZ0FSeU93RXdJQThoQVF0Qk55RVFETFFCQ3lBQUlBQXZBVEJCRUhJN0FUQU1xd0VMSUJCQkZVWU5pd0VnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZkNPZ0lBQU5nSVFJQUJCSERZQ0RFRUFJUkFNeXdFTElBQkJ3d0EyQWh3Z0FDQUJOZ0lNSUFBZ0RVRUJhallDRkVFQUlSQU15Z0VMQWtBZ0FTMEFBRUU2UncwQUlBQW9BZ1FoRUNBQVFRQTJBZ1FDUUNBQUlCQWdBUkN2Z0lDQUFDSVFEUUFnQVVFQmFpRUJER01MSUFCQnd3QTJBaHdnQUNBUU5nSU1JQUFnQVVFQmFqWUNGRUVBSVJBTXlnRUxJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR3hrWUNBQURZQ0VDQUFRUW8yQWd4QkFDRVFETWtCQ3lBQVFRQTJBaHdnQUNBQk5nSVVJQUJCb0ptQWdBQTJBaEFnQUVFZU5nSU1RUUFoRUF6SUFRc2dBRUVBTmdJQUN5QUFRWUFTT3dFcUlBQWdGMEVCYWlJQklBSVFxSUNBZ0FBaUVBMEJJQUVoQVF0Qnh3QWhFQXlzQVFzZ0VFRVZSdzJEQVNBQVFkRUFOZ0ljSUFBZ0FUWUNGQ0FBUWVPWGdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTXhBRUxJQUFvQWdRaEVDQUFRUUEyQWdRQ1FDQUFJQkFnQVJDbmdJQ0FBQ0lRRFFBZ0FTRUJERjRMSUFCQjBnQTJBaHdnQUNBQk5nSVVJQUFnRURZQ0RFRUFJUkFNd3dFTElBQkJBRFlDSENBQUlCUTJBaFFnQUVIQnFJQ0FBRFlDRUNBQVFRYzJBZ3dnQUVFQU5nSUFRUUFoRUF6Q0FRc2dBQ2dDQkNFUUlBQkJBRFlDQkFKQUlBQWdFQ0FCRUtlQWdJQUFJaEFOQUNBQklRRU1YUXNnQUVIVEFEWUNIQ0FBSUFFMkFoUWdBQ0FRTmdJTVFRQWhFQXpCQVF0QkFDRVFJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR0FrWUNBQURZQ0VDQUFRUWsyQWd3TXdBRUxJQkJCRlVZTmZTQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQmxJMkFnQUEyQWhBZ0FFRWhOZ0lNUVFBaEVBeS9BUXRCQVNFV1FRQWhGMEVBSVJSQkFTRVFDeUFBSUJBNkFDc2dBVUVCYWlFQkFrQUNRQ0FBTFFBdFFSQnhEUUFDUUFKQUFrQWdBQzBBS2c0REFRQUNCQXNnRmtVTkF3d0NDeUFVRFFFTUFnc2dGMFVOQVFzZ0FDZ0NCQ0VRSUFCQkFEWUNCQUpBSUFBZ0VDQUJFSzJBZ0lBQUloQU5BQ0FCSVFFTVhBc2dBRUhZQURZQ0hDQUFJQUUyQWhRZ0FDQVFOZ0lNUVFBaEVBeStBUXNnQUNnQ0JDRUVJQUJCQURZQ0JBSkFJQUFnQkNBQkVLMkFnSUFBSWdRTkFDQUJJUUVNclFFTElBQkIyUUEyQWh3Z0FDQUJOZ0lVSUFBZ0JEWUNERUVBSVJBTXZRRUxJQUFvQWdRaEJDQUFRUUEyQWdRQ1FDQUFJQVFnQVJDdGdJQ0FBQ0lFRFFBZ0FTRUJES3NCQ3lBQVFkb0FOZ0ljSUFBZ0FUWUNGQ0FBSUFRMkFneEJBQ0VRREx3QkN5QUFLQUlFSVFRZ0FFRUFOZ0lFQWtBZ0FDQUVJQUVRcllDQWdBQWlCQTBBSUFFaEFReXBBUXNnQUVIY0FEWUNIQ0FBSUFFMkFoUWdBQ0FFTmdJTVFRQWhFQXk3QVFzQ1FDQUJMUUFBUVZCcUloQkIvd0Z4UVFwUERRQWdBQ0FRT2dBcUlBRkJBV29oQVVIUEFDRVFES0lCQ3lBQUtBSUVJUVFnQUVFQU5nSUVBa0FnQUNBRUlBRVFyWUNBZ0FBaUJBMEFJQUVoQVF5bkFRc2dBRUhlQURZQ0hDQUFJQUUyQWhRZ0FDQUVOZ0lNUVFBaEVBeTZBUXNnQUVFQU5nSUFJQmRCQVdvaEFRSkFJQUF0QUNsQkkwOE5BQ0FCSVFFTVdRc2dBRUVBTmdJY0lBQWdBVFlDRkNBQVFkT0pnSUFBTmdJUUlBQkJDRFlDREVFQUlSQU11UUVMSUFCQkFEWUNBQXRCQUNFUUlBQkJBRFlDSENBQUlBRTJBaFFnQUVHUXM0Q0FBRFlDRUNBQVFRZzJBZ3dNdHdFTElBQkJBRFlDQUNBWFFRRnFJUUVDUUNBQUxRQXBRU0ZIRFFBZ0FTRUJERllMSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUdiaW9DQUFEWUNFQ0FBUVFnMkFneEJBQ0VRRExZQkN5QUFRUUEyQWdBZ0YwRUJhaUVCQWtBZ0FDMEFLU0lRUVYxcVFRdFBEUUFnQVNFQkRGVUxBa0FnRUVFR1N3MEFRUUVnRUhSQnlnQnhSUTBBSUFFaEFReFZDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWZlSmdJQUFOZ0lRSUFCQkNEWUNEQXkxQVFzZ0VFRVZSZzF4SUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUc1allDQUFEWUNFQ0FBUVJvMkFneEJBQ0VRRExRQkN5QUFLQUlFSVJBZ0FFRUFOZ0lFQWtBZ0FDQVFJQUVRcDRDQWdBQWlFQTBBSUFFaEFReFVDeUFBUWVVQU5nSWNJQUFnQVRZQ0ZDQUFJQkEyQWd4QkFDRVFETE1CQ3lBQUtBSUVJUkFnQUVFQU5nSUVBa0FnQUNBUUlBRVFwNENBZ0FBaUVBMEFJQUVoQVF4TkN5QUFRZElBTmdJY0lBQWdBVFlDRkNBQUlCQTJBZ3hCQUNFUURMSUJDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXA0Q0FnQUFpRUEwQUlBRWhBUXhOQ3lBQVFkTUFOZ0ljSUFBZ0FUWUNGQ0FBSUJBMkFneEJBQ0VRRExFQkN5QUFLQUlFSVJBZ0FFRUFOZ0lFQWtBZ0FDQVFJQUVRcDRDQWdBQWlFQTBBSUFFaEFReFJDeUFBUWVVQU5nSWNJQUFnQVRZQ0ZDQUFJQkEyQWd4QkFDRVFETEFCQ3lBQVFRQTJBaHdnQUNBQk5nSVVJQUJCeG9xQWdBQTJBaEFnQUVFSE5nSU1RUUFoRUF5dkFRc2dBQ2dDQkNFUUlBQkJBRFlDQkFKQUlBQWdFQ0FCRUtlQWdJQUFJaEFOQUNBQklRRU1TUXNnQUVIU0FEWUNIQ0FBSUFFMkFoUWdBQ0FRTmdJTVFRQWhFQXl1QVFzZ0FDZ0NCQ0VRSUFCQkFEWUNCQUpBSUFBZ0VDQUJFS2VBZ0lBQUloQU5BQ0FCSVFFTVNRc2dBRUhUQURZQ0hDQUFJQUUyQWhRZ0FDQVFOZ0lNUVFBaEVBeXRBUXNnQUNnQ0JDRVFJQUJCQURZQ0JBSkFJQUFnRUNBQkVLZUFnSUFBSWhBTkFDQUJJUUVNVFFzZ0FFSGxBRFlDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF5c0FRc2dBRUVBTmdJY0lBQWdBVFlDRkNBQVFkeUlnSUFBTmdJUUlBQkJCellDREVFQUlSQU1xd0VMSUJCQlAwY05BU0FCUVFGcUlRRUxRUVVoRUF5UUFRdEJBQ0VRSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUg5a29DQUFEWUNFQ0FBUVFjMkFnd01xQUVMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQ25nSUNBQUNJUURRQWdBU0VCREVJTElBQkIwZ0EyQWh3Z0FDQUJOZ0lVSUFBZ0VEWUNERUVBSVJBTXB3RUxJQUFvQWdRaEVDQUFRUUEyQWdRQ1FDQUFJQkFnQVJDbmdJQ0FBQ0lRRFFBZ0FTRUJERUlMSUFCQjB3QTJBaHdnQUNBQk5nSVVJQUFnRURZQ0RFRUFJUkFNcGdFTElBQW9BZ1FoRUNBQVFRQTJBZ1FDUUNBQUlCQWdBUkNuZ0lDQUFDSVFEUUFnQVNFQkRFWUxJQUJCNVFBMkFod2dBQ0FCTmdJVUlBQWdFRFlDREVFQUlSQU1wUUVMSUFBb0FnUWhBU0FBUVFBMkFnUUNRQ0FBSUFFZ0ZCQ25nSUNBQUNJQkRRQWdGQ0VCREQ4TElBQkIwZ0EyQWh3Z0FDQVVOZ0lVSUFBZ0FUWUNERUVBSVJBTXBBRUxJQUFvQWdRaEFTQUFRUUEyQWdRQ1FDQUFJQUVnRkJDbmdJQ0FBQ0lCRFFBZ0ZDRUJERDhMSUFCQjB3QTJBaHdnQUNBVU5nSVVJQUFnQVRZQ0RFRUFJUkFNb3dFTElBQW9BZ1FoQVNBQVFRQTJBZ1FDUUNBQUlBRWdGQkNuZ0lDQUFDSUJEUUFnRkNFQkRFTUxJQUJCNVFBMkFod2dBQ0FVTmdJVUlBQWdBVFlDREVFQUlSQU1vZ0VMSUFCQkFEWUNIQ0FBSUJRMkFoUWdBRUhEajRDQUFEWUNFQ0FBUVFjMkFneEJBQ0VRREtFQkN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQnc0K0FnQUEyQWhBZ0FFRUhOZ0lNUVFBaEVBeWdBUXRCQUNFUUlBQkJBRFlDSENBQUlCUTJBaFFnQUVHTW5JQ0FBRFlDRUNBQVFRYzJBZ3dNbndFTElBQkJBRFlDSENBQUlCUTJBaFFnQUVHTW5JQ0FBRFlDRUNBQVFRYzJBZ3hCQUNFUURKNEJDeUFBUVFBMkFod2dBQ0FVTmdJVUlBQkIvcEdBZ0FBMkFoQWdBRUVITmdJTVFRQWhFQXlkQVFzZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUVk2YmdJQUFOZ0lRSUFCQkJqWUNERUVBSVJBTW5BRUxJQkJCRlVZTlZ5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQnpJNkFnQUEyQWhBZ0FFRWdOZ0lNUVFBaEVBeWJBUXNnQUVFQU5nSUFJQkJCQVdvaEFVRWtJUkFMSUFBZ0VEb0FLU0FBS0FJRUlSQWdBRUVBTmdJRUlBQWdFQ0FCRUt1QWdJQUFJaEFOVkNBQklRRU1QZ3NnQUVFQU5nSUFDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0JEWUNGQ0FBUWZHYmdJQUFOZ0lRSUFCQkJqWUNEQXlYQVFzZ0FVRVZSZzFRSUFCQkFEWUNIQ0FBSUFVMkFoUWdBRUh3aklDQUFEWUNFQ0FBUVJzMkFneEJBQ0VRREpZQkN5QUFLQUlFSVFVZ0FFRUFOZ0lFSUFBZ0JTQVFFS21BZ0lBQUlnVU5BU0FRUVFGcUlRVUxRYTBCSVJBTWV3c2dBRUhCQVRZQ0hDQUFJQVUyQWd3Z0FDQVFRUUZxTmdJVVFRQWhFQXlUQVFzZ0FDZ0NCQ0VHSUFCQkFEWUNCQ0FBSUFZZ0VCQ3BnSUNBQUNJR0RRRWdFRUVCYWlFR0MwR3VBU0VRREhnTElBQkJ3Z0UyQWh3Z0FDQUdOZ0lNSUFBZ0VFRUJhallDRkVFQUlSQU1rQUVMSUFCQkFEWUNIQ0FBSUFjMkFoUWdBRUdYaTRDQUFEWUNFQ0FBUVEwMkFneEJBQ0VRREk4QkN5QUFRUUEyQWh3Z0FDQUlOZ0lVSUFCQjQ1Q0FnQUEyQWhBZ0FFRUpOZ0lNUVFBaEVBeU9BUXNnQUVFQU5nSWNJQUFnQ0RZQ0ZDQUFRWlNOZ0lBQU5nSVFJQUJCSVRZQ0RFRUFJUkFNalFFTFFRRWhGa0VBSVJkQkFDRVVRUUVoRUFzZ0FDQVFPZ0FySUFsQkFXb2hDQUpBQWtBZ0FDMEFMVUVRY1EwQUFrQUNRQUpBSUFBdEFDb09Bd0VBQWdRTElCWkZEUU1NQWdzZ0ZBMEJEQUlMSUJkRkRRRUxJQUFvQWdRaEVDQUFRUUEyQWdRZ0FDQVFJQWdRcllDQWdBQWlFRVVOUFNBQVFja0JOZ0ljSUFBZ0NEWUNGQ0FBSUJBMkFneEJBQ0VRREl3QkN5QUFLQUlFSVFRZ0FFRUFOZ0lFSUFBZ0JDQUlFSzJBZ0lBQUlnUkZEWFlnQUVIS0FUWUNIQ0FBSUFnMkFoUWdBQ0FFTmdJTVFRQWhFQXlMQVFzZ0FDZ0NCQ0VFSUFCQkFEWUNCQ0FBSUFRZ0NSQ3RnSUNBQUNJRVJRMTBJQUJCeXdFMkFod2dBQ0FKTmdJVUlBQWdCRFlDREVFQUlSQU1pZ0VMSUFBb0FnUWhCQ0FBUVFBMkFnUWdBQ0FFSUFvUXJZQ0FnQUFpQkVVTmNpQUFRYzBCTmdJY0lBQWdDallDRkNBQUlBUTJBZ3hCQUNFUURJa0JDd0pBSUFzdEFBQkJVR29pRUVIL0FYRkJDazhOQUNBQUlCQTZBQ29nQzBFQmFpRUtRYllCSVJBTWNBc2dBQ2dDQkNFRUlBQkJBRFlDQkNBQUlBUWdDeEN0Z0lDQUFDSUVSUTF3SUFCQnp3RTJBaHdnQUNBTE5nSVVJQUFnQkRZQ0RFRUFJUkFNaUFFTElBQkJBRFlDSENBQUlBUTJBaFFnQUVHUXM0Q0FBRFlDRUNBQVFRZzJBZ3dnQUVFQU5nSUFRUUFoRUF5SEFRc2dBVUVWUmcwL0lBQkJBRFlDSENBQUlBdzJBaFFnQUVITWpvQ0FBRFlDRUNBQVFTQTJBZ3hCQUNFUURJWUJDeUFBUVlFRU93RW9JQUFvQWdRaEVDQUFRZ0EzQXdBZ0FDQVFJQXhCQVdvaURCQ3JnSUNBQUNJUVJRMDRJQUJCMHdFMkFod2dBQ0FNTmdJVUlBQWdFRFlDREVFQUlSQU1oUUVMSUFCQkFEWUNBQXRCQUNFUUlBQkJBRFlDSENBQUlBUTJBaFFnQUVIWW00Q0FBRFlDRUNBQVFRZzJBZ3dNZ3dFTElBQW9BZ1FoRUNBQVFnQTNBd0FnQUNBUUlBdEJBV29pQ3hDcmdJQ0FBQ0lRRFFGQnhnRWhFQXhwQ3lBQVFRSTZBQ2dNVlFzZ0FFSFZBVFlDSENBQUlBczJBaFFnQUNBUU5nSU1RUUFoRUF5QUFRc2dFRUVWUmcwM0lBQkJBRFlDSENBQUlBUTJBaFFnQUVHa2pJQ0FBRFlDRUNBQVFSQTJBZ3hCQUNFUURIOExJQUF0QURSQkFVY05OQ0FBSUFRZ0FoQzhnSUNBQUNJUVJRMDBJQkJCRlVjTk5TQUFRZHdCTmdJY0lBQWdCRFlDRkNBQVFkV1dnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1mZ3RCQUNFUUlBQkJBRFlDSENBQVFhK0xnSUFBTmdJUUlBQkJBallDRENBQUlCUkJBV28yQWhRTWZRdEJBQ0VRREdNTFFRSWhFQXhpQzBFTklSQU1ZUXRCRHlFUURHQUxRU1VoRUF4ZkMwRVRJUkFNWGd0QkZTRVFERjBMUVJZaEVBeGNDMEVYSVJBTVd3dEJHQ0VRREZvTFFSa2hFQXhaQzBFYUlSQU1XQXRCR3lFUURGY0xRUndoRUF4V0MwRWRJUkFNVlF0Qkh5RVFERlFMUVNFaEVBeFRDMEVqSVJBTVVndEJ4Z0FoRUF4UkMwRXVJUkFNVUF0Qkx5RVFERThMUVRzaEVBeE9DMEU5SVJBTVRRdEJ5QUFoRUF4TUMwSEpBQ0VRREVzTFFjc0FJUkFNU2d0QnpBQWhFQXhKQzBIT0FDRVFERWdMUWRFQUlSQU1Sd3RCMVFBaEVBeEdDMEhZQUNFUURFVUxRZGtBSVJBTVJBdEIyd0FoRUF4REMwSGtBQ0VRREVJTFFlVUFJUkFNUVF0QjhRQWhFQXhBQzBIMEFDRVFERDhMUVkwQklSQU1QZ3RCbHdFaEVBdzlDMEdwQVNFUUREd0xRYXdCSVJBTU93dEJ3QUVoRUF3NkMwRzVBU0VRRERrTFFhOEJJUkFNT0F0QnNRRWhFQXczQzBHeUFTRVFERFlMUWJRQklSQU1OUXRCdFFFaEVBdzBDMEc2QVNFUURETUxRYjBCSVJBTU1ndEJ2d0VoRUF3eEMwSEJBU0VRRERBTElBQkJBRFlDSENBQUlBUTJBaFFnQUVIcGk0Q0FBRFlDRUNBQVFSODJBZ3hCQUNFUURFZ0xJQUJCMndFMkFod2dBQ0FFTmdJVUlBQkIrcGFBZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXhIQ3lBQVFmZ0FOZ0ljSUFBZ0REWUNGQ0FBUWNxWWdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTVJnc2dBRUhSQURZQ0hDQUFJQVUyQWhRZ0FFR3dsNENBQURZQ0VDQUFRUlUyQWd4QkFDRVFERVVMSUFCQitRQTJBaHdnQUNBQk5nSVVJQUFnRURZQ0RFRUFJUkFNUkFzZ0FFSDRBRFlDSENBQUlBRTJBaFFnQUVIS21JQ0FBRFlDRUNBQVFSVTJBZ3hCQUNFUURFTUxJQUJCNUFBMkFod2dBQ0FCTmdJVUlBQkI0NWVBZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXhDQ3lBQVFkY0FOZ0ljSUFBZ0FUWUNGQ0FBUWNtWGdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTVFRc2dBRUVBTmdJY0lBQWdBVFlDRkNBQVFibU5nSUFBTmdJUUlBQkJHallDREVFQUlSQU1RQXNnQUVIQ0FEWUNIQ0FBSUFFMkFoUWdBRUhqbUlDQUFEWUNFQ0FBUVJVMkFneEJBQ0VRREQ4TElBQkJBRFlDQkNBQUlBOGdEeEN4Z0lDQUFDSUVSUTBCSUFCQk9qWUNIQ0FBSUFRMkFnd2dBQ0FQUVFGcU5nSVVRUUFoRUF3K0N5QUFLQUlFSVFRZ0FFRUFOZ0lFQWtBZ0FDQUVJQUVRc1lDQWdBQWlCRVVOQUNBQVFUczJBaHdnQUNBRU5nSU1JQUFnQVVFQmFqWUNGRUVBSVJBTVBnc2dBVUVCYWlFQkRDMExJQTlCQVdvaEFRd3RDeUFBUVFBMkFod2dBQ0FQTmdJVUlBQkI1SktBZ0FBMkFoQWdBRUVFTmdJTVFRQWhFQXc3Q3lBQVFUWTJBaHdnQUNBRU5nSVVJQUFnQWpZQ0RFRUFJUkFNT2dzZ0FFRXVOZ0ljSUFBZ0RqWUNGQ0FBSUFRMkFneEJBQ0VRRERrTElBQkIwQUEyQWh3Z0FDQUJOZ0lVSUFCQmtaaUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBdzRDeUFOUVFGcUlRRU1MQXNnQUVFVk5nSWNJQUFnQVRZQ0ZDQUFRWUtaZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNTmdzZ0FFRWJOZ0ljSUFBZ0FUWUNGQ0FBUVpHWGdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTU5Rc2dBRUVQTmdJY0lBQWdBVFlDRkNBQVFaR1hnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1OQXNnQUVFTE5nSWNJQUFnQVRZQ0ZDQUFRWkdYZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNTXdzZ0FFRWFOZ0ljSUFBZ0FUWUNGQ0FBUVlLWmdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTU1nc2dBRUVMTmdJY0lBQWdBVFlDRkNBQVFZS1pnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1NUXNnQUVFS05nSWNJQUFnQVRZQ0ZDQUFRZVNXZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNTUFzZ0FFRWVOZ0ljSUFBZ0FUWUNGQ0FBUWZtWGdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTUx3c2dBRUVBTmdJY0lBQWdFRFlDRkNBQVFkcU5nSUFBTmdJUUlBQkJGRFlDREVFQUlSQU1MZ3NnQUVFRU5nSWNJQUFnQVRZQ0ZDQUFRYkNZZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNTFFzZ0FFRUFOZ0lBSUF0QkFXb2hDd3RCdUFFaEVBd1NDeUFBUVFBMkFnQWdFRUVCYWlFQlFmVUFJUkFNRVFzZ0FTRUJBa0FnQUMwQUtVRUZSdzBBUWVNQUlSQU1FUXRCNGdBaEVBd1FDMEVBSVJBZ0FFRUFOZ0ljSUFCQjVKR0FnQUEyQWhBZ0FFRUhOZ0lNSUFBZ0ZFRUJhallDRkF3b0N5QUFRUUEyQWdBZ0YwRUJhaUVCUWNBQUlSQU1EZ3RCQVNFQkN5QUFJQUU2QUN3Z0FFRUFOZ0lBSUJkQkFXb2hBUXRCS0NFUURBc0xJQUVoQVF0Qk9DRVFEQWtMQWtBZ0FTSVBJQUpHRFFBRFFBSkFJQTh0QUFCQmdMNkFnQUJxTFFBQUlnRkJBVVlOQUNBQlFRSkhEUU1nRDBFQmFpRUJEQVFMSUE5QkFXb2lEeUFDUncwQUMwRStJUkFNSWd0QlBpRVFEQ0VMSUFCQkFEb0FMQ0FQSVFFTUFRdEJDeUVRREFZTFFUb2hFQXdGQ3lBQlFRRnFJUUZCTFNFUURBUUxJQUFnQVRvQUxDQUFRUUEyQWdBZ0ZrRUJhaUVCUVF3aEVBd0RDeUFBUVFBMkFnQWdGMEVCYWlFQlFRb2hFQXdDQ3lBQVFRQTJBZ0FMSUFCQkFEb0FMQ0FOSVFGQkNTRVFEQUFMQzBFQUlSQWdBRUVBTmdJY0lBQWdDellDRkNBQVFjMlFnSUFBTmdJUUlBQkJDVFlDREF3WEMwRUFJUkFnQUVFQU5nSWNJQUFnQ2pZQ0ZDQUFRZW1LZ0lBQU5nSVFJQUJCQ1RZQ0RBd1dDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0NUWUNGQ0FBUWJlUWdJQUFOZ0lRSUFCQkNUWUNEQXdWQzBFQUlSQWdBRUVBTmdJY0lBQWdDRFlDRkNBQVFaeVJnSUFBTmdJUUlBQkJDVFlDREF3VUMwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRYzJRZ0lBQU5nSVFJQUJCQ1RZQ0RBd1RDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWVtS2dJQUFOZ0lRSUFCQkNUWUNEQXdTQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFiZVFnSUFBTmdJUUlBQkJDVFlDREF3UkMwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRWnlSZ0lBQU5nSVFJQUJCQ1RZQ0RBd1FDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUVplVmdJQUFOZ0lRSUFCQkR6WUNEQXdQQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFaZVZnSUFBTmdJUUlBQkJEellDREF3T0MwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRY0NTZ0lBQU5nSVFJQUJCQ3pZQ0RBd05DMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUVpXSmdJQUFOZ0lRSUFCQkN6WUNEQXdNQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFlR1BnSUFBTmdJUUlBQkJDallDREF3TEMwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZnVQZ0lBQU5nSVFJQUJCQ2pZQ0RBd0tDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWZHWmdJQUFOZ0lRSUFCQkFqWUNEQXdKQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFjU1VnSUFBTmdJUUlBQkJBallDREF3SUMwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZktWZ0lBQU5nSVFJQUJCQWpZQ0RBd0hDeUFBUVFJMkFod2dBQ0FCTmdJVUlBQkJuSnFBZ0FBMkFoQWdBRUVXTmdJTVFRQWhFQXdHQzBFQklSQU1CUXRCMUFBaEVDQUJJZ1FnQWtZTkJDQURRUWhxSUFBZ0JDQUNRZGpDZ0lBQVFRb1F4WUNBZ0FBZ0F5Z0NEQ0VFSUFNb0FnZ09Bd0VFQWdBTEVNcUFnSUFBQUFzZ0FFRUFOZ0ljSUFCQnRacUFnQUEyQWhBZ0FFRVhOZ0lNSUFBZ0JFRUJhallDRkVFQUlSQU1BZ3NnQUVFQU5nSWNJQUFnQkRZQ0ZDQUFRY3FhZ0lBQU5nSVFJQUJCQ1RZQ0RFRUFJUkFNQVFzQ1FDQUJJZ1FnQWtjTkFFRWlJUkFNQVFzZ0FFR0pnSUNBQURZQ0NDQUFJQVEyQWdSQklTRVFDeUFEUVJCcUpJQ0FnSUFBSUJBTHJ3RUJBbjhnQVNnQ0FDRUdBa0FDUUNBQ0lBTkdEUUFnQkNBR2FpRUVJQVlnQTJvZ0Ftc2hCeUFDSUFaQmYzTWdCV29pQm1vaEJRTkFBa0FnQWkwQUFDQUVMUUFBUmcwQVFRSWhCQXdEQ3dKQUlBWU5BRUVBSVFRZ0JTRUNEQU1MSUFaQmYyb2hCaUFFUVFGcUlRUWdBa0VCYWlJQ0lBTkhEUUFMSUFjaEJpQURJUUlMSUFCQkFUWUNBQ0FCSUFZMkFnQWdBQ0FDTmdJRUR3c2dBVUVBTmdJQUlBQWdCRFlDQUNBQUlBSTJBZ1FMQ2dBZ0FCREhnSUNBQUF2eU5nRUxmeU9BZ0lDQUFFRVFheUlCSklDQWdJQUFBa0JCQUNnQ29OQ0FnQUFOQUVFQUVNdUFnSUFBUVlEVWhJQUFheUlDUWRrQVNRMEFRUUFoQXdKQVFRQW9BdURUZ0lBQUlnUU5BRUVBUW44M0F1elRnSUFBUVFCQ2dJQ0VnSUNBd0FBM0F1VFRnSUFBUVFBZ0FVRUlha0Z3Y1VIWXF0V3FCWE1pQkRZQzROT0FnQUJCQUVFQU5nTDAwNENBQUVFQVFRQTJBc1RUZ0lBQUMwRUFJQUkyQXN6VGdJQUFRUUJCZ05TRWdBQTJBc2pUZ0lBQVFRQkJnTlNFZ0FBMkFwalFnSUFBUVFBZ0JEWUNyTkNBZ0FCQkFFRi9OZ0tvMElDQUFBTkFJQU5CeE5DQWdBQnFJQU5CdU5DQWdBQnFJZ1EyQWdBZ0JDQURRYkRRZ0lBQWFpSUZOZ0lBSUFOQnZOQ0FnQUJxSUFVMkFnQWdBMEhNMElDQUFHb2dBMEhBMElDQUFHb2lCVFlDQUNBRklBUTJBZ0FnQTBIVTBJQ0FBR29nQTBISTBJQ0FBR29pQkRZQ0FDQUVJQVUyQWdBZ0EwSFEwSUNBQUdvZ0JEWUNBQ0FEUVNCcUlnTkJnQUpIRFFBTFFZRFVoSUFBUVhoQmdOU0VnQUJyUVE5eFFRQkJnTlNFZ0FCQkNHcEJEM0ViSWdOcUlnUkJCR29nQWtGSWFpSUZJQU5ySWdOQkFYSTJBZ0JCQUVFQUtBTHcwNENBQURZQ3BOQ0FnQUJCQUNBRE5nS1UwSUNBQUVFQUlBUTJBcURRZ0lBQVFZRFVoSUFBSUFWcVFUZzJBZ1FMQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUJCN0FGTERRQUNRRUVBS0FLSTBJQ0FBQ0lHUVJBZ0FFRVRha0Z3Y1NBQVFRdEpHeUlDUVFOMklnUjJJZ05CQTNGRkRRQUNRQUpBSUFOQkFYRWdCSEpCQVhNaUJVRURkQ0lFUWJEUWdJQUFhaUlESUFSQnVOQ0FnQUJxS0FJQUlnUW9BZ2dpQWtjTkFFRUFJQVpCZmlBRmQzRTJBb2pRZ0lBQURBRUxJQU1nQWpZQ0NDQUNJQU0yQWd3TElBUkJDR29oQXlBRUlBVkJBM1FpQlVFRGNqWUNCQ0FFSUFWcUlnUWdCQ2dDQkVFQmNqWUNCQXdNQ3lBQ1FRQW9BcERRZ0lBQUlnZE5EUUVDUUNBRFJRMEFBa0FDUUNBRElBUjBRUUlnQkhRaUEwRUFJQU5yY25FaUEwRUFJQU5yY1VGL2FpSURJQU5CREhaQkVIRWlBM1lpQkVFRmRrRUljU0lGSUFOeUlBUWdCWFlpQTBFQ2RrRUVjU0lFY2lBRElBUjJJZ05CQVhaQkFuRWlCSElnQXlBRWRpSURRUUYyUVFGeElnUnlJQU1nQkhacUlnUkJBM1FpQTBHdzBJQ0FBR29pQlNBRFFialFnSUFBYWlnQ0FDSURLQUlJSWdCSERRQkJBQ0FHUVg0Z0JIZHhJZ1kyQW9qUWdJQUFEQUVMSUFVZ0FEWUNDQ0FBSUFVMkFnd0xJQU1nQWtFRGNqWUNCQ0FESUFSQkEzUWlCR29nQkNBQ2F5SUZOZ0lBSUFNZ0Ftb2lBQ0FGUVFGeU5nSUVBa0FnQjBVTkFDQUhRWGh4UWJEUWdJQUFhaUVDUVFBb0FwelFnSUFBSVFRQ1FBSkFJQVpCQVNBSFFRTjJkQ0lJY1EwQVFRQWdCaUFJY2pZQ2lOQ0FnQUFnQWlFSURBRUxJQUlvQWdnaENBc2dDQ0FFTmdJTUlBSWdCRFlDQ0NBRUlBSTJBZ3dnQkNBSU5nSUlDeUFEUVFocUlRTkJBQ0FBTmdLYzBJQ0FBRUVBSUFVMkFwRFFnSUFBREF3TFFRQW9Bb3pRZ0lBQUlnbEZEUUVnQ1VFQUlBbHJjVUYvYWlJRElBTkJESFpCRUhFaUEzWWlCRUVGZGtFSWNTSUZJQU55SUFRZ0JYWWlBMEVDZGtFRWNTSUVjaUFESUFSMklnTkJBWFpCQW5FaUJISWdBeUFFZGlJRFFRRjJRUUZ4SWdSeUlBTWdCSFpxUVFKMFFialNnSUFBYWlnQ0FDSUFLQUlFUVhoeElBSnJJUVFnQUNFRkFrQURRQUpBSUFVb0FoQWlBdzBBSUFWQkZHb29BZ0FpQTBVTkFnc2dBeWdDQkVGNGNTQUNheUlGSUFRZ0JTQUVTU0lGR3lFRUlBTWdBQ0FGR3lFQUlBTWhCUXdBQ3dzZ0FDZ0NHQ0VLQWtBZ0FDZ0NEQ0lJSUFCR0RRQWdBQ2dDQ0NJRFFRQW9BcGpRZ0lBQVNSb2dDQ0FETmdJSUlBTWdDRFlDREF3TEN3SkFJQUJCRkdvaUJTZ0NBQ0lERFFBZ0FDZ0NFQ0lEUlEwRElBQkJFR29oQlFzRFFDQUZJUXNnQXlJSVFSUnFJZ1VvQWdBaUF3MEFJQWhCRUdvaEJTQUlLQUlRSWdNTkFBc2dDMEVBTmdJQURBb0xRWDhoQWlBQVFiOS9TdzBBSUFCQkUyb2lBMEZ3Y1NFQ1FRQW9Bb3pRZ0lBQUlnZEZEUUJCQUNFTEFrQWdBa0dBQWtrTkFFRWZJUXNnQWtILy8vOEhTdzBBSUFOQkNIWWlBeUFEUVlEK1AycEJFSFpCQ0hFaUEzUWlCQ0FFUVlEZ0gycEJFSFpCQkhFaUJIUWlCU0FGUVlDQUQycEJFSFpCQW5FaUJYUkJEM1lnQXlBRWNpQUZjbXNpQTBFQmRDQUNJQU5CRldwMlFRRnhja0VjYWlFTEMwRUFJQUpySVFRQ1FBSkFBa0FDUUNBTFFRSjBRYmpTZ0lBQWFpZ0NBQ0lGRFFCQkFDRURRUUFoQ0F3QkMwRUFJUU1nQWtFQVFSa2dDMEVCZG1zZ0MwRWZSaHQwSVFCQkFDRUlBMEFDUUNBRktBSUVRWGh4SUFKcklnWWdCRThOQUNBR0lRUWdCU0VJSUFZTkFFRUFJUVFnQlNFSUlBVWhBd3dEQ3lBRElBVkJGR29vQWdBaUJpQUdJQVVnQUVFZGRrRUVjV3BCRUdvb0FnQWlCVVliSUFNZ0Joc2hBeUFBUVFGMElRQWdCUTBBQ3dzQ1FDQURJQWh5RFFCQkFDRUlRUUlnQzNRaUEwRUFJQU5yY2lBSGNTSURSUTBESUFOQkFDQURhM0ZCZjJvaUF5QURRUXgyUVJCeElnTjJJZ1ZCQlhaQkNIRWlBQ0FEY2lBRklBQjJJZ05CQW5aQkJIRWlCWElnQXlBRmRpSURRUUYyUVFKeElnVnlJQU1nQlhZaUEwRUJka0VCY1NJRmNpQURJQVYyYWtFQ2RFRzQwb0NBQUdvb0FnQWhBd3NnQTBVTkFRc0RRQ0FES0FJRVFYaHhJQUpySWdZZ0JFa2hBQUpBSUFNb0FoQWlCUTBBSUFOQkZHb29BZ0FoQlFzZ0JpQUVJQUFiSVFRZ0F5QUlJQUFiSVFnZ0JTRURJQVVOQUFzTElBaEZEUUFnQkVFQUtBS1EwSUNBQUNBQ2EwOE5BQ0FJS0FJWUlRc0NRQ0FJS0FJTUlnQWdDRVlOQUNBSUtBSUlJZ05CQUNnQ21OQ0FnQUJKR2lBQUlBTTJBZ2dnQXlBQU5nSU1EQWtMQWtBZ0NFRVVhaUlGS0FJQUlnTU5BQ0FJS0FJUUlnTkZEUU1nQ0VFUWFpRUZDd05BSUFVaEJpQURJZ0JCRkdvaUJTZ0NBQ0lERFFBZ0FFRVFhaUVGSUFBb0FoQWlBdzBBQ3lBR1FRQTJBZ0FNQ0FzQ1FFRUFLQUtRMElDQUFDSURJQUpKRFFCQkFDZ0NuTkNBZ0FBaEJBSkFBa0FnQXlBQ2F5SUZRUkJKRFFBZ0JDQUNhaUlBSUFWQkFYSTJBZ1JCQUNBRk5nS1EwSUNBQUVFQUlBQTJBcHpRZ0lBQUlBUWdBMm9nQlRZQ0FDQUVJQUpCQTNJMkFnUU1BUXNnQkNBRFFRTnlOZ0lFSUFRZ0Eyb2lBeUFES0FJRVFRRnlOZ0lFUVFCQkFEWUNuTkNBZ0FCQkFFRUFOZ0tRMElDQUFBc2dCRUVJYWlFRERBb0xBa0JCQUNnQ2xOQ0FnQUFpQUNBQ1RRMEFRUUFvQXFEUWdJQUFJZ01nQW1vaUJDQUFJQUpySWdWQkFYSTJBZ1JCQUNBRk5nS1UwSUNBQUVFQUlBUTJBcURRZ0lBQUlBTWdBa0VEY2pZQ0JDQURRUWhxSVFNTUNnc0NRQUpBUVFBb0F1RFRnSUFBUlEwQVFRQW9BdWpUZ0lBQUlRUU1BUXRCQUVKL053THMwNENBQUVFQVFvQ0FoSUNBZ01BQU53TGswNENBQUVFQUlBRkJER3BCY0hGQjJLclZxZ1Z6TmdMZzA0Q0FBRUVBUVFBMkF2VFRnSUFBUVFCQkFEWUN4Tk9BZ0FCQmdJQUVJUVFMUVFBaEF3SkFJQVFnQWtISEFHb2lCMm9pQmtFQUlBUnJJZ3R4SWdnZ0Frc05BRUVBUVRBMkF2alRnSUFBREFvTEFrQkJBQ2dDd05PQWdBQWlBMFVOQUFKQVFRQW9BcmpUZ0lBQUlnUWdDR29pQlNBRVRRMEFJQVVnQTAwTkFRdEJBQ0VEUVFCQk1EWUMrTk9BZ0FBTUNndEJBQzBBeE5PQWdBQkJCSEVOQkFKQUFrQUNRRUVBS0FLZzBJQ0FBQ0lFUlEwQVFjalRnSUFBSVFNRFFBSkFJQU1vQWdBaUJTQUVTdzBBSUFVZ0F5Z0NCR29nQkVzTkF3c2dBeWdDQ0NJRERRQUxDMEVBRU11QWdJQUFJZ0JCZjBZTkJTQUlJUVlDUUVFQUtBTGswNENBQUNJRFFYOXFJZ1FnQUhGRkRRQWdDQ0FBYXlBRUlBQnFRUUFnQTJ0eGFpRUdDeUFHSUFKTkRRVWdCa0grLy8vL0Iwc05CUUpBUVFBb0FzRFRnSUFBSWdORkRRQkJBQ2dDdU5PQWdBQWlCQ0FHYWlJRklBUk5EUVlnQlNBRFN3MEdDeUFHRU11QWdJQUFJZ01nQUVjTkFRd0hDeUFHSUFCcklBdHhJZ1pCL3YvLy93ZExEUVFnQmhETGdJQ0FBQ0lBSUFNb0FnQWdBeWdDQkdwR0RRTWdBQ0VEQ3dKQUlBTkJmMFlOQUNBQ1FjZ0FhaUFHVFEwQUFrQWdCeUFHYTBFQUtBTG8wNENBQUNJRWFrRUFJQVJyY1NJRVFmNy8vLzhIVFEwQUlBTWhBQXdIQ3dKQUlBUVF5NENBZ0FCQmYwWU5BQ0FFSUFacUlRWWdBeUVBREFjTFFRQWdCbXNReTRDQWdBQWFEQVFMSUFNaEFDQURRWDlIRFFVTUF3dEJBQ0VJREFjTFFRQWhBQXdGQ3lBQVFYOUhEUUlMUVFCQkFDZ0N4Tk9BZ0FCQkJISTJBc1RUZ0lBQUN5QUlRZjcvLy84SFN3MEJJQWdReTRDQWdBQWhBRUVBRU11QWdJQUFJUU1nQUVGL1JnMEJJQU5CZjBZTkFTQUFJQU5QRFFFZ0F5QUFheUlHSUFKQk9HcE5EUUVMUVFCQkFDZ0N1Tk9BZ0FBZ0Jtb2lBellDdU5PQWdBQUNRQ0FEUVFBb0FyelRnSUFBVFEwQVFRQWdBellDdk5PQWdBQUxBa0FDUUFKQUFrQkJBQ2dDb05DQWdBQWlCRVVOQUVISTA0Q0FBQ0VEQTBBZ0FDQURLQUlBSWdVZ0F5Z0NCQ0lJYWtZTkFpQURLQUlJSWdNTkFBd0RDd3NDUUFKQVFRQW9BcGpRZ0lBQUlnTkZEUUFnQUNBRFR3MEJDMEVBSUFBMkFwalFnSUFBQzBFQUlRTkJBQ0FHTmdMTTA0Q0FBRUVBSUFBMkFzalRnSUFBUVFCQmZ6WUNxTkNBZ0FCQkFFRUFLQUxnMDRDQUFEWUNyTkNBZ0FCQkFFRUFOZ0xVMDRDQUFBTkFJQU5CeE5DQWdBQnFJQU5CdU5DQWdBQnFJZ1EyQWdBZ0JDQURRYkRRZ0lBQWFpSUZOZ0lBSUFOQnZOQ0FnQUJxSUFVMkFnQWdBMEhNMElDQUFHb2dBMEhBMElDQUFHb2lCVFlDQUNBRklBUTJBZ0FnQTBIVTBJQ0FBR29nQTBISTBJQ0FBR29pQkRZQ0FDQUVJQVUyQWdBZ0EwSFEwSUNBQUdvZ0JEWUNBQ0FEUVNCcUlnTkJnQUpIRFFBTElBQkJlQ0FBYTBFUGNVRUFJQUJCQ0dwQkQzRWJJZ05xSWdRZ0JrRklhaUlGSUFOcklnTkJBWEkyQWdSQkFFRUFLQUx3MDRDQUFEWUNwTkNBZ0FCQkFDQUROZ0tVMElDQUFFRUFJQVEyQXFEUWdJQUFJQUFnQldwQk9EWUNCQXdDQ3lBRExRQU1RUWh4RFFBZ0JDQUZTUTBBSUFRZ0FFOE5BQ0FFUVhnZ0JHdEJEM0ZCQUNBRVFRaHFRUTl4R3lJRmFpSUFRUUFvQXBUUWdJQUFJQVpxSWdzZ0JXc2lCVUVCY2pZQ0JDQURJQWdnQm1vMkFnUkJBRUVBS0FMdzA0Q0FBRFlDcE5DQWdBQkJBQ0FGTmdLVTBJQ0FBRUVBSUFBMkFxRFFnSUFBSUFRZ0MycEJPRFlDQkF3QkN3SkFJQUJCQUNnQ21OQ0FnQUFpQ0U4TkFFRUFJQUEyQXBqUWdJQUFJQUFoQ0FzZ0FDQUdhaUVGUWNqVGdJQUFJUU1DUUFKQUFrQUNRQUpBQWtBQ1FBTkFJQU1vQWdBZ0JVWU5BU0FES0FJSUlnTU5BQXdDQ3dzZ0F5MEFERUVJY1VVTkFRdEJ5Tk9BZ0FBaEF3TkFBa0FnQXlnQ0FDSUZJQVJMRFFBZ0JTQURLQUlFYWlJRklBUkxEUU1MSUFNb0FnZ2hBd3dBQ3dzZ0F5QUFOZ0lBSUFNZ0F5Z0NCQ0FHYWpZQ0JDQUFRWGdnQUd0QkQzRkJBQ0FBUVFocVFROXhHMm9pQ3lBQ1FRTnlOZ0lFSUFWQmVDQUZhMEVQY1VFQUlBVkJDR3BCRDNFYmFpSUdJQXNnQW1vaUFtc2hBd0pBSUFZZ0JFY05BRUVBSUFJMkFxRFFnSUFBUVFCQkFDZ0NsTkNBZ0FBZ0Eyb2lBellDbE5DQWdBQWdBaUFEUVFGeU5nSUVEQU1MQWtBZ0JrRUFLQUtjMElDQUFFY05BRUVBSUFJMkFwelFnSUFBUVFCQkFDZ0NrTkNBZ0FBZ0Eyb2lBellDa05DQWdBQWdBaUFEUVFGeU5nSUVJQUlnQTJvZ0F6WUNBQXdEQ3dKQUlBWW9BZ1FpQkVFRGNVRUJSdzBBSUFSQmVIRWhCd0pBQWtBZ0JFSC9BVXNOQUNBR0tBSUlJZ1VnQkVFRGRpSUlRUU4wUWJEUWdJQUFhaUlBUmhvQ1FDQUdLQUlNSWdRZ0JVY05BRUVBUVFBb0FvalFnSUFBUVg0Z0NIZHhOZ0tJMElDQUFBd0NDeUFFSUFCR0dpQUVJQVUyQWdnZ0JTQUVOZ0lNREFFTElBWW9BaGdoQ1FKQUFrQWdCaWdDRENJQUlBWkdEUUFnQmlnQ0NDSUVJQWhKR2lBQUlBUTJBZ2dnQkNBQU5nSU1EQUVMQWtBZ0JrRVVhaUlFS0FJQUlnVU5BQ0FHUVJCcUlnUW9BZ0FpQlEwQVFRQWhBQXdCQ3dOQUlBUWhDQ0FGSWdCQkZHb2lCQ2dDQUNJRkRRQWdBRUVRYWlFRUlBQW9BaEFpQlEwQUN5QUlRUUEyQWdBTElBbEZEUUFDUUFKQUlBWWdCaWdDSENJRlFRSjBRYmpTZ0lBQWFpSUVLQUlBUncwQUlBUWdBRFlDQUNBQURRRkJBRUVBS0FLTTBJQ0FBRUYrSUFWM2NUWUNqTkNBZ0FBTUFnc2dDVUVRUVJRZ0NTZ0NFQ0FHUmh0cUlBQTJBZ0FnQUVVTkFRc2dBQ0FKTmdJWUFrQWdCaWdDRUNJRVJRMEFJQUFnQkRZQ0VDQUVJQUEyQWhnTElBWW9BaFFpQkVVTkFDQUFRUlJxSUFRMkFnQWdCQ0FBTmdJWUN5QUhJQU5xSVFNZ0JpQUhhaUlHS0FJRUlRUUxJQVlnQkVGK2NUWUNCQ0FDSUFOcUlBTTJBZ0FnQWlBRFFRRnlOZ0lFQWtBZ0EwSC9BVXNOQUNBRFFYaHhRYkRRZ0lBQWFpRUVBa0FDUUVFQUtBS0kwSUNBQUNJRlFRRWdBMEVEZG5RaUEzRU5BRUVBSUFVZ0EzSTJBb2pRZ0lBQUlBUWhBd3dCQ3lBRUtBSUlJUU1MSUFNZ0FqWUNEQ0FFSUFJMkFnZ2dBaUFFTmdJTUlBSWdBellDQ0F3REMwRWZJUVFDUUNBRFFmLy8vd2RMRFFBZ0EwRUlkaUlFSUFSQmdQNC9ha0VRZGtFSWNTSUVkQ0lGSUFWQmdPQWZha0VRZGtFRWNTSUZkQ0lBSUFCQmdJQVBha0VRZGtFQ2NTSUFkRUVQZGlBRUlBVnlJQUJ5YXlJRVFRRjBJQU1nQkVFVmFuWkJBWEZ5UVJ4cUlRUUxJQUlnQkRZQ0hDQUNRZ0EzQWhBZ0JFRUNkRUc0MG9DQUFHb2hCUUpBUVFBb0FvelFnSUFBSWdCQkFTQUVkQ0lJY1EwQUlBVWdBallDQUVFQUlBQWdDSEkyQW96UWdJQUFJQUlnQlRZQ0dDQUNJQUkyQWdnZ0FpQUNOZ0lNREFNTElBTkJBRUVaSUFSQkFYWnJJQVJCSDBZYmRDRUVJQVVvQWdBaEFBTkFJQUFpQlNnQ0JFRjRjU0FEUmcwQ0lBUkJIWFloQUNBRVFRRjBJUVFnQlNBQVFRUnhha0VRYWlJSUtBSUFJZ0FOQUFzZ0NDQUNOZ0lBSUFJZ0JUWUNHQ0FDSUFJMkFnd2dBaUFDTmdJSURBSUxJQUJCZUNBQWEwRVBjVUVBSUFCQkNHcEJEM0ViSWdOcUlnc2dCa0ZJYWlJSUlBTnJJZ05CQVhJMkFnUWdBQ0FJYWtFNE5nSUVJQVFnQlVFM0lBVnJRUTl4UVFBZ0JVRkpha0VQY1J0cVFVRnFJZ2dnQ0NBRVFSQnFTUnNpQ0VFak5nSUVRUUJCQUNnQzhOT0FnQUEyQXFUUWdJQUFRUUFnQXpZQ2xOQ0FnQUJCQUNBTE5nS2cwSUNBQUNBSVFSQnFRUUFwQXREVGdJQUFOd0lBSUFoQkFDa0N5Tk9BZ0FBM0FnaEJBQ0FJUVFocU5nTFEwNENBQUVFQUlBWTJBc3pUZ0lBQVFRQWdBRFlDeU5PQWdBQkJBRUVBTmdMVTA0Q0FBQ0FJUVNScUlRTURRQ0FEUVFjMkFnQWdBMEVFYWlJRElBVkpEUUFMSUFnZ0JFWU5BeUFJSUFnb0FnUkJmbkUyQWdRZ0NDQUlJQVJySWdBMkFnQWdCQ0FBUVFGeU5nSUVBa0FnQUVIL0FVc05BQ0FBUVhoeFFiRFFnSUFBYWlFREFrQUNRRUVBS0FLSTBJQ0FBQ0lGUVFFZ0FFRURkblFpQUhFTkFFRUFJQVVnQUhJMkFvalFnSUFBSUFNaEJRd0JDeUFES0FJSUlRVUxJQVVnQkRZQ0RDQURJQVEyQWdnZ0JDQUROZ0lNSUFRZ0JUWUNDQXdFQzBFZklRTUNRQ0FBUWYvLy93ZExEUUFnQUVFSWRpSURJQU5CZ1A0L2FrRVFka0VJY1NJRGRDSUZJQVZCZ09BZmFrRVFka0VFY1NJRmRDSUlJQWhCZ0lBUGFrRVFka0VDY1NJSWRFRVBkaUFESUFWeUlBaHlheUlEUVFGMElBQWdBMEVWYW5aQkFYRnlRUnhxSVFNTElBUWdBellDSENBRVFnQTNBaEFnQTBFQ2RFRzQwb0NBQUdvaEJRSkFRUUFvQW96UWdJQUFJZ2hCQVNBRGRDSUdjUTBBSUFVZ0JEWUNBRUVBSUFnZ0JuSTJBb3pRZ0lBQUlBUWdCVFlDR0NBRUlBUTJBZ2dnQkNBRU5nSU1EQVFMSUFCQkFFRVpJQU5CQVhacklBTkJIMFliZENFRElBVW9BZ0FoQ0FOQUlBZ2lCU2dDQkVGNGNTQUFSZzBESUFOQkhYWWhDQ0FEUVFGMElRTWdCU0FJUVFSeGFrRVFhaUlHS0FJQUlnZ05BQXNnQmlBRU5nSUFJQVFnQlRZQ0dDQUVJQVEyQWd3Z0JDQUVOZ0lJREFNTElBVW9BZ2dpQXlBQ05nSU1JQVVnQWpZQ0NDQUNRUUEyQWhnZ0FpQUZOZ0lNSUFJZ0F6WUNDQXNnQzBFSWFpRUREQVVMSUFVb0FnZ2lBeUFFTmdJTUlBVWdCRFlDQ0NBRVFRQTJBaGdnQkNBRk5nSU1JQVFnQXpZQ0NBdEJBQ2dDbE5DQWdBQWlBeUFDVFEwQVFRQW9BcURRZ0lBQUlnUWdBbW9pQlNBRElBSnJJZ05CQVhJMkFnUkJBQ0FETmdLVTBJQ0FBRUVBSUFVMkFxRFFnSUFBSUFRZ0FrRURjallDQkNBRVFRaHFJUU1NQXd0QkFDRURRUUJCTURZQytOT0FnQUFNQWdzQ1FDQUxSUTBBQWtBQ1FDQUlJQWdvQWh3aUJVRUNkRUc0MG9DQUFHb2lBeWdDQUVjTkFDQURJQUEyQWdBZ0FBMEJRUUFnQjBGK0lBVjNjU0lITmdLTTBJQ0FBQXdDQ3lBTFFSQkJGQ0FMS0FJUUlBaEdHMm9nQURZQ0FDQUFSUTBCQ3lBQUlBczJBaGdDUUNBSUtBSVFJZ05GRFFBZ0FDQUROZ0lRSUFNZ0FEWUNHQXNnQ0VFVWFpZ0NBQ0lEUlEwQUlBQkJGR29nQXpZQ0FDQURJQUEyQWhnTEFrQUNRQ0FFUVE5TERRQWdDQ0FFSUFKcUlnTkJBM0kyQWdRZ0NDQURhaUlESUFNb0FnUkJBWEkyQWdRTUFRc2dDQ0FDYWlJQUlBUkJBWEkyQWdRZ0NDQUNRUU55TmdJRUlBQWdCR29nQkRZQ0FBSkFJQVJCL3dGTERRQWdCRUY0Y1VHdzBJQ0FBR29oQXdKQUFrQkJBQ2dDaU5DQWdBQWlCVUVCSUFSQkEzWjBJZ1J4RFFCQkFDQUZJQVJ5TmdLSTBJQ0FBQ0FESVFRTUFRc2dBeWdDQ0NFRUN5QUVJQUEyQWd3Z0F5QUFOZ0lJSUFBZ0F6WUNEQ0FBSUFRMkFnZ01BUXRCSHlFREFrQWdCRUgvLy84SFN3MEFJQVJCQ0hZaUF5QURRWUQrUDJwQkVIWkJDSEVpQTNRaUJTQUZRWURnSDJwQkVIWkJCSEVpQlhRaUFpQUNRWUNBRDJwQkVIWkJBbkVpQW5SQkQzWWdBeUFGY2lBQ2Ntc2lBMEVCZENBRUlBTkJGV3AyUVFGeGNrRWNhaUVEQ3lBQUlBTTJBaHdnQUVJQU53SVFJQU5CQW5SQnVOS0FnQUJxSVFVQ1FDQUhRUUVnQTNRaUFuRU5BQ0FGSUFBMkFnQkJBQ0FISUFKeU5nS00wSUNBQUNBQUlBVTJBaGdnQUNBQU5nSUlJQUFnQURZQ0RBd0JDeUFFUVFCQkdTQURRUUYyYXlBRFFSOUdHM1FoQXlBRktBSUFJUUlDUUFOQUlBSWlCU2dDQkVGNGNTQUVSZzBCSUFOQkhYWWhBaUFEUVFGMElRTWdCU0FDUVFSeGFrRVFhaUlHS0FJQUlnSU5BQXNnQmlBQU5nSUFJQUFnQlRZQ0dDQUFJQUEyQWd3Z0FDQUFOZ0lJREFFTElBVW9BZ2dpQXlBQU5nSU1JQVVnQURZQ0NDQUFRUUEyQWhnZ0FDQUZOZ0lNSUFBZ0F6WUNDQXNnQ0VFSWFpRUREQUVMQWtBZ0NrVU5BQUpBQWtBZ0FDQUFLQUljSWdWQkFuUkJ1TktBZ0FCcUlnTW9BZ0JIRFFBZ0F5QUlOZ0lBSUFnTkFVRUFJQWxCZmlBRmQzRTJBb3pRZ0lBQURBSUxJQXBCRUVFVUlBb29BaEFnQUVZYmFpQUlOZ0lBSUFoRkRRRUxJQWdnQ2pZQ0dBSkFJQUFvQWhBaUEwVU5BQ0FJSUFNMkFoQWdBeUFJTmdJWUN5QUFRUlJxS0FJQUlnTkZEUUFnQ0VFVWFpQUROZ0lBSUFNZ0NEWUNHQXNDUUFKQUlBUkJEMHNOQUNBQUlBUWdBbW9pQTBFRGNqWUNCQ0FBSUFOcUlnTWdBeWdDQkVFQmNqWUNCQXdCQ3lBQUlBSnFJZ1VnQkVFQmNqWUNCQ0FBSUFKQkEzSTJBZ1FnQlNBRWFpQUVOZ0lBQWtBZ0IwVU5BQ0FIUVhoeFFiRFFnSUFBYWlFQ1FRQW9BcHpRZ0lBQUlRTUNRQUpBUVFFZ0IwRURkblFpQ0NBR2NRMEFRUUFnQ0NBR2NqWUNpTkNBZ0FBZ0FpRUlEQUVMSUFJb0FnZ2hDQXNnQ0NBRE5nSU1JQUlnQXpZQ0NDQURJQUkyQWd3Z0F5QUlOZ0lJQzBFQUlBVTJBcHpRZ0lBQVFRQWdCRFlDa05DQWdBQUxJQUJCQ0dvaEF3c2dBVUVRYWlTQWdJQ0FBQ0FEQ3dvQUlBQVF5WUNBZ0FBTDRnMEJCMzhDUUNBQVJRMEFJQUJCZUdvaUFTQUFRWHhxS0FJQUlnSkJlSEVpQUdvaEF3SkFJQUpCQVhFTkFDQUNRUU54UlEwQklBRWdBU2dDQUNJQ2F5SUJRUUFvQXBqUWdJQUFJZ1JKRFFFZ0FpQUFhaUVBQWtBZ0FVRUFLQUtjMElDQUFFWU5BQUpBSUFKQi93RkxEUUFnQVNnQ0NDSUVJQUpCQTNZaUJVRURkRUd3MElDQUFHb2lCa1lhQWtBZ0FTZ0NEQ0lDSUFSSERRQkJBRUVBS0FLSTBJQ0FBRUYrSUFWM2NUWUNpTkNBZ0FBTUF3c2dBaUFHUmhvZ0FpQUVOZ0lJSUFRZ0FqWUNEQXdDQ3lBQktBSVlJUWNDUUFKQUlBRW9BZ3dpQmlBQlJnMEFJQUVvQWdnaUFpQUVTUm9nQmlBQ05nSUlJQUlnQmpZQ0RBd0JDd0pBSUFGQkZHb2lBaWdDQUNJRURRQWdBVUVRYWlJQ0tBSUFJZ1FOQUVFQUlRWU1BUXNEUUNBQ0lRVWdCQ0lHUVJScUlnSW9BZ0FpQkEwQUlBWkJFR29oQWlBR0tBSVFJZ1FOQUFzZ0JVRUFOZ0lBQ3lBSFJRMEJBa0FDUUNBQklBRW9BaHdpQkVFQ2RFRzQwb0NBQUdvaUFpZ0NBRWNOQUNBQ0lBWTJBZ0FnQmcwQlFRQkJBQ2dDak5DQWdBQkJmaUFFZDNFMkFvelFnSUFBREFNTElBZEJFRUVVSUFjb0FoQWdBVVliYWlBR05nSUFJQVpGRFFJTElBWWdCellDR0FKQUlBRW9BaEFpQWtVTkFDQUdJQUkyQWhBZ0FpQUdOZ0lZQ3lBQktBSVVJZ0pGRFFFZ0JrRVVhaUFDTmdJQUlBSWdCallDR0F3QkN5QURLQUlFSWdKQkEzRkJBMGNOQUNBRElBSkJmbkUyQWdSQkFDQUFOZ0tRMElDQUFDQUJJQUJxSUFBMkFnQWdBU0FBUVFGeU5nSUVEd3NnQVNBRFR3MEFJQU1vQWdRaUFrRUJjVVVOQUFKQUFrQWdBa0VDY1EwQUFrQWdBMEVBS0FLZzBJQ0FBRWNOQUVFQUlBRTJBcURRZ0lBQVFRQkJBQ2dDbE5DQWdBQWdBR29pQURZQ2xOQ0FnQUFnQVNBQVFRRnlOZ0lFSUFGQkFDZ0NuTkNBZ0FCSERRTkJBRUVBTmdLUTBJQ0FBRUVBUVFBMkFwelFnSUFBRHdzQ1FDQURRUUFvQXB6UWdJQUFSdzBBUVFBZ0FUWUNuTkNBZ0FCQkFFRUFLQUtRMElDQUFDQUFhaUlBTmdLUTBJQ0FBQ0FCSUFCQkFYSTJBZ1FnQVNBQWFpQUFOZ0lBRHdzZ0FrRjRjU0FBYWlFQUFrQUNRQ0FDUWY4QlN3MEFJQU1vQWdnaUJDQUNRUU4ySWdWQkEzUkJzTkNBZ0FCcUlnWkdHZ0pBSUFNb0Fnd2lBaUFFUncwQVFRQkJBQ2dDaU5DQWdBQkJmaUFGZDNFMkFvalFnSUFBREFJTElBSWdCa1lhSUFJZ0JEWUNDQ0FFSUFJMkFnd01BUXNnQXlnQ0dDRUhBa0FDUUNBREtBSU1JZ1lnQTBZTkFDQURLQUlJSWdKQkFDZ0NtTkNBZ0FCSkdpQUdJQUkyQWdnZ0FpQUdOZ0lNREFFTEFrQWdBMEVVYWlJQ0tBSUFJZ1FOQUNBRFFSQnFJZ0lvQWdBaUJBMEFRUUFoQmd3QkN3TkFJQUloQlNBRUlnWkJGR29pQWlnQ0FDSUVEUUFnQmtFUWFpRUNJQVlvQWhBaUJBMEFDeUFGUVFBMkFnQUxJQWRGRFFBQ1FBSkFJQU1nQXlnQ0hDSUVRUUowUWJqU2dJQUFhaUlDS0FJQVJ3MEFJQUlnQmpZQ0FDQUdEUUZCQUVFQUtBS00wSUNBQUVGK0lBUjNjVFlDak5DQWdBQU1BZ3NnQjBFUVFSUWdCeWdDRUNBRFJodHFJQVkyQWdBZ0JrVU5BUXNnQmlBSE5nSVlBa0FnQXlnQ0VDSUNSUTBBSUFZZ0FqWUNFQ0FDSUFZMkFoZ0xJQU1vQWhRaUFrVU5BQ0FHUVJScUlBSTJBZ0FnQWlBR05nSVlDeUFCSUFCcUlBQTJBZ0FnQVNBQVFRRnlOZ0lFSUFGQkFDZ0NuTkNBZ0FCSERRRkJBQ0FBTmdLUTBJQ0FBQThMSUFNZ0FrRitjVFlDQkNBQklBQnFJQUEyQWdBZ0FTQUFRUUZ5TmdJRUN3SkFJQUJCL3dGTERRQWdBRUY0Y1VHdzBJQ0FBR29oQWdKQUFrQkJBQ2dDaU5DQWdBQWlCRUVCSUFCQkEzWjBJZ0J4RFFCQkFDQUVJQUJ5TmdLSTBJQ0FBQ0FDSVFBTUFRc2dBaWdDQ0NFQUN5QUFJQUUyQWd3Z0FpQUJOZ0lJSUFFZ0FqWUNEQ0FCSUFBMkFnZ1BDMEVmSVFJQ1FDQUFRZi8vL3dkTERRQWdBRUVJZGlJQ0lBSkJnUDQvYWtFUWRrRUljU0lDZENJRUlBUkJnT0FmYWtFUWRrRUVjU0lFZENJR0lBWkJnSUFQYWtFUWRrRUNjU0lHZEVFUGRpQUNJQVJ5SUFaeWF5SUNRUUYwSUFBZ0FrRVZhblpCQVhGeVFSeHFJUUlMSUFFZ0FqWUNIQ0FCUWdBM0FoQWdBa0VDZEVHNDBvQ0FBR29oQkFKQUFrQkJBQ2dDak5DQWdBQWlCa0VCSUFKMElnTnhEUUFnQkNBQk5nSUFRUUFnQmlBRGNqWUNqTkNBZ0FBZ0FTQUVOZ0lZSUFFZ0FUWUNDQ0FCSUFFMkFnd01BUXNnQUVFQVFSa2dBa0VCZG1zZ0FrRWZSaHQwSVFJZ0JDZ0NBQ0VHQWtBRFFDQUdJZ1FvQWdSQmVIRWdBRVlOQVNBQ1FSMTJJUVlnQWtFQmRDRUNJQVFnQmtFRWNXcEJFR29pQXlnQ0FDSUdEUUFMSUFNZ0FUWUNBQ0FCSUFRMkFoZ2dBU0FCTmdJTUlBRWdBVFlDQ0F3QkN5QUVLQUlJSWdBZ0FUWUNEQ0FFSUFFMkFnZ2dBVUVBTmdJWUlBRWdCRFlDRENBQklBQTJBZ2dMUVFCQkFDZ0NxTkNBZ0FCQmYyb2lBVUYvSUFFYk5nS28wSUNBQUFzTEJBQUFBQXRPQUFKQUlBQU5BRDhBUVJCMER3c0NRQ0FBUWYvL0EzRU5BQ0FBUVg5TURRQUNRQ0FBUVJCMlFBQWlBRUYvUncwQVFRQkJNRFlDK05PQWdBQkJmdzhMSUFCQkVIUVBDeERLZ0lDQUFBQUw4Z0lDQTM4QmZnSkFJQUpGRFFBZ0FDQUJPZ0FBSUFJZ0FHb2lBMEYvYWlBQk9nQUFJQUpCQTBrTkFDQUFJQUU2QUFJZ0FDQUJPZ0FCSUFOQmZXb2dBVG9BQUNBRFFYNXFJQUU2QUFBZ0FrRUhTUTBBSUFBZ0FUb0FBeUFEUVh4cUlBRTZBQUFnQWtFSlNRMEFJQUJCQUNBQWEwRURjU0lFYWlJRElBRkIvd0Z4UVlHQ2hBaHNJZ0UyQWdBZ0F5QUNJQVJyUVh4eElnUnFJZ0pCZkdvZ0FUWUNBQ0FFUVFsSkRRQWdBeUFCTmdJSUlBTWdBVFlDQkNBQ1FYaHFJQUUyQWdBZ0FrRjBhaUFCTmdJQUlBUkJHVWtOQUNBRElBRTJBaGdnQXlBQk5nSVVJQU1nQVRZQ0VDQURJQUUyQWd3Z0FrRndhaUFCTmdJQUlBSkJiR29nQVRZQ0FDQUNRV2hxSUFFMkFnQWdBa0ZrYWlBQk5nSUFJQVFnQTBFRWNVRVljaUlGYXlJQ1FTQkpEUUFnQWExQ2dZQ0FnQkIrSVFZZ0F5QUZhaUVCQTBBZ0FTQUdOd01ZSUFFZ0JqY0RFQ0FCSUFZM0F3Z2dBU0FHTndNQUlBRkJJR29oQVNBQ1FXQnFJZ0pCSDBzTkFBc0xJQUFMQzQ1SUFRQkJnQWdMaGtnQkFBQUFBZ0FBQUFNQUFBQUFBQUFBQUFBQUFBUUFBQUFGQUFBQUFBQUFBQUFBQUFBR0FBQUFCd0FBQUFnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFbHVkbUZzYVdRZ1kyaGhjaUJwYmlCMWNtd2djWFZsY25rQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5aWIyUjVBRU52Ym5SbGJuUXRUR1Z1WjNSb0lHOTJaWEptYkc5M0FFTm9kVzVySUhOcGVtVWdiM1psY21ac2IzY0FVbVZ6Y0c5dWMyVWdiM1psY21ac2IzY0FTVzUyWVd4cFpDQnRaWFJvYjJRZ1ptOXlJRWhVVkZBdmVDNTRJSEpsY1hWbGMzUUFTVzUyWVd4cFpDQnRaWFJvYjJRZ1ptOXlJRkpVVTFBdmVDNTRJSEpsY1hWbGMzUUFSWGh3WldOMFpXUWdVMDlWVWtORklHMWxkR2h2WkNCbWIzSWdTVU5GTDNndWVDQnlaWEYxWlhOMEFFbHVkbUZzYVdRZ1kyaGhjaUJwYmlCMWNtd2dabkpoWjIxbGJuUWdjM1JoY25RQVJYaHdaV04wWldRZ1pHOTBBRk53WVc0Z1kyRnNiR0poWTJzZ1pYSnliM0lnYVc0Z2IyNWZjM1JoZEhWekFFbHVkbUZzYVdRZ2NtVnpjRzl1YzJVZ2MzUmhkSFZ6QUVsdWRtRnNhV1FnWTJoaGNtRmpkR1Z5SUdsdUlHTm9kVzVySUdWNGRHVnVjMmx2Ym5NQVZYTmxjaUJqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmY21WelpYUmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDlqYUhWdWExOW9aV0ZrWlhKZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOXRaWE56WVdkbFgySmxaMmx1WUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZlkyaDFibXRmWlhoMFpXNXphVzl1WDNaaGJIVmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmYzNSaGRIVnpYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmZG1WeWMybHZibDlqYjIxd2JHVjBaV0FnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDNWeWJGOWpiMjF3YkdWMFpXQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYMk5vZFc1clgyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZhR1ZoWkdWeVgzWmhiSFZsWDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZmJXVnpjMkZuWlY5amIyMXdiR1YwWldBZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgyMWxkR2h2WkY5amIyMXdiR1YwWldBZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgyaGxZV1JsY2w5bWFXVnNaRjlqYjIxd2JHVjBaV0FnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDJOb2RXNXJYMlY0ZEdWdWMybHZibDl1WVcxbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCVmJtVjRjR1ZqZEdWa0lHTm9ZWElnYVc0Z2RYSnNJSE5sY25abGNnQkpiblpoYkdsa0lHaGxZV1JsY2lCMllXeDFaU0JqYUdGeUFFbHVkbUZzYVdRZ2FHVmhaR1Z5SUdacFpXeGtJR05vWVhJQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5MlpYSnphVzl1QUVsdWRtRnNhV1FnYldsdWIzSWdkbVZ5YzJsdmJnQkpiblpoYkdsa0lHMWhhbTl5SUhabGNuTnBiMjRBUlhod1pXTjBaV1FnYzNCaFkyVWdZV1owWlhJZ2RtVnljMmx2YmdCRmVIQmxZM1JsWkNCRFVreEdJR0ZtZEdWeUlIWmxjbk5wYjI0QVNXNTJZV3hwWkNCSVZGUlFJSFpsY25OcGIyNEFTVzUyWVd4cFpDQm9aV0ZrWlhJZ2RHOXJaVzRBVTNCaGJpQmpZV3hzWW1GamF5Qmxjbkp2Y2lCcGJpQnZibDkxY213QVNXNTJZV3hwWkNCamFHRnlZV04wWlhKeklHbHVJSFZ5YkFCVmJtVjRjR1ZqZEdWa0lITjBZWEowSUdOb1lYSWdhVzRnZFhKc0FFUnZkV0pzWlNCQUlHbHVJSFZ5YkFCRmJYQjBlU0JEYjI1MFpXNTBMVXhsYm1kMGFBQkpiblpoYkdsa0lHTm9ZWEpoWTNSbGNpQnBiaUJEYjI1MFpXNTBMVXhsYm1kMGFBQkVkWEJzYVdOaGRHVWdRMjl1ZEdWdWRDMU1aVzVuZEdnQVNXNTJZV3hwWkNCamFHRnlJR2x1SUhWeWJDQndZWFJvQUVOdmJuUmxiblF0VEdWdVozUm9JR05oYmlkMElHSmxJSEJ5WlhObGJuUWdkMmwwYUNCVWNtRnVjMlpsY2kxRmJtTnZaR2x1WndCSmJuWmhiR2xrSUdOb1lYSmhZM1JsY2lCcGJpQmphSFZ1YXlCemFYcGxBRk53WVc0Z1kyRnNiR0poWTJzZ1pYSnliM0lnYVc0Z2IyNWZhR1ZoWkdWeVgzWmhiSFZsQUZOd1lXNGdZMkZzYkdKaFkyc2daWEp5YjNJZ2FXNGdiMjVmWTJoMWJtdGZaWGgwWlc1emFXOXVYM1poYkhWbEFFbHVkbUZzYVdRZ1kyaGhjbUZqZEdWeUlHbHVJR05vZFc1cklHVjRkR1Z1YzJsdmJuTWdkbUZzZFdVQVRXbHpjMmx1WnlCbGVIQmxZM1JsWkNCTVJpQmhablJsY2lCb1pXRmtaWElnZG1Gc2RXVUFTVzUyWVd4cFpDQmdWSEpoYm5ObVpYSXRSVzVqYjJScGJtZGdJR2hsWVdSbGNpQjJZV3gxWlFCSmJuWmhiR2xrSUdOb1lYSmhZM1JsY2lCcGJpQmphSFZ1YXlCbGVIUmxibk5wYjI1eklIRjFiM1JsSUhaaGJIVmxBRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUdOb2RXNXJJR1Y0ZEdWdWMybHZibk1nY1hWdmRHVmtJSFpoYkhWbEFGQmhkWE5sWkNCaWVTQnZibDlvWldGa1pYSnpYMk52YlhCc1pYUmxBRWx1ZG1Gc2FXUWdSVTlHSUhOMFlYUmxBRzl1WDNKbGMyVjBJSEJoZFhObEFHOXVYMk5vZFc1clgyaGxZV1JsY2lCd1lYVnpaUUJ2Ymw5dFpYTnpZV2RsWDJKbFoybHVJSEJoZFhObEFHOXVYMk5vZFc1clgyVjRkR1Z1YzJsdmJsOTJZV3gxWlNCd1lYVnpaUUJ2Ymw5emRHRjBkWE5mWTI5dGNHeGxkR1VnY0dGMWMyVUFiMjVmZG1WeWMybHZibDlqYjIxd2JHVjBaU0J3WVhWelpRQnZibDkxY214ZlkyOXRjR3hsZEdVZ2NHRjFjMlVBYjI1ZlkyaDFibXRmWTI5dGNHeGxkR1VnY0dGMWMyVUFiMjVmYUdWaFpHVnlYM1poYkhWbFgyTnZiWEJzWlhSbElIQmhkWE5sQUc5dVgyMWxjM05oWjJWZlkyOXRjR3hsZEdVZ2NHRjFjMlVBYjI1ZmJXVjBhRzlrWDJOdmJYQnNaWFJsSUhCaGRYTmxBRzl1WDJobFlXUmxjbDltYVdWc1pGOWpiMjF3YkdWMFpTQndZWFZ6WlFCdmJsOWphSFZ1YTE5bGVIUmxibk5wYjI1ZmJtRnRaU0J3WVhWelpRQlZibVY0Y0dWamRHVmtJSE53WVdObElHRm1kR1Z5SUhOMFlYSjBJR3hwYm1VQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5amFIVnVhMTlsZUhSbGJuTnBiMjVmYm1GdFpRQkpiblpoYkdsa0lHTm9ZWEpoWTNSbGNpQnBiaUJqYUhWdWF5QmxlSFJsYm5OcGIyNXpJRzVoYldVQVVHRjFjMlVnYjI0Z1EwOU9Ua1ZEVkM5VmNHZHlZV1JsQUZCaGRYTmxJRzl1SUZCU1NTOVZjR2R5WVdSbEFFVjRjR1ZqZEdWa0lFaFVWRkF2TWlCRGIyNXVaV04wYVc5dUlGQnlaV1poWTJVQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5dFpYUm9iMlFBUlhod1pXTjBaV1FnYzNCaFkyVWdZV1owWlhJZ2JXVjBhRzlrQUZOd1lXNGdZMkZzYkdKaFkyc2daWEp5YjNJZ2FXNGdiMjVmYUdWaFpHVnlYMlpwWld4a0FGQmhkWE5sWkFCSmJuWmhiR2xrSUhkdmNtUWdaVzVqYjNWdWRHVnlaV1FBU1c1MllXeHBaQ0J0WlhSb2IyUWdaVzVqYjNWdWRHVnlaV1FBVlc1bGVIQmxZM1JsWkNCamFHRnlJR2x1SUhWeWJDQnpZMmhsYldFQVVtVnhkV1Z6ZENCb1lYTWdhVzUyWVd4cFpDQmdWSEpoYm5ObVpYSXRSVzVqYjJScGJtZGdBRk5YU1ZSRFNGOVFVazlZV1FCVlUwVmZVRkpQV0ZrQVRVdEJRMVJKVmtsVVdRQlZUbEJTVDBORlUxTkJRa3hGWDBWT1ZFbFVXUUJEVDFCWkFFMVBWa1ZFWDFCRlVrMUJUa1ZPVkV4WkFGUlBUMTlGUVZKTVdRQk9UMVJKUmxrQVJrRkpURVZFWDBSRlVFVk9SRVZPUTFrQVFrRkVYMGRCVkVWWFFWa0FVRXhCV1FCUVZWUUFRMGhGUTB0UFZWUUFSMEZVUlZkQldWOVVTVTFGVDFWVUFGSkZVVlZGVTFSZlZFbE5SVTlWVkFCT1JWUlhUMUpMWDBOUFRrNUZRMVJmVkVsTlJVOVZWQUJEVDA1T1JVTlVTVTlPWDFSSlRVVlBWVlFBVEU5SFNVNWZWRWxOUlU5VlZBQk9SVlJYVDFKTFgxSkZRVVJmVkVsTlJVOVZWQUJRVDFOVUFFMUpVMFJKVWtWRFZFVkVYMUpGVVZWRlUxUUFRMHhKUlU1VVgwTk1UMU5GUkY5U1JWRlZSVk5VQUVOTVNVVk9WRjlEVEU5VFJVUmZURTlCUkY5Q1FVeEJUa05GUkY5U1JWRlZSVk5VQUVKQlJGOVNSVkZWUlZOVUFFaFVWRkJmVWtWUlZVVlRWRjlUUlU1VVgxUlBYMGhVVkZCVFgxQlBVbFFBVWtWUVQxSlVBRWxOWDBGZlZFVkJVRTlVQUZKRlUwVlVYME5QVGxSRlRsUUFUazlmUTA5T1ZFVk9WQUJRUVZKVVNVRk1YME5QVGxSRlRsUUFTRkJGWDBsT1ZrRk1TVVJmUTA5T1UxUkJUbFFBU0ZCRlgwTkNYMUpGVTBWVUFFZEZWQUJJVUVWZlUxUlNTVU5VQUVOUFRrWk1TVU5VQUZSRlRWQlBVa0ZTV1Y5U1JVUkpVa1ZEVkFCUVJWSk5RVTVGVGxSZlVrVkVTVkpGUTFRQVEwOU9Ua1ZEVkFCTlZVeFVTVjlUVkVGVVZWTUFTRkJGWDBsT1ZrRk1TVVJmVTFSQlZGVlRBRlJQVDE5TlFVNVpYMUpGVVZWRlUxUlRBRVZCVWt4WlgwaEpUbFJUQUZWT1FWWkJTVXhCUWt4RlgwWlBVbDlNUlVkQlRGOVNSVUZUVDA1VEFFOVFWRWxQVGxNQVUxZEpWRU5JU1U1SFgxQlNUMVJQUTA5TVV3QldRVkpKUVU1VVgwRk1VMDlmVGtWSFQxUkpRVlJGVXdCTlZVeFVTVkJNUlY5RFNFOUpRMFZUQUVsT1ZFVlNUa0ZNWDFORlVsWkZVbDlGVWxKUFVnQlhSVUpmVTBWU1ZrVlNYMVZPUzA1UFYwNWZSVkpTVDFJQVVrRkpURWRWVGw5RlVsSlBVZ0JKUkVWT1ZFbFVXVjlRVWs5V1NVUkZVbDlCVlZSSVJVNVVTVU5CVkVsUFRsOUZVbEpQVWdCVFUweGZRMFZTVkVsR1NVTkJWRVZmUlZKU1QxSUFTVTVXUVV4SlJGOVlYMFpQVWxkQlVrUkZSRjlHVDFJQVUwVlVYMUJCVWtGTlJWUkZVZ0JIUlZSZlVFRlNRVTFGVkVWU0FFaFFSVjlWVTBWU0FGTkZSVjlQVkVoRlVnQklVRVZmUTBKZlEwaFZUa3RmU0VWQlJFVlNBRTFMUTBGTVJVNUVRVklBVTBWVVZWQUFWMFZDWDFORlVsWkZVbDlKVTE5RVQxZE9BRlJGUVZKRVQxZE9BRWhRUlY5RFRFOVRSVVJmUTA5T1RrVkRWRWxQVGdCSVJWVlNTVk5VU1VOZlJWaFFTVkpCVkVsUFRnQkVTVk5EVDA1T1JVTlVSVVJmVDFCRlVrRlVTVTlPQUU1UFRsOUJWVlJJVDFKSlZFRlVTVlpGWDBsT1JrOVNUVUZVU1U5T0FFaFFSVjlKVGxaQlRFbEVYMVpGVWxOSlQwNEFTRkJGWDBOQ1gwMUZVMU5CUjBWZlFrVkhTVTRBVTBsVVJWOUpVMTlHVWs5YVJVNEFTRkJGWDBsT1ZrRk1TVVJmU0VWQlJFVlNYMVJQUzBWT0FFbE9Wa0ZNU1VSZlZFOUxSVTRBUms5U1FrbEVSRVZPQUVWT1NFRk9RMFZmV1U5VlVsOURRVXhOQUVoUVJWOUpUbFpCVEVsRVgxVlNUQUJDVEU5RFMwVkVYMEpaWDFCQlVrVk9WRUZNWDBOUFRsUlNUMHdBVFV0RFQwd0FRVU5NQUVoUVJWOUpUbFJGVWs1QlRBQlNSVkZWUlZOVVgwaEZRVVJGVWw5R1NVVk1SRk5mVkU5UFgweEJVa2RGWDFWT1QwWkdTVU5KUVV3QVNGQkZYMDlMQUZWT1RFbE9Td0JWVGt4UFEwc0FVRkpKQUZKRlZGSlpYMWRKVkVnQVNGQkZYMGxPVmtGTVNVUmZRMDlPVkVWT1ZGOU1SVTVIVkVnQVNGQkZYMVZPUlZoUVJVTlVSVVJmUTA5T1ZFVk9WRjlNUlU1SFZFZ0FSa3hWVTBnQVVGSlBVRkJCVkVOSUFFMHRVMFZCVWtOSUFGVlNTVjlVVDA5ZlRFOU9Sd0JRVWs5RFJWTlRTVTVIQUUxSlUwTkZURXhCVGtWUFZWTmZVRVZTVTBsVFZFVk9WRjlYUVZKT1NVNUhBRTFKVTBORlRFeEJUa1ZQVlZOZlYwRlNUa2xPUndCSVVFVmZTVTVXUVV4SlJGOVVVa0ZPVTBaRlVsOUZUa05QUkVsT1J3QkZlSEJsWTNSbFpDQkRVa3hHQUVoUVJWOUpUbFpCVEVsRVgwTklWVTVMWDFOSldrVUFUVTlXUlFCRFQwNVVTVTVWUlFCSVVFVmZRMEpmVTFSQlZGVlRYME5QVFZCTVJWUkZBRWhRUlY5RFFsOUlSVUZFUlZKVFgwTlBUVkJNUlZSRkFFaFFSVjlEUWw5V1JWSlRTVTlPWDBOUFRWQk1SVlJGQUVoUVJWOURRbDlWVWt4ZlEwOU5VRXhGVkVVQVNGQkZYME5DWDBOSVZVNUxYME5QVFZCTVJWUkZBRWhRUlY5RFFsOUlSVUZFUlZKZlZrRk1WVVZmUTA5TlVFeEZWRVVBU0ZCRlgwTkNYME5JVlU1TFgwVllWRVZPVTBsUFRsOVdRVXhWUlY5RFQwMVFURVZVUlFCSVVFVmZRMEpmUTBoVlRrdGZSVmhVUlU1VFNVOU9YMDVCVFVWZlEwOU5VRXhGVkVVQVNGQkZYME5DWDAxRlUxTkJSMFZmUTA5TlVFeEZWRVVBU0ZCRlgwTkNYMDFGVkVoUFJGOURUMDFRVEVWVVJRQklVRVZmUTBKZlNFVkJSRVZTWDBaSlJVeEVYME5QVFZCTVJWUkZBRVJGVEVWVVJRQklVRVZmU1U1V1FVeEpSRjlGVDBaZlUxUkJWRVVBU1U1V1FVeEpSRjlUVTB4ZlEwVlNWRWxHU1VOQlZFVUFVRUZWVTBVQVRrOWZVa1ZUVUU5T1UwVUFWVTVUVlZCUVQxSlVSVVJmVFVWRVNVRmZWRmxRUlFCSFQwNUZBRTVQVkY5QlEwTkZVRlJCUWt4RkFGTkZVbFpKUTBWZlZVNUJWa0ZKVEVGQ1RFVUFVa0ZPUjBWZlRrOVVYMU5CVkVsVFJrbEJRa3hGQUU5U1NVZEpUbDlKVTE5VlRsSkZRVU5JUVVKTVJRQlNSVk5RVDA1VFJWOUpVMTlUVkVGTVJRQlFWVkpIUlFCTlJWSkhSUUJTUlZGVlJWTlVYMGhGUVVSRlVsOUdTVVZNUkZOZlZFOVBYMHhCVWtkRkFGSkZVVlZGVTFSZlNFVkJSRVZTWDFSUFQxOU1RVkpIUlFCUVFWbE1UMEZFWDFSUFQxOU1RVkpIUlFCSlRsTlZSa1pKUTBsRlRsUmZVMVJQVWtGSFJRQklVRVZmVUVGVlUwVkVYMVZRUjFKQlJFVUFTRkJGWDFCQlZWTkZSRjlJTWw5VlVFZFNRVVJGQUZOUFZWSkRSUUJCVGs1UFZVNURSUUJVVWtGRFJRQklVRVZmVlU1RldGQkZRMVJGUkY5VFVFRkRSUUJFUlZORFVrbENSUUJWVGxOVlFsTkRVa2xDUlFCU1JVTlBVa1FBU0ZCRlgwbE9Wa0ZNU1VSZlRVVlVTRTlFQUU1UFZGOUdUMVZPUkFCUVVrOVFSa2xPUkFCVlRrSkpUa1FBVWtWQ1NVNUVBRlZPUVZWVVNFOVNTVnBGUkFCTlJWUklUMFJmVGs5VVgwRk1URTlYUlVRQVNGUlVVRjlXUlZKVFNVOU9YMDVQVkY5VFZWQlFUMUpVUlVRQVFVeFNSVUZFV1Y5U1JWQlBVbFJGUkFCQlEwTkZVRlJGUkFCT1QxUmZTVTFRVEVWTlJVNVVSVVFBVEU5UFVGOUVSVlJGUTFSRlJBQklVRVZmUTFKZlJWaFFSVU5VUlVRQVNGQkZYMHhHWDBWWVVFVkRWRVZFQUVOU1JVRlVSVVFBU1UxZlZWTkZSQUJJVUVWZlVFRlZVMFZFQUZSSlRVVlBWVlJmVDBORFZWSkZSQUJRUVZsTlJVNVVYMUpGVVZWSlVrVkVBRkJTUlVOUFRrUkpWRWxQVGw5U1JWRlZTVkpGUkFCUVVrOVlXVjlCVlZSSVJVNVVTVU5CVkVsUFRsOVNSVkZWU1ZKRlJBQk9SVlJYVDFKTFgwRlZWRWhGVGxSSlEwRlVTVTlPWDFKRlVWVkpVa1ZFQUV4RlRrZFVTRjlTUlZGVlNWSkZSQUJUVTB4ZlEwVlNWRWxHU1VOQlZFVmZVa1ZSVlVsU1JVUUFWVkJIVWtGRVJWOVNSVkZWU1ZKRlJBQlFRVWRGWDBWWVVFbFNSVVFBVUZKRlEwOU9SRWxVU1U5T1gwWkJTVXhGUkFCRldGQkZRMVJCVkVsUFRsOUdRVWxNUlVRQVVrVldRVXhKUkVGVVNVOU9YMFpCU1V4RlJBQlRVMHhmU0VGT1JGTklRVXRGWDBaQlNVeEZSQUJNVDBOTFJVUUFWRkpCVGxOR1QxSk5RVlJKVDA1ZlFWQlFURWxGUkFCT1QxUmZUVTlFU1VaSlJVUUFUazlVWDBWWVZFVk9SRVZFQUVKQlRrUlhTVVJVU0Y5TVNVMUpWRjlGV0VORlJVUkZSQUJUU1ZSRlgwbFRYMDlXUlZKTVQwRkVSVVFBU0VWQlJBQkZlSEJsWTNSbFpDQklWRlJRTHdBQVhoTUFBQ1lUQUFBd0VBQUE4QmNBQUowVEFBQVZFZ0FBT1JjQUFQQVNBQUFLRUFBQWRSSUFBSzBTQUFDQ0V3QUFUeFFBQUg4UUFBQ2dGUUFBSXhRQUFJa1NBQUNMRkFBQVRSVUFBTlFSQUFEUEZBQUFFQmdBQU1rV0FBRGNGZ0FBd1JFQUFPQVhBQUM3RkFBQWRCUUFBSHdWQUFEbEZBQUFDQmNBQUI4UUFBQmxGUUFBb3hRQUFDZ1ZBQUFDRlFBQW1SVUFBQ3dRQUFDTEdRQUFUdzhBQU5RT0FBQnFFQUFBemhBQUFBSVhBQUNKRGdBQWJoTUFBQndUQUFCbUZBQUFWaGNBQU1FVEFBRE5Fd0FBYkJNQUFHZ1hBQUJtRndBQVh4Y0FBQ0lUQUFET0R3QUFhUTRBQU5nT0FBQmpGZ0FBeXhNQUFLb09BQUFvRndBQUpoY0FBTVVUQUFCZEZnQUE2QkVBQUdjVEFBQmxFd0FBOGhZQUFITVRBQUFkRndBQStSWUFBUE1SQUFEUERnQUF6aFVBQUF3U0FBQ3pFUUFBcFJFQUFHRVFBQUF5RndBQXV4TUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFRSUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQUFBQUFBQUFBQUFBQUFBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUlEQWdJQ0FnSUFBQUlDQUFJQ0FBSUNBZ0lDQWdJQ0FnSUFCQUFBQUFBQUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQUFBQUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0FDQUFJQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ0FBSUNBZ0lDQUFBQ0FnQUNBZ0FDQWdJQ0FnSUNBZ0lDQUFNQUJBQUFBQUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBQUFBQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQUFnQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBYkc5elpXVmxjQzFoYkdsMlpRQUFBQUFBQUFBQUFBQUFBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFBQUFBQUFBQUFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUVCQVFFQkFRRUJBUUVCQVFJQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJZMmgxYm10bFpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFFQUFRRUJBUUVBQUFFQkFBRUJBQUVCQVFFQkFRRUJBUUVBQUFBQUFBQUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBQUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJsWTNScGIyNWxiblF0YkdWdVozUm9iMjV5YjNoNUxXTnZibTVsWTNScGIyNEFBQUFBQUFBQUFBQUFBQUFBQUFCeVlXNXpabVZ5TFdWdVkyOWthVzVuY0dkeVlXUmxEUW9OQ2cwS1UwME5DZzBLVkZSUUwwTkZMMVJUVUM4QUFBQUFBQUFBQUFBQUFBQUJBZ0FCQXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFBQUFBQUFBQUFBQVFJQUFRTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUVBUUVGQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUFBQUFBQUFBQUFBRUFBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQUFBQUFBQUFBQUFBQVFBQUFnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTUVBQUFFQkFRRUJBUUVCQVFFQkFVRUJBUUVCQVFFQkFRRUJBUUFCQUFHQndRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUFBUUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUFBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUlBQUFBQUFBQURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3QUFBQUFBQUFNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBSUFBQUFBQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01BQUFBQUFBQURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCT1QxVk9RMFZGUTB0UFZWUk9SVU5VUlZSRlExSkpRa1ZNVlZOSVJWUkZRVVJUUlVGU1EwaFNSMFZEVkVsV1NWUlpURVZPUkVGU1ZrVlBWRWxHV1ZCVVNVOU9VME5JVTBWQldWTlVRVlJEU0VkRlQxSkVTVkpGUTFSUFVsUlNRMGhRUVZKQlRVVlVSVkpWVWtORlFsTkRVa2xDUlVGU1JFOVhUa0ZEUlVsT1JFNUxRMHRWUWxORFVrbENSVWhVVkZBdlFVUlVVQzg9J1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/llhttp/llhttp-wasm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js ***!
  \**********************************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = \"AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbGxodHRwL2xsaHR0cF9zaW1kLXdhc20uanMiLCJtYXBwaW5ncyI6IjtBQUFBQSxPQUFPQyxPQUFPLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvbGxodHRwX3NpbWQtd2FzbS5qcz8xNDFmIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gJ0FHRnpiUUVBQUFBQk1BaGdBWDhCZjJBRGYzOS9BWDlnQkg5L2YzOEJmMkFBQUdBRGYzOS9BR0FCZndCZ0FuOS9BR0FHZjM5L2YzOS9BQUxMQVFnRFpXNTJHSGRoYzIxZmIyNWZhR1ZoWkdWeWMxOWpiMjF3YkdWMFpRQUNBMlZ1ZGhWM1lYTnRYMjl1WDIxbGMzTmhaMlZmWW1WbmFXNEFBQU5sYm5ZTGQyRnpiVjl2Ymw5MWNtd0FBUU5sYm5ZT2QyRnpiVjl2Ymw5emRHRjBkWE1BQVFObGJuWVVkMkZ6YlY5dmJsOW9aV0ZrWlhKZlptbGxiR1FBQVFObGJuWVVkMkZ6YlY5dmJsOW9aV0ZrWlhKZmRtRnNkV1VBQVFObGJuWU1kMkZ6YlY5dmJsOWliMlI1QUFFRFpXNTJHSGRoYzIxZmIyNWZiV1Z6YzJGblpWOWpiMjF3YkdWMFpRQUFBMFpGQXdNRUFBQUZBQUFBQUFBQUJRRUZBQVVGQlFBQUJnQUFBQUFHQmdZR0FRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFBQUJBUWNBQUFVRkF3QUJCQVVCY0FFU0VnVURBUUFDQmdnQmZ3RkJnTlFFQ3dmUkJTSUdiV1Z0YjNKNUFnQUxYMmx1YVhScFlXeHBlbVVBQ1JsZlgybHVaR2x5WldOMFgyWjFibU4wYVc5dVgzUmhZbXhsQVFBTGJHeG9kSFJ3WDJsdWFYUUFDaGhzYkdoMGRIQmZjMmh2ZFd4a1gydGxaWEJmWVd4cGRtVUFRUXhzYkdoMGRIQmZZV3hzYjJNQURBWnRZV3hzYjJNQVJndHNiR2gwZEhCZlpuSmxaUUFOQkdaeVpXVUFTQTlzYkdoMGRIQmZaMlYwWDNSNWNHVUFEaFZzYkdoMGRIQmZaMlYwWDJoMGRIQmZiV0ZxYjNJQUR4VnNiR2gwZEhCZloyVjBYMmgwZEhCZmJXbHViM0lBRUJGc2JHaDBkSEJmWjJWMFgyMWxkR2h2WkFBUkZteHNhSFIwY0Y5blpYUmZjM1JoZEhWelgyTnZaR1VBRWhKc2JHaDBkSEJmWjJWMFgzVndaM0poWkdVQUV3eHNiR2gwZEhCZmNtVnpaWFFBRkE1c2JHaDBkSEJmWlhobFkzVjBaUUFWRkd4c2FIUjBjRjl6WlhSMGFXNW5jMTlwYm1sMEFCWU5iR3hvZEhSd1gyWnBibWx6YUFBWERHeHNhSFIwY0Y5d1lYVnpaUUFZRFd4c2FIUjBjRjl5WlhOMWJXVUFHUnRzYkdoMGRIQmZjbVZ6ZFcxbFgyRm1kR1Z5WDNWd1ozSmhaR1VBR2hCc2JHaDBkSEJmWjJWMFgyVnljbTV2QUJzWGJHeG9kSFJ3WDJkbGRGOWxjbkp2Y2w5eVpXRnpiMjRBSEJkc2JHaDBkSEJmYzJWMFgyVnljbTl5WDNKbFlYTnZiZ0FkRkd4c2FIUjBjRjluWlhSZlpYSnliM0pmY0c5ekFCNFJiR3hvZEhSd1gyVnljbTV2WDI1aGJXVUFIeEpzYkdoMGRIQmZiV1YwYUc5a1gyNWhiV1VBSUJKc2JHaDBkSEJmYzNSaGRIVnpYMjVoYldVQUlScHNiR2gwZEhCZmMyVjBYMnhsYm1sbGJuUmZhR1ZoWkdWeWN3QWlJV3hzYUhSMGNGOXpaWFJmYkdWdWFXVnVkRjlqYUhWdWEyVmtYMnhsYm1kMGFBQWpIV3hzYUhSMGNGOXpaWFJmYkdWdWFXVnVkRjlyWldWd1gyRnNhWFpsQUNRa2JHeG9kSFJ3WDNObGRGOXNaVzVwWlc1MFgzUnlZVzV6Wm1WeVgyVnVZMjlrYVc1bkFDVVliR3hvZEhSd1gyMWxjM05oWjJWZmJtVmxaSE5mWlc5bUFEOEpGd0VBUVFFTEVRRUNBd1FGQ3dZSE5UazNNUzh0SnlzcENyTGdBa1VDQUFzSUFCQ0lnSUNBQUFzWkFDQUFFTUtBZ0lBQUdpQUFJQUkyQWpnZ0FDQUJPZ0FvQ3h3QUlBQWdBQzhCTWlBQUxRQXVJQUFRd1lDQWdBQVFnSUNBZ0FBTEtnRUJmMEhBQUJER2dJQ0FBQ0lCRU1LQWdJQUFHaUFCUVlDSWdJQUFOZ0k0SUFFZ0FEb0FLQ0FCQ3dvQUlBQVF5SUNBZ0FBTEJ3QWdBQzBBS0FzSEFDQUFMUUFxQ3djQUlBQXRBQ3NMQndBZ0FDMEFLUXNIQUNBQUx3RXlDd2NBSUFBdEFDNExSUUVFZnlBQUtBSVlJUUVnQUMwQUxTRUNJQUF0QUNnaEF5QUFLQUk0SVFRZ0FCRENnSUNBQUJvZ0FDQUVOZ0k0SUFBZ0F6b0FLQ0FBSUFJNkFDMGdBQ0FCTmdJWUN4RUFJQUFnQVNBQklBSnFFTU9BZ0lBQUN4QUFJQUJCQUVIY0FCRE1nSUNBQUJvTFp3RUJmMEVBSVFFQ1FDQUFLQUlNRFFBQ1FBSkFBa0FDUUNBQUxRQXZEZ01CQUFNQ0N5QUFLQUk0SWdGRkRRQWdBU2dDTENJQlJRMEFJQUFnQVJHQWdJQ0FBQUFpQVEwREMwRUFEd3NReW9DQWdBQUFDeUFBUWNPV2dJQUFOZ0lRUVE0aEFRc2dBUXNlQUFKQUlBQW9BZ3dOQUNBQVFkR2JnSUFBTmdJUUlBQkJGVFlDREFzTEZnQUNRQ0FBS0FJTVFSVkhEUUFnQUVFQU5nSU1Dd3NXQUFKQUlBQW9BZ3hCRmtjTkFDQUFRUUEyQWd3TEN3Y0FJQUFvQWd3TEJ3QWdBQ2dDRUFzSkFDQUFJQUUyQWhBTEJ3QWdBQ2dDRkFzaUFBSkFJQUJCSkVrTkFCREtnSUNBQUFBTElBQkJBblJCb0xPQWdBQnFLQUlBQ3lJQUFrQWdBRUV1U1EwQUVNcUFnSUFBQUFzZ0FFRUNkRUd3dElDQUFHb29BZ0FMN2dzQkFYOUI2NmlBZ0FBaEFRSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUJCbkg5cUR2UURZMklBQVdGaFlXRmhZUUlEQkFWaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhCZ2NJQ1FvTERBME9EMkZoWVdGaEVHRmhZV0ZoWVdGaFlXRmhFV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZUklURkJVV0Z4Z1pHaHRoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoSEIwZUh5QWhJaU1rSlNZbktDa3FLeXd0TGk4d01USXpORFUyWVRjNE9UcGhZV0ZoWVdGaFlUdGhZV0U4WVdGaFlUMCtQMkZoWVdGaFlXRmhRR0ZoUVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlVSkRSRVZHUjBoSlNrdE1UVTVQVUZGU1UyRmhZV0ZoWVdGaFZGVldWMWhaV2x0aFhGMWhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZlWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWDJCaEMwSGhwNENBQUE4TFFhU2hnSUFBRHd0Qnk2eUFnQUFQQzBIK3NZQ0FBQThMUWNDa2dJQUFEd3RCcTZTQWdBQVBDMEdOcUlDQUFBOExRZUttZ0lBQUR3dEJnTENBZ0FBUEMwRzVyNENBQUE4TFFkZWtnSUFBRHd0Qjc1K0FnQUFQQzBIaG40Q0FBQThMUWZxZmdJQUFEd3RCOHFDQWdBQVBDMEdvcjRDQUFBOExRYTZ5Z0lBQUR3dEJpTENBZ0FBUEMwSHNwNENBQUE4TFFZS2lnSUFBRHd0QmpwMkFnQUFQQzBIUXJvQ0FBQThMUWNxamdJQUFEd3RCeGJLQWdBQVBDMEhmbklDQUFBOExRZEtjZ0lBQUR3dEJ4S0NBZ0FBUEMwSFhvSUNBQUE4TFFhS2ZnSUFBRHd0QjdhNkFnQUFQQzBHcnNJQ0FBQThMUWRTbGdJQUFEd3RCeks2QWdBQVBDMEg2cm9DQUFBOExRZnlyZ0lBQUR3dEIwckNBZ0FBUEMwSHhuWUNBQUE4TFFidWdnSUFBRHd0Qjk2dUFnQUFQQzBHUXNZQ0FBQThMUWRleGdJQUFEd3RCb3EyQWdBQVBDMEhVcDRDQUFBOExRZUNyZ0lBQUR3dEJuNnlBZ0FBUEMwSHJzWUNBQUE4TFFkV2ZnSUFBRHd0QnlyR0FnQUFQQzBIZXBZQ0FBQThMUWRTZWdJQUFEd3RCOUp5QWdBQVBDMEduc29DQUFBOExRYkdkZ0lBQUR3dEJvSjJBZ0FBUEMwRzVzWUNBQUE4TFFieXdnSUFBRHd0QmtxR0FnQUFQQzBHenBvQ0FBQThMUWVtc2dJQUFEd3RCcko2QWdBQVBDMEhVcTRDQUFBOExRZmVtZ0lBQUR3dEJnS2FBZ0FBUEMwR3dvWUNBQUE4TFFmNmVnSUFBRHd0QmphT0FnQUFQQzBHSnJZQ0FBQThMUWZlaWdJQUFEd3RCb0xHQWdBQVBDMEd1bjRDQUFBOExRY2FsZ0lBQUR3dEI2SjZBZ0FBUEMwR1Rvb0NBQUE4TFFjS3ZnSUFBRHd0Qnc1MkFnQUFQQzBHTHJJQ0FBQThMUWVHZGdJQUFEd3RCamErQWdBQVBDMEhxb1lDQUFBOExRYlN0Z0lBQUR3dEIwcStBZ0FBUEMwSGZzb0NBQUE4TFFkS3lnSUFBRHd0QjhMQ0FnQUFQQzBHcG9vQ0FBQThMUWZtamdJQUFEd3RCbVo2QWdBQVBDMEcxcklDQUFBOExRWnV3Z0lBQUR3dEJrcktBZ0FBUEMwRzJxNENBQUE4TFFjS2lnSUFBRHd0QitMS0FnQUFQQzBHZXBZQ0FBQThMUWRDaWdJQUFEd3RCdXA2QWdBQVBDMEdCbm9DQUFBOExFTXFBZ0lBQUFBdEIxcUdBZ0FBaEFRc2dBUXNXQUNBQUlBQXRBQzFCL2dGeElBRkJBRWR5T2dBdEN4a0FJQUFnQUMwQUxVSDlBWEVnQVVFQVIwRUJkSEk2QUMwTEdRQWdBQ0FBTFFBdFFmc0JjU0FCUVFCSFFRSjBjam9BTFFzWkFDQUFJQUF0QUMxQjl3RnhJQUZCQUVkQkEzUnlPZ0F0Q3k0QkFuOUJBQ0VEQWtBZ0FDZ0NPQ0lFUlEwQUlBUW9BZ0FpQkVVTkFDQUFJQVFSZ0lDQWdBQUFJUU1MSUFNTFNRRUNmMEVBSVFNQ1FDQUFLQUk0SWdSRkRRQWdCQ2dDQkNJRVJRMEFJQUFnQVNBQ0lBRnJJQVFSZ1lDQWdBQUFJZ05CZjBjTkFDQUFRY2FSZ0lBQU5nSVFRUmdoQXdzZ0F3c3VBUUovUVFBaEF3SkFJQUFvQWpnaUJFVU5BQ0FFS0FJd0lnUkZEUUFnQUNBRUVZQ0FnSUFBQUNFREN5QURDMGtCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FnZ2lCRVVOQUNBQUlBRWdBaUFCYXlBRUVZR0FnSUFBQUNJRFFYOUhEUUFnQUVIMmlvQ0FBRFlDRUVFWUlRTUxJQU1MTGdFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NOQ0lFUlEwQUlBQWdCQkdBZ0lDQUFBQWhBd3NnQXd0SkFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUlNSWdSRkRRQWdBQ0FCSUFJZ0FXc2dCQkdCZ0lDQUFBQWlBMEYvUncwQUlBQkI3WnFBZ0FBMkFoQkJHQ0VEQ3lBREN5NEJBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWpnaUJFVU5BQ0FBSUFRUmdJQ0FnQUFBSVFNTElBTUxTUUVDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ0VDSUVSUTBBSUFBZ0FTQUNJQUZySUFRUmdZQ0FnQUFBSWdOQmYwY05BQ0FBUVpXUWdJQUFOZ0lRUVJnaEF3c2dBd3N1QVFKL1FRQWhBd0pBSUFBb0FqZ2lCRVVOQUNBRUtBSThJZ1JGRFFBZ0FDQUVFWUNBZ0lBQUFDRURDeUFEQzBrQkFuOUJBQ0VEQWtBZ0FDZ0NPQ0lFUlEwQUlBUW9BaFFpQkVVTkFDQUFJQUVnQWlBQmF5QUVFWUdBZ0lBQUFDSURRWDlIRFFBZ0FFR3FtNENBQURZQ0VFRVlJUU1MSUFNTExnRUNmMEVBSVFNQ1FDQUFLQUk0SWdSRkRRQWdCQ2dDUUNJRVJRMEFJQUFnQkJHQWdJQ0FBQUFoQXdzZ0F3dEpBUUovUVFBaEF3SkFJQUFvQWpnaUJFVU5BQ0FFS0FJWUlnUkZEUUFnQUNBQklBSWdBV3NnQkJHQmdJQ0FBQUFpQTBGL1J3MEFJQUJCN1pPQWdBQTJBaEJCR0NFREN5QURDeTRCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FrUWlCRVVOQUNBQUlBUVJnSUNBZ0FBQUlRTUxJQU1MTGdFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NKQ0lFUlEwQUlBQWdCQkdBZ0lDQUFBQWhBd3NnQXdzdUFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUlzSWdSRkRRQWdBQ0FFRVlDQWdJQUFBQ0VEQ3lBREMwa0JBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWlnaUJFVU5BQ0FBSUFFZ0FpQUJheUFFRVlHQWdJQUFBQ0lEUVg5SERRQWdBRUgyaUlDQUFEWUNFRUVZSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ1VDSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3RKQVFKL1FRQWhBd0pBSUFBb0FqZ2lCRVVOQUNBRUtBSWNJZ1JGRFFBZ0FDQUJJQUlnQVdzZ0JCR0JnSUNBQUFBaUEwRi9SdzBBSUFCQndwbUFnQUEyQWhCQkdDRURDeUFEQ3k0QkFuOUJBQ0VEQWtBZ0FDZ0NPQ0lFUlEwQUlBUW9Ba2dpQkVVTkFDQUFJQVFSZ0lDQWdBQUFJUU1MSUFNTFNRRUNmMEVBSVFNQ1FDQUFLQUk0SWdSRkRRQWdCQ2dDSUNJRVJRMEFJQUFnQVNBQ0lBRnJJQVFSZ1lDQWdBQUFJZ05CZjBjTkFDQUFRWlNVZ0lBQU5nSVFRUmdoQXdzZ0F3c3VBUUovUVFBaEF3SkFJQUFvQWpnaUJFVU5BQ0FFS0FKTUlnUkZEUUFnQUNBRUVZQ0FnSUFBQUNFREN5QURDeTRCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FsUWlCRVVOQUNBQUlBUVJnSUNBZ0FBQUlRTUxJQU1MTGdFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NXQ0lFUlEwQUlBQWdCQkdBZ0lDQUFBQWhBd3NnQXd0RkFRRi9Ba0FDUUNBQUx3RXdRUlJ4UVJSSERRQkJBU0VESUFBdEFDaEJBVVlOQVNBQUx3RXlRZVVBUmlFRERBRUxJQUF0QUNsQkJVWWhBd3NnQUNBRE9nQXVRUUFML2dFQkEzOUJBU0VEQWtBZ0FDOEJNQ0lFUVFoeERRQWdBQ2tESUVJQVVpRURDd0pBQWtBZ0FDMEFMa1VOQUVFQklRVWdBQzBBS1VFRlJnMEJRUUVoQlNBRVFjQUFjVVVnQTNGQkFVY05BUXRCQUNFRklBUkJ3QUJ4RFFCQkFpRUZJQVJCLy84RGNTSURRUWh4RFFBQ1FDQURRWUFFY1VVTkFBSkFJQUF0QUNoQkFVY05BQ0FBTFFBdFFRcHhEUUJCQlE4TFFRUVBDd0pBSUFOQklIRU5BQUpBSUFBdEFDaEJBVVlOQUNBQUx3RXlRZi8vQTNFaUFFR2NmMnBCNUFCSkRRQWdBRUhNQVVZTkFDQUFRYkFDUmcwQVFRUWhCU0FFUVNoeFJRMENJQU5CaUFSeFFZQUVSZzBDQzBFQUR3dEJBRUVESUFBcEF5QlFHeUVGQ3lBRkMySUJBbjlCQUNFQkFrQWdBQzBBS0VFQlJnMEFJQUF2QVRKQi8vOERjU0lDUVp4L2FrSGtBRWtOQUNBQ1Fjd0JSZzBBSUFKQnNBSkdEUUFnQUM4Qk1DSUFRY0FBY1EwQVFRRWhBU0FBUVlnRWNVR0FCRVlOQUNBQVFTaHhSU0VCQ3lBQkM2Y0JBUU4vQWtBQ1FBSkFJQUF0QUNwRkRRQWdBQzBBSzBVTkFFRUFJUU1nQUM4Qk1DSUVRUUp4UlEwQkRBSUxRUUFoQXlBQUx3RXdJZ1JCQVhGRkRRRUxRUUVoQXlBQUxRQW9RUUZHRFFBZ0FDOEJNa0gvL3dOeElnVkJuSDlxUWVRQVNRMEFJQVZCekFGR0RRQWdCVUd3QWtZTkFDQUVRY0FBY1EwQVFRQWhBeUFFUVlnRWNVR0FCRVlOQUNBRVFTaHhRUUJISVFNTElBQkJBRHNCTUNBQVFRQTZBQzhnQXd1WkFRRUNmd0pBQWtBQ1FDQUFMUUFxUlEwQUlBQXRBQ3RGRFFCQkFDRUJJQUF2QVRBaUFrRUNjVVVOQVF3Q0MwRUFJUUVnQUM4Qk1DSUNRUUZ4UlEwQkMwRUJJUUVnQUMwQUtFRUJSZzBBSUFBdkFUSkIvLzhEY1NJQVFaeC9ha0hrQUVrTkFDQUFRY3dCUmcwQUlBQkJzQUpHRFFBZ0FrSEFBSEVOQUVFQUlRRWdBa0dJQkhGQmdBUkdEUUFnQWtFb2NVRUFSeUVCQ3lBQkMwa0JBWHNnQUVFUWF2ME1BQUFBQUFBQUFBQUFBQUFBQUFBQUFDSUIvUXNEQUNBQUlBSDlDd01BSUFCQk1Hb2dBZjBMQXdBZ0FFRWdhaUFCL1FzREFDQUFRZDBCTmdJY1FRQUxld0VCZndKQUlBQW9BZ3dpQXcwQUFrQWdBQ2dDQkVVTkFDQUFJQUUyQWdRTEFrQWdBQ0FCSUFJUXhJQ0FnQUFpQXcwQUlBQW9BZ3dQQ3lBQUlBTTJBaHhCQUNFRElBQW9BZ1FpQVVVTkFDQUFJQUVnQWlBQUtBSUlFWUdBZ0lBQUFDSUJSUTBBSUFBZ0FqWUNGQ0FBSUFFMkFnd2dBU0VEQ3lBREMrVHpBUU1PZndOK0JIOGpnSUNBZ0FCQkVHc2lBeVNBZ0lDQUFDQUJJUVFnQVNFRklBRWhCaUFCSVFjZ0FTRUlJQUVoQ1NBQklRb2dBU0VMSUFFaERDQUJJUTBnQVNFT0lBRWhEd0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FBS0FJY0loQkJmMm9PM1FIYUFRSFpBUUlEQkFVR0J3Z0pDZ3NNRFE3WUFROFExd0VSRXRZQkV4UVZGaGNZR1JvYjRBSGZBUndkSHRVQkh5QWhJaU1rSmRRQkppY29LU29yTE5NQjBnRXRMdEVCMEFFdk1ERXlNelExTmpjNE9UbzdQRDArUDBCQlFrTkVSVWJiQVVkSVNVclBBYzRCUzgwQlRNd0JUVTVQVUZGU1UxUlZWbGRZV1ZwYlhGMWVYMkJoWW1Oa1pXWm5hR2xxYTJ4dGJtOXdjWEp6ZEhWMmQzaDVlbnQ4Zlg1L2dBR0JBWUlCZ3dHRUFZVUJoZ0dIQVlnQmlRR0tBWXNCakFHTkFZNEJqd0dRQVpFQmtnR1RBWlFCbFFHV0FaY0JtQUdaQVpvQm13R2NBWjBCbmdHZkFhQUJvUUdpQWFNQnBBR2xBYVlCcHdHb0Fha0JxZ0dyQWF3QnJRR3VBYThCc0FHeEFiSUJzd0cwQWJVQnRnRzNBY3NCeWdHNEFja0J1UUhJQWJvQnV3RzhBYjBCdmdHL0FjQUJ3UUhDQWNNQnhBSEZBY1lCQU53QkMwRUFJUkFNeGdFTFFRNGhFQXpGQVF0QkRTRVFETVFCQzBFUElSQU13d0VMUVJBaEVBekNBUXRCRXlFUURNRUJDMEVVSVJBTXdBRUxRUlVoRUF5L0FRdEJGaUVRREw0QkMwRVhJUkFNdlFFTFFSZ2hFQXk4QVF0QkdTRVFETHNCQzBFYUlSQU11Z0VMUVJzaEVBeTVBUXRCSENFUURMZ0JDMEVJSVJBTXR3RUxRUjBoRUF5MkFRdEJJQ0VRRExVQkMwRWZJUkFNdEFFTFFRY2hFQXl6QVF0QklTRVFETElCQzBFaUlSQU1zUUVMUVI0aEVBeXdBUXRCSXlFUURLOEJDMEVTSVJBTXJnRUxRUkVoRUF5dEFRdEJKQ0VRREt3QkMwRWxJUkFNcXdFTFFTWWhFQXlxQVF0Qkp5RVFES2tCQzBIREFTRVFES2dCQzBFcElSQU1wd0VMUVNzaEVBeW1BUXRCTENFUURLVUJDMEV0SVJBTXBBRUxRUzRoRUF5akFRdEJMeUVRREtJQkMwSEVBU0VRREtFQkMwRXdJUkFNb0FFTFFUUWhFQXlmQVF0QkRDRVFESjRCQzBFeElSQU1uUUVMUVRJaEVBeWNBUXRCTXlFUURKc0JDMEU1SVJBTW1nRUxRVFVoRUF5WkFRdEJ4UUVoRUF5WUFRdEJDeUVRREpjQkMwRTZJUkFNbGdFTFFUWWhFQXlWQVF0QkNpRVFESlFCQzBFM0lSQU1rd0VMUVRnaEVBeVNBUXRCUENFUURKRUJDMEU3SVJBTWtBRUxRVDBoRUF5UEFRdEJDU0VRREk0QkMwRW9JUkFNalFFTFFUNGhFQXlNQVF0QlB5RVFESXNCQzBIQUFDRVFESW9CQzBIQkFDRVFESWtCQzBIQ0FDRVFESWdCQzBIREFDRVFESWNCQzBIRUFDRVFESVlCQzBIRkFDRVFESVVCQzBIR0FDRVFESVFCQzBFcUlSQU1nd0VMUWNjQUlSQU1nZ0VMUWNnQUlSQU1nUUVMUWNrQUlSQU1nQUVMUWNvQUlSQU1md3RCeXdBaEVBeCtDMEhOQUNFUURIMExRY3dBSVJBTWZBdEJ6Z0FoRUF4N0MwSFBBQ0VRREhvTFFkQUFJUkFNZVF0QjBRQWhFQXg0QzBIU0FDRVFESGNMUWRNQUlSQU1kZ3RCMUFBaEVBeDFDMEhXQUNFUURIUUxRZFVBSVJBTWN3dEJCaUVRREhJTFFkY0FJUkFNY1F0QkJTRVFESEFMUWRnQUlSQU1id3RCQkNFUURHNExRZGtBSVJBTWJRdEIyZ0FoRUF4c0MwSGJBQ0VRREdzTFFkd0FJUkFNYWd0QkF5RVFER2tMUWQwQUlSQU1hQXRCM2dBaEVBeG5DMEhmQUNFUURHWUxRZUVBSVJBTVpRdEI0QUFoRUF4a0MwSGlBQ0VRREdNTFFlTUFJUkFNWWd0QkFpRVFER0VMUWVRQUlSQU1ZQXRCNVFBaEVBeGZDMEhtQUNFUURGNExRZWNBSVJBTVhRdEI2QUFoRUF4Y0MwSHBBQ0VRREZzTFFlb0FJUkFNV2d0QjZ3QWhFQXhaQzBIc0FDRVFERmdMUWUwQUlSQU1Wd3RCN2dBaEVBeFdDMEh2QUNFUURGVUxRZkFBSVJBTVZBdEI4UUFoRUF4VEMwSHlBQ0VRREZJTFFmTUFJUkFNVVF0QjlBQWhFQXhRQzBIMUFDRVFERThMUWZZQUlSQU1UZ3RCOXdBaEVBeE5DMEg0QUNFUURFd0xRZmtBSVJBTVN3dEIrZ0FoRUF4S0MwSDdBQ0VRREVrTFFmd0FJUkFNU0F0Qi9RQWhFQXhIQzBIK0FDRVFERVlMUWY4QUlSQU1SUXRCZ0FFaEVBeEVDMEdCQVNFUURFTUxRWUlCSVJBTVFndEJnd0VoRUF4QkMwR0VBU0VRREVBTFFZVUJJUkFNUHd0QmhnRWhFQXcrQzBHSEFTRVFERDBMUVlnQklSQU1QQXRCaVFFaEVBdzdDMEdLQVNFUUREb0xRWXNCSVJBTU9RdEJqQUVoRUF3NEMwR05BU0VRRERjTFFZNEJJUkFNTmd0Qmp3RWhFQXcxQzBHUUFTRVFERFFMUVpFQklSQU1Nd3RCa2dFaEVBd3lDMEdUQVNFUURERUxRWlFCSVJBTU1BdEJsUUVoRUF3dkMwR1dBU0VRREM0TFFaY0JJUkFNTFF0Qm1BRWhFQXdzQzBHWkFTRVFEQ3NMUVpvQklSQU1LZ3RCbXdFaEVBd3BDMEdjQVNFUURDZ0xRWjBCSVJBTUp3dEJuZ0VoRUF3bUMwR2ZBU0VRRENVTFFhQUJJUkFNSkF0Qm9RRWhFQXdqQzBHaUFTRVFEQ0lMUWFNQklSQU1JUXRCcEFFaEVBd2dDMEdsQVNFUURCOExRYVlCSVJBTUhndEJwd0VoRUF3ZEMwR29BU0VRREJ3TFFha0JJUkFNR3d0QnFnRWhFQXdhQzBHckFTRVFEQmtMUWF3QklSQU1HQXRCclFFaEVBd1hDMEd1QVNFUURCWUxRUUVoRUF3VkMwR3ZBU0VRREJRTFFiQUJJUkFNRXd0QnNRRWhFQXdTQzBHekFTRVFEQkVMUWJJQklSQU1FQXRCdEFFaEVBd1BDMEcxQVNFUURBNExRYllCSVJBTURRdEJ0d0VoRUF3TUMwRzRBU0VRREFzTFFia0JJUkFNQ2d0QnVnRWhFQXdKQzBHN0FTRVFEQWdMUWNZQklSQU1Cd3RCdkFFaEVBd0dDMEc5QVNFUURBVUxRYjRCSVJBTUJBdEJ2d0VoRUF3REMwSEFBU0VRREFJTFFjSUJJUkFNQVF0QndRRWhFQXNEUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlCQU94d0VBQVFJREJBVUdCd2dKQ2dzTURRNFBFQkVTRXhRVkZoY1lHUm9iSEI0ZklDRWpKU2cvUUVGRVJVWkhTRWxLUzB4TlQxQlJVbFBlQTFkWlcxeGRZR0psWm1kb2FXcHJiRzF2Y0hGeWMzUjFkbmQ0ZVhwN2ZIMStnQUdDQVlVQmhnR0hBWWtCaXdHTUFZMEJqZ0dQQVpBQmtRR1VBWlVCbGdHWEFaZ0JtUUdhQVpzQm5BR2RBWjRCbndHZ0FhRUJvZ0dqQWFRQnBRR21BYWNCcUFHcEFhb0Jxd0dzQWEwQnJnR3ZBYkFCc1FHeUFiTUJ0QUcxQWJZQnR3RzRBYmtCdWdHN0Fid0J2UUcrQWI4QndBSEJBY0lCd3dIRUFjVUJ4Z0hIQWNnQnlRSEtBY3NCekFITkFjNEJ6d0hRQWRFQjBnSFRBZFFCMVFIV0FkY0IyQUhaQWRvQjJ3SGNBZDBCM2dIZ0FlRUI0Z0hqQWVRQjVRSG1BZWNCNkFIcEFlb0I2d0hzQWUwQjdnSHZBZkFCOFFIeUFmTUJtUUtrQXJBQy9nTCtBZ3NnQVNJRUlBSkhEZk1CUWQwQklSQU0vd01MSUFFaUVDQUNSdzNkQVVIREFTRVFEUDREQ3lBQklnRWdBa2NOa0FGQjl3QWhFQXo5QXdzZ0FTSUJJQUpIRFlZQlFlOEFJUkFNL0FNTElBRWlBU0FDUncxL1Flb0FJUkFNK3dNTElBRWlBU0FDUncxN1FlZ0FJUkFNK2dNTElBRWlBU0FDUncxNFFlWUFJUkFNK1FNTElBRWlBU0FDUncwYVFSZ2hFQXo0QXdzZ0FTSUJJQUpIRFJSQkVpRVFEUGNEQ3lBQklnRWdBa2NOV1VIRkFDRVFEUFlEQ3lBQklnRWdBa2NOU2tFL0lSQU05UU1MSUFFaUFTQUNSdzFJUVR3aEVBejBBd3NnQVNJQklBSkhEVUZCTVNFUURQTURDeUFBTFFBdVFRRkdEZXNEREljQ0N5QUFJQUVpQVNBQ0VNQ0FnSUFBUVFGSERlWUJJQUJDQURjRElBem5BUXNnQUNBQklnRWdBaEMwZ0lDQUFDSVFEZWNCSUFFaEFRejFBZ3NDUUNBQklnRWdBa2NOQUVFR0lSQU04QU1MSUFBZ0FVRUJhaUlCSUFJUXU0Q0FnQUFpRUEzb0FTQUJJUUVNTVFzZ0FFSUFOd01nUVJJaEVBelZBd3NnQVNJUUlBSkhEU3RCSFNFUURPMERDd0pBSUFFaUFTQUNSZzBBSUFGQkFXb2hBVUVRSVJBTTFBTUxRUWNoRUF6c0F3c2dBRUlBSUFBcEF5QWlFU0FDSUFFaUVHdXRJaEo5SWhNZ0V5QVJWaHMzQXlBZ0VTQVNWaUlVUlEzbEFVRUlJUkFNNndNTEFrQWdBU0lCSUFKR0RRQWdBRUdKZ0lDQUFEWUNDQ0FBSUFFMkFnUWdBU0VCUVJRaEVBelNBd3RCQ1NFUURPb0RDeUFCSVFFZ0FDa0RJRkFONUFFZ0FTRUJEUElDQ3dKQUlBRWlBU0FDUncwQVFRc2hFQXpwQXdzZ0FDQUJRUUZxSWdFZ0FoQzJnSUNBQUNJUURlVUJJQUVoQVF6eUFnc2dBQ0FCSWdFZ0FoQzRnSUNBQUNJUURlVUJJQUVoQVF6eUFnc2dBQ0FCSWdFZ0FoQzRnSUNBQUNJUURlWUJJQUVoQVF3TkN5QUFJQUVpQVNBQ0VMcUFnSUFBSWhBTjV3RWdBU0VCRFBBQ0N3SkFJQUVpQVNBQ1J3MEFRUThoRUF6bEF3c2dBUzBBQUNJUVFUdEdEUWdnRUVFTlJ3M29BU0FCUVFGcUlRRU03d0lMSUFBZ0FTSUJJQUlRdW9DQWdBQWlFQTNvQVNBQklRRU04Z0lMQTBBQ1FDQUJMUUFBUWZDMWdJQUFhaTBBQUNJUVFRRkdEUUFnRUVFQ1J3M3JBU0FBS0FJRUlSQWdBRUVBTmdJRUlBQWdFQ0FCUVFGcUlnRVF1WUNBZ0FBaUVBM3FBU0FCSVFFTTlBSUxJQUZCQVdvaUFTQUNSdzBBQzBFU0lSQU00Z01MSUFBZ0FTSUJJQUlRdW9DQWdBQWlFQTNwQVNBQklRRU1DZ3NnQVNJQklBSkhEUVpCR3lFUURPQURDd0pBSUFFaUFTQUNSdzBBUVJZaEVBemdBd3NnQUVHS2dJQ0FBRFlDQ0NBQUlBRTJBZ1FnQUNBQklBSVF1SUNBZ0FBaUVBM3FBU0FCSVFGQklDRVFETVlEQ3dKQUlBRWlBU0FDUmcwQUEwQUNRQ0FCTFFBQVFmQzNnSUFBYWkwQUFDSVFRUUpHRFFBQ1FDQVFRWDlxRGdUbEFld0JBT3NCN0FFTElBRkJBV29oQVVFSUlSQU15QU1MSUFGQkFXb2lBU0FDUncwQUMwRVZJUkFNM3dNTFFSVWhFQXplQXdzRFFBSkFJQUV0QUFCQjhMbUFnQUJxTFFBQUloQkJBa1lOQUNBUVFYOXFEZ1RlQWV3QjRBSHJBZXdCQ3lBQlFRRnFJZ0VnQWtjTkFBdEJHQ0VRRE4wREN3SkFJQUVpQVNBQ1JnMEFJQUJCaTRDQWdBQTJBZ2dnQUNBQk5nSUVJQUVoQVVFSElSQU14QU1MUVJraEVBemNBd3NnQVVFQmFpRUJEQUlMQWtBZ0FTSVVJQUpIRFFCQkdpRVFETnNEQ3lBVUlRRUNRQ0FVTFFBQVFYTnFEaFRkQXU0QzdnTHVBdTRDN2dMdUF1NEM3Z0x1QXU0QzdnTHVBdTRDN2dMdUF1NEM3Z0x1QWdEdUFndEJBQ0VRSUFCQkFEWUNIQ0FBUWErTGdJQUFOZ0lRSUFCQkFqWUNEQ0FBSUJSQkFXbzJBaFFNMmdNTEFrQWdBUzBBQUNJUVFUdEdEUUFnRUVFTlJ3M29BU0FCUVFGcUlRRU01UUlMSUFGQkFXb2hBUXRCSWlFUURMOERDd0pBSUFFaUVDQUNSdzBBUVJ3aEVBellBd3RDQUNFUklCQWhBU0FRTFFBQVFWQnFEamZuQWVZQkFRSURCQVVHQndnQUFBQUFBQUFBQ1FvTERBME9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVBFQkVTRXhRQUMwRWVJUkFNdlFNTFFnSWhFUXpsQVF0Q0F5RVJET1FCQzBJRUlSRU00d0VMUWdVaEVRemlBUXRDQmlFUkRPRUJDMElISVJFTTRBRUxRZ2doRVF6ZkFRdENDU0VSRE40QkMwSUtJUkVNM1FFTFFnc2hFUXpjQVF0Q0RDRVJETnNCQzBJTklSRU0yZ0VMUWc0aEVRelpBUXRDRHlFUkROZ0JDMElLSVJFTTF3RUxRZ3NoRVF6V0FRdENEQ0VSRE5VQkMwSU5JUkVNMUFFTFFnNGhFUXpUQVF0Q0R5RVJETklCQzBJQUlSRUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUJBdEFBQkJVR29PTitVQjVBRUFBUUlEQkFVR0IrWUI1Z0htQWVZQjVnSG1BZVlCQ0FrS0N3d041Z0htQWVZQjVnSG1BZVlCNWdIbUFlWUI1Z0htQWVZQjVnSG1BZVlCNWdIbUFlWUI1Z0htQWVZQjVnSG1BZVlCNWdIbUFRNFBFQkVTRStZQkMwSUNJUkVNNUFFTFFnTWhFUXpqQVF0Q0JDRVJET0lCQzBJRklSRU00UUVMUWdZaEVRemdBUXRDQnlFUkROOEJDMElJSVJFTTNnRUxRZ2toRVF6ZEFRdENDaUVSRE53QkMwSUxJUkVNMndFTFFnd2hFUXphQVF0Q0RTRVJETmtCQzBJT0lSRU0yQUVMUWc4aEVRelhBUXRDQ2lFUkROWUJDMElMSVJFTTFRRUxRZ3doRVF6VUFRdENEU0VSRE5NQkMwSU9JUkVNMGdFTFFnOGhFUXpSQVFzZ0FFSUFJQUFwQXlBaUVTQUNJQUVpRUd1dEloSjlJaE1nRXlBUlZoczNBeUFnRVNBU1ZpSVVSUTNTQVVFZklSQU13QU1MQWtBZ0FTSUJJQUpHRFFBZ0FFR0pnSUNBQURZQ0NDQUFJQUUyQWdRZ0FTRUJRU1FoRUF5bkF3dEJJQ0VRREw4REN5QUFJQUVpRUNBQ0VMNkFnSUFBUVg5cURnVzJBUURGQWdIUkFkSUJDMEVSSVJBTXBBTUxJQUJCQVRvQUx5QVFJUUVNdXdNTElBRWlBU0FDUnczU0FVRWtJUkFNdXdNTElBRWlEU0FDUncwZVFjWUFJUkFNdWdNTElBQWdBU0lCSUFJUXNvQ0FnQUFpRUEzVUFTQUJJUUVNdFFFTElBRWlFQ0FDUncwbVFkQUFJUkFNdUFNTEFrQWdBU0lCSUFKSERRQkJLQ0VRRExnREN5QUFRUUEyQWdRZ0FFR01nSUNBQURZQ0NDQUFJQUVnQVJDeGdJQ0FBQ0lRRGRNQklBRWhBUXpZQVFzQ1FDQUJJaEFnQWtjTkFFRXBJUkFNdHdNTElCQXRBQUFpQVVFZ1JnMFVJQUZCQ1VjTjB3RWdFRUVCYWlFQkRCVUxBa0FnQVNJQklBSkdEUUFnQVVFQmFpRUJEQmNMUVNvaEVBeTFBd3NDUUNBQkloQWdBa2NOQUVFcklSQU10UU1MQWtBZ0VDMEFBQ0lCUVFsR0RRQWdBVUVnUnczVkFRc2dBQzBBTEVFSVJnM1RBU0FRSVFFTWtRTUxBa0FnQVNJQklBSkhEUUJCTENFUURMUURDeUFCTFFBQVFRcEhEZFVCSUFGQkFXb2hBUXpKQWdzZ0FTSU9JQUpIRGRVQlFTOGhFQXl5QXdzRFFBSkFJQUV0QUFBaUVFRWdSZzBBQWtBZ0VFRjJhZzRFQU53QjNBRUEyZ0VMSUFFaEFRemdBUXNnQVVFQmFpSUJJQUpIRFFBTFFURWhFQXl4QXd0Qk1pRVFJQUVpRkNBQ1JnMndBeUFDSUJScklBQW9BZ0FpQVdvaEZTQVVJQUZyUVFOcUlSWUNRQU5BSUJRdEFBQWlGMEVnY2lBWElCZEJ2MzlxUWY4QmNVRWFTUnRCL3dGeElBRkI4THVBZ0FCcUxRQUFSdzBCQWtBZ0FVRURSdzBBUVFZaEFReVdBd3NnQVVFQmFpRUJJQlJCQVdvaUZDQUNSdzBBQ3lBQUlCVTJBZ0FNc1FNTElBQkJBRFlDQUNBVUlRRU0yUUVMUVRNaEVDQUJJaFFnQWtZTnJ3TWdBaUFVYXlBQUtBSUFJZ0ZxSVJVZ0ZDQUJhMEVJYWlFV0FrQURRQ0FVTFFBQUloZEJJSElnRnlBWFFiOS9ha0gvQVhGQkdra2JRZjhCY1NBQlFmUzdnSUFBYWkwQUFFY05BUUpBSUFGQkNFY05BRUVGSVFFTWxRTUxJQUZCQVdvaEFTQVVRUUZxSWhRZ0FrY05BQXNnQUNBVk5nSUFETEFEQ3lBQVFRQTJBZ0FnRkNFQkROZ0JDMEUwSVJBZ0FTSVVJQUpHRGE0RElBSWdGR3NnQUNnQ0FDSUJhaUVWSUJRZ0FXdEJCV29oRmdKQUEwQWdGQzBBQUNJWFFTQnlJQmNnRjBHL2YycEIvd0Z4UVJwSkcwSC9BWEVnQVVIUXdvQ0FBR290QUFCSERRRUNRQ0FCUVFWSERRQkJCeUVCREpRREN5QUJRUUZxSVFFZ0ZFRUJhaUlVSUFKSERRQUxJQUFnRlRZQ0FBeXZBd3NnQUVFQU5nSUFJQlFoQVF6WEFRc0NRQ0FCSWdFZ0FrWU5BQU5BQWtBZ0FTMEFBRUdBdm9DQUFHb3RBQUFpRUVFQlJnMEFJQkJCQWtZTkNpQUJJUUVNM1FFTElBRkJBV29pQVNBQ1J3MEFDMEV3SVJBTXJnTUxRVEFoRUF5dEF3c0NRQ0FCSWdFZ0FrWU5BQU5BQWtBZ0FTMEFBQ0lRUVNCR0RRQWdFRUYyYWc0RTJRSGFBZG9CMlFIYUFRc2dBVUVCYWlJQklBSkhEUUFMUVRnaEVBeXRBd3RCT0NFUURLd0RDd05BQWtBZ0FTMEFBQ0lRUVNCR0RRQWdFRUVKUncwREN5QUJRUUZxSWdFZ0FrY05BQXRCUENFUURLc0RDd05BQWtBZ0FTMEFBQ0lRUVNCR0RRQUNRQUpBSUJCQmRtb09CTm9CQVFIYUFRQUxJQkJCTEVZTjJ3RUxJQUVoQVF3RUN5QUJRUUZxSWdFZ0FrY05BQXRCUHlFUURLb0RDeUFCSVFFTTJ3RUxRY0FBSVJBZ0FTSVVJQUpHRGFnRElBSWdGR3NnQUNnQ0FDSUJhaUVXSUJRZ0FXdEJCbW9oRndKQUEwQWdGQzBBQUVFZ2NpQUJRWURBZ0lBQWFpMEFBRWNOQVNBQlFRWkdEWTRESUFGQkFXb2hBU0FVUVFGcUloUWdBa2NOQUFzZ0FDQVdOZ0lBREtrREN5QUFRUUEyQWdBZ0ZDRUJDMEUySVJBTWpnTUxBa0FnQVNJUElBSkhEUUJCd1FBaEVBeW5Bd3NnQUVHTWdJQ0FBRFlDQ0NBQUlBODJBZ1FnRHlFQklBQXRBQ3hCZjJvT0JNMEIxUUhYQWRrQmh3TUxJQUZCQVdvaEFRek1BUXNDUUNBQklnRWdBa1lOQUFOQUFrQWdBUzBBQUNJUVFTQnlJQkFnRUVHL2YycEIvd0Z4UVJwSkcwSC9BWEVpRUVFSlJnMEFJQkJCSUVZTkFBSkFBa0FDUUFKQUlCQkJuWDlxRGhNQUF3TURBd01EQXdFREF3TURBd01EQXdNQ0F3c2dBVUVCYWlFQlFURWhFQXlSQXdzZ0FVRUJhaUVCUVRJaEVBeVFBd3NnQVVFQmFpRUJRVE1oRUF5UEF3c2dBU0VCRE5BQkN5QUJRUUZxSWdFZ0FrY05BQXRCTlNFUURLVURDMEUxSVJBTXBBTUxBa0FnQVNJQklBSkdEUUFEUUFKQUlBRXRBQUJCZ0x5QWdBQnFMUUFBUVFGR0RRQWdBU0VCRE5NQkN5QUJRUUZxSWdFZ0FrY05BQXRCUFNFUURLUURDMEU5SVJBTW93TUxJQUFnQVNJQklBSVFzSUNBZ0FBaUVBM1dBU0FCSVFFTUFRc2dFRUVCYWlFQkMwRThJUkFNaHdNTEFrQWdBU0lCSUFKSERRQkJ3Z0FoRUF5Z0F3c0NRQU5BQWtBZ0FTMEFBRUYzYWc0WUFBTCtBdjRDaEFQK0F2NEMvZ0wrQXY0Qy9nTCtBdjRDL2dMK0F2NEMvZ0wrQXY0Qy9nTCtBdjRDL2dJQS9nSUxJQUZCQVdvaUFTQUNSdzBBQzBIQ0FDRVFES0FEQ3lBQlFRRnFJUUVnQUMwQUxVRUJjVVVOdlFFZ0FTRUJDMEVzSVJBTWhRTUxJQUVpQVNBQ1J3M1RBVUhFQUNFUURKMERDd05BQWtBZ0FTMEFBRUdRd0lDQUFHb3RBQUJCQVVZTkFDQUJJUUVNdHdJTElBRkJBV29pQVNBQ1J3MEFDMEhGQUNFUURKd0RDeUFOTFFBQUloQkJJRVlOc3dFZ0VFRTZSdzJCQXlBQUtBSUVJUUVnQUVFQU5nSUVJQUFnQVNBTkVLK0FnSUFBSWdFTjBBRWdEVUVCYWlFQkRMTUNDMEhIQUNFUUlBRWlEU0FDUmcyYUF5QUNJQTFySUFBb0FnQWlBV29oRmlBTklBRnJRUVZxSVJjRFFDQU5MUUFBSWhSQklISWdGQ0FVUWI5L2FrSC9BWEZCR2trYlFmOEJjU0FCUVpEQ2dJQUFhaTBBQUVjTmdBTWdBVUVGUmczMEFpQUJRUUZxSVFFZ0RVRUJhaUlOSUFKSERRQUxJQUFnRmpZQ0FBeWFBd3RCeUFBaEVDQUJJZzBnQWtZTm1RTWdBaUFOYXlBQUtBSUFJZ0ZxSVJZZ0RTQUJhMEVKYWlFWEEwQWdEUzBBQUNJVVFTQnlJQlFnRkVHL2YycEIvd0Z4UVJwSkcwSC9BWEVnQVVHV3dvQ0FBR290QUFCSERmOENBa0FnQVVFSlJ3MEFRUUloQVF6MUFnc2dBVUVCYWlFQklBMUJBV29pRFNBQ1J3MEFDeUFBSUJZMkFnQU1tUU1MQWtBZ0FTSU5JQUpIRFFCQnlRQWhFQXlaQXdzQ1FBSkFJQTB0QUFBaUFVRWdjaUFCSUFGQnYzOXFRZjhCY1VFYVNSdEIvd0Z4UVpKL2FnNEhBSUFEZ0FPQUE0QURnQU1CZ0FNTElBMUJBV29oQVVFK0lSQU1nQU1MSUExQkFXb2hBVUUvSVJBTS93SUxRY29BSVJBZ0FTSU5JQUpHRFpjRElBSWdEV3NnQUNnQ0FDSUJhaUVXSUEwZ0FXdEJBV29oRndOQUlBMHRBQUFpRkVFZ2NpQVVJQlJCdjM5cVFmOEJjVUVhU1J0Qi93RnhJQUZCb01LQWdBQnFMUUFBUnczOUFpQUJRUUZHRGZBQ0lBRkJBV29oQVNBTlFRRnFJZzBnQWtjTkFBc2dBQ0FXTmdJQURKY0RDMEhMQUNFUUlBRWlEU0FDUmcyV0F5QUNJQTFySUFBb0FnQWlBV29oRmlBTklBRnJRUTVxSVJjRFFDQU5MUUFBSWhSQklISWdGQ0FVUWI5L2FrSC9BWEZCR2trYlFmOEJjU0FCUWFMQ2dJQUFhaTBBQUVjTi9BSWdBVUVPUmczd0FpQUJRUUZxSVFFZ0RVRUJhaUlOSUFKSERRQUxJQUFnRmpZQ0FBeVdBd3RCekFBaEVDQUJJZzBnQWtZTmxRTWdBaUFOYXlBQUtBSUFJZ0ZxSVJZZ0RTQUJhMEVQYWlFWEEwQWdEUzBBQUNJVVFTQnlJQlFnRkVHL2YycEIvd0Z4UVJwSkcwSC9BWEVnQVVIQXdvQ0FBR290QUFCSERmc0NBa0FnQVVFUFJ3MEFRUU1oQVF6eEFnc2dBVUVCYWlFQklBMUJBV29pRFNBQ1J3MEFDeUFBSUJZMkFnQU1sUU1MUWMwQUlSQWdBU0lOSUFKR0RaUURJQUlnRFdzZ0FDZ0NBQ0lCYWlFV0lBMGdBV3RCQldvaEZ3TkFJQTB0QUFBaUZFRWdjaUFVSUJSQnYzOXFRZjhCY1VFYVNSdEIvd0Z4SUFGQjBNS0FnQUJxTFFBQVJ3MzZBZ0pBSUFGQkJVY05BRUVFSVFFTThBSUxJQUZCQVdvaEFTQU5RUUZxSWcwZ0FrY05BQXNnQUNBV05nSUFESlFEQ3dKQUlBRWlEU0FDUncwQVFjNEFJUkFNbEFNTEFrQUNRQUpBQWtBZ0RTMEFBQ0lCUVNCeUlBRWdBVUcvZjJwQi93RnhRUnBKRzBIL0FYRkJuWDlxRGhNQS9RTDlBdjBDL1FMOUF2MEMvUUw5QXYwQy9RTDlBdjBDQWYwQy9RTDlBZ0lEL1FJTElBMUJBV29oQVVIQkFDRVFEUDBDQ3lBTlFRRnFJUUZCd2dBaEVBejhBZ3NnRFVFQmFpRUJRY01BSVJBTSt3SUxJQTFCQVdvaEFVSEVBQ0VRRFBvQ0N3SkFJQUVpQVNBQ1JnMEFJQUJCallDQWdBQTJBZ2dnQUNBQk5nSUVJQUVoQVVIRkFDRVFEUG9DQzBIUEFDRVFESklEQ3lBUUlRRUNRQUpBSUJBdEFBQkJkbW9PQkFHb0FxZ0NBS2dDQ3lBUVFRRnFJUUVMUVNjaEVBejRBZ3NDUUNBQklnRWdBa2NOQUVIUkFDRVFESkVEQ3dKQUlBRXRBQUJCSUVZTkFDQUJJUUVNalFFTElBRkJBV29oQVNBQUxRQXRRUUZ4UlEzSEFTQUJJUUVNakFFTElBRWlGeUFDUnczSUFVSFNBQ0VRREk4REMwSFRBQ0VRSUFFaUZDQUNSZzJPQXlBQ0lCUnJJQUFvQWdBaUFXb2hGaUFVSUFGclFRRnFJUmNEUUNBVUxRQUFJQUZCMXNLQWdBQnFMUUFBUnczTUFTQUJRUUZHRGNjQklBRkJBV29oQVNBVVFRRnFJaFFnQWtjTkFBc2dBQ0FXTmdJQURJNERDd0pBSUFFaUFTQUNSdzBBUWRVQUlSQU1qZ01MSUFFdEFBQkJDa2NOekFFZ0FVRUJhaUVCRE1jQkN3SkFJQUVpQVNBQ1J3MEFRZFlBSVJBTWpRTUxBa0FDUUNBQkxRQUFRWFpxRGdRQXpRSE5BUUhOQVFzZ0FVRUJhaUVCRE1jQkN5QUJRUUZxSVFGQnlnQWhFQXp6QWdzZ0FDQUJJZ0VnQWhDdWdJQ0FBQ0lRRGNzQklBRWhBVUhOQUNFUURQSUNDeUFBTFFBcFFTSkdEWVVEREtZQ0N3SkFJQUVpQVNBQ1J3MEFRZHNBSVJBTWlnTUxRUUFoRkVFQklSZEJBU0VXUVFBaEVBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUJMUUFBUVZCcURnclVBZE1CQUFFQ0F3UUZCZ2pWQVF0QkFpRVFEQVlMUVFNaEVBd0ZDMEVFSVJBTUJBdEJCU0VRREFNTFFRWWhFQXdDQzBFSElSQU1BUXRCQ0NFUUMwRUFJUmRCQUNFV1FRQWhGQXpNQVF0QkNTRVFRUUVoRkVFQUlSZEJBQ0VXRE1zQkN3SkFJQUVpQVNBQ1J3MEFRZDBBSVJBTWlRTUxJQUV0QUFCQkxrY056QUVnQVVFQmFpRUJES1lDQ3lBQklnRWdBa2NOekFGQjN3QWhFQXlIQXdzQ1FDQUJJZ0VnQWtZTkFDQUFRWTZBZ0lBQU5nSUlJQUFnQVRZQ0JDQUJJUUZCMEFBaEVBenVBZ3RCNEFBaEVBeUdBd3RCNFFBaEVDQUJJZ0VnQWtZTmhRTWdBaUFCYXlBQUtBSUFJaFJxSVJZZ0FTQVVhMEVEYWlFWEEwQWdBUzBBQUNBVVFlTENnSUFBYWkwQUFFY056UUVnRkVFRFJnM01BU0FVUVFGcUlSUWdBVUVCYWlJQklBSkhEUUFMSUFBZ0ZqWUNBQXlGQXd0QjRnQWhFQ0FCSWdFZ0FrWU5oQU1nQWlBQmF5QUFLQUlBSWhScUlSWWdBU0FVYTBFQ2FpRVhBMEFnQVMwQUFDQVVRZWJDZ0lBQWFpMEFBRWNOekFFZ0ZFRUNSZzNPQVNBVVFRRnFJUlFnQVVFQmFpSUJJQUpIRFFBTElBQWdGallDQUF5RUF3dEI0d0FoRUNBQklnRWdBa1lOZ3dNZ0FpQUJheUFBS0FJQUloUnFJUllnQVNBVWEwRURhaUVYQTBBZ0FTMEFBQ0FVUWVuQ2dJQUFhaTBBQUVjTnl3RWdGRUVEUmczT0FTQVVRUUZxSVJRZ0FVRUJhaUlCSUFKSERRQUxJQUFnRmpZQ0FBeURBd3NDUUNBQklnRWdBa2NOQUVIbEFDRVFESU1EQ3lBQUlBRkJBV29pQVNBQ0VLaUFnSUFBSWhBTnpRRWdBU0VCUWRZQUlSQU02UUlMQWtBZ0FTSUJJQUpHRFFBRFFBSkFJQUV0QUFBaUVFRWdSZzBBQWtBQ1FBSkFJQkJCdUg5cURnc0FBYzhCendIUEFjOEJ6d0hQQWM4Qnp3RUN6d0VMSUFGQkFXb2hBVUhTQUNFUURPMENDeUFCUVFGcUlRRkIwd0FoRUF6c0Fnc2dBVUVCYWlFQlFkUUFJUkFNNndJTElBRkJBV29pQVNBQ1J3MEFDMEhrQUNFUURJSURDMEhrQUNFUURJRURDd05BQWtBZ0FTMEFBRUh3d29DQUFHb3RBQUFpRUVFQlJnMEFJQkJCZm1vT0E4OEIwQUhSQWRJQkN5QUJRUUZxSWdFZ0FrY05BQXRCNWdBaEVBeUFBd3NDUUNBQklnRWdBa1lOQUNBQlFRRnFJUUVNQXd0QjV3QWhFQXovQWdzRFFBSkFJQUV0QUFCQjhNU0FnQUJxTFFBQUloQkJBVVlOQUFKQUlCQkJmbW9PQk5JQjB3SFVBUURWQVFzZ0FTRUJRZGNBSVJBTTV3SUxJQUZCQVdvaUFTQUNSdzBBQzBIb0FDRVFEUDRDQ3dKQUlBRWlBU0FDUncwQVFla0FJUkFNL2dJTEFrQWdBUzBBQUNJUVFYWnFEaHE2QWRVQjFRRzhBZFVCMVFIVkFkVUIxUUhWQWRVQjFRSFZBZFVCMVFIVkFkVUIxUUhWQWRVQjFRSFZBY29CMVFIVkFRRFRBUXNnQVVFQmFpRUJDMEVHSVJBTTR3SUxBMEFDUUNBQkxRQUFRZkRHZ0lBQWFpMEFBRUVCUmcwQUlBRWhBUXllQWdzZ0FVRUJhaUlCSUFKSERRQUxRZW9BSVJBTSt3SUxBa0FnQVNJQklBSkdEUUFnQVVFQmFpRUJEQU1MUWVzQUlSQU0rZ0lMQWtBZ0FTSUJJQUpIRFFCQjdBQWhFQXo2QWdzZ0FVRUJhaUVCREFFTEFrQWdBU0lCSUFKSERRQkI3UUFoRUF6NUFnc2dBVUVCYWlFQkMwRUVJUkFNM2dJTEFrQWdBU0lVSUFKSERRQkI3Z0FoRUF6M0Fnc2dGQ0VCQWtBQ1FBSkFJQlF0QUFCQjhNaUFnQUJxTFFBQVFYOXFEZ2ZVQWRVQjFnRUFuQUlCQXRjQkN5QVVRUUZxSVFFTUNnc2dGRUVCYWlFQkRNMEJDMEVBSVJBZ0FFRUFOZ0ljSUFCQm01S0FnQUEyQWhBZ0FFRUhOZ0lNSUFBZ0ZFRUJhallDRkF6MkFnc0NRQU5BQWtBZ0FTMEFBRUh3eUlDQUFHb3RBQUFpRUVFRVJnMEFBa0FDUUNBUVFYOXFEZ2ZTQWRNQjFBSFpBUUFFQWRrQkN5QUJJUUZCMmdBaEVBemdBZ3NnQVVFQmFpRUJRZHdBSVJBTTN3SUxJQUZCQVdvaUFTQUNSdzBBQzBIdkFDRVFEUFlDQ3lBQlFRRnFJUUVNeXdFTEFrQWdBU0lVSUFKSERRQkI4QUFoRUF6MUFnc2dGQzBBQUVFdlJ3M1VBU0FVUVFGcUlRRU1CZ3NDUUNBQkloUWdBa2NOQUVIeEFDRVFEUFFDQ3dKQUlCUXRBQUFpQVVFdlJ3MEFJQlJCQVdvaEFVSGRBQ0VRRE5zQ0N5QUJRWFpxSWdSQkZrc04wd0ZCQVNBRWRFR0pnSUFDY1VVTjB3RU15Z0lMQWtBZ0FTSUJJQUpHRFFBZ0FVRUJhaUVCUWQ0QUlSQU0yZ0lMUWZJQUlSQU04Z0lMQWtBZ0FTSVVJQUpIRFFCQjlBQWhFQXp5QWdzZ0ZDRUJBa0FnRkMwQUFFSHd6SUNBQUdvdEFBQkJmMm9PQThrQ2xBSUExQUVMUWVFQUlSQU0yQUlMQWtBZ0FTSVVJQUpHRFFBRFFBSkFJQlF0QUFCQjhNcUFnQUJxTFFBQUlnRkJBMFlOQUFKQUlBRkJmMm9PQXNzQ0FOVUJDeUFVSVFGQjN3QWhFQXphQWdzZ0ZFRUJhaUlVSUFKSERRQUxRZk1BSVJBTThRSUxRZk1BSVJBTThBSUxBa0FnQVNJQklBSkdEUUFnQUVHUGdJQ0FBRFlDQ0NBQUlBRTJBZ1FnQVNFQlFlQUFJUkFNMXdJTFFmVUFJUkFNN3dJTEFrQWdBU0lCSUFKSERRQkI5Z0FoRUF6dkFnc2dBRUdQZ0lDQUFEWUNDQ0FBSUFFMkFnUWdBU0VCQzBFRElSQU0xQUlMQTBBZ0FTMEFBRUVnUnczREFpQUJRUUZxSWdFZ0FrY05BQXRCOXdBaEVBenNBZ3NDUUNBQklnRWdBa2NOQUVINEFDRVFET3dDQ3lBQkxRQUFRU0JIRGM0QklBRkJBV29oQVF6dkFRc2dBQ0FCSWdFZ0FoQ3NnSUNBQUNJUURjNEJJQUVoQVF5T0Fnc0NRQ0FCSWdRZ0FrY05BRUg2QUNFUURPb0NDeUFFTFFBQVFjd0FSdzNSQVNBRVFRRnFJUUZCRXlFUURNOEJDd0pBSUFFaUJDQUNSdzBBUWZzQUlSQU02UUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkJXb2hFQU5BSUFRdEFBQWdBVUh3em9DQUFHb3RBQUJIRGRBQklBRkJCVVlOemdFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQit3QWhFQXpvQWdzQ1FDQUJJZ1FnQWtjTkFFSDhBQ0VRRE9nQ0N3SkFBa0FnQkMwQUFFRzlmMm9PREFEUkFkRUIwUUhSQWRFQjBRSFJBZEVCMFFIUkFRSFJBUXNnQkVFQmFpRUJRZVlBSVJBTXp3SUxJQVJCQVdvaEFVSG5BQ0VRRE00Q0N3SkFJQUVpQkNBQ1J3MEFRZjBBSVJBTTV3SUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQW1vaEVBSkFBMEFnQkMwQUFDQUJRZTNQZ0lBQWFpMEFBRWNOendFZ0FVRUNSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWYwQUlSQU01d0lMSUFCQkFEWUNBQ0FRUVFGcUlRRkJFQ0VRRE13QkN3SkFJQUVpQkNBQ1J3MEFRZjRBSVJBTTVnSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQldvaEVBSkFBMEFnQkMwQUFDQUJRZmJPZ0lBQWFpMEFBRWNOemdFZ0FVRUZSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWY0QUlSQU01Z0lMSUFCQkFEWUNBQ0FRUVFGcUlRRkJGaUVRRE1zQkN3SkFJQUVpQkNBQ1J3MEFRZjhBSVJBTTVRSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQTJvaEVBSkFBMEFnQkMwQUFDQUJRZnpPZ0lBQWFpMEFBRWNOelFFZ0FVRURSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWY4QUlSQU01UUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJCU0VRRE1vQkN3SkFJQUVpQkNBQ1J3MEFRWUFCSVJBTTVBSUxJQVF0QUFCQjJRQkhEY3NCSUFSQkFXb2hBVUVJSVJBTXlRRUxBa0FnQVNJRUlBSkhEUUJCZ1FFaEVBempBZ3NDUUFKQUlBUXRBQUJCc245cURnTUF6QUVCekFFTElBUkJBV29oQVVIckFDRVFETW9DQ3lBRVFRRnFJUUZCN0FBaEVBekpBZ3NDUUNBQklnUWdBa2NOQUVHQ0FTRVFET0lDQ3dKQUFrQWdCQzBBQUVHNGYyb09DQURMQWNzQnl3SExBY3NCeXdFQnl3RUxJQVJCQVdvaEFVSHFBQ0VRRE1rQ0N5QUVRUUZxSVFGQjdRQWhFQXpJQWdzQ1FDQUJJZ1FnQWtjTkFFR0RBU0VRRE9FQ0N5QUNJQVJySUFBb0FnQWlBV29oRUNBRUlBRnJRUUpxSVJRQ1FBTkFJQVF0QUFBZ0FVR0F6NENBQUdvdEFBQkhEY2tCSUFGQkFrWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0VEWUNBRUdEQVNFUURPRUNDMEVBSVJBZ0FFRUFOZ0lBSUJSQkFXb2hBUXpHQVFzQ1FDQUJJZ1FnQWtjTkFFR0VBU0VRRE9BQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUVJxSVJBQ1FBTkFJQVF0QUFBZ0FVR0R6NENBQUdvdEFBQkhEY2dCSUFGQkJFWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUdFQVNFUURPQUNDeUFBUVFBMkFnQWdFRUVCYWlFQlFTTWhFQXpGQVFzQ1FDQUJJZ1FnQWtjTkFFR0ZBU0VRRE44Q0N3SkFBa0FnQkMwQUFFRzBmMm9PQ0FESUFjZ0J5QUhJQWNnQnlBRUJ5QUVMSUFSQkFXb2hBVUh2QUNFUURNWUNDeUFFUVFGcUlRRkI4QUFoRUF6RkFnc0NRQ0FCSWdRZ0FrY05BRUdHQVNFUURONENDeUFFTFFBQVFjVUFSdzNGQVNBRVFRRnFJUUVNZ3dJTEFrQWdBU0lFSUFKSERRQkJod0VoRUF6ZEFnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVEYWlFUUFrQURRQ0FFTFFBQUlBRkJpTStBZ0FCcUxRQUFSdzNGQVNBQlFRTkdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCaHdFaEVBemRBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRXRJUkFNd2dFTEFrQWdBU0lFSUFKSERRQkJpQUVoRUF6Y0Fnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVJYWlFUUFrQURRQ0FFTFFBQUlBRkIwTStBZ0FCcUxRQUFSdzNFQVNBQlFRaEdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCaUFFaEVBemNBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRXBJUkFNd1FFTEFrQWdBU0lCSUFKSERRQkJpUUVoRUF6YkFndEJBU0VRSUFFdEFBQkIzd0JIRGNBQklBRkJBV29oQVF5QkFnc0NRQ0FCSWdRZ0FrY05BRUdLQVNFUUROb0NDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFGcUlSQURRQ0FFTFFBQUlBRkJqTStBZ0FCcUxRQUFSdzNCQVNBQlFRRkdEYThDSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUVlvQklSQU0yUUlMQWtBZ0FTSUVJQUpIRFFCQml3RWhFQXpaQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUNhaUVRQWtBRFFDQUVMUUFBSUFGQmpzK0FnQUJxTFFBQVJ3M0JBU0FCUVFKR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJpd0VoRUF6WkFnc2dBRUVBTmdJQUlCQkJBV29oQVVFQ0lSQU12Z0VMQWtBZ0FTSUVJQUpIRFFCQmpBRWhFQXpZQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUJhaUVRQWtBRFFDQUVMUUFBSUFGQjhNK0FnQUJxTFFBQVJ3M0FBU0FCUVFGR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJqQUVoRUF6WUFnc2dBRUVBTmdJQUlCQkJBV29oQVVFZklSQU12UUVMQWtBZ0FTSUVJQUpIRFFCQmpRRWhFQXpYQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUJhaUVRQWtBRFFDQUVMUUFBSUFGQjhzK0FnQUJxTFFBQVJ3Mi9BU0FCUVFGR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJqUUVoRUF6WEFnc2dBRUVBTmdJQUlCQkJBV29oQVVFSklSQU12QUVMQWtBZ0FTSUVJQUpIRFFCQmpnRWhFQXpXQWdzQ1FBSkFJQVF0QUFCQnQzOXFEZ2NBdndHL0FiOEJ2d0cvQVFHL0FRc2dCRUVCYWlFQlFmZ0FJUkFNdlFJTElBUkJBV29oQVVINUFDRVFETHdDQ3dKQUlBRWlCQ0FDUncwQVFZOEJJUkFNMVFJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJCV29oRUFKQUEwQWdCQzBBQUNBQlFaSFBnSUFBYWkwQUFFY052UUVnQVVFRlJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRWThCSVJBTTFRSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkdDRVFETG9CQ3dKQUlBRWlCQ0FDUncwQVFaQUJJUkFNMUFJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBbW9oRUFKQUEwQWdCQzBBQUNBQlFaZlBnSUFBYWkwQUFFY052QUVnQVVFQ1JnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRWkFCSVJBTTFBSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkZ5RVFETGtCQ3dKQUlBRWlCQ0FDUncwQVFaRUJJUkFNMHdJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJCbW9oRUFKQUEwQWdCQzBBQUNBQlFaclBnSUFBYWkwQUFFY051d0VnQVVFR1JnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRWkVCSVJBTTB3SUxJQUJCQURZQ0FDQVFRUUZxSVFGQkZTRVFETGdCQ3dKQUlBRWlCQ0FDUncwQVFaSUJJUkFNMGdJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJCV29oRUFKQUEwQWdCQzBBQUNBQlFhSFBnSUFBYWkwQUFFY051Z0VnQVVFRlJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRWklCSVJBTTBnSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkhpRVFETGNCQ3dKQUlBRWlCQ0FDUncwQVFaTUJJUkFNMFFJTElBUXRBQUJCekFCSERiZ0JJQVJCQVdvaEFVRUtJUkFNdGdFTEFrQWdCQ0FDUncwQVFaUUJJUkFNMEFJTEFrQUNRQ0FFTFFBQVFiOS9hZzRQQUxrQnVRRzVBYmtCdVFHNUFia0J1UUc1QWJrQnVRRzVBYmtCQWJrQkN5QUVRUUZxSVFGQi9nQWhFQXkzQWdzZ0JFRUJhaUVCUWY4QUlSQU10Z0lMQWtBZ0JDQUNSdzBBUVpVQklSQU16d0lMQWtBQ1FDQUVMUUFBUWI5L2FnNERBTGdCQWJnQkN5QUVRUUZxSVFGQi9RQWhFQXkyQWdzZ0JFRUJhaUVFUVlBQklSQU10UUlMQWtBZ0JDQUNSdzBBUVpZQklSQU16Z0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFXb2hFQUpBQTBBZ0JDMEFBQ0FCUWFmUGdJQUFhaTBBQUVjTnRnRWdBVUVCUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFaWUJJUkFNemdJTElBQkJBRFlDQUNBUVFRRnFJUUZCQ3lFUURMTUJDd0pBSUFRZ0FrY05BRUdYQVNFUURNMENDd0pBQWtBQ1FBSkFJQVF0QUFCQlUyb09Jd0M0QWJnQnVBRzRBYmdCdUFHNEFiZ0J1QUc0QWJnQnVBRzRBYmdCdUFHNEFiZ0J1QUc0QWJnQnVBRzRBYmdCQWJnQnVBRzRBYmdCdUFFQ3VBRzRBYmdCQTdnQkN5QUVRUUZxSVFGQit3QWhFQXkyQWdzZ0JFRUJhaUVCUWZ3QUlSQU10UUlMSUFSQkFXb2hCRUdCQVNFUURMUUNDeUFFUVFGcUlRUkJnZ0VoRUF5ekFnc0NRQ0FFSUFKSERRQkJtQUVoRUF6TUFnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVFYWlFUUFrQURRQ0FFTFFBQUlBRkJxYytBZ0FCcUxRQUFSdzIwQVNBQlFRUkdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCbUFFaEVBek1BZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRVpJUkFNc1FFTEFrQWdCQ0FDUncwQVFaa0JJUkFNeXdJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJCV29oRUFKQUEwQWdCQzBBQUNBQlFhN1BnSUFBYWkwQUFFY05zd0VnQVVFRlJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRWmtCSVJBTXl3SUxJQUJCQURZQ0FDQVFRUUZxSVFGQkJpRVFETEFCQ3dKQUlBUWdBa2NOQUVHYUFTRVFETW9DQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRRnFJUkFDUUFOQUlBUXRBQUFnQVVHMHo0Q0FBR290QUFCSERiSUJJQUZCQVVZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR2FBU0VRRE1vQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVJ3aEVBeXZBUXNDUUNBRUlBSkhEUUJCbXdFaEVBekpBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQmFpRVFBa0FEUUNBRUxRQUFJQUZCdHMrQWdBQnFMUUFBUncyeEFTQUJRUUZHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQm13RWhFQXpKQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVuSVJBTXJnRUxBa0FnQkNBQ1J3MEFRWndCSVJBTXlBSUxBa0FDUUNBRUxRQUFRYXgvYWc0Q0FBR3hBUXNnQkVFQmFpRUVRWVlCSVJBTXJ3SUxJQVJCQVdvaEJFR0hBU0VRREs0Q0N3SkFJQVFnQWtjTkFFR2RBU0VRRE1jQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUZxSVJBQ1FBTkFJQVF0QUFBZ0FVRzR6NENBQUdvdEFBQkhEYThCSUFGQkFVWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUdkQVNFUURNY0NDeUFBUVFBMkFnQWdFRUVCYWlFQlFTWWhFQXlzQVFzQ1FDQUVJQUpIRFFCQm5nRWhFQXpHQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUJhaUVRQWtBRFFDQUVMUUFBSUFGQnVzK0FnQUJxTFFBQVJ3MnVBU0FCUVFGR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJuZ0VoRUF6R0Fnc2dBRUVBTmdJQUlCQkJBV29oQVVFRElSQU1xd0VMQWtBZ0JDQUNSdzBBUVo4QklSQU14UUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFtb2hFQUpBQTBBZ0JDMEFBQ0FCUWUzUGdJQUFhaTBBQUVjTnJRRWdBVUVDUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFaOEJJUkFNeFFJTElBQkJBRFlDQUNBUVFRRnFJUUZCRENFUURLb0JDd0pBSUFRZ0FrY05BRUdnQVNFUURNUUNDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFOcUlSQUNRQU5BSUFRdEFBQWdBVUc4ejRDQUFHb3RBQUJIRGF3QklBRkJBMFlOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHZ0FTRVFETVFDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUTBoRUF5cEFRc0NRQ0FFSUFKSERRQkJvUUVoRUF6REFnc0NRQUpBSUFRdEFBQkJ1bjlxRGdzQXJBR3NBYXdCckFHc0Fhd0JyQUdzQWF3QkFhd0JDeUFFUVFGcUlRUkJpd0VoRUF5cUFnc2dCRUVCYWlFRVFZd0JJUkFNcVFJTEFrQWdCQ0FDUncwQVFhSUJJUkFNd2dJTElBUXRBQUJCMEFCSERha0JJQVJCQVdvaEJBenBBUXNDUUNBRUlBSkhEUUJCb3dFaEVBekJBZ3NDUUFKQUlBUXRBQUJCdDM5cURnY0JxZ0dxQWFvQnFnR3FBUUNxQVFzZ0JFRUJhaUVFUVk0QklSQU1xQUlMSUFSQkFXb2hBVUVpSVJBTXBnRUxBa0FnQkNBQ1J3MEFRYVFCSVJBTXdBSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQVdvaEVBSkFBMEFnQkMwQUFDQUJRY0RQZ0lBQWFpMEFBRWNOcUFFZ0FVRUJSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWFRQklSQU13QUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJIU0VRREtVQkN3SkFJQVFnQWtjTkFFR2xBU0VRREw4Q0N3SkFBa0FnQkMwQUFFR3VmMm9PQXdDb0FRR29BUXNnQkVFQmFpRUVRWkFCSVJBTXBnSUxJQVJCQVdvaEFVRUVJUkFNcEFFTEFrQWdCQ0FDUncwQVFhWUJJUkFNdmdJTEFrQUNRQUpBQWtBQ1FDQUVMUUFBUWI5L2FnNFZBS29CcWdHcUFhb0JxZ0dxQWFvQnFnR3FBYW9CQWFvQnFnRUNxZ0dxQVFPcUFhb0JCS29CQ3lBRVFRRnFJUVJCaUFFaEVBeW9BZ3NnQkVFQmFpRUVRWWtCSVJBTXB3SUxJQVJCQVdvaEJFR0tBU0VRREtZQ0N5QUVRUUZxSVFSQmp3RWhFQXlsQWdzZ0JFRUJhaUVFUVpFQklSQU1wQUlMQWtBZ0JDQUNSdzBBUWFjQklSQU12UUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFtb2hFQUpBQTBBZ0JDMEFBQ0FCUWUzUGdJQUFhaTBBQUVjTnBRRWdBVUVDUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFhY0JJUkFNdlFJTElBQkJBRFlDQUNBUVFRRnFJUUZCRVNFUURLSUJDd0pBSUFRZ0FrY05BRUdvQVNFUURMd0NDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFKcUlSQUNRQU5BSUFRdEFBQWdBVUhDejRDQUFHb3RBQUJIRGFRQklBRkJBa1lOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHb0FTRVFETHdDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRU3doRUF5aEFRc0NRQ0FFSUFKSERRQkJxUUVoRUF5N0Fnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVFYWlFUUFrQURRQ0FFTFFBQUlBRkJ4YytBZ0FCcUxRQUFSdzJqQVNBQlFRUkdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCcVFFaEVBeTdBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRXJJUkFNb0FFTEFrQWdCQ0FDUncwQVFhb0JJUkFNdWdJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBbW9oRUFKQUEwQWdCQzBBQUNBQlFjclBnSUFBYWkwQUFFY05vZ0VnQVVFQ1JnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRYW9CSVJBTXVnSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkZDRVFESjhCQ3dKQUlBUWdBa2NOQUVHckFTRVFETGtDQ3dKQUFrQUNRQUpBSUFRdEFBQkJ2bjlxRGc4QUFRS2tBYVFCcEFHa0FhUUJwQUdrQWFRQnBBR2tBYVFCQTZRQkN5QUVRUUZxSVFSQmt3RWhFQXlpQWdzZ0JFRUJhaUVFUVpRQklSQU1vUUlMSUFSQkFXb2hCRUdWQVNFUURLQUNDeUFFUVFGcUlRUkJsZ0VoRUF5ZkFnc0NRQ0FFSUFKSERRQkJyQUVoRUF5NEFnc2dCQzBBQUVIRkFFY05ud0VnQkVFQmFpRUVET0FCQ3dKQUlBUWdBa2NOQUVHdEFTRVFETGNDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRSnFJUkFDUUFOQUlBUXRBQUFnQVVITno0Q0FBR290QUFCSERaOEJJQUZCQWtZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR3RBU0VRRExjQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVE0aEVBeWNBUXNDUUNBRUlBSkhEUUJCcmdFaEVBeTJBZ3NnQkMwQUFFSFFBRWNOblFFZ0JFRUJhaUVCUVNVaEVBeWJBUXNDUUNBRUlBSkhEUUJCcndFaEVBeTFBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFSWFpRVFBa0FEUUNBRUxRQUFJQUZCME0rQWdBQnFMUUFBUncyZEFTQUJRUWhHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQnJ3RWhFQXkxQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVxSVJBTW1nRUxBa0FnQkNBQ1J3MEFRYkFCSVJBTXRBSUxBa0FDUUNBRUxRQUFRYXQvYWc0TEFKMEJuUUdkQVowQm5RR2RBWjBCblFHZEFRR2RBUXNnQkVFQmFpRUVRWm9CSVJBTW13SUxJQVJCQVdvaEJFR2JBU0VRREpvQ0N3SkFJQVFnQWtjTkFFR3hBU0VRRExNQ0N3SkFBa0FnQkMwQUFFRy9mMm9PRkFDY0Fad0JuQUdjQVp3Qm5BR2NBWndCbkFHY0Fad0JuQUdjQVp3Qm5BR2NBWndCbkFFQm5BRUxJQVJCQVdvaEJFR1pBU0VRREpvQ0N5QUVRUUZxSVFSQm5BRWhFQXlaQWdzQ1FDQUVJQUpIRFFCQnNnRWhFQXl5QWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRURhaUVRQWtBRFFDQUVMUUFBSUFGQjJjK0FnQUJxTFFBQVJ3MmFBU0FCUVFOR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJzZ0VoRUF5eUFnc2dBRUVBTmdJQUlCQkJBV29oQVVFaElSQU1sd0VMQWtBZ0JDQUNSdzBBUWJNQklSQU1zUUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkJtb2hFQUpBQTBBZ0JDMEFBQ0FCUWQzUGdJQUFhaTBBQUVjTm1RRWdBVUVHUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFiTUJJUkFNc1FJTElBQkJBRFlDQUNBUVFRRnFJUUZCR2lFUURKWUJDd0pBSUFRZ0FrY05BRUcwQVNFUURMQUNDd0pBQWtBQ1FDQUVMUUFBUWJ0L2FnNFJBSm9CbWdHYUFab0JtZ0dhQVpvQm1nR2FBUUdhQVpvQm1nR2FBWm9CQXBvQkN5QUVRUUZxSVFSQm5RRWhFQXlZQWdzZ0JFRUJhaUVFUVo0QklSQU1sd0lMSUFSQkFXb2hCRUdmQVNFUURKWUNDd0pBSUFRZ0FrY05BRUcxQVNFUURLOENDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFWcUlSQUNRQU5BSUFRdEFBQWdBVUhrejRDQUFHb3RBQUJIRFpjQklBRkJCVVlOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHMUFTRVFESzhDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRU2doRUF5VUFRc0NRQ0FFSUFKSERRQkJ0Z0VoRUF5dUFnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVDYWlFUUFrQURRQ0FFTFFBQUlBRkI2cytBZ0FCcUxRQUFSdzJXQVNBQlFRSkdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCdGdFaEVBeXVBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRUhJUkFNa3dFTEFrQWdCQ0FDUncwQVFiY0JJUkFNclFJTEFrQUNRQ0FFTFFBQVFidC9hZzRPQUpZQmxnR1dBWllCbGdHV0FaWUJsZ0dXQVpZQmxnR1dBUUdXQVFzZ0JFRUJhaUVFUWFFQklSQU1sQUlMSUFSQkFXb2hCRUdpQVNFUURKTUNDd0pBSUFRZ0FrY05BRUc0QVNFUURLd0NDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFKcUlSQUNRQU5BSUFRdEFBQWdBVUh0ejRDQUFHb3RBQUJIRFpRQklBRkJBa1lOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHNEFTRVFES3dDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUkloRUF5UkFRc0NRQ0FFSUFKSERRQkJ1UUVoRUF5ckFnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVCYWlFUUFrQURRQ0FFTFFBQUlBRkI4TStBZ0FCcUxRQUFSdzJUQVNBQlFRRkdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCdVFFaEVBeXJBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRWdJUkFNa0FFTEFrQWdCQ0FDUncwQVFib0JJUkFNcWdJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBV29oRUFKQUEwQWdCQzBBQUNBQlFmTFBnSUFBYWkwQUFFY05rZ0VnQVVFQlJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRYm9CSVJBTXFnSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkR5RVFESThCQ3dKQUlBUWdBa2NOQUVHN0FTRVFES2tDQ3dKQUFrQWdCQzBBQUVHM2Yyb09Cd0NTQVpJQmtnR1NBWklCQVpJQkN5QUVRUUZxSVFSQnBRRWhFQXlRQWdzZ0JFRUJhaUVFUWFZQklSQU1qd0lMQWtBZ0JDQUNSdzBBUWJ3QklSQU1xQUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkIyb2hFQUpBQTBBZ0JDMEFBQ0FCUWZUUGdJQUFhaTBBQUVjTmtBRWdBVUVIUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFid0JJUkFNcUFJTElBQkJBRFlDQUNBUVFRRnFJUUZCR3lFUURJMEJDd0pBSUFRZ0FrY05BRUc5QVNFUURLY0NDd0pBQWtBQ1FDQUVMUUFBUWI1L2FnNFNBSkVCa1FHUkFaRUJrUUdSQVpFQmtRR1JBUUdSQVpFQmtRR1JBWkVCa1FFQ2tRRUxJQVJCQVdvaEJFR2tBU0VRREk4Q0N5QUVRUUZxSVFSQnB3RWhFQXlPQWdzZ0JFRUJhaUVFUWFnQklSQU1qUUlMQWtBZ0JDQUNSdzBBUWI0QklSQU1wZ0lMSUFRdEFBQkJ6Z0JIRFkwQklBUkJBV29oQkF6UEFRc0NRQ0FFSUFKSERRQkJ2d0VoRUF5bEFnc0NRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBRUxRQUFRYjkvYWc0VkFBRUNBNXdCQkFVR25BR2NBWndCQndnSkNndWNBUXdORGcrY0FRc2dCRUVCYWlFQlFlZ0FJUkFNbWdJTElBUkJBV29oQVVIcEFDRVFESmtDQ3lBRVFRRnFJUUZCN2dBaEVBeVlBZ3NnQkVFQmFpRUJRZklBSVJBTWx3SUxJQVJCQVdvaEFVSHpBQ0VRREpZQ0N5QUVRUUZxSVFGQjlnQWhFQXlWQWdzZ0JFRUJhaUVCUWZjQUlSQU1sQUlMSUFSQkFXb2hBVUg2QUNFUURKTUNDeUFFUVFGcUlRUkJnd0VoRUF5U0Fnc2dCRUVCYWlFRVFZUUJJUkFNa1FJTElBUkJBV29oQkVHRkFTRVFESkFDQ3lBRVFRRnFJUVJCa2dFaEVBeVBBZ3NnQkVFQmFpRUVRWmdCSVJBTWpnSUxJQVJCQVdvaEJFR2dBU0VRREkwQ0N5QUVRUUZxSVFSQm93RWhFQXlNQWdzZ0JFRUJhaUVFUWFvQklSQU1pd0lMQWtBZ0JDQUNSZzBBSUFCQmtJQ0FnQUEyQWdnZ0FDQUVOZ0lFUWFzQklSQU1pd0lMUWNBQklSQU1vd0lMSUFBZ0JTQUNFS3FBZ0lBQUlnRU5pd0VnQlNFQkRGd0xBa0FnQmlBQ1JnMEFJQVpCQVdvaEJReU5BUXRCd2dFaEVBeWhBZ3NEUUFKQUlCQXRBQUJCZG1vT0JJd0JBQUNQQVFBTElCQkJBV29pRUNBQ1J3MEFDMEhEQVNFUURLQUNDd0pBSUFjZ0FrWU5BQ0FBUVpHQWdJQUFOZ0lJSUFBZ0J6WUNCQ0FISVFGQkFTRVFESWNDQzBIRUFTRVFESjhDQ3dKQUlBY2dBa2NOQUVIRkFTRVFESjhDQ3dKQUFrQWdCeTBBQUVGMmFnNEVBYzRCemdFQXpnRUxJQWRCQVdvaEJneU5BUXNnQjBFQmFpRUZESWtCQ3dKQUlBY2dBa2NOQUVIR0FTRVFESjRDQ3dKQUFrQWdCeTBBQUVGMmFnNFhBWThCandFQmp3R1BBWThCandHUEFZOEJqd0dQQVk4Qmp3R1BBWThCandHUEFZOEJqd0dQQVk4QkFJOEJDeUFIUVFGcUlRY0xRYkFCSVJBTWhBSUxBa0FnQ0NBQ1J3MEFRY2dCSVJBTW5RSUxJQWd0QUFCQklFY05qUUVnQUVFQU93RXlJQWhCQVdvaEFVR3pBU0VRRElNQ0N5QUJJUmNDUUFOQUlCY2lCeUFDUmcwQklBY3RBQUJCVUdwQi93RnhJaEJCQ2s4TnpBRUNRQ0FBTHdFeUloUkJtVE5MRFFBZ0FDQVVRUXBzSWhRN0FUSWdFRUgvL3dOeklCUkIvdjhEY1VrTkFDQUhRUUZxSVJjZ0FDQVVJQkJxSWhBN0FUSWdFRUgvL3dOeFFlZ0hTUTBCQ3d0QkFDRVFJQUJCQURZQ0hDQUFRY0dKZ0lBQU5nSVFJQUJCRFRZQ0RDQUFJQWRCQVdvMkFoUU1uQUlMUWNjQklSQU1td0lMSUFBZ0NDQUNFSzZBZ0lBQUloQkZEY29CSUJCQkZVY05qQUVnQUVISUFUWUNIQ0FBSUFnMkFoUWdBRUhKbDRDQUFEWUNFQ0FBUVJVMkFneEJBQ0VRREpvQ0N3SkFJQWtnQWtjTkFFSE1BU0VRREpvQ0MwRUFJUlJCQVNFWFFRRWhGa0VBSVJBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0NTMEFBRUZRYWc0S2xnR1ZBUUFCQWdNRUJRWUlsd0VMUVFJaEVBd0dDMEVESVJBTUJRdEJCQ0VRREFRTFFRVWhFQXdEQzBFR0lSQU1BZ3RCQnlFUURBRUxRUWdoRUF0QkFDRVhRUUFoRmtFQUlSUU1qZ0VMUVFraEVFRUJJUlJCQUNFWFFRQWhGZ3lOQVFzQ1FDQUtJQUpIRFFCQnpnRWhFQXlaQWdzZ0NpMEFBRUV1UncyT0FTQUtRUUZxSVFrTXlnRUxJQXNnQWtjTmpnRkIwQUVoRUF5WEFnc0NRQ0FMSUFKR0RRQWdBRUdPZ0lDQUFEWUNDQ0FBSUFzMkFnUkJ0d0VoRUF6K0FRdEIwUUVoRUF5V0Fnc0NRQ0FFSUFKSERRQkIwZ0VoRUF5V0Fnc2dBaUFFYXlBQUtBSUFJaEJxSVJRZ0JDQVFhMEVFYWlFTEEwQWdCQzBBQUNBUVFmelBnSUFBYWkwQUFFY05qZ0VnRUVFRVJnM3BBU0FRUVFGcUlSQWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUhTQVNFUURKVUNDeUFBSUF3Z0FoQ3NnSUNBQUNJQkRZMEJJQXdoQVF5NEFRc0NRQ0FFSUFKSERRQkIxQUVoRUF5VUFnc2dBaUFFYXlBQUtBSUFJaEJxSVJRZ0JDQVFhMEVCYWlFTUEwQWdCQzBBQUNBUVFZSFFnSUFBYWkwQUFFY05qd0VnRUVFQlJnMk9BU0FRUVFGcUlSQWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUhVQVNFUURKTUNDd0pBSUFRZ0FrY05BRUhXQVNFUURKTUNDeUFDSUFScklBQW9BZ0FpRUdvaEZDQUVJQkJyUVFKcUlRc0RRQ0FFTFFBQUlCQkJnOUNBZ0FCcUxRQUFSdzJPQVNBUVFRSkdEWkFCSUJCQkFXb2hFQ0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWRZQklSQU1rZ0lMQWtBZ0JDQUNSdzBBUWRjQklSQU1rZ0lMQWtBQ1FDQUVMUUFBUWJ0L2FnNFFBSThCandHUEFZOEJqd0dQQVk4Qmp3R1BBWThCandHUEFZOEJqd0VCandFTElBUkJBV29oQkVHN0FTRVFEUGtCQ3lBRVFRRnFJUVJCdkFFaEVBejRBUXNDUUNBRUlBSkhEUUJCMkFFaEVBeVJBZ3NnQkMwQUFFSElBRWNOakFFZ0JFRUJhaUVFRE1RQkN3SkFJQVFnQWtZTkFDQUFRWkNBZ0lBQU5nSUlJQUFnQkRZQ0JFRytBU0VRRFBjQkMwSFpBU0VRREk4Q0N3SkFJQVFnQWtjTkFFSGFBU0VRREk4Q0N5QUVMUUFBUWNnQVJnM0RBU0FBUVFFNkFDZ011UUVMSUFCQkFqb0FMeUFBSUFRZ0FoQ21nSUNBQUNJUURZMEJRY0lCSVJBTTlBRUxJQUF0QUNoQmYyb09BcmNCdVFHNEFRc0RRQUpBSUFRdEFBQkJkbW9PQkFDT0FZNEJBSTRCQ3lBRVFRRnFJZ1FnQWtjTkFBdEIzUUVoRUF5TEFnc2dBRUVBT2dBdklBQXRBQzFCQkhGRkRZUUNDeUFBUVFBNkFDOGdBRUVCT2dBMElBRWhBUXlNQVFzZ0VFRVZSZzNhQVNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCcDQ2QWdBQTJBaEFnQUVFU05nSU1RUUFoRUF5SUFnc0NRQ0FBSUJBZ0FoQzBnSUNBQUNJRURRQWdFQ0VCRElFQ0N3SkFJQVJCRlVjTkFDQUFRUU0yQWh3Z0FDQVFOZ0lVSUFCQnNKaUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBeUlBZ3NnQUVFQU5nSWNJQUFnRURZQ0ZDQUFRYWVPZ0lBQU5nSVFJQUJCRWpZQ0RFRUFJUkFNaHdJTElCQkJGVVlOMWdFZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWRxTmdJQUFOZ0lRSUFCQkZEWUNERUVBSVJBTWhnSUxJQUFvQWdRaEZ5QUFRUUEyQWdRZ0VDQVJwMm9pRmlFQklBQWdGeUFRSUJZZ0ZCc2lFQkMxZ0lDQUFDSVVSUTJOQVNBQVFRYzJBaHdnQUNBUU5nSVVJQUFnRkRZQ0RFRUFJUkFNaFFJTElBQWdBQzhCTUVHQUFYSTdBVEFnQVNFQkMwRXFJUkFNNmdFTElCQkJGVVlOMFFFZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUVlPTWdJQUFOZ0lRSUFCQkV6WUNERUVBSVJBTWdnSUxJQkJCRlVZTnp3RWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFacVBnSUFBTmdJUUlBQkJJallDREVFQUlSQU1nUUlMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQzNnSUNBQUNJUURRQWdBVUVCYWlFQkRJMEJDeUFBUVF3MkFod2dBQ0FRTmdJTUlBQWdBVUVCYWpZQ0ZFRUFJUkFNZ0FJTElCQkJGVVlOekFFZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUVpxUGdJQUFOZ0lRSUFCQklqWUNERUVBSVJBTS93RUxJQUFvQWdRaEVDQUFRUUEyQWdRQ1FDQUFJQkFnQVJDM2dJQ0FBQ0lRRFFBZ0FVRUJhaUVCREl3QkN5QUFRUTAyQWh3Z0FDQVFOZ0lNSUFBZ0FVRUJhallDRkVFQUlSQU0vZ0VMSUJCQkZVWU55UUVnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRY2FNZ0lBQU5nSVFJQUJCSXpZQ0RFRUFJUkFNL1FFTElBQW9BZ1FoRUNBQVFRQTJBZ1FDUUNBQUlCQWdBUkM1Z0lDQUFDSVFEUUFnQVVFQmFpRUJESXNCQ3lBQVFRNDJBaHdnQUNBUU5nSU1JQUFnQVVFQmFqWUNGRUVBSVJBTS9BRUxJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSEFsWUNBQURZQ0VDQUFRUUkyQWd4QkFDRVFEUHNCQ3lBUVFSVkdEY1VCSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUhHaklDQUFEWUNFQ0FBUVNNMkFneEJBQ0VRRFBvQkN5QUFRUkEyQWh3Z0FDQUJOZ0lVSUFBZ0VEWUNERUVBSVJBTStRRUxJQUFvQWdRaEJDQUFRUUEyQWdRQ1FDQUFJQVFnQVJDNWdJQ0FBQ0lFRFFBZ0FVRUJhaUVCRFBFQkN5QUFRUkUyQWh3Z0FDQUVOZ0lNSUFBZ0FVRUJhallDRkVFQUlSQU0rQUVMSUJCQkZVWU53UUVnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRY2FNZ0lBQU5nSVFJQUJCSXpZQ0RFRUFJUkFNOXdFTElBQW9BZ1FoRUNBQVFRQTJBZ1FDUUNBQUlCQWdBUkM1Z0lDQUFDSVFEUUFnQVVFQmFpRUJESWdCQ3lBQVFSTTJBaHdnQUNBUU5nSU1JQUFnQVVFQmFqWUNGRUVBSVJBTTlnRUxJQUFvQWdRaEJDQUFRUUEyQWdRQ1FDQUFJQVFnQVJDNWdJQ0FBQ0lFRFFBZ0FVRUJhaUVCRE8wQkN5QUFRUlEyQWh3Z0FDQUVOZ0lNSUFBZ0FVRUJhallDRkVFQUlSQU05UUVMSUJCQkZVWU52UUVnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRWnFQZ0lBQU5nSVFJQUJCSWpZQ0RFRUFJUkFNOUFFTElBQW9BZ1FoRUNBQVFRQTJBZ1FDUUNBQUlCQWdBUkMzZ0lDQUFDSVFEUUFnQVVFQmFpRUJESVlCQ3lBQVFSWTJBaHdnQUNBUU5nSU1JQUFnQVVFQmFqWUNGRUVBSVJBTTh3RUxJQUFvQWdRaEJDQUFRUUEyQWdRQ1FDQUFJQVFnQVJDM2dJQ0FBQ0lFRFFBZ0FVRUJhaUVCRE9rQkN5QUFRUmMyQWh3Z0FDQUVOZ0lNSUFBZ0FVRUJhallDRkVFQUlSQU04Z0VMSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUhOazRDQUFEWUNFQ0FBUVF3MkFneEJBQ0VRRFBFQkMwSUJJUkVMSUJCQkFXb2hBUUpBSUFBcEF5QWlFa0wvLy8vLy8vLy8vdzlXRFFBZ0FDQVNRZ1NHSUJHRU53TWdJQUVoQVF5RUFRc2dBRUVBTmdJY0lBQWdBVFlDRkNBQVFhMkpnSUFBTmdJUUlBQkJERFlDREVFQUlSQU03d0VMSUFCQkFEWUNIQ0FBSUJBMkFoUWdBRUhOazRDQUFEWUNFQ0FBUVF3MkFneEJBQ0VRRE80QkN5QUFLQUlFSVJjZ0FFRUFOZ0lFSUJBZ0VhZHFJaFloQVNBQUlCY2dFQ0FXSUJRYkloQVF0WUNBZ0FBaUZFVU5jeUFBUVFVMkFod2dBQ0FRTmdJVUlBQWdGRFlDREVFQUlSQU03UUVMSUFCQkFEWUNIQ0FBSUJBMkFoUWdBRUdxbklDQUFEWUNFQ0FBUVE4MkFneEJBQ0VRRE93QkN5QUFJQkFnQWhDMGdJQ0FBQ0lCRFFFZ0VDRUJDMEVPSVJBTTBRRUxBa0FnQVVFVlJ3MEFJQUJCQWpZQ0hDQUFJQkEyQWhRZ0FFR3dtSUNBQURZQ0VDQUFRUlUyQWd4QkFDRVFET29CQ3lBQVFRQTJBaHdnQUNBUU5nSVVJQUJCcDQ2QWdBQTJBaEFnQUVFU05nSU1RUUFoRUF6cEFRc2dBVUVCYWlFUUFrQWdBQzhCTUNJQlFZQUJjVVVOQUFKQUlBQWdFQ0FDRUx1QWdJQUFJZ0VOQUNBUUlRRU1jQXNnQVVFVlJ3MjZBU0FBUVFVMkFod2dBQ0FRTmdJVUlBQkIrWmVBZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXpwQVFzQ1FDQUJRYUFFY1VHZ0JFY05BQ0FBTFFBdFFRSnhEUUFnQUVFQU5nSWNJQUFnRURZQ0ZDQUFRWmFUZ0lBQU5nSVFJQUJCQkRZQ0RFRUFJUkFNNlFFTElBQWdFQ0FDRUwyQWdJQUFHaUFRSVFFQ1FBSkFBa0FDUUFKQUlBQWdFQ0FDRUxPQWdJQUFEaFlDQVFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRREJBc2dBRUVCT2dBdUN5QUFJQUF2QVRCQndBQnlPd0V3SUJBaEFRdEJKaUVRRE5FQkN5QUFRU00yQWh3Z0FDQVFOZ0lVSUFCQnBaYUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBenBBUXNnQUVFQU5nSWNJQUFnRURZQ0ZDQUFRZFdMZ0lBQU5nSVFJQUJCRVRZQ0RFRUFJUkFNNkFFTElBQXRBQzFCQVhGRkRRRkJ3d0VoRUF6T0FRc0NRQ0FOSUFKR0RRQURRQUpBSUEwdEFBQkJJRVlOQUNBTklRRU14QUVMSUExQkFXb2lEU0FDUncwQUMwRWxJUkFNNXdFTFFTVWhFQXptQVFzZ0FDZ0NCQ0VFSUFCQkFEWUNCQ0FBSUFRZ0RSQ3ZnSUNBQUNJRVJRMnRBU0FBUVNZMkFod2dBQ0FFTmdJTUlBQWdEVUVCYWpZQ0ZFRUFJUkFNNVFFTElCQkJGVVlOcXdFZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWYyTmdJQUFOZ0lRSUFCQkhUWUNERUVBSVJBTTVBRUxJQUJCSnpZQ0hDQUFJQUUyQWhRZ0FDQVFOZ0lNUVFBaEVBempBUXNnRUNFQlFRRWhGQUpBQWtBQ1FBSkFBa0FDUUFKQUlBQXRBQ3hCZm1vT0J3WUZCUU1CQWdBRkN5QUFJQUF2QVRCQkNISTdBVEFNQXd0QkFpRVVEQUVMUVFRaEZBc2dBRUVCT2dBc0lBQWdBQzhCTUNBVWNqc0JNQXNnRUNFQkMwRXJJUkFNeWdFTElBQkJBRFlDSENBQUlCQTJBaFFnQUVHcmtvQ0FBRFlDRUNBQVFRczJBZ3hCQUNFUURPSUJDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkI0WStBZ0FBMkFoQWdBRUVLTmdJTVFRQWhFQXpoQVFzZ0FFRUFPZ0FzSUJBaEFReTlBUXNnRUNFQlFRRWhGQUpBQWtBQ1FBSkFBa0FnQUMwQUxFRjdhZzRFQXdFQ0FBVUxJQUFnQUM4Qk1FRUljanNCTUF3REMwRUNJUlFNQVF0QkJDRVVDeUFBUVFFNkFDd2dBQ0FBTHdFd0lCUnlPd0V3Q3lBUUlRRUxRU2toRUF6RkFRc2dBRUVBTmdJY0lBQWdBVFlDRkNBQVFmQ1VnSUFBTmdJUUlBQkJBellDREVFQUlSQU0zUUVMQWtBZ0RpMEFBRUVOUncwQUlBQW9BZ1FoQVNBQVFRQTJBZ1FDUUNBQUlBRWdEaEN4Z0lDQUFDSUJEUUFnRGtFQmFpRUJESFVMSUFCQkxEWUNIQ0FBSUFFMkFnd2dBQ0FPUVFGcU5nSVVRUUFoRUF6ZEFRc2dBQzBBTFVFQmNVVU5BVUhFQVNFUURNTUJDd0pBSUE0Z0FrY05BRUV0SVJBTTNBRUxBa0FDUUFOQUFrQWdEaTBBQUVGMmFnNEVBZ0FBQXdBTElBNUJBV29pRGlBQ1J3MEFDMEV0SVJBTTNRRUxJQUFvQWdRaEFTQUFRUUEyQWdRQ1FDQUFJQUVnRGhDeGdJQ0FBQ0lCRFFBZ0RpRUJESFFMSUFCQkxEWUNIQ0FBSUE0MkFoUWdBQ0FCTmdJTVFRQWhFQXpjQVFzZ0FDZ0NCQ0VCSUFCQkFEWUNCQUpBSUFBZ0FTQU9FTEdBZ0lBQUlnRU5BQ0FPUVFGcUlRRU1jd3NnQUVFc05nSWNJQUFnQVRZQ0RDQUFJQTVCQVdvMkFoUkJBQ0VRRE5zQkN5QUFLQUlFSVFRZ0FFRUFOZ0lFSUFBZ0JDQU9FTEdBZ0lBQUlnUU5vQUVnRGlFQkRNNEJDeUFRUVN4SERRRWdBVUVCYWlFUVFRRWhBUUpBQWtBQ1FBSkFBa0FnQUMwQUxFRjdhZzRFQXdFQ0JBQUxJQkFoQVF3RUMwRUNJUUVNQVF0QkJDRUJDeUFBUVFFNkFDd2dBQ0FBTHdFd0lBRnlPd0V3SUJBaEFRd0JDeUFBSUFBdkFUQkJDSEk3QVRBZ0VDRUJDMEU1SVJBTXZ3RUxJQUJCQURvQUxDQUJJUUVMUVRRaEVBeTlBUXNnQUNBQUx3RXdRU0J5T3dFd0lBRWhBUXdDQ3lBQUtBSUVJUVFnQUVFQU5nSUVBa0FnQUNBRUlBRVFzWUNBZ0FBaUJBMEFJQUVoQVF6SEFRc2dBRUUzTmdJY0lBQWdBVFlDRkNBQUlBUTJBZ3hCQUNFUUROUUJDeUFBUVFnNkFDd2dBU0VCQzBFd0lSQU11UUVMQWtBZ0FDMEFLRUVCUmcwQUlBRWhBUXdFQ3lBQUxRQXRRUWh4UlEyVEFTQUJJUUVNQXdzZ0FDMEFNRUVnY1EyVUFVSEZBU0VRRExjQkN3SkFJQThnQWtZTkFBSkFBMEFDUUNBUExRQUFRVkJxSWdGQi93RnhRUXBKRFFBZ0R5RUJRVFVoRUF5NkFRc2dBQ2tESUNJUlFwbXo1c3lacytiTUdWWU5BU0FBSUJGQ0NuNGlFVGNESUNBUklBR3RRdjhCZ3lJU1FuK0ZWZzBCSUFBZ0VTQVNmRGNESUNBUFFRRnFJZzhnQWtjTkFBdEJPU0VRRE5FQkN5QUFLQUlFSVFJZ0FFRUFOZ0lFSUFBZ0FpQVBRUUZxSWdRUXNZQ0FnQUFpQWcyVkFTQUVJUUVNd3dFTFFUa2hFQXpQQVFzQ1FDQUFMd0V3SWdGQkNIRkZEUUFnQUMwQUtFRUJSdzBBSUFBdEFDMUJDSEZGRFpBQkN5QUFJQUZCOS9zRGNVR0FCSEk3QVRBZ0R5RUJDMEUzSVJBTXRBRUxJQUFnQUM4Qk1FRVFjanNCTUF5ckFRc2dFRUVWUmcyTEFTQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjhJNkFnQUEyQWhBZ0FFRWNOZ0lNUVFBaEVBekxBUXNnQUVIREFEWUNIQ0FBSUFFMkFnd2dBQ0FOUVFGcU5nSVVRUUFoRUF6S0FRc0NRQ0FCTFFBQVFUcEhEUUFnQUNnQ0JDRVFJQUJCQURZQ0JBSkFJQUFnRUNBQkVLK0FnSUFBSWhBTkFDQUJRUUZxSVFFTVl3c2dBRUhEQURZQ0hDQUFJQkEyQWd3Z0FDQUJRUUZxTmdJVVFRQWhFQXpLQVFzZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWJHUmdJQUFOZ0lRSUFCQkNqWUNERUVBSVJBTXlRRUxJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR2dtWUNBQURZQ0VDQUFRUjQyQWd4QkFDRVFETWdCQ3lBQVFRQTJBZ0FMSUFCQmdCSTdBU29nQUNBWFFRRnFJZ0VnQWhDb2dJQ0FBQ0lRRFFFZ0FTRUJDMEhIQUNFUURLd0JDeUFRUVJWSERZTUJJQUJCMFFBMkFod2dBQ0FCTmdJVUlBQkI0NWVBZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXpFQVFzZ0FDZ0NCQ0VRSUFCQkFEWUNCQUpBSUFBZ0VDQUJFS2VBZ0lBQUloQU5BQ0FCSVFFTVhnc2dBRUhTQURZQ0hDQUFJQUUyQWhRZ0FDQVFOZ0lNUVFBaEVBekRBUXNnQUVFQU5nSWNJQUFnRkRZQ0ZDQUFRY0dvZ0lBQU5nSVFJQUJCQnpZQ0RDQUFRUUEyQWdCQkFDRVFETUlCQ3lBQUtBSUVJUkFnQUVFQU5nSUVBa0FnQUNBUUlBRVFwNENBZ0FBaUVBMEFJQUVoQVF4ZEN5QUFRZE1BTmdJY0lBQWdBVFlDRkNBQUlCQTJBZ3hCQUNFUURNRUJDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUVlDUmdJQUFOZ0lRSUFCQkNUWUNEQXpBQVFzZ0VFRVZSZzE5SUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUdVallDQUFEWUNFQ0FBUVNFMkFneEJBQ0VRREw4QkMwRUJJUlpCQUNFWFFRQWhGRUVCSVJBTElBQWdFRG9BS3lBQlFRRnFJUUVDUUFKQUlBQXRBQzFCRUhFTkFBSkFBa0FDUUNBQUxRQXFEZ01CQUFJRUN5QVdSUTBEREFJTElCUU5BUXdDQ3lBWFJRMEJDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXJZQ0FnQUFpRUEwQUlBRWhBUXhjQ3lBQVFkZ0FOZ0ljSUFBZ0FUWUNGQ0FBSUJBMkFneEJBQ0VRREw0QkN5QUFLQUlFSVFRZ0FFRUFOZ0lFQWtBZ0FDQUVJQUVRcllDQWdBQWlCQTBBSUFFaEFReXRBUXNnQUVIWkFEWUNIQ0FBSUFFMkFoUWdBQ0FFTmdJTVFRQWhFQXk5QVFzZ0FDZ0NCQ0VFSUFCQkFEWUNCQUpBSUFBZ0JDQUJFSzJBZ0lBQUlnUU5BQ0FCSVFFTXF3RUxJQUJCMmdBMkFod2dBQ0FCTmdJVUlBQWdCRFlDREVFQUlSQU12QUVMSUFBb0FnUWhCQ0FBUVFBMkFnUUNRQ0FBSUFRZ0FSQ3RnSUNBQUNJRURRQWdBU0VCREtrQkN5QUFRZHdBTmdJY0lBQWdBVFlDRkNBQUlBUTJBZ3hCQUNFUURMc0JDd0pBSUFFdEFBQkJVR29pRUVIL0FYRkJDazhOQUNBQUlCQTZBQ29nQVVFQmFpRUJRYzhBSVJBTW9nRUxJQUFvQWdRaEJDQUFRUUEyQWdRQ1FDQUFJQVFnQVJDdGdJQ0FBQ0lFRFFBZ0FTRUJES2NCQ3lBQVFkNEFOZ0ljSUFBZ0FUWUNGQ0FBSUFRMkFneEJBQ0VRRExvQkN5QUFRUUEyQWdBZ0YwRUJhaUVCQWtBZ0FDMEFLVUVqVHcwQUlBRWhBUXhaQ3lBQVFRQTJBaHdnQUNBQk5nSVVJQUJCMDRtQWdBQTJBaEFnQUVFSU5nSU1RUUFoRUF5NUFRc2dBRUVBTmdJQUMwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRWkN6Z0lBQU5nSVFJQUJCQ0RZQ0RBeTNBUXNnQUVFQU5nSUFJQmRCQVdvaEFRSkFJQUF0QUNsQklVY05BQ0FCSVFFTVZnc2dBRUVBTmdJY0lBQWdBVFlDRkNBQVFadUtnSUFBTmdJUUlBQkJDRFlDREVFQUlSQU10Z0VMSUFCQkFEWUNBQ0FYUVFGcUlRRUNRQ0FBTFFBcEloQkJYV3BCQzA4TkFDQUJJUUVNVlFzQ1FDQVFRUVpMRFFCQkFTQVFkRUhLQUhGRkRRQWdBU0VCREZVTFFRQWhFQ0FBUVFBMkFod2dBQ0FCTmdJVUlBQkI5NG1BZ0FBMkFoQWdBRUVJTmdJTURMVUJDeUFRUVJWR0RYRWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFibU5nSUFBTmdJUUlBQkJHallDREVFQUlSQU10QUVMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQ25nSUNBQUNJUURRQWdBU0VCREZRTElBQkI1UUEyQWh3Z0FDQUJOZ0lVSUFBZ0VEWUNERUVBSVJBTXN3RUxJQUFvQWdRaEVDQUFRUUEyQWdRQ1FDQUFJQkFnQVJDbmdJQ0FBQ0lRRFFBZ0FTRUJERTBMSUFCQjBnQTJBaHdnQUNBQk5nSVVJQUFnRURZQ0RFRUFJUkFNc2dFTElBQW9BZ1FoRUNBQVFRQTJBZ1FDUUNBQUlCQWdBUkNuZ0lDQUFDSVFEUUFnQVNFQkRFMExJQUJCMHdBMkFod2dBQ0FCTmdJVUlBQWdFRFlDREVFQUlSQU1zUUVMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQ25nSUNBQUNJUURRQWdBU0VCREZFTElBQkI1UUEyQWh3Z0FDQUJOZ0lVSUFBZ0VEWUNERUVBSVJBTXNBRUxJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSEdpb0NBQURZQ0VDQUFRUWMyQWd4QkFDRVFESzhCQ3lBQUtBSUVJUkFnQUVFQU5nSUVBa0FnQUNBUUlBRVFwNENBZ0FBaUVBMEFJQUVoQVF4SkN5QUFRZElBTmdJY0lBQWdBVFlDRkNBQUlCQTJBZ3hCQUNFUURLNEJDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXA0Q0FnQUFpRUEwQUlBRWhBUXhKQ3lBQVFkTUFOZ0ljSUFBZ0FUWUNGQ0FBSUJBMkFneEJBQ0VRREswQkN5QUFLQUlFSVJBZ0FFRUFOZ0lFQWtBZ0FDQVFJQUVRcDRDQWdBQWlFQTBBSUFFaEFReE5DeUFBUWVVQU5nSWNJQUFnQVRZQ0ZDQUFJQkEyQWd4QkFDRVFES3dCQ3lBQVFRQTJBaHdnQUNBQk5nSVVJQUJCM0lpQWdBQTJBaEFnQUVFSE5nSU1RUUFoRUF5ckFRc2dFRUUvUncwQklBRkJBV29oQVF0QkJTRVFESkFCQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFmMlNnSUFBTmdJUUlBQkJCellDREF5b0FRc2dBQ2dDQkNFUUlBQkJBRFlDQkFKQUlBQWdFQ0FCRUtlQWdJQUFJaEFOQUNBQklRRU1RZ3NnQUVIU0FEWUNIQ0FBSUFFMkFoUWdBQ0FRTmdJTVFRQWhFQXluQVFzZ0FDZ0NCQ0VRSUFCQkFEWUNCQUpBSUFBZ0VDQUJFS2VBZ0lBQUloQU5BQ0FCSVFFTVFnc2dBRUhUQURZQ0hDQUFJQUUyQWhRZ0FDQVFOZ0lNUVFBaEVBeW1BUXNnQUNnQ0JDRVFJQUJCQURZQ0JBSkFJQUFnRUNBQkVLZUFnSUFBSWhBTkFDQUJJUUVNUmdzZ0FFSGxBRFlDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF5bEFRc2dBQ2dDQkNFQklBQkJBRFlDQkFKQUlBQWdBU0FVRUtlQWdJQUFJZ0VOQUNBVUlRRU1Qd3NnQUVIU0FEWUNIQ0FBSUJRMkFoUWdBQ0FCTmdJTVFRQWhFQXlrQVFzZ0FDZ0NCQ0VCSUFCQkFEWUNCQUpBSUFBZ0FTQVVFS2VBZ0lBQUlnRU5BQ0FVSVFFTVB3c2dBRUhUQURZQ0hDQUFJQlEyQWhRZ0FDQUJOZ0lNUVFBaEVBeWpBUXNnQUNnQ0JDRUJJQUJCQURZQ0JBSkFJQUFnQVNBVUVLZUFnSUFBSWdFTkFDQVVJUUVNUXdzZ0FFSGxBRFlDSENBQUlCUTJBaFFnQUNBQk5nSU1RUUFoRUF5aUFRc2dBRUVBTmdJY0lBQWdGRFlDRkNBQVFjT1BnSUFBTmdJUUlBQkJCellDREVFQUlSQU1vUUVMSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUhEajRDQUFEWUNFQ0FBUVFjMkFneEJBQ0VRREtBQkMwRUFJUkFnQUVFQU5nSWNJQUFnRkRZQ0ZDQUFRWXljZ0lBQU5nSVFJQUJCQnpZQ0RBeWZBUXNnQUVFQU5nSWNJQUFnRkRZQ0ZDQUFRWXljZ0lBQU5nSVFJQUJCQnpZQ0RFRUFJUkFNbmdFTElBQkJBRFlDSENBQUlCUTJBaFFnQUVIK2tZQ0FBRFlDRUNBQVFRYzJBZ3hCQUNFUURKMEJDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkJqcHVBZ0FBMkFoQWdBRUVHTmdJTVFRQWhFQXljQVFzZ0VFRVZSZzFYSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUhNam9DQUFEWUNFQ0FBUVNBMkFneEJBQ0VRREpzQkN5QUFRUUEyQWdBZ0VFRUJhaUVCUVNRaEVBc2dBQ0FRT2dBcElBQW9BZ1FoRUNBQVFRQTJBZ1FnQUNBUUlBRVFxNENBZ0FBaUVBMVVJQUVoQVF3K0N5QUFRUUEyQWdBTFFRQWhFQ0FBUVFBMkFod2dBQ0FFTmdJVUlBQkI4WnVBZ0FBMkFoQWdBRUVHTmdJTURKY0JDeUFCUVJWR0RWQWdBRUVBTmdJY0lBQWdCVFlDRkNBQVFmQ01nSUFBTmdJUUlBQkJHellDREVFQUlSQU1sZ0VMSUFBb0FnUWhCU0FBUVFBMkFnUWdBQ0FGSUJBUXFZQ0FnQUFpQlEwQklCQkJBV29oQlF0QnJRRWhFQXg3Q3lBQVFjRUJOZ0ljSUFBZ0JUWUNEQ0FBSUJCQkFXbzJBaFJCQUNFUURKTUJDeUFBS0FJRUlRWWdBRUVBTmdJRUlBQWdCaUFRRUttQWdJQUFJZ1lOQVNBUVFRRnFJUVlMUWE0QklSQU1lQXNnQUVIQ0FUWUNIQ0FBSUFZMkFnd2dBQ0FRUVFGcU5nSVVRUUFoRUF5UUFRc2dBRUVBTmdJY0lBQWdCellDRkNBQVFaZUxnSUFBTmdJUUlBQkJEVFlDREVFQUlSQU1qd0VMSUFCQkFEWUNIQ0FBSUFnMkFoUWdBRUhqa0lDQUFEWUNFQ0FBUVFrMkFneEJBQ0VRREk0QkN5QUFRUUEyQWh3Z0FDQUlOZ0lVSUFCQmxJMkFnQUEyQWhBZ0FFRWhOZ0lNUVFBaEVBeU5BUXRCQVNFV1FRQWhGMEVBSVJSQkFTRVFDeUFBSUJBNkFDc2dDVUVCYWlFSUFrQUNRQ0FBTFFBdFFSQnhEUUFDUUFKQUFrQWdBQzBBS2c0REFRQUNCQXNnRmtVTkF3d0NDeUFVRFFFTUFnc2dGMFVOQVFzZ0FDZ0NCQ0VRSUFCQkFEWUNCQ0FBSUJBZ0NCQ3RnSUNBQUNJUVJRMDlJQUJCeVFFMkFod2dBQ0FJTmdJVUlBQWdFRFlDREVFQUlSQU1qQUVMSUFBb0FnUWhCQ0FBUVFBMkFnUWdBQ0FFSUFnUXJZQ0FnQUFpQkVVTmRpQUFRY29CTmdJY0lBQWdDRFlDRkNBQUlBUTJBZ3hCQUNFUURJc0JDeUFBS0FJRUlRUWdBRUVBTmdJRUlBQWdCQ0FKRUsyQWdJQUFJZ1JGRFhRZ0FFSExBVFlDSENBQUlBazJBaFFnQUNBRU5nSU1RUUFoRUF5S0FRc2dBQ2dDQkNFRUlBQkJBRFlDQkNBQUlBUWdDaEN0Z0lDQUFDSUVSUTF5SUFCQnpRRTJBaHdnQUNBS05nSVVJQUFnQkRZQ0RFRUFJUkFNaVFFTEFrQWdDeTBBQUVGUWFpSVFRZjhCY1VFS1R3MEFJQUFnRURvQUtpQUxRUUZxSVFwQnRnRWhFQXh3Q3lBQUtBSUVJUVFnQUVFQU5nSUVJQUFnQkNBTEVLMkFnSUFBSWdSRkRYQWdBRUhQQVRZQ0hDQUFJQXMyQWhRZ0FDQUVOZ0lNUVFBaEVBeUlBUXNnQUVFQU5nSWNJQUFnQkRZQ0ZDQUFRWkN6Z0lBQU5nSVFJQUJCQ0RZQ0RDQUFRUUEyQWdCQkFDRVFESWNCQ3lBQlFSVkdEVDhnQUVFQU5nSWNJQUFnRERZQ0ZDQUFRY3lPZ0lBQU5nSVFJQUJCSURZQ0RFRUFJUkFNaGdFTElBQkJnUVE3QVNnZ0FDZ0NCQ0VRSUFCQ0FEY0RBQ0FBSUJBZ0RFRUJhaUlNRUt1QWdJQUFJaEJGRFRnZ0FFSFRBVFlDSENBQUlBdzJBaFFnQUNBUU5nSU1RUUFoRUF5RkFRc2dBRUVBTmdJQUMwRUFJUkFnQUVFQU5nSWNJQUFnQkRZQ0ZDQUFRZGliZ0lBQU5nSVFJQUJCQ0RZQ0RBeURBUXNnQUNnQ0JDRVFJQUJDQURjREFDQUFJQkFnQzBFQmFpSUxFS3VBZ0lBQUloQU5BVUhHQVNFUURHa0xJQUJCQWpvQUtBeFZDeUFBUWRVQk5nSWNJQUFnQ3pZQ0ZDQUFJQkEyQWd4QkFDRVFESUFCQ3lBUVFSVkdEVGNnQUVFQU5nSWNJQUFnQkRZQ0ZDQUFRYVNNZ0lBQU5nSVFJQUJCRURZQ0RFRUFJUkFNZndzZ0FDMEFORUVCUncwMElBQWdCQ0FDRUx5QWdJQUFJaEJGRFRRZ0VFRVZSdzAxSUFCQjNBRTJBaHdnQUNBRU5nSVVJQUJCMVphQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF4K0MwRUFJUkFnQUVFQU5nSWNJQUJCcjR1QWdBQTJBaEFnQUVFQ05nSU1JQUFnRkVFQmFqWUNGQXg5QzBFQUlSQU1Zd3RCQWlFUURHSUxRUTBoRUF4aEMwRVBJUkFNWUF0QkpTRVFERjhMUVJNaEVBeGVDMEVWSVJBTVhRdEJGaUVRREZ3TFFSY2hFQXhiQzBFWUlSQU1XZ3RCR1NFUURGa0xRUm9oRUF4WUMwRWJJUkFNVnd0QkhDRVFERllMUVIwaEVBeFZDMEVmSVJBTVZBdEJJU0VRREZNTFFTTWhFQXhTQzBIR0FDRVFERkVMUVM0aEVBeFFDMEV2SVJBTVR3dEJPeUVRREU0TFFUMGhFQXhOQzBISUFDRVFERXdMUWNrQUlSQU1Td3RCeXdBaEVBeEtDMEhNQUNFUURFa0xRYzRBSVJBTVNBdEIwUUFoRUF4SEMwSFZBQ0VRREVZTFFkZ0FJUkFNUlF0QjJRQWhFQXhFQzBIYkFDRVFERU1MUWVRQUlSQU1RZ3RCNVFBaEVBeEJDMEh4QUNFUURFQUxRZlFBSVJBTVB3dEJqUUVoRUF3K0MwR1hBU0VRREQwTFFha0JJUkFNUEF0QnJBRWhFQXc3QzBIQUFTRVFERG9MUWJrQklSQU1PUXRCcndFaEVBdzRDMEd4QVNFUUREY0xRYklCSVJBTU5ndEJ0QUVoRUF3MUMwRzFBU0VRRERRTFFib0JJUkFNTXd0QnZRRWhFQXd5QzBHL0FTRVFEREVMUWNFQklSQU1NQXNnQUVFQU5nSWNJQUFnQkRZQ0ZDQUFRZW1MZ0lBQU5nSVFJQUJCSHpZQ0RFRUFJUkFNU0FzZ0FFSGJBVFlDSENBQUlBUTJBaFFnQUVINmxvQ0FBRFlDRUNBQVFSVTJBZ3hCQUNFUURFY0xJQUJCK0FBMkFod2dBQ0FNTmdJVUlBQkJ5cGlBZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXhHQ3lBQVFkRUFOZ0ljSUFBZ0JUWUNGQ0FBUWJDWGdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTVJRc2dBRUg1QURZQ0hDQUFJQUUyQWhRZ0FDQVFOZ0lNUVFBaEVBeEVDeUFBUWZnQU5nSWNJQUFnQVRZQ0ZDQUFRY3FZZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNUXdzZ0FFSGtBRFlDSENBQUlBRTJBaFFnQUVIamw0Q0FBRFlDRUNBQVFSVTJBZ3hCQUNFUURFSUxJQUJCMXdBMkFod2dBQ0FCTmdJVUlBQkJ5WmVBZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXhCQ3lBQVFRQTJBaHdnQUNBQk5nSVVJQUJCdVkyQWdBQTJBaEFnQUVFYU5nSU1RUUFoRUF4QUN5QUFRY0lBTmdJY0lBQWdBVFlDRkNBQVFlT1lnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1Qd3NnQUVFQU5nSUVJQUFnRHlBUEVMR0FnSUFBSWdSRkRRRWdBRUU2TmdJY0lBQWdCRFlDRENBQUlBOUJBV28yQWhSQkFDRVFERDRMSUFBb0FnUWhCQ0FBUVFBMkFnUUNRQ0FBSUFRZ0FSQ3hnSUNBQUNJRVJRMEFJQUJCT3pZQ0hDQUFJQVEyQWd3Z0FDQUJRUUZxTmdJVVFRQWhFQXcrQ3lBQlFRRnFJUUVNTFFzZ0QwRUJhaUVCREMwTElBQkJBRFlDSENBQUlBODJBaFFnQUVIa2tvQ0FBRFlDRUNBQVFRUTJBZ3hCQUNFUUREc0xJQUJCTmpZQ0hDQUFJQVEyQWhRZ0FDQUNOZ0lNUVFBaEVBdzZDeUFBUVM0MkFod2dBQ0FPTmdJVUlBQWdCRFlDREVFQUlSQU1PUXNnQUVIUUFEWUNIQ0FBSUFFMkFoUWdBRUdSbUlDQUFEWUNFQ0FBUVJVMkFneEJBQ0VRRERnTElBMUJBV29oQVF3c0N5QUFRUlUyQWh3Z0FDQUJOZ0lVSUFCQmdwbUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBdzJDeUFBUVJzMkFod2dBQ0FCTmdJVUlBQkJrWmVBZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXcxQ3lBQVFRODJBaHdnQUNBQk5nSVVJQUJCa1plQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF3MEN5QUFRUXMyQWh3Z0FDQUJOZ0lVSUFCQmtaZUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBd3pDeUFBUVJvMkFod2dBQ0FCTmdJVUlBQkJncG1BZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXd5Q3lBQVFRczJBaHdnQUNBQk5nSVVJQUJCZ3BtQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF3eEN5QUFRUW8yQWh3Z0FDQUJOZ0lVSUFCQjVKYUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBd3dDeUFBUVI0MkFod2dBQ0FCTmdJVUlBQkIrWmVBZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXd2Q3lBQVFRQTJBaHdnQUNBUU5nSVVJQUJCMm8yQWdBQTJBaEFnQUVFVU5nSU1RUUFoRUF3dUN5QUFRUVEyQWh3Z0FDQUJOZ0lVSUFCQnNKaUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBd3RDeUFBUVFBMkFnQWdDMEVCYWlFTEMwRzRBU0VRREJJTElBQkJBRFlDQUNBUVFRRnFJUUZCOVFBaEVBd1JDeUFCSVFFQ1FDQUFMUUFwUVFWSERRQkI0d0FoRUF3UkMwSGlBQ0VRREJBTFFRQWhFQ0FBUVFBMkFod2dBRUhra1lDQUFEWUNFQ0FBUVFjMkFnd2dBQ0FVUVFGcU5nSVVEQ2dMSUFCQkFEWUNBQ0FYUVFGcUlRRkJ3QUFoRUF3T0MwRUJJUUVMSUFBZ0FUb0FMQ0FBUVFBMkFnQWdGMEVCYWlFQkMwRW9JUkFNQ3dzZ0FTRUJDMEU0SVJBTUNRc0NRQ0FCSWc4Z0FrWU5BQU5BQWtBZ0R5MEFBRUdBdm9DQUFHb3RBQUFpQVVFQlJnMEFJQUZCQWtjTkF5QVBRUUZxSVFFTUJBc2dEMEVCYWlJUElBSkhEUUFMUVQ0aEVBd2lDMEUrSVJBTUlRc2dBRUVBT2dBc0lBOGhBUXdCQzBFTElSQU1CZ3RCT2lFUURBVUxJQUZCQVdvaEFVRXRJUkFNQkFzZ0FDQUJPZ0FzSUFCQkFEWUNBQ0FXUVFGcUlRRkJEQ0VRREFNTElBQkJBRFlDQUNBWFFRRnFJUUZCQ2lFUURBSUxJQUJCQURZQ0FBc2dBRUVBT2dBc0lBMGhBVUVKSVJBTUFBc0xRUUFoRUNBQVFRQTJBaHdnQUNBTE5nSVVJQUJCelpDQWdBQTJBaEFnQUVFSk5nSU1EQmNMUVFBaEVDQUFRUUEyQWh3Z0FDQUtOZ0lVSUFCQjZZcUFnQUEyQWhBZ0FFRUpOZ0lNREJZTFFRQWhFQ0FBUVFBMkFod2dBQ0FKTmdJVUlBQkJ0NUNBZ0FBMkFoQWdBRUVKTmdJTURCVUxRUUFoRUNBQVFRQTJBaHdnQUNBSU5nSVVJQUJCbkpHQWdBQTJBaEFnQUVFSk5nSU1EQlFMUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQnpaQ0FnQUEyQWhBZ0FFRUpOZ0lNREJNTFFRQWhFQ0FBUVFBMkFod2dBQ0FCTmdJVUlBQkI2WXFBZ0FBMkFoQWdBRUVKTmdJTURCSUxRUUFoRUNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCdDVDQWdBQTJBaEFnQUVFSk5nSU1EQkVMUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQm5KR0FnQUEyQWhBZ0FFRUpOZ0lNREJBTFFRQWhFQ0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJsNVdBZ0FBMkFoQWdBRUVQTmdJTURBOExRUUFoRUNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCbDVXQWdBQTJBaEFnQUVFUE5nSU1EQTRMUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQndKS0FnQUEyQWhBZ0FFRUxOZ0lNREEwTFFRQWhFQ0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJsWW1BZ0FBMkFoQWdBRUVMTmdJTURBd0xRUUFoRUNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCNFkrQWdBQTJBaEFnQUVFS05nSU1EQXNMUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQis0K0FnQUEyQWhBZ0FFRUtOZ0lNREFvTFFRQWhFQ0FBUVFBMkFod2dBQ0FCTmdJVUlBQkI4Wm1BZ0FBMkFoQWdBRUVDTmdJTURBa0xRUUFoRUNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCeEpTQWdBQTJBaEFnQUVFQ05nSU1EQWdMUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjhwV0FnQUEyQWhBZ0FFRUNOZ0lNREFjTElBQkJBallDSENBQUlBRTJBaFFnQUVHY21vQ0FBRFlDRUNBQVFSWTJBZ3hCQUNFUURBWUxRUUVoRUF3RkMwSFVBQ0VRSUFFaUJDQUNSZzBFSUFOQkNHb2dBQ0FFSUFKQjJNS0FnQUJCQ2hERmdJQ0FBQ0FES0FJTUlRUWdBeWdDQ0E0REFRUUNBQXNReW9DQWdBQUFDeUFBUVFBMkFod2dBRUcxbW9DQUFEWUNFQ0FBUVJjMkFnd2dBQ0FFUVFGcU5nSVVRUUFoRUF3Q0N5QUFRUUEyQWh3Z0FDQUVOZ0lVSUFCQnlwcUFnQUEyQWhBZ0FFRUpOZ0lNUVFBaEVBd0JDd0pBSUFFaUJDQUNSdzBBUVNJaEVBd0JDeUFBUVltQWdJQUFOZ0lJSUFBZ0JEWUNCRUVoSVJBTElBTkJFR29rZ0lDQWdBQWdFQXV2QVFFQ2Z5QUJLQUlBSVFZQ1FBSkFJQUlnQTBZTkFDQUVJQVpxSVFRZ0JpQURhaUFDYXlFSElBSWdCa0YvY3lBRmFpSUdhaUVGQTBBQ1FDQUNMUUFBSUFRdEFBQkdEUUJCQWlFRURBTUxBa0FnQmcwQVFRQWhCQ0FGSVFJTUF3c2dCa0YvYWlFR0lBUkJBV29oQkNBQ1FRRnFJZ0lnQTBjTkFBc2dCeUVHSUFNaEFnc2dBRUVCTmdJQUlBRWdCallDQUNBQUlBSTJBZ1FQQ3lBQlFRQTJBZ0FnQUNBRU5nSUFJQUFnQWpZQ0JBc0tBQ0FBRU1lQWdJQUFDL0kyQVF0L0k0Q0FnSUFBUVJCcklnRWtnSUNBZ0FBQ1FFRUFLQUtnMElDQUFBMEFRUUFReTRDQWdBQkJnTlNFZ0FCcklnSkIyUUJKRFFCQkFDRURBa0JCQUNnQzROT0FnQUFpQkEwQVFRQkNmemNDN05PQWdBQkJBRUtBZ0lTQWdJREFBRGNDNU5PQWdBQkJBQ0FCUVFocVFYQnhRZGlxMWFvRmN5SUVOZ0xnMDRDQUFFRUFRUUEyQXZUVGdJQUFRUUJCQURZQ3hOT0FnQUFMUVFBZ0FqWUN6Tk9BZ0FCQkFFR0ExSVNBQURZQ3lOT0FnQUJCQUVHQTFJU0FBRFlDbU5DQWdBQkJBQ0FFTmdLczBJQ0FBRUVBUVg4MkFxalFnSUFBQTBBZ0EwSEUwSUNBQUdvZ0EwRzQwSUNBQUdvaUJEWUNBQ0FFSUFOQnNOQ0FnQUJxSWdVMkFnQWdBMEc4MElDQUFHb2dCVFlDQUNBRFFjelFnSUFBYWlBRFFjRFFnSUFBYWlJRk5nSUFJQVVnQkRZQ0FDQURRZFRRZ0lBQWFpQURRY2pRZ0lBQWFpSUVOZ0lBSUFRZ0JUWUNBQ0FEUWREUWdJQUFhaUFFTmdJQUlBTkJJR29pQTBHQUFrY05BQXRCZ05TRWdBQkJlRUdBMUlTQUFHdEJEM0ZCQUVHQTFJU0FBRUVJYWtFUGNSc2lBMm9pQkVFRWFpQUNRVWhxSWdVZ0Eyc2lBMEVCY2pZQ0FFRUFRUUFvQXZEVGdJQUFOZ0trMElDQUFFRUFJQU0yQXBUUWdJQUFRUUFnQkRZQ29OQ0FnQUJCZ05TRWdBQWdCV3BCT0RZQ0JBc0NRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FFSHNBVXNOQUFKQVFRQW9Bb2pRZ0lBQUlnWkJFQ0FBUVJOcVFYQnhJQUJCQzBrYklnSkJBM1lpQkhZaUEwRURjVVVOQUFKQUFrQWdBMEVCY1NBRWNrRUJjeUlGUVFOMElnUkJzTkNBZ0FCcUlnTWdCRUc0MElDQUFHb29BZ0FpQkNnQ0NDSUNSdzBBUVFBZ0JrRitJQVYzY1RZQ2lOQ0FnQUFNQVFzZ0F5QUNOZ0lJSUFJZ0F6WUNEQXNnQkVFSWFpRURJQVFnQlVFRGRDSUZRUU55TmdJRUlBUWdCV29pQkNBRUtBSUVRUUZ5TmdJRURBd0xJQUpCQUNnQ2tOQ0FnQUFpQjAwTkFRSkFJQU5GRFFBQ1FBSkFJQU1nQkhSQkFpQUVkQ0lEUVFBZ0EydHljU0lEUVFBZ0EydHhRWDlxSWdNZ0EwRU1ka0VRY1NJRGRpSUVRUVYyUVFoeElnVWdBM0lnQkNBRmRpSURRUUoyUVFSeElnUnlJQU1nQkhZaUEwRUJka0VDY1NJRWNpQURJQVIySWdOQkFYWkJBWEVpQkhJZ0F5QUVkbW9pQkVFRGRDSURRYkRRZ0lBQWFpSUZJQU5CdU5DQWdBQnFLQUlBSWdNb0FnZ2lBRWNOQUVFQUlBWkJmaUFFZDNFaUJqWUNpTkNBZ0FBTUFRc2dCU0FBTmdJSUlBQWdCVFlDREFzZ0F5QUNRUU55TmdJRUlBTWdCRUVEZENJRWFpQUVJQUpySWdVMkFnQWdBeUFDYWlJQUlBVkJBWEkyQWdRQ1FDQUhSUTBBSUFkQmVIRkJzTkNBZ0FCcUlRSkJBQ2dDbk5DQWdBQWhCQUpBQWtBZ0JrRUJJQWRCQTNaMElnaHhEUUJCQUNBR0lBaHlOZ0tJMElDQUFDQUNJUWdNQVFzZ0FpZ0NDQ0VJQ3lBSUlBUTJBZ3dnQWlBRU5nSUlJQVFnQWpZQ0RDQUVJQWcyQWdnTElBTkJDR29oQTBFQUlBQTJBcHpRZ0lBQVFRQWdCVFlDa05DQWdBQU1EQXRCQUNnQ2pOQ0FnQUFpQ1VVTkFTQUpRUUFnQ1d0eFFYOXFJZ01nQTBFTWRrRVFjU0lEZGlJRVFRVjJRUWh4SWdVZ0EzSWdCQ0FGZGlJRFFRSjJRUVJ4SWdSeUlBTWdCSFlpQTBFQmRrRUNjU0lFY2lBRElBUjJJZ05CQVhaQkFYRWlCSElnQXlBRWRtcEJBblJCdU5LQWdBQnFLQUlBSWdBb0FnUkJlSEVnQW1zaEJDQUFJUVVDUUFOQUFrQWdCU2dDRUNJRERRQWdCVUVVYWlnQ0FDSURSUTBDQ3lBREtBSUVRWGh4SUFKcklnVWdCQ0FGSUFSSklnVWJJUVFnQXlBQUlBVWJJUUFnQXlFRkRBQUxDeUFBS0FJWUlRb0NRQ0FBS0FJTUlnZ2dBRVlOQUNBQUtBSUlJZ05CQUNnQ21OQ0FnQUJKR2lBSUlBTTJBZ2dnQXlBSU5nSU1EQXNMQWtBZ0FFRVVhaUlGS0FJQUlnTU5BQ0FBS0FJUUlnTkZEUU1nQUVFUWFpRUZDd05BSUFVaEN5QURJZ2hCRkdvaUJTZ0NBQ0lERFFBZ0NFRVFhaUVGSUFnb0FoQWlBdzBBQ3lBTFFRQTJBZ0FNQ2d0QmZ5RUNJQUJCdjM5TERRQWdBRUVUYWlJRFFYQnhJUUpCQUNnQ2pOQ0FnQUFpQjBVTkFFRUFJUXNDUUNBQ1FZQUNTUTBBUVI4aEN5QUNRZi8vL3dkTERRQWdBMEVJZGlJRElBTkJnUDQvYWtFUWRrRUljU0lEZENJRUlBUkJnT0FmYWtFUWRrRUVjU0lFZENJRklBVkJnSUFQYWtFUWRrRUNjU0lGZEVFUGRpQURJQVJ5SUFWeWF5SURRUUYwSUFJZ0EwRVZhblpCQVhGeVFSeHFJUXNMUVFBZ0Ftc2hCQUpBQWtBQ1FBSkFJQXRCQW5SQnVOS0FnQUJxS0FJQUlnVU5BRUVBSVFOQkFDRUlEQUVMUVFBaEF5QUNRUUJCR1NBTFFRRjJheUFMUVI5R0czUWhBRUVBSVFnRFFBSkFJQVVvQWdSQmVIRWdBbXNpQmlBRVR3MEFJQVloQkNBRklRZ2dCZzBBUVFBaEJDQUZJUWdnQlNFRERBTUxJQU1nQlVFVWFpZ0NBQ0lHSUFZZ0JTQUFRUjEyUVFSeGFrRVFhaWdDQUNJRlJoc2dBeUFHR3lFRElBQkJBWFFoQUNBRkRRQUxDd0pBSUFNZ0NISU5BRUVBSVFoQkFpQUxkQ0lEUVFBZ0EydHlJQWR4SWdORkRRTWdBMEVBSUFOcmNVRi9haUlESUFOQkRIWkJFSEVpQTNZaUJVRUZka0VJY1NJQUlBTnlJQVVnQUhZaUEwRUNka0VFY1NJRmNpQURJQVYySWdOQkFYWkJBbkVpQlhJZ0F5QUZkaUlEUVFGMlFRRnhJZ1Z5SUFNZ0JYWnFRUUowUWJqU2dJQUFhaWdDQUNFREN5QURSUTBCQ3dOQUlBTW9BZ1JCZUhFZ0Ftc2lCaUFFU1NFQUFrQWdBeWdDRUNJRkRRQWdBMEVVYWlnQ0FDRUZDeUFHSUFRZ0FCc2hCQ0FESUFnZ0FCc2hDQ0FGSVFNZ0JRMEFDd3NnQ0VVTkFDQUVRUUFvQXBEUWdJQUFJQUpyVHcwQUlBZ29BaGdoQ3dKQUlBZ29BZ3dpQUNBSVJnMEFJQWdvQWdnaUEwRUFLQUtZMElDQUFFa2FJQUFnQXpZQ0NDQURJQUEyQWd3TUNRc0NRQ0FJUVJScUlnVW9BZ0FpQXcwQUlBZ29BaEFpQTBVTkF5QUlRUkJxSVFVTEEwQWdCU0VHSUFNaUFFRVVhaUlGS0FJQUlnTU5BQ0FBUVJCcUlRVWdBQ2dDRUNJRERRQUxJQVpCQURZQ0FBd0lDd0pBUVFBb0FwRFFnSUFBSWdNZ0Fra05BRUVBS0FLYzBJQ0FBQ0VFQWtBQ1FDQURJQUpySWdWQkVFa05BQ0FFSUFKcUlnQWdCVUVCY2pZQ0JFRUFJQVUyQXBEUWdJQUFRUUFnQURZQ25OQ0FnQUFnQkNBRGFpQUZOZ0lBSUFRZ0FrRURjallDQkF3QkN5QUVJQU5CQTNJMkFnUWdCQ0FEYWlJRElBTW9BZ1JCQVhJMkFnUkJBRUVBTmdLYzBJQ0FBRUVBUVFBMkFwRFFnSUFBQ3lBRVFRaHFJUU1NQ2dzQ1FFRUFLQUtVMElDQUFDSUFJQUpORFFCQkFDZ0NvTkNBZ0FBaUF5QUNhaUlFSUFBZ0Ftc2lCVUVCY2pZQ0JFRUFJQVUyQXBUUWdJQUFRUUFnQkRZQ29OQ0FnQUFnQXlBQ1FRTnlOZ0lFSUFOQkNHb2hBd3dLQ3dKQUFrQkJBQ2dDNE5PQWdBQkZEUUJCQUNnQzZOT0FnQUFoQkF3QkMwRUFRbjgzQXV6VGdJQUFRUUJDZ0lDRWdJQ0F3QUEzQXVUVGdJQUFRUUFnQVVFTWFrRndjVUhZcXRXcUJYTTJBdURUZ0lBQVFRQkJBRFlDOU5PQWdBQkJBRUVBTmdMRTA0Q0FBRUdBZ0FRaEJBdEJBQ0VEQWtBZ0JDQUNRY2NBYWlJSGFpSUdRUUFnQkdzaUMzRWlDQ0FDU3cwQVFRQkJNRFlDK05PQWdBQU1DZ3NDUUVFQUtBTEEwNENBQUNJRFJRMEFBa0JCQUNnQ3VOT0FnQUFpQkNBSWFpSUZJQVJORFFBZ0JTQURUUTBCQzBFQUlRTkJBRUV3TmdMNDA0Q0FBQXdLQzBFQUxRREUwNENBQUVFRWNRMEVBa0FDUUFKQVFRQW9BcURRZ0lBQUlnUkZEUUJCeU5PQWdBQWhBd05BQWtBZ0F5Z0NBQ0lGSUFSTERRQWdCU0FES0FJRWFpQUVTdzBEQ3lBREtBSUlJZ01OQUFzTFFRQVF5NENBZ0FBaUFFRi9SZzBGSUFnaEJnSkFRUUFvQXVUVGdJQUFJZ05CZjJvaUJDQUFjVVVOQUNBSUlBQnJJQVFnQUdwQkFDQURhM0ZxSVFZTElBWWdBazBOQlNBR1FmNy8vLzhIU3cwRkFrQkJBQ2dDd05PQWdBQWlBMFVOQUVFQUtBSzQwNENBQUNJRUlBWnFJZ1VnQkUwTkJpQUZJQU5MRFFZTElBWVF5NENBZ0FBaUF5QUFSdzBCREFjTElBWWdBR3NnQzNFaUJrSCsvLy8vQjBzTkJDQUdFTXVBZ0lBQUlnQWdBeWdDQUNBREtBSUVha1lOQXlBQUlRTUxBa0FnQTBGL1JnMEFJQUpCeUFCcUlBWk5EUUFDUUNBSElBWnJRUUFvQXVqVGdJQUFJZ1JxUVFBZ0JHdHhJZ1JCL3YvLy93ZE5EUUFnQXlFQURBY0xBa0FnQkJETGdJQ0FBRUYvUmcwQUlBUWdCbW9oQmlBRElRQU1Cd3RCQUNBR2F4RExnSUNBQUJvTUJBc2dBeUVBSUFOQmYwY05CUXdEQzBFQUlRZ01Cd3RCQUNFQURBVUxJQUJCZjBjTkFndEJBRUVBS0FMRTA0Q0FBRUVFY2pZQ3hOT0FnQUFMSUFoQi92Ly8vd2RMRFFFZ0NCRExnSUNBQUNFQVFRQVF5NENBZ0FBaEF5QUFRWDlHRFFFZ0EwRi9SZzBCSUFBZ0EwOE5BU0FESUFCcklnWWdBa0U0YWswTkFRdEJBRUVBS0FLNDA0Q0FBQ0FHYWlJRE5nSzQwNENBQUFKQUlBTkJBQ2dDdk5PQWdBQk5EUUJCQUNBRE5nSzgwNENBQUFzQ1FBSkFBa0FDUUVFQUtBS2cwSUNBQUNJRVJRMEFRY2pUZ0lBQUlRTURRQ0FBSUFNb0FnQWlCU0FES0FJRUlnaHFSZzBDSUFNb0FnZ2lBdzBBREFNTEN3SkFBa0JCQUNnQ21OQ0FnQUFpQTBVTkFDQUFJQU5QRFFFTFFRQWdBRFlDbU5DQWdBQUxRUUFoQTBFQUlBWTJBc3pUZ0lBQVFRQWdBRFlDeU5PQWdBQkJBRUYvTmdLbzBJQ0FBRUVBUVFBb0F1RFRnSUFBTmdLczBJQ0FBRUVBUVFBMkF0VFRnSUFBQTBBZ0EwSEUwSUNBQUdvZ0EwRzQwSUNBQUdvaUJEWUNBQ0FFSUFOQnNOQ0FnQUJxSWdVMkFnQWdBMEc4MElDQUFHb2dCVFlDQUNBRFFjelFnSUFBYWlBRFFjRFFnSUFBYWlJRk5nSUFJQVVnQkRZQ0FDQURRZFRRZ0lBQWFpQURRY2pRZ0lBQWFpSUVOZ0lBSUFRZ0JUWUNBQ0FEUWREUWdJQUFhaUFFTmdJQUlBTkJJR29pQTBHQUFrY05BQXNnQUVGNElBQnJRUTl4UVFBZ0FFRUlha0VQY1JzaUEyb2lCQ0FHUVVocUlnVWdBMnNpQTBFQmNqWUNCRUVBUVFBb0F2RFRnSUFBTmdLazBJQ0FBRUVBSUFNMkFwVFFnSUFBUVFBZ0JEWUNvTkNBZ0FBZ0FDQUZha0U0TmdJRURBSUxJQU10QUF4QkNIRU5BQ0FFSUFWSkRRQWdCQ0FBVHcwQUlBUkJlQ0FFYTBFUGNVRUFJQVJCQ0dwQkQzRWJJZ1ZxSWdCQkFDZ0NsTkNBZ0FBZ0Jtb2lDeUFGYXlJRlFRRnlOZ0lFSUFNZ0NDQUdhallDQkVFQVFRQW9BdkRUZ0lBQU5nS2swSUNBQUVFQUlBVTJBcFRRZ0lBQVFRQWdBRFlDb05DQWdBQWdCQ0FMYWtFNE5nSUVEQUVMQWtBZ0FFRUFLQUtZMElDQUFDSUlUdzBBUVFBZ0FEWUNtTkNBZ0FBZ0FDRUlDeUFBSUFacUlRVkJ5Tk9BZ0FBaEF3SkFBa0FDUUFKQUFrQUNRQUpBQTBBZ0F5Z0NBQ0FGUmcwQklBTW9BZ2dpQXcwQURBSUxDeUFETFFBTVFRaHhSUTBCQzBISTA0Q0FBQ0VEQTBBQ1FDQURLQUlBSWdVZ0JFc05BQ0FGSUFNb0FnUnFJZ1VnQkVzTkF3c2dBeWdDQ0NFRERBQUxDeUFESUFBMkFnQWdBeUFES0FJRUlBWnFOZ0lFSUFCQmVDQUFhMEVQY1VFQUlBQkJDR3BCRDNFYmFpSUxJQUpCQTNJMkFnUWdCVUY0SUFWclFROXhRUUFnQlVFSWFrRVBjUnRxSWdZZ0N5QUNhaUlDYXlFREFrQWdCaUFFUncwQVFRQWdBallDb05DQWdBQkJBRUVBS0FLVTBJQ0FBQ0FEYWlJRE5nS1UwSUNBQUNBQ0lBTkJBWEkyQWdRTUF3c0NRQ0FHUVFBb0FwelFnSUFBUncwQVFRQWdBallDbk5DQWdBQkJBRUVBS0FLUTBJQ0FBQ0FEYWlJRE5nS1EwSUNBQUNBQ0lBTkJBWEkyQWdRZ0FpQURhaUFETmdJQURBTUxBa0FnQmlnQ0JDSUVRUU54UVFGSERRQWdCRUY0Y1NFSEFrQUNRQ0FFUWY4QlN3MEFJQVlvQWdnaUJTQUVRUU4ySWdoQkEzUkJzTkNBZ0FCcUlnQkdHZ0pBSUFZb0Fnd2lCQ0FGUncwQVFRQkJBQ2dDaU5DQWdBQkJmaUFJZDNFMkFvalFnSUFBREFJTElBUWdBRVlhSUFRZ0JUWUNDQ0FGSUFRMkFnd01BUXNnQmlnQ0dDRUpBa0FDUUNBR0tBSU1JZ0FnQmtZTkFDQUdLQUlJSWdRZ0NFa2FJQUFnQkRZQ0NDQUVJQUEyQWd3TUFRc0NRQ0FHUVJScUlnUW9BZ0FpQlEwQUlBWkJFR29pQkNnQ0FDSUZEUUJCQUNFQURBRUxBMEFnQkNFSUlBVWlBRUVVYWlJRUtBSUFJZ1VOQUNBQVFSQnFJUVFnQUNnQ0VDSUZEUUFMSUFoQkFEWUNBQXNnQ1VVTkFBSkFBa0FnQmlBR0tBSWNJZ1ZCQW5SQnVOS0FnQUJxSWdRb0FnQkhEUUFnQkNBQU5nSUFJQUFOQVVFQVFRQW9Bb3pRZ0lBQVFYNGdCWGR4TmdLTTBJQ0FBQXdDQ3lBSlFSQkJGQ0FKS0FJUUlBWkdHMm9nQURZQ0FDQUFSUTBCQ3lBQUlBazJBaGdDUUNBR0tBSVFJZ1JGRFFBZ0FDQUVOZ0lRSUFRZ0FEWUNHQXNnQmlnQ0ZDSUVSUTBBSUFCQkZHb2dCRFlDQUNBRUlBQTJBaGdMSUFjZ0Eyb2hBeUFHSUFkcUlnWW9BZ1FoQkFzZ0JpQUVRWDV4TmdJRUlBSWdBMm9nQXpZQ0FDQUNJQU5CQVhJMkFnUUNRQ0FEUWY4QlN3MEFJQU5CZUhGQnNOQ0FnQUJxSVFRQ1FBSkFRUUFvQW9qUWdJQUFJZ1ZCQVNBRFFRTjJkQ0lEY1EwQVFRQWdCU0FEY2pZQ2lOQ0FnQUFnQkNFRERBRUxJQVFvQWdnaEF3c2dBeUFDTmdJTUlBUWdBallDQ0NBQ0lBUTJBZ3dnQWlBRE5nSUlEQU1MUVI4aEJBSkFJQU5CLy8vL0Iwc05BQ0FEUVFoMklnUWdCRUdBL2o5cVFSQjJRUWh4SWdSMElnVWdCVUdBNEI5cVFSQjJRUVJ4SWdWMElnQWdBRUdBZ0E5cVFSQjJRUUp4SWdCMFFROTJJQVFnQlhJZ0FISnJJZ1JCQVhRZ0F5QUVRUlZxZGtFQmNYSkJIR29oQkFzZ0FpQUVOZ0ljSUFKQ0FEY0NFQ0FFUVFKMFFialNnSUFBYWlFRkFrQkJBQ2dDak5DQWdBQWlBRUVCSUFSMElnaHhEUUFnQlNBQ05nSUFRUUFnQUNBSWNqWUNqTkNBZ0FBZ0FpQUZOZ0lZSUFJZ0FqWUNDQ0FDSUFJMkFnd01Bd3NnQTBFQVFSa2dCRUVCZG1zZ0JFRWZSaHQwSVFRZ0JTZ0NBQ0VBQTBBZ0FDSUZLQUlFUVhoeElBTkdEUUlnQkVFZGRpRUFJQVJCQVhRaEJDQUZJQUJCQkhGcVFSQnFJZ2dvQWdBaUFBMEFDeUFJSUFJMkFnQWdBaUFGTmdJWUlBSWdBallDRENBQ0lBSTJBZ2dNQWdzZ0FFRjRJQUJyUVE5eFFRQWdBRUVJYWtFUGNSc2lBMm9pQ3lBR1FVaHFJZ2dnQTJzaUEwRUJjallDQkNBQUlBaHFRVGcyQWdRZ0JDQUZRVGNnQld0QkQzRkJBQ0FGUVVscVFROXhHMnBCUVdvaUNDQUlJQVJCRUdwSkd5SUlRU00yQWdSQkFFRUFLQUx3MDRDQUFEWUNwTkNBZ0FCQkFDQUROZ0tVMElDQUFFRUFJQXMyQXFEUWdJQUFJQWhCRUdwQkFDa0MwTk9BZ0FBM0FnQWdDRUVBS1FMSTA0Q0FBRGNDQ0VFQUlBaEJDR28yQXREVGdJQUFRUUFnQmpZQ3pOT0FnQUJCQUNBQU5nTEkwNENBQUVFQVFRQTJBdFRUZ0lBQUlBaEJKR29oQXdOQUlBTkJCellDQUNBRFFRUnFJZ01nQlVrTkFBc2dDQ0FFUmcwRElBZ2dDQ2dDQkVGK2NUWUNCQ0FJSUFnZ0JHc2lBRFlDQUNBRUlBQkJBWEkyQWdRQ1FDQUFRZjhCU3cwQUlBQkJlSEZCc05DQWdBQnFJUU1DUUFKQVFRQW9Bb2pRZ0lBQUlnVkJBU0FBUVFOMmRDSUFjUTBBUVFBZ0JTQUFjallDaU5DQWdBQWdBeUVGREFFTElBTW9BZ2doQlFzZ0JTQUVOZ0lNSUFNZ0JEWUNDQ0FFSUFNMkFnd2dCQ0FGTmdJSURBUUxRUjhoQXdKQUlBQkIvLy8vQjBzTkFDQUFRUWgySWdNZ0EwR0EvajlxUVJCMlFRaHhJZ04wSWdVZ0JVR0E0QjlxUVJCMlFRUnhJZ1YwSWdnZ0NFR0FnQTlxUVJCMlFRSnhJZ2gwUVE5MklBTWdCWElnQ0hKcklnTkJBWFFnQUNBRFFSVnFka0VCY1hKQkhHb2hBd3NnQkNBRE5nSWNJQVJDQURjQ0VDQURRUUowUWJqU2dJQUFhaUVGQWtCQkFDZ0NqTkNBZ0FBaUNFRUJJQU4wSWdaeERRQWdCU0FFTmdJQVFRQWdDQ0FHY2pZQ2pOQ0FnQUFnQkNBRk5nSVlJQVFnQkRZQ0NDQUVJQVEyQWd3TUJBc2dBRUVBUVJrZ0EwRUJkbXNnQTBFZlJodDBJUU1nQlNnQ0FDRUlBMEFnQ0NJRktBSUVRWGh4SUFCR0RRTWdBMEVkZGlFSUlBTkJBWFFoQXlBRklBaEJCSEZxUVJCcUlnWW9BZ0FpQ0EwQUN5QUdJQVEyQWdBZ0JDQUZOZ0lZSUFRZ0JEWUNEQ0FFSUFRMkFnZ01Bd3NnQlNnQ0NDSURJQUkyQWd3Z0JTQUNOZ0lJSUFKQkFEWUNHQ0FDSUFVMkFnd2dBaUFETmdJSUN5QUxRUWhxSVFNTUJRc2dCU2dDQ0NJRElBUTJBZ3dnQlNBRU5nSUlJQVJCQURZQ0dDQUVJQVUyQWd3Z0JDQUROZ0lJQzBFQUtBS1UwSUNBQUNJRElBSk5EUUJCQUNnQ29OQ0FnQUFpQkNBQ2FpSUZJQU1nQW1zaUEwRUJjallDQkVFQUlBTTJBcFRRZ0lBQVFRQWdCVFlDb05DQWdBQWdCQ0FDUVFOeU5nSUVJQVJCQ0dvaEF3d0RDMEVBSVFOQkFFRXdOZ0w0MDRDQUFBd0NDd0pBSUF0RkRRQUNRQUpBSUFnZ0NDZ0NIQ0lGUVFKMFFialNnSUFBYWlJREtBSUFSdzBBSUFNZ0FEWUNBQ0FBRFFGQkFDQUhRWDRnQlhkeElnYzJBb3pRZ0lBQURBSUxJQXRCRUVFVUlBc29BaEFnQ0VZYmFpQUFOZ0lBSUFCRkRRRUxJQUFnQ3pZQ0dBSkFJQWdvQWhBaUEwVU5BQ0FBSUFNMkFoQWdBeUFBTmdJWUN5QUlRUlJxS0FJQUlnTkZEUUFnQUVFVWFpQUROZ0lBSUFNZ0FEWUNHQXNDUUFKQUlBUkJEMHNOQUNBSUlBUWdBbW9pQTBFRGNqWUNCQ0FJSUFOcUlnTWdBeWdDQkVFQmNqWUNCQXdCQ3lBSUlBSnFJZ0FnQkVFQmNqWUNCQ0FJSUFKQkEzSTJBZ1FnQUNBRWFpQUVOZ0lBQWtBZ0JFSC9BVXNOQUNBRVFYaHhRYkRRZ0lBQWFpRURBa0FDUUVFQUtBS0kwSUNBQUNJRlFRRWdCRUVEZG5RaUJIRU5BRUVBSUFVZ0JISTJBb2pRZ0lBQUlBTWhCQXdCQ3lBREtBSUlJUVFMSUFRZ0FEWUNEQ0FESUFBMkFnZ2dBQ0FETmdJTUlBQWdCRFlDQ0F3QkMwRWZJUU1DUUNBRVFmLy8vd2RMRFFBZ0JFRUlkaUlESUFOQmdQNC9ha0VRZGtFSWNTSURkQ0lGSUFWQmdPQWZha0VRZGtFRWNTSUZkQ0lDSUFKQmdJQVBha0VRZGtFQ2NTSUNkRUVQZGlBRElBVnlJQUp5YXlJRFFRRjBJQVFnQTBFVmFuWkJBWEZ5UVJ4cUlRTUxJQUFnQXpZQ0hDQUFRZ0EzQWhBZ0EwRUNkRUc0MG9DQUFHb2hCUUpBSUFkQkFTQURkQ0lDY1EwQUlBVWdBRFlDQUVFQUlBY2dBbkkyQW96UWdJQUFJQUFnQlRZQ0dDQUFJQUEyQWdnZ0FDQUFOZ0lNREFFTElBUkJBRUVaSUFOQkFYWnJJQU5CSDBZYmRDRURJQVVvQWdBaEFnSkFBMEFnQWlJRktBSUVRWGh4SUFSR0RRRWdBMEVkZGlFQ0lBTkJBWFFoQXlBRklBSkJCSEZxUVJCcUlnWW9BZ0FpQWcwQUN5QUdJQUEyQWdBZ0FDQUZOZ0lZSUFBZ0FEWUNEQ0FBSUFBMkFnZ01BUXNnQlNnQ0NDSURJQUEyQWd3Z0JTQUFOZ0lJSUFCQkFEWUNHQ0FBSUFVMkFnd2dBQ0FETmdJSUN5QUlRUWhxSVFNTUFRc0NRQ0FLUlEwQUFrQUNRQ0FBSUFBb0Fod2lCVUVDZEVHNDBvQ0FBR29pQXlnQ0FFY05BQ0FESUFnMkFnQWdDQTBCUVFBZ0NVRitJQVYzY1RZQ2pOQ0FnQUFNQWdzZ0NrRVFRUlFnQ2lnQ0VDQUFSaHRxSUFnMkFnQWdDRVVOQVFzZ0NDQUtOZ0lZQWtBZ0FDZ0NFQ0lEUlEwQUlBZ2dBellDRUNBRElBZzJBaGdMSUFCQkZHb29BZ0FpQTBVTkFDQUlRUlJxSUFNMkFnQWdBeUFJTmdJWUN3SkFBa0FnQkVFUFN3MEFJQUFnQkNBQ2FpSURRUU55TmdJRUlBQWdBMm9pQXlBREtBSUVRUUZ5TmdJRURBRUxJQUFnQW1vaUJTQUVRUUZ5TmdJRUlBQWdBa0VEY2pZQ0JDQUZJQVJxSUFRMkFnQUNRQ0FIUlEwQUlBZEJlSEZCc05DQWdBQnFJUUpCQUNnQ25OQ0FnQUFoQXdKQUFrQkJBU0FIUVFOMmRDSUlJQVp4RFFCQkFDQUlJQVp5TmdLSTBJQ0FBQ0FDSVFnTUFRc2dBaWdDQ0NFSUN5QUlJQU0yQWd3Z0FpQUROZ0lJSUFNZ0FqWUNEQ0FESUFnMkFnZ0xRUUFnQlRZQ25OQ0FnQUJCQUNBRU5nS1EwSUNBQUFzZ0FFRUlhaUVEQ3lBQlFSQnFKSUNBZ0lBQUlBTUxDZ0FnQUJESmdJQ0FBQXZpRFFFSGZ3SkFJQUJGRFFBZ0FFRjRhaUlCSUFCQmZHb29BZ0FpQWtGNGNTSUFhaUVEQWtBZ0FrRUJjUTBBSUFKQkEzRkZEUUVnQVNBQktBSUFJZ0pySWdGQkFDZ0NtTkNBZ0FBaUJFa05BU0FDSUFCcUlRQUNRQ0FCUVFBb0FwelFnSUFBUmcwQUFrQWdBa0gvQVVzTkFDQUJLQUlJSWdRZ0FrRURkaUlGUVFOMFFiRFFnSUFBYWlJR1Job0NRQ0FCS0FJTUlnSWdCRWNOQUVFQVFRQW9Bb2pRZ0lBQVFYNGdCWGR4TmdLSTBJQ0FBQXdEQ3lBQ0lBWkdHaUFDSUFRMkFnZ2dCQ0FDTmdJTURBSUxJQUVvQWhnaEJ3SkFBa0FnQVNnQ0RDSUdJQUZHRFFBZ0FTZ0NDQ0lDSUFSSkdpQUdJQUkyQWdnZ0FpQUdOZ0lNREFFTEFrQWdBVUVVYWlJQ0tBSUFJZ1FOQUNBQlFSQnFJZ0lvQWdBaUJBMEFRUUFoQmd3QkN3TkFJQUloQlNBRUlnWkJGR29pQWlnQ0FDSUVEUUFnQmtFUWFpRUNJQVlvQWhBaUJBMEFDeUFGUVFBMkFnQUxJQWRGRFFFQ1FBSkFJQUVnQVNnQ0hDSUVRUUowUWJqU2dJQUFhaUlDS0FJQVJ3MEFJQUlnQmpZQ0FDQUdEUUZCQUVFQUtBS00wSUNBQUVGK0lBUjNjVFlDak5DQWdBQU1Bd3NnQjBFUVFSUWdCeWdDRUNBQlJodHFJQVkyQWdBZ0JrVU5BZ3NnQmlBSE5nSVlBa0FnQVNnQ0VDSUNSUTBBSUFZZ0FqWUNFQ0FDSUFZMkFoZ0xJQUVvQWhRaUFrVU5BU0FHUVJScUlBSTJBZ0FnQWlBR05nSVlEQUVMSUFNb0FnUWlBa0VEY1VFRFJ3MEFJQU1nQWtGK2NUWUNCRUVBSUFBMkFwRFFnSUFBSUFFZ0FHb2dBRFlDQUNBQklBQkJBWEkyQWdRUEN5QUJJQU5QRFFBZ0F5Z0NCQ0lDUVFGeFJRMEFBa0FDUUNBQ1FRSnhEUUFDUUNBRFFRQW9BcURRZ0lBQVJ3MEFRUUFnQVRZQ29OQ0FnQUJCQUVFQUtBS1UwSUNBQUNBQWFpSUFOZ0tVMElDQUFDQUJJQUJCQVhJMkFnUWdBVUVBS0FLYzBJQ0FBRWNOQTBFQVFRQTJBcERRZ0lBQVFRQkJBRFlDbk5DQWdBQVBDd0pBSUFOQkFDZ0NuTkNBZ0FCSERRQkJBQ0FCTmdLYzBJQ0FBRUVBUVFBb0FwRFFnSUFBSUFCcUlnQTJBcERRZ0lBQUlBRWdBRUVCY2pZQ0JDQUJJQUJxSUFBMkFnQVBDeUFDUVhoeElBQnFJUUFDUUFKQUlBSkIvd0ZMRFFBZ0F5Z0NDQ0lFSUFKQkEzWWlCVUVEZEVHdzBJQ0FBR29pQmtZYUFrQWdBeWdDRENJQ0lBUkhEUUJCQUVFQUtBS0kwSUNBQUVGK0lBVjNjVFlDaU5DQWdBQU1BZ3NnQWlBR1Job2dBaUFFTmdJSUlBUWdBallDREF3QkN5QURLQUlZSVFjQ1FBSkFJQU1vQWd3aUJpQURSZzBBSUFNb0FnZ2lBa0VBS0FLWTBJQ0FBRWthSUFZZ0FqWUNDQ0FDSUFZMkFnd01BUXNDUUNBRFFSUnFJZ0lvQWdBaUJBMEFJQU5CRUdvaUFpZ0NBQ0lFRFFCQkFDRUdEQUVMQTBBZ0FpRUZJQVFpQmtFVWFpSUNLQUlBSWdRTkFDQUdRUkJxSVFJZ0JpZ0NFQ0lFRFFBTElBVkJBRFlDQUFzZ0IwVU5BQUpBQWtBZ0F5QURLQUljSWdSQkFuUkJ1TktBZ0FCcUlnSW9BZ0JIRFFBZ0FpQUdOZ0lBSUFZTkFVRUFRUUFvQW96UWdJQUFRWDRnQkhkeE5nS00wSUNBQUF3Q0N5QUhRUkJCRkNBSEtBSVFJQU5HRzJvZ0JqWUNBQ0FHUlEwQkN5QUdJQWMyQWhnQ1FDQURLQUlRSWdKRkRRQWdCaUFDTmdJUUlBSWdCallDR0FzZ0F5Z0NGQ0lDUlEwQUlBWkJGR29nQWpZQ0FDQUNJQVkyQWhnTElBRWdBR29nQURZQ0FDQUJJQUJCQVhJMkFnUWdBVUVBS0FLYzBJQ0FBRWNOQVVFQUlBQTJBcERRZ0lBQUR3c2dBeUFDUVg1eE5nSUVJQUVnQUdvZ0FEWUNBQ0FCSUFCQkFYSTJBZ1FMQWtBZ0FFSC9BVXNOQUNBQVFYaHhRYkRRZ0lBQWFpRUNBa0FDUUVFQUtBS0kwSUNBQUNJRVFRRWdBRUVEZG5RaUFIRU5BRUVBSUFRZ0FISTJBb2pRZ0lBQUlBSWhBQXdCQ3lBQ0tBSUlJUUFMSUFBZ0FUWUNEQ0FDSUFFMkFnZ2dBU0FDTmdJTUlBRWdBRFlDQ0E4TFFSOGhBZ0pBSUFCQi8vLy9CMHNOQUNBQVFRaDJJZ0lnQWtHQS9qOXFRUkIyUVFoeElnSjBJZ1FnQkVHQTRCOXFRUkIyUVFSeElnUjBJZ1lnQmtHQWdBOXFRUkIyUVFKeElnWjBRUTkySUFJZ0JISWdCbkpySWdKQkFYUWdBQ0FDUVJWcWRrRUJjWEpCSEdvaEFnc2dBU0FDTmdJY0lBRkNBRGNDRUNBQ1FRSjBRYmpTZ0lBQWFpRUVBa0FDUUVFQUtBS00wSUNBQUNJR1FRRWdBblFpQTNFTkFDQUVJQUUyQWdCQkFDQUdJQU55TmdLTTBJQ0FBQ0FCSUFRMkFoZ2dBU0FCTmdJSUlBRWdBVFlDREF3QkN5QUFRUUJCR1NBQ1FRRjJheUFDUVI5R0czUWhBaUFFS0FJQUlRWUNRQU5BSUFZaUJDZ0NCRUY0Y1NBQVJnMEJJQUpCSFhZaEJpQUNRUUYwSVFJZ0JDQUdRUVJ4YWtFUWFpSURLQUlBSWdZTkFBc2dBeUFCTmdJQUlBRWdCRFlDR0NBQklBRTJBZ3dnQVNBQk5nSUlEQUVMSUFRb0FnZ2lBQ0FCTmdJTUlBUWdBVFlDQ0NBQlFRQTJBaGdnQVNBRU5nSU1JQUVnQURZQ0NBdEJBRUVBS0FLbzBJQ0FBRUYvYWlJQlFYOGdBUnMyQXFqUWdJQUFDd3NFQUFBQUMwNEFBa0FnQUEwQVB3QkJFSFFQQ3dKQUlBQkIvLzhEY1EwQUlBQkJmMHdOQUFKQUlBQkJFSFpBQUNJQVFYOUhEUUJCQUVFd05nTDQwNENBQUVGL0R3c2dBRUVRZEE4TEVNcUFnSUFBQUF2eUFnSURmd0YrQWtBZ0FrVU5BQ0FBSUFFNkFBQWdBaUFBYWlJRFFYOXFJQUU2QUFBZ0FrRURTUTBBSUFBZ0FUb0FBaUFBSUFFNkFBRWdBMEY5YWlBQk9nQUFJQU5CZm1vZ0FUb0FBQ0FDUVFkSkRRQWdBQ0FCT2dBRElBTkJmR29nQVRvQUFDQUNRUWxKRFFBZ0FFRUFJQUJyUVFOeElnUnFJZ01nQVVIL0FYRkJnWUtFQ0d3aUFUWUNBQ0FESUFJZ0JHdEJmSEVpQkdvaUFrRjhhaUFCTmdJQUlBUkJDVWtOQUNBRElBRTJBZ2dnQXlBQk5nSUVJQUpCZUdvZ0FUWUNBQ0FDUVhScUlBRTJBZ0FnQkVFWlNRMEFJQU1nQVRZQ0dDQURJQUUyQWhRZ0F5QUJOZ0lRSUFNZ0FUWUNEQ0FDUVhCcUlBRTJBZ0FnQWtGc2FpQUJOZ0lBSUFKQmFHb2dBVFlDQUNBQ1FXUnFJQUUyQWdBZ0JDQURRUVJ4UVJoeUlnVnJJZ0pCSUVrTkFDQUJyVUtCZ0lDQUVINGhCaUFESUFWcUlRRURRQ0FCSUFZM0F4Z2dBU0FHTndNUUlBRWdCamNEQ0NBQklBWTNBd0FnQVVFZ2FpRUJJQUpCWUdvaUFrRWZTdzBBQ3dzZ0FBc0xqa2dCQUVHQUNBdUdTQUVBQUFBQ0FBQUFBd0FBQUFBQUFBQUFBQUFBQkFBQUFBVUFBQUFBQUFBQUFBQUFBQVlBQUFBSEFBQUFDQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBU1c1MllXeHBaQ0JqYUdGeUlHbHVJSFZ5YkNCeGRXVnllUUJUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYMkp2WkhrQVEyOXVkR1Z1ZEMxTVpXNW5kR2dnYjNabGNtWnNiM2NBUTJoMWJtc2djMmw2WlNCdmRtVnlabXh2ZHdCU1pYTndiMjV6WlNCdmRtVnlabXh2ZHdCSmJuWmhiR2xrSUcxbGRHaHZaQ0JtYjNJZ1NGUlVVQzk0TG5nZ2NtVnhkV1Z6ZEFCSmJuWmhiR2xrSUcxbGRHaHZaQ0JtYjNJZ1VsUlRVQzk0TG5nZ2NtVnhkV1Z6ZEFCRmVIQmxZM1JsWkNCVFQxVlNRMFVnYldWMGFHOWtJR1p2Y2lCSlEwVXZlQzU0SUhKbGNYVmxjM1FBU1c1MllXeHBaQ0JqYUdGeUlHbHVJSFZ5YkNCbWNtRm5iV1Z1ZENCemRHRnlkQUJGZUhCbFkzUmxaQ0JrYjNRQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5emRHRjBkWE1BU1c1MllXeHBaQ0J5WlhOd2IyNXpaU0J6ZEdGMGRYTUFTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdhVzRnWTJoMWJtc2daWGgwWlc1emFXOXVjd0JWYzJWeUlHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOXlaWE5sZEdBZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgyTm9kVzVyWDJobFlXUmxjbUFnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDIxbGMzTmhaMlZmWW1WbmFXNWdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDlqYUhWdWExOWxlSFJsYm5OcGIyNWZkbUZzZFdWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOXpkR0YwZFhOZlkyOXRjR3hsZEdWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOTJaWEp6YVc5dVgyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZkWEpzWDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZlkyaDFibXRmWTI5dGNHeGxkR1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5b1pXRmtaWEpmZG1Gc2RXVmZZMjl0Y0d4bGRHVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDl0WlhOellXZGxYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmYldWMGFHOWtYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmYUdWaFpHVnlYMlpwWld4a1gyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZZMmgxYm10ZlpYaDBaVzV6YVc5dVgyNWhiV1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBRlZ1Wlhod1pXTjBaV1FnWTJoaGNpQnBiaUIxY213Z2MyVnlkbVZ5QUVsdWRtRnNhV1FnYUdWaFpHVnlJSFpoYkhWbElHTm9ZWElBU1c1MllXeHBaQ0JvWldGa1pYSWdabWxsYkdRZ1kyaGhjZ0JUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYM1psY25OcGIyNEFTVzUyWVd4cFpDQnRhVzV2Y2lCMlpYSnphVzl1QUVsdWRtRnNhV1FnYldGcWIzSWdkbVZ5YzJsdmJnQkZlSEJsWTNSbFpDQnpjR0ZqWlNCaFpuUmxjaUIyWlhKemFXOXVBRVY0Y0dWamRHVmtJRU5TVEVZZ1lXWjBaWElnZG1WeWMybHZiZ0JKYm5aaGJHbGtJRWhVVkZBZ2RtVnljMmx2YmdCSmJuWmhiR2xrSUdobFlXUmxjaUIwYjJ0bGJnQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgzVnliQUJKYm5aaGJHbGtJR05vWVhKaFkzUmxjbk1nYVc0Z2RYSnNBRlZ1Wlhod1pXTjBaV1FnYzNSaGNuUWdZMmhoY2lCcGJpQjFjbXdBUkc5MVlteGxJRUFnYVc0Z2RYSnNBRVZ0Y0hSNUlFTnZiblJsYm5RdFRHVnVaM1JvQUVsdWRtRnNhV1FnWTJoaGNtRmpkR1Z5SUdsdUlFTnZiblJsYm5RdFRHVnVaM1JvQUVSMWNHeHBZMkYwWlNCRGIyNTBaVzUwTFV4bGJtZDBhQUJKYm5aaGJHbGtJR05vWVhJZ2FXNGdkWEpzSUhCaGRHZ0FRMjl1ZEdWdWRDMU1aVzVuZEdnZ1kyRnVKM1FnWW1VZ2NISmxjMlZ1ZENCM2FYUm9JRlJ5WVc1elptVnlMVVZ1WTI5a2FXNW5BRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUdOb2RXNXJJSE5wZW1VQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5b1pXRmtaWEpmZG1Gc2RXVUFVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOWphSFZ1YTE5bGVIUmxibk5wYjI1ZmRtRnNkV1VBU1c1MllXeHBaQ0JqYUdGeVlXTjBaWElnYVc0Z1kyaDFibXNnWlhoMFpXNXphVzl1Y3lCMllXeDFaUUJOYVhOemFXNW5JR1Y0Y0dWamRHVmtJRXhHSUdGbWRHVnlJR2hsWVdSbGNpQjJZV3gxWlFCSmJuWmhiR2xrSUdCVWNtRnVjMlpsY2kxRmJtTnZaR2x1WjJBZ2FHVmhaR1Z5SUhaaGJIVmxBRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUdOb2RXNXJJR1Y0ZEdWdWMybHZibk1nY1hWdmRHVWdkbUZzZFdVQVNXNTJZV3hwWkNCamFHRnlZV04wWlhJZ2FXNGdZMmgxYm1zZ1pYaDBaVzV6YVc5dWN5QnhkVzkwWldRZ2RtRnNkV1VBVUdGMWMyVmtJR0o1SUc5dVgyaGxZV1JsY25OZlkyOXRjR3hsZEdVQVNXNTJZV3hwWkNCRlQwWWdjM1JoZEdVQWIyNWZjbVZ6WlhRZ2NHRjFjMlVBYjI1ZlkyaDFibXRmYUdWaFpHVnlJSEJoZFhObEFHOXVYMjFsYzNOaFoyVmZZbVZuYVc0Z2NHRjFjMlVBYjI1ZlkyaDFibXRmWlhoMFpXNXphVzl1WDNaaGJIVmxJSEJoZFhObEFHOXVYM04wWVhSMWMxOWpiMjF3YkdWMFpTQndZWFZ6WlFCdmJsOTJaWEp6YVc5dVgyTnZiWEJzWlhSbElIQmhkWE5sQUc5dVgzVnliRjlqYjIxd2JHVjBaU0J3WVhWelpRQnZibDlqYUhWdWExOWpiMjF3YkdWMFpTQndZWFZ6WlFCdmJsOW9aV0ZrWlhKZmRtRnNkV1ZmWTI5dGNHeGxkR1VnY0dGMWMyVUFiMjVmYldWemMyRm5aVjlqYjIxd2JHVjBaU0J3WVhWelpRQnZibDl0WlhSb2IyUmZZMjl0Y0d4bGRHVWdjR0YxYzJVQWIyNWZhR1ZoWkdWeVgyWnBaV3hrWDJOdmJYQnNaWFJsSUhCaGRYTmxBRzl1WDJOb2RXNXJYMlY0ZEdWdWMybHZibDl1WVcxbElIQmhkWE5sQUZWdVpYaHdaV04wWldRZ2MzQmhZMlVnWVdaMFpYSWdjM1JoY25RZ2JHbHVaUUJUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYMk5vZFc1clgyVjRkR1Z1YzJsdmJsOXVZVzFsQUVsdWRtRnNhV1FnWTJoaGNtRmpkR1Z5SUdsdUlHTm9kVzVySUdWNGRHVnVjMmx2Ym5NZ2JtRnRaUUJRWVhWelpTQnZiaUJEVDA1T1JVTlVMMVZ3WjNKaFpHVUFVR0YxYzJVZ2IyNGdVRkpKTDFWd1ozSmhaR1VBUlhod1pXTjBaV1FnU0ZSVVVDOHlJRU52Ym01bFkzUnBiMjRnVUhKbFptRmpaUUJUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYMjFsZEdodlpBQkZlSEJsWTNSbFpDQnpjR0ZqWlNCaFpuUmxjaUJ0WlhSb2IyUUFVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOW9aV0ZrWlhKZlptbGxiR1FBVUdGMWMyVmtBRWx1ZG1Gc2FXUWdkMjl5WkNCbGJtTnZkVzUwWlhKbFpBQkpiblpoYkdsa0lHMWxkR2h2WkNCbGJtTnZkVzUwWlhKbFpBQlZibVY0Y0dWamRHVmtJR05vWVhJZ2FXNGdkWEpzSUhOamFHVnRZUUJTWlhGMVpYTjBJR2hoY3lCcGJuWmhiR2xrSUdCVWNtRnVjMlpsY2kxRmJtTnZaR2x1WjJBQVUxZEpWRU5JWDFCU1QxaFpBRlZUUlY5UVVrOVlXUUJOUzBGRFZFbFdTVlJaQUZWT1VGSlBRMFZUVTBGQ1RFVmZSVTVVU1ZSWkFFTlBVRmtBVFU5V1JVUmZVRVZTVFVGT1JVNVVURmtBVkU5UFgwVkJVa3haQUU1UFZFbEdXUUJHUVVsTVJVUmZSRVZRUlU1RVJVNURXUUJDUVVSZlIwRlVSVmRCV1FCUVRFRlpBRkJWVkFCRFNFVkRTMDlWVkFCSFFWUkZWMEZaWDFSSlRVVlBWVlFBVWtWUlZVVlRWRjlVU1UxRlQxVlVBRTVGVkZkUFVrdGZRMDlPVGtWRFZGOVVTVTFGVDFWVUFFTlBUazVGUTFSSlQwNWZWRWxOUlU5VlZBQk1UMGRKVGw5VVNVMUZUMVZVQUU1RlZGZFBVa3RmVWtWQlJGOVVTVTFGVDFWVUFGQlBVMVFBVFVsVFJFbFNSVU5VUlVSZlVrVlJWVVZUVkFCRFRFbEZUbFJmUTB4UFUwVkVYMUpGVVZWRlUxUUFRMHhKUlU1VVgwTk1UMU5GUkY5TVQwRkVYMEpCVEVGT1EwVkVYMUpGVVZWRlUxUUFRa0ZFWDFKRlVWVkZVMVFBU0ZSVVVGOVNSVkZWUlZOVVgxTkZUbFJmVkU5ZlNGUlVVRk5mVUU5U1ZBQlNSVkJQVWxRQVNVMWZRVjlVUlVGUVQxUUFVa1ZUUlZSZlEwOU9WRVZPVkFCT1QxOURUMDVVUlU1VUFGQkJVbFJKUVV4ZlEwOU9WRVZPVkFCSVVFVmZTVTVXUVV4SlJGOURUMDVUVkVGT1ZBQklVRVZmUTBKZlVrVlRSVlFBUjBWVUFFaFFSVjlUVkZKSlExUUFRMDlPUmt4SlExUUFWRVZOVUU5U1FWSlpYMUpGUkVsU1JVTlVBRkJGVWsxQlRrVk9WRjlTUlVSSlVrVkRWQUJEVDA1T1JVTlVBRTFWVEZSSlgxTlVRVlJWVXdCSVVFVmZTVTVXUVV4SlJGOVRWRUZVVlZNQVZFOVBYMDFCVGxsZlVrVlJWVVZUVkZNQVJVRlNURmxmU0VsT1ZGTUFWVTVCVmtGSlRFRkNURVZmUms5U1gweEZSMEZNWDFKRlFWTlBUbE1BVDFCVVNVOU9Vd0JUVjBsVVEwaEpUa2RmVUZKUFZFOURUMHhUQUZaQlVrbEJUbFJmUVV4VFQxOU9SVWRQVkVsQlZFVlRBRTFWVEZSSlVFeEZYME5JVDBsRFJWTUFTVTVVUlZKT1FVeGZVMFZTVmtWU1gwVlNVazlTQUZkRlFsOVRSVkpXUlZKZlZVNUxUazlYVGw5RlVsSlBVZ0JTUVVsTVIxVk9YMFZTVWs5U0FFbEVSVTVVU1ZSWlgxQlNUMVpKUkVWU1gwRlZWRWhGVGxSSlEwRlVTVTlPWDBWU1VrOVNBRk5UVEY5RFJWSlVTVVpKUTBGVVJWOUZVbEpQVWdCSlRsWkJURWxFWDFoZlJrOVNWMEZTUkVWRVgwWlBVZ0JUUlZSZlVFRlNRVTFGVkVWU0FFZEZWRjlRUVZKQlRVVlVSVklBU0ZCRlgxVlRSVklBVTBWRlgwOVVTRVZTQUVoUVJWOURRbDlEU0ZWT1MxOUlSVUZFUlZJQVRVdERRVXhGVGtSQlVnQlRSVlJWVUFCWFJVSmZVMFZTVmtWU1gwbFRYMFJQVjA0QVZFVkJVa1JQVjA0QVNGQkZYME5NVDFORlJGOURUMDVPUlVOVVNVOU9BRWhGVlZKSlUxUkpRMTlGV0ZCSlVrRlVTVTlPQUVSSlUwTlBUazVGUTFSRlJGOVBVRVZTUVZSSlQwNEFUazlPWDBGVlZFaFBVa2xVUVZSSlZrVmZTVTVHVDFKTlFWUkpUMDRBU0ZCRlgwbE9Wa0ZNU1VSZlZrVlNVMGxQVGdCSVVFVmZRMEpmVFVWVFUwRkhSVjlDUlVkSlRnQlRTVlJGWDBsVFgwWlNUMXBGVGdCSVVFVmZTVTVXUVV4SlJGOUlSVUZFUlZKZlZFOUxSVTRBU1U1V1FVeEpSRjlVVDB0RlRnQkdUMUpDU1VSRVJVNEFSVTVJUVU1RFJWOVpUMVZTWDBOQlRFMEFTRkJGWDBsT1ZrRk1TVVJmVlZKTUFFSk1UME5MUlVSZlFsbGZVRUZTUlU1VVFVeGZRMDlPVkZKUFRBQk5TME5QVEFCQlEwd0FTRkJGWDBsT1ZFVlNUa0ZNQUZKRlVWVkZVMVJmU0VWQlJFVlNYMFpKUlV4RVUxOVVUMDlmVEVGU1IwVmZWVTVQUmtaSlEwbEJUQUJJVUVWZlQwc0FWVTVNU1U1TEFGVk9URTlEU3dCUVVra0FVa1ZVVWxsZlYwbFVTQUJJVUVWZlNVNVdRVXhKUkY5RFQwNVVSVTVVWDB4RlRrZFVTQUJJVUVWZlZVNUZXRkJGUTFSRlJGOURUMDVVUlU1VVgweEZUa2RVU0FCR1RGVlRTQUJRVWs5UVVFRlVRMGdBVFMxVFJVRlNRMGdBVlZKSlgxUlBUMTlNVDA1SEFGQlNUME5GVTFOSlRrY0FUVWxUUTBWTVRFRk9SVTlWVTE5UVJWSlRTVk5VUlU1VVgxZEJVazVKVGtjQVRVbFRRMFZNVEVGT1JVOVZVMTlYUVZKT1NVNUhBRWhRUlY5SlRsWkJURWxFWDFSU1FVNVRSa1ZTWDBWT1EwOUVTVTVIQUVWNGNHVmpkR1ZrSUVOU1RFWUFTRkJGWDBsT1ZrRk1TVVJmUTBoVlRrdGZVMGxhUlFCTlQxWkZBRU5QVGxSSlRsVkZBRWhRUlY5RFFsOVRWRUZVVlZOZlEwOU5VRXhGVkVVQVNGQkZYME5DWDBoRlFVUkZVbE5mUTA5TlVFeEZWRVVBU0ZCRlgwTkNYMVpGVWxOSlQwNWZRMDlOVUV4RlZFVUFTRkJGWDBOQ1gxVlNURjlEVDAxUVRFVlVSUUJJVUVWZlEwSmZRMGhWVGt0ZlEwOU5VRXhGVkVVQVNGQkZYME5DWDBoRlFVUkZVbDlXUVV4VlJWOURUMDFRVEVWVVJRQklVRVZmUTBKZlEwaFZUa3RmUlZoVVJVNVRTVTlPWDFaQlRGVkZYME5QVFZCTVJWUkZBRWhRUlY5RFFsOURTRlZPUzE5RldGUkZUbE5KVDA1ZlRrRk5SVjlEVDAxUVRFVlVSUUJJVUVWZlEwSmZUVVZUVTBGSFJWOURUMDFRVEVWVVJRQklVRVZmUTBKZlRVVlVTRTlFWDBOUFRWQk1SVlJGQUVoUVJWOURRbDlJUlVGRVJWSmZSa2xGVEVSZlEwOU5VRXhGVkVVQVJFVk1SVlJGQUVoUVJWOUpUbFpCVEVsRVgwVlBSbDlUVkVGVVJRQkpUbFpCVEVsRVgxTlRURjlEUlZKVVNVWkpRMEZVUlFCUVFWVlRSUUJPVDE5U1JWTlFUMDVUUlFCVlRsTlZVRkJQVWxSRlJGOU5SVVJKUVY5VVdWQkZBRWRQVGtVQVRrOVVYMEZEUTBWUVZFRkNURVVBVTBWU1ZrbERSVjlWVGtGV1FVbE1RVUpNUlFCU1FVNUhSVjlPVDFSZlUwRlVTVk5HU1VGQ1RFVUFUMUpKUjBsT1gwbFRYMVZPVWtWQlEwaEJRa3hGQUZKRlUxQlBUbE5GWDBsVFgxTlVRVXhGQUZCVlVrZEZBRTFGVWtkRkFGSkZVVlZGVTFSZlNFVkJSRVZTWDBaSlJVeEVVMTlVVDA5ZlRFRlNSMFVBVWtWUlZVVlRWRjlJUlVGRVJWSmZWRTlQWDB4QlVrZEZBRkJCV1V4UFFVUmZWRTlQWDB4QlVrZEZBRWxPVTFWR1JrbERTVVZPVkY5VFZFOVNRVWRGQUVoUVJWOVFRVlZUUlVSZlZWQkhVa0ZFUlFCSVVFVmZVRUZWVTBWRVgwZ3lYMVZRUjFKQlJFVUFVMDlWVWtORkFFRk9UazlWVGtORkFGUlNRVU5GQUVoUVJWOVZUa1ZZVUVWRFZFVkVYMU5RUVVORkFFUkZVME5TU1VKRkFGVk9VMVZDVTBOU1NVSkZBRkpGUTA5U1JBQklVRVZmU1U1V1FVeEpSRjlOUlZSSVQwUUFUazlVWDBaUFZVNUVBRkJTVDFCR1NVNUVBRlZPUWtsT1JBQlNSVUpKVGtRQVZVNUJWVlJJVDFKSldrVkVBRTFGVkVoUFJGOU9UMVJmUVV4TVQxZEZSQUJJVkZSUVgxWkZVbE5KVDA1ZlRrOVVYMU5WVUZCUFVsUkZSQUJCVEZKRlFVUlpYMUpGVUU5U1ZFVkVBRUZEUTBWUVZFVkVBRTVQVkY5SlRWQk1SVTFGVGxSRlJBQk1UMDlRWDBSRlZFVkRWRVZFQUVoUVJWOURVbDlGV0ZCRlExUkZSQUJJVUVWZlRFWmZSVmhRUlVOVVJVUUFRMUpGUVZSRlJBQkpUVjlWVTBWRUFFaFFSVjlRUVZWVFJVUUFWRWxOUlU5VlZGOVBRME5WVWtWRUFGQkJXVTFGVGxSZlVrVlJWVWxTUlVRQVVGSkZRMDlPUkVsVVNVOU9YMUpGVVZWSlVrVkVBRkJTVDFoWlgwRlZWRWhGVGxSSlEwRlVTVTlPWDFKRlVWVkpVa1ZFQUU1RlZGZFBVa3RmUVZWVVNFVk9WRWxEUVZSSlQwNWZVa1ZSVlVsU1JVUUFURVZPUjFSSVgxSkZVVlZKVWtWRUFGTlRURjlEUlZKVVNVWkpRMEZVUlY5U1JWRlZTVkpGUkFCVlVFZFNRVVJGWDFKRlVWVkpVa1ZFQUZCQlIwVmZSVmhRU1ZKRlJBQlFVa1ZEVDA1RVNWUkpUMDVmUmtGSlRFVkVBRVZZVUVWRFZFRlVTVTlPWDBaQlNVeEZSQUJTUlZaQlRFbEVRVlJKVDA1ZlJrRkpURVZFQUZOVFRGOUlRVTVFVTBoQlMwVmZSa0ZKVEVWRUFFeFBRMHRGUkFCVVVrRk9VMFpQVWsxQlZFbFBUbDlCVUZCTVNVVkVBRTVQVkY5TlQwUkpSa2xGUkFCT1QxUmZSVmhVUlU1RVJVUUFRa0ZPUkZkSlJGUklYMHhKVFVsVVgwVllRMFZGUkVWRUFGTkpWRVZmU1ZOZlQxWkZVa3hQUVVSRlJBQklSVUZFQUVWNGNHVmpkR1ZrSUVoVVZGQXZBQUJlRXdBQUpoTUFBREFRQUFEd0Z3QUFuUk1BQUJVU0FBQTVGd0FBOEJJQUFBb1FBQUIxRWdBQXJSSUFBSUlUQUFCUEZBQUFmeEFBQUtBVkFBQWpGQUFBaVJJQUFJc1VBQUJORlFBQTFCRUFBTThVQUFBUUdBQUF5UllBQU53V0FBREJFUUFBNEJjQUFMc1VBQUIwRkFBQWZCVUFBT1VVQUFBSUZ3QUFIeEFBQUdVVkFBQ2pGQUFBS0JVQUFBSVZBQUNaRlFBQUxCQUFBSXNaQUFCUER3QUExQTRBQUdvUUFBRE9FQUFBQWhjQUFJa09BQUJ1RXdBQUhCTUFBR1lVQUFCV0Z3QUF3Uk1BQU0wVEFBQnNFd0FBYUJjQUFHWVhBQUJmRndBQUloTUFBTTRQQUFCcERnQUEyQTRBQUdNV0FBRExFd0FBcWc0QUFDZ1hBQUFtRndBQXhSTUFBRjBXQUFEb0VRQUFaeE1BQUdVVEFBRHlGZ0FBY3hNQUFCMFhBQUQ1RmdBQTh4RUFBTThPQUFET0ZRQUFEQklBQUxNUkFBQ2xFUUFBWVJBQUFESVhBQUM3RXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUVCQWdFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUFBQUFBQUFBQUFBQUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFnTUNBZ0lDQWdBQUFnSUFBZ0lBQWdJQ0FnSUNBZ0lDQWdBRUFBQUFBQUFDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0FBQUFJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FBSUFBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUlBQWdJQ0FnSUFBQUlDQUFJQ0FBSUNBZ0lDQWdJQ0FnSUFBd0FFQUFBQUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQUFBQUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0FDQUFJQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQnNiM05sWldWd0xXRnNhWFpsQUFBQUFBQUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFBQUFBQUFBQUFBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRRUJBUUVCQVFFQkFRRUJBZ0VCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFGamFIVnVhMlZrQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBUUFCQVFFQkFRQUFBUUVBQVFFQUFRRUJBUUVCQVFFQkFRQUFBQUFBQUFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQUFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUVBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFHVmpkR2x2Ym1WdWRDMXNaVzVuZEdodmJuSnZlSGt0WTI5dWJtVmpkR2x2YmdBQUFBQUFBQUFBQUFBQUFBQUFBSEpoYm5ObVpYSXRaVzVqYjJScGJtZHdaM0poWkdVTkNnMEtEUXBUVFEwS0RRcFVWRkF2UTBVdlZGTlFMd0FBQUFBQUFBQUFBQUFBQUFFQ0FBRURBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBQUFBQUFBQUFBQUJBZ0FCQXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQkFRVUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFBQUFBQUFBQUFBQVFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUFBQUFBQUFBQUFBQUJBQUFDQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXdRQUFBUUVCQVFFQkFRRUJBUUVCUVFFQkFRRUJBUUVCQVFFQkFBRUFBWUhCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFBQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFnQUFBQUFBQUFNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQUFBQUFBQUFBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUFBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBQUFBQUFBQUFBQWdBQUFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3QUFBQUFBQUFNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRTVQVlU1RFJVVkRTMDlWVkU1RlExUkZWRVZEVWtsQ1JVeFZVMGhGVkVWQlJGTkZRVkpEU0ZKSFJVTlVTVlpKVkZsTVJVNUVRVkpXUlU5VVNVWlpVRlJKVDA1VFEwaFRSVUZaVTFSQlZFTklSMFZQVWtSSlVrVkRWRTlTVkZKRFNGQkJVa0ZOUlZSRlVsVlNRMFZDVTBOU1NVSkZRVkpFVDFkT1FVTkZTVTVFVGt0RFMxVkNVME5TU1VKRlNGUlVVQzlCUkZSUUx3PT0nXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/llhttp/utils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/llhttp/utils.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.enumToMap = void 0;\nfunction enumToMap(obj) {\n    const res = {};\n    Object.keys(obj).forEach((key)=>{\n        const value = obj[key];\n        if (typeof value === \"number\") {\n            res[key] = value;\n        }\n    });\n    return res;\n}\nexports.enumToMap = enumToMap; //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbGxodHRwL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBRyxLQUFLO0FBQ3pCLFNBQVNFLFVBQVVDLEdBQUc7SUFDbEIsTUFBTUMsTUFBTSxDQUFDO0lBQ2JOLE9BQU9PLElBQUksQ0FBQ0YsS0FBS0csT0FBTyxDQUFDLENBQUNDO1FBQ3RCLE1BQU1OLFFBQVFFLEdBQUcsQ0FBQ0ksSUFBSTtRQUN0QixJQUFJLE9BQU9OLFVBQVUsVUFBVTtZQUMzQkcsR0FBRyxDQUFDRyxJQUFJLEdBQUdOO1FBQ2Y7SUFDSjtJQUNBLE9BQU9HO0FBQ1g7QUFDQUosaUJBQWlCLEdBQUdFLFdBQ3BCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2xsaHR0cC91dGlscy5qcz8wZWM5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbnVtVG9NYXAgPSB2b2lkIDA7XG5mdW5jdGlvbiBlbnVtVG9NYXAob2JqKSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJlc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5lbnVtVG9NYXAgPSBlbnVtVG9NYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtVG9NYXAiLCJvYmoiLCJyZXMiLCJrZXlzIiwiZm9yRWFjaCIsImtleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/llhttp/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-agent.js":
/*!**************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/mock/mock-agent.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kClients } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\");\nconst Agent = __webpack_require__(/*! ../agent */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/agent.js\");\nconst { kAgent, kMockAgentSet, kMockAgentGet, kDispatches, kIsMockActive, kNetConnect, kGetNetConnect, kOptions, kFactory } = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-symbols.js\");\nconst MockClient = __webpack_require__(/*! ./mock-client */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-client.js\");\nconst MockPool = __webpack_require__(/*! ./mock-pool */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-pool.js\");\nconst { matchValue, buildMockOptions } = __webpack_require__(/*! ./mock-utils */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-utils.js\");\nconst { InvalidArgumentError, UndiciError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\nconst Dispatcher = __webpack_require__(/*! ../dispatcher */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/dispatcher.js\");\nconst Pluralizer = __webpack_require__(/*! ./pluralizer */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/pluralizer.js\");\nconst PendingInterceptorsFormatter = __webpack_require__(/*! ./pending-interceptors-formatter */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/pending-interceptors-formatter.js\");\nclass FakeWeakRef {\n    constructor(value){\n        this.value = value;\n    }\n    deref() {\n        return this.value;\n    }\n}\nclass MockAgent extends Dispatcher {\n    constructor(opts){\n        super(opts);\n        this[kNetConnect] = true;\n        this[kIsMockActive] = true;\n        // Instantiate Agent and encapsulate\n        if (opts && opts.agent && typeof opts.agent.dispatch !== \"function\") {\n            throw new InvalidArgumentError(\"Argument opts.agent must implement Agent\");\n        }\n        const agent = opts && opts.agent ? opts.agent : new Agent(opts);\n        this[kAgent] = agent;\n        this[kClients] = agent[kClients];\n        this[kOptions] = buildMockOptions(opts);\n    }\n    get(origin) {\n        let dispatcher = this[kMockAgentGet](origin);\n        if (!dispatcher) {\n            dispatcher = this[kFactory](origin);\n            this[kMockAgentSet](origin, dispatcher);\n        }\n        return dispatcher;\n    }\n    dispatch(opts, handler) {\n        // Call MockAgent.get to perform additional setup before dispatching as normal\n        this.get(opts.origin);\n        return this[kAgent].dispatch(opts, handler);\n    }\n    async close() {\n        await this[kAgent].close();\n        this[kClients].clear();\n    }\n    deactivate() {\n        this[kIsMockActive] = false;\n    }\n    activate() {\n        this[kIsMockActive] = true;\n    }\n    enableNetConnect(matcher) {\n        if (typeof matcher === \"string\" || typeof matcher === \"function\" || matcher instanceof RegExp) {\n            if (Array.isArray(this[kNetConnect])) {\n                this[kNetConnect].push(matcher);\n            } else {\n                this[kNetConnect] = [\n                    matcher\n                ];\n            }\n        } else if (typeof matcher === \"undefined\") {\n            this[kNetConnect] = true;\n        } else {\n            throw new InvalidArgumentError(\"Unsupported matcher. Must be one of String|Function|RegExp.\");\n        }\n    }\n    disableNetConnect() {\n        this[kNetConnect] = false;\n    }\n    // This is required to bypass issues caused by using global symbols - see:\n    // https://github.com/nodejs/undici/issues/1447\n    get isMockActive() {\n        return this[kIsMockActive];\n    }\n    [kMockAgentSet](origin, dispatcher) {\n        this[kClients].set(origin, new FakeWeakRef(dispatcher));\n    }\n    [kFactory](origin) {\n        const mockOptions = Object.assign({\n            agent: this\n        }, this[kOptions]);\n        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);\n    }\n    [kMockAgentGet](origin) {\n        // First check if we can immediately find it\n        const ref = this[kClients].get(origin);\n        if (ref) {\n            return ref.deref();\n        }\n        // If the origin is not a string create a dummy parent pool and return to user\n        if (typeof origin !== \"string\") {\n            const dispatcher = this[kFactory](\"http://localhost:9999\");\n            this[kMockAgentSet](origin, dispatcher);\n            return dispatcher;\n        }\n        // If we match, create a pool and assign the same dispatches\n        for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])){\n            const nonExplicitDispatcher = nonExplicitRef.deref();\n            if (nonExplicitDispatcher && typeof keyMatcher !== \"string\" && matchValue(keyMatcher, origin)) {\n                const dispatcher = this[kFactory](origin);\n                this[kMockAgentSet](origin, dispatcher);\n                dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];\n                return dispatcher;\n            }\n        }\n    }\n    [kGetNetConnect]() {\n        return this[kNetConnect];\n    }\n    pendingInterceptors() {\n        const mockAgentClients = this[kClients];\n        return Array.from(mockAgentClients.entries()).flatMap(([origin, scope])=>scope.deref()[kDispatches].map((dispatch)=>({\n                    ...dispatch,\n                    origin\n                }))).filter(({ pending })=>pending);\n    }\n    assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {\n        const pending = this.pendingInterceptors();\n        if (pending.length === 0) {\n            return;\n        }\n        const pluralizer = new Pluralizer(\"interceptor\", \"interceptors\").pluralize(pending.length);\n        throw new UndiciError(`\n${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:\n\n${pendingInterceptorsFormatter.format(pending)}\n`.trim());\n    }\n}\nmodule.exports = MockAgent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLWFnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxRQUFRLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDN0IsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDdEIsTUFBTSxFQUNKRSxNQUFNLEVBQ05DLGFBQWEsRUFDYkMsYUFBYSxFQUNiQyxXQUFXLEVBQ1hDLGFBQWEsRUFDYkMsV0FBVyxFQUNYQyxjQUFjLEVBQ2RDLFFBQVEsRUFDUkMsUUFBUSxFQUNULEdBQUdWLG1CQUFPQSxDQUFDO0FBQ1osTUFBTVcsYUFBYVgsbUJBQU9BLENBQUM7QUFDM0IsTUFBTVksV0FBV1osbUJBQU9BLENBQUM7QUFDekIsTUFBTSxFQUFFYSxVQUFVLEVBQUVDLGdCQUFnQixFQUFFLEdBQUdkLG1CQUFPQSxDQUFDO0FBQ2pELE1BQU0sRUFBRWUsb0JBQW9CLEVBQUVDLFdBQVcsRUFBRSxHQUFHaEIsbUJBQU9BLENBQUM7QUFDdEQsTUFBTWlCLGFBQWFqQixtQkFBT0EsQ0FBQztBQUMzQixNQUFNa0IsYUFBYWxCLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1tQiwrQkFBK0JuQixtQkFBT0EsQ0FBQztBQUU3QyxNQUFNb0I7SUFDSkMsWUFBYUMsS0FBSyxDQUFFO1FBQ2xCLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtJQUNmO0lBRUFDLFFBQVM7UUFDUCxPQUFPLElBQUksQ0FBQ0QsS0FBSztJQUNuQjtBQUNGO0FBRUEsTUFBTUUsa0JBQWtCUDtJQUN0QkksWUFBYUksSUFBSSxDQUFFO1FBQ2pCLEtBQUssQ0FBQ0E7UUFFTixJQUFJLENBQUNsQixZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDRCxjQUFjLEdBQUc7UUFFdEIsb0NBQW9DO1FBQ3BDLElBQUttQixRQUFRQSxLQUFLQyxLQUFLLElBQUksT0FBT0QsS0FBS0MsS0FBSyxDQUFDQyxRQUFRLEtB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QUV6RixNQUFNLElBQUloRCxZQUFZLENBQUM7QUFDM0IsRUFBRWlELFdBQVdFLEtBQUssQ0FBQyxDQUFDLEVBQUVGLFdBQVdHLElBQUksQ0FBQyxDQUFDLEVBQUVILFdBQVdJLEVBQUUsQ0FBQzs7QUFFdkQsRUFBRU4sNkJBQTZCTyxNQUFNLENBQUNULFNBQVM7QUFDL0MsQ0FBQyxDQUFDVSxJQUFJO0lBQ0o7QUFDRjtBQUVBQyxPQUFPQyxPQUFPLEdBQUdqRCIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay1hZ2VudC5qcz82MGY4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGtDbGllbnRzIH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgQWdlbnQgPSByZXF1aXJlKCcuLi9hZ2VudCcpXG5jb25zdCB7XG4gIGtBZ2VudCxcbiAga01vY2tBZ2VudFNldCxcbiAga01vY2tBZ2VudEdldCxcbiAga0Rpc3BhdGNoZXMsXG4gIGtJc01vY2tBY3RpdmUsXG4gIGtOZXRDb25uZWN0LFxuICBrR2V0TmV0Q29ubmVjdCxcbiAga09wdGlvbnMsXG4gIGtGYWN0b3J5XG59ID0gcmVxdWlyZSgnLi9tb2NrLXN5bWJvbHMnKVxuY29uc3QgTW9ja0NsaWVudCA9IHJlcXVpcmUoJy4vbW9jay1jbGllbnQnKVxuY29uc3QgTW9ja1Bvb2wgPSByZXF1aXJlKCcuL21vY2stcG9vbCcpXG5jb25zdCB7IG1hdGNoVmFsdWUsIGJ1aWxkTW9ja09wdGlvbnMgfSA9IHJlcXVpcmUoJy4vbW9jay11dGlscycpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBVbmRpY2lFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL2Rpc3BhdGNoZXInKVxuY29uc3QgUGx1cmFsaXplciA9IHJlcXVpcmUoJy4vcGx1cmFsaXplcicpXG5jb25zdCBQZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyID0gcmVxdWlyZSgnLi9wZW5kaW5nLWludGVyY2VwdG9ycy1mb3JtYXR0ZXInKVxuXG5jbGFzcyBGYWtlV2Vha1JlZiB7XG4gIGNvbnN0cnVjdG9yICh2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICB9XG5cbiAgZGVyZWYgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlXG4gIH1cbn1cblxuY2xhc3MgTW9ja0FnZW50IGV4dGVuZHMgRGlzcGF0Y2hlciB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cylcblxuICAgIHRoaXNba05ldENvbm5lY3RdID0gdHJ1ZVxuICAgIHRoaXNba0lzTW9ja0FjdGl2ZV0gPSB0cnVlXG5cbiAgICAvLyBJbnN0YW50aWF0ZSBBZ2VudCBhbmQgZW5jYXBzdWxhdGVcbiAgICBpZiAoKG9wdHMgJiYgb3B0cy5hZ2VudCAmJiB0eXBlb2Ygb3B0cy5hZ2VudC5kaXNwYXRjaCAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignQXJndW1lbnQgb3B0cy5hZ2VudCBtdXN0IGltcGxlbWVudCBBZ2VudCcpXG4gICAgfVxuICAgIGNvbnN0IGFnZW50ID0gb3B0cyAmJiBvcHRzLmFnZW50ID8gb3B0cy5hZ2VudCA6IG5ldyBBZ2VudChvcHRzKVxuICAgIHRoaXNba0FnZW50XSA9IGFnZW50XG5cbiAgICB0aGlzW2tDbGllbnRzXSA9IGFnZW50W2tDbGllbnRzXVxuICAgIHRoaXNba09wdGlvbnNdID0gYnVpbGRNb2NrT3B0aW9ucyhvcHRzKVxuICB9XG5cbiAgZ2V0IChvcmlnaW4pIHtcbiAgICBsZXQgZGlzcGF0Y2hlciA9IHRoaXNba01vY2tBZ2VudEdldF0ob3JpZ2luKVxuXG4gICAgaWYgKCFkaXNwYXRjaGVyKSB7XG4gICAgICBkaXNwYXRjaGVyID0gdGhpc1trRmFjdG9yeV0ob3JpZ2luKVxuICAgICAgdGhpc1trTW9ja0FnZW50U2V0XShvcmlnaW4sIGRpc3BhdGNoZXIpXG4gICAgfVxuICAgIHJldHVybiBkaXNwYXRjaGVyXG4gIH1cblxuICBkaXNwYXRjaCAob3B0cywgaGFuZGxlcikge1xuICAgIC8vIENhbGwgTW9ja0FnZW50LmdldCB0byBwZXJmb3JtIGFkZGl0aW9uYWwgc2V0dXAgYmVmb3JlIGRpc3BhdGNoaW5nIGFzIG5vcm1hbFxuICAgIHRoaXMuZ2V0KG9wdHMub3JpZ2luKVxuICAgIHJldHVybiB0aGlzW2tBZ2VudF0uZGlzcGF0Y2gob3B0cywgaGFuZGxlcilcbiAgfVxuXG4gIGFzeW5jIGNsb3NlICgpIHtcbiAgICBhd2FpdCB0aGlzW2tBZ2VudF0uY2xvc2UoKVxuICAgIHRoaXNba0NsaWVudHNdLmNsZWFyKClcbiAgfVxuXG4gIGRlYWN0aXZhdGUgKCkge1xuICAgIHRoaXNba0lzTW9ja0FjdGl2ZV0gPSBmYWxzZVxuICB9XG5cbiAgYWN0aXZhdGUgKCkge1xuICAgIHRoaXNba0lzTW9ja0FjdGl2ZV0gPSB0cnVlXG4gIH1cblxuICBlbmFibGVOZXRDb25uZWN0IChtYXRjaGVyKSB7XG4gICAgaWYgKHR5cGVvZiBtYXRjaGVyID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbWF0Y2hlciA9PT0gJ2Z1bmN0aW9uJyB8fCBtYXRjaGVyIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzW2tOZXRDb25uZWN0XSkpIHtcbiAgICAgICAgdGhpc1trTmV0Q29ubmVjdF0ucHVzaChtYXRjaGVyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1trTmV0Q29ubmVjdF0gPSBbbWF0Y2hlcl1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXRjaGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpc1trTmV0Q29ubmVjdF0gPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignVW5zdXBwb3J0ZWQgbWF0Y2hlci4gTXVzdCBiZSBvbmUgb2YgU3RyaW5nfEZ1bmN0aW9ufFJlZ0V4cC4nKVxuICAgIH1cbiAgfVxuXG4gIGRpc2FibGVOZXRDb25uZWN0ICgpIHtcbiAgICB0aGlzW2tOZXRDb25uZWN0XSA9IGZhbHNlXG4gIH1cblxuICAvLyBUaGlzIGlzIHJlcXVpcmVkIHRvIGJ5cGFzcyBpc3N1ZXMgY2F1c2VkIGJ5IHVzaW5nIGdsb2JhbCBzeW1ib2xzIC0gc2VlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMTQ0N1xuICBnZXQgaXNNb2NrQWN0aXZlICgpIHtcbiAgICByZXR1cm4gdGhpc1trSXNNb2NrQWN0aXZlXVxuICB9XG5cbiAgW2tNb2NrQWdlbnRTZXRdIChvcmlnaW4sIGRpc3BhdGNoZXIpIHtcbiAgICB0aGlzW2tDbGllbnRzXS5zZXQob3JpZ2luLCBuZXcgRmFrZVdlYWtSZWYoZGlzcGF0Y2hlcikpXG4gIH1cblxuICBba0ZhY3RvcnldIChvcmlnaW4pIHtcbiAgICBjb25zdCBtb2NrT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBhZ2VudDogdGhpcyB9LCB0aGlzW2tPcHRpb25zXSlcbiAgICByZXR1cm4gdGhpc1trT3B0aW9uc10gJiYgdGhpc1trT3B0aW9uc10uY29ubmVjdGlvbnMgPT09IDFcbiAgICAgID8gbmV3IE1vY2tDbGllbnQob3JpZ2luLCBtb2NrT3B0aW9ucylcbiAgICAgIDogbmV3IE1vY2tQb29sKG9yaWdpbiwgbW9ja09wdGlvbnMpXG4gIH1cblxuICBba01vY2tBZ2VudEdldF0gKG9yaWdpbikge1xuICAgIC8vIEZpcnN0IGNoZWNrIGlmIHdlIGNhbiBpbW1lZGlhdGVseSBmaW5kIGl0XG4gICAgY29uc3QgcmVmID0gdGhpc1trQ2xpZW50c10uZ2V0KG9yaWdpbilcbiAgICBpZiAocmVmKSB7XG4gICAgICByZXR1cm4gcmVmLmRlcmVmKClcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgb3JpZ2luIGlzIG5vdCBhIHN0cmluZyBjcmVhdGUgYSBkdW1teSBwYXJlbnQgcG9vbCBhbmQgcmV0dXJuIHRvIHVzZXJcbiAgICBpZiAodHlwZW9mIG9yaWdpbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGRpc3BhdGNoZXIgPSB0aGlzW2tGYWN0b3J5XSgnaHR0cDovL2xvY2FsaG9zdDo5OTk5JylcbiAgICAgIHRoaXNba01vY2tBZ2VudFNldF0ob3JpZ2luLCBkaXNwYXRjaGVyKVxuICAgICAgcmV0dXJuIGRpc3BhdGNoZXJcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBtYXRjaCwgY3JlYXRlIGEgcG9vbCBhbmQgYXNzaWduIHRoZSBzYW1lIGRpc3BhdGNoZXNcbiAgICBmb3IgKGNvbnN0IFtrZXlNYXRjaGVyLCBub25FeHBsaWNpdFJlZl0gb2YgQXJyYXkuZnJvbSh0aGlzW2tDbGllbnRzXSkpIHtcbiAgICAgIGNvbnN0IG5vbkV4cGxpY2l0RGlzcGF0Y2hlciA9IG5vbkV4cGxpY2l0UmVmLmRlcmVmKClcbiAgICAgIGlmIChub25FeHBsaWNpdERpc3BhdGNoZXIgJiYgdHlwZW9mIGtleU1hdGNoZXIgIT09ICdzdHJpbmcnICYmIG1hdGNoVmFsdWUoa2V5TWF0Y2hlciwgb3JpZ2luKSkge1xuICAgICAgICBjb25zdCBkaXNwYXRjaGVyID0gdGhpc1trRmFjdG9yeV0ob3JpZ2luKVxuICAgICAgICB0aGlzW2tNb2NrQWdlbnRTZXRdKG9yaWdpbiwgZGlzcGF0Y2hlcilcbiAgICAgICAgZGlzcGF0Y2hlcltrRGlzcGF0Y2hlc10gPSBub25FeHBsaWNpdERpc3BhdGNoZXJba0Rpc3BhdGNoZXNdXG4gICAgICAgIHJldHVybiBkaXNwYXRjaGVyXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgW2tHZXROZXRDb25uZWN0XSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba05ldENvbm5lY3RdXG4gIH1cblxuICBwZW5kaW5nSW50ZXJjZXB0b3JzICgpIHtcbiAgICBjb25zdCBtb2NrQWdlbnRDbGllbnRzID0gdGhpc1trQ2xpZW50c11cblxuICAgIHJldHVybiBBcnJheS5mcm9tKG1vY2tBZ2VudENsaWVudHMuZW50cmllcygpKVxuICAgICAgLmZsYXRNYXAoKFtvcmlnaW4sIHNjb3BlXSkgPT4gc2NvcGUuZGVyZWYoKVtrRGlzcGF0Y2hlc10ubWFwKGRpc3BhdGNoID0+ICh7IC4uLmRpc3BhdGNoLCBvcmlnaW4gfSkpKVxuICAgICAgLmZpbHRlcigoeyBwZW5kaW5nIH0pID0+IHBlbmRpbmcpXG4gIH1cblxuICBhc3NlcnROb1BlbmRpbmdJbnRlcmNlcHRvcnMgKHsgcGVuZGluZ0ludGVyY2VwdG9yc0Zvcm1hdHRlciA9IG5ldyBQZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyKCkgfSA9IHt9KSB7XG4gICAgY29uc3QgcGVuZGluZyA9IHRoaXMucGVuZGluZ0ludGVyY2VwdG9ycygpXG5cbiAgICBpZiAocGVuZGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHBsdXJhbGl6ZXIgPSBuZXcgUGx1cmFsaXplcignaW50ZXJjZXB0b3InLCAnaW50ZXJjZXB0b3JzJykucGx1cmFsaXplKHBlbmRpbmcubGVuZ3RoKVxuXG4gICAgdGhyb3cgbmV3IFVuZGljaUVycm9yKGBcbiR7cGx1cmFsaXplci5jb3VudH0gJHtwbHVyYWxpemVyLm5vdW59ICR7cGx1cmFsaXplci5pc30gcGVuZGluZzpcblxuJHtwZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyLmZvcm1hdChwZW5kaW5nKX1cbmAudHJpbSgpKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTW9ja0FnZW50XG4iXSwibmFtZXMiOlsia0NsaWVudHMiLCJyZXF1aXJlIiwiQWdlbnQiLCJrQWdlbnQiLCJrTW9ja0FnZW50U2V0Iiwia01vY2tBZ2VudEdldCIsImtEaXNwYXRjaGVzIiwia0lzTW9ja0FjdGl2ZSIsImtOZXRDb25uZWN0Iiwia0dldE5ldENvbm5lY3QiLCJrT3B0aW9ucyIsImtGYWN0b3J5IiwiTW9ja0NsaWVudCIsIk1vY2tQb29sIiwibWF0Y2hWYWx1ZSIsImJ1aWxkTW9ja09wdGlvbnMiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIlVuZGljaUVycm9yIiwiRGlzcGF0Y2hlciIsIlBsdXJhbGl6ZXIiLCJQZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyIiwiRmFrZVdlYWtSZWYiLCJjb25zdHJ1Y3RvciIsInZhbHVlIiwiZGVyZWYiLCJNb2NrQWdlbnQiLCJvcHRzIiwiYWdlbnQiLCJkaXNwYXRjaCIsImdldCIsIm9yaWdpbiIsImRpc3BhdGNoZXIiLCJoYW5kbGVyIiwiY2xvc2UiLCJjbGVhciIsImRlYWN0aXZhdGUiLCJhY3RpdmF0ZSIsImVuYWJsZU5ldENvbm5lY3QiLCJtYXRjaGVyIiwiUmVnRXhwIiwiQXJyYXkiLCJpc0FycmF5IiwicHVzaCIsImRpc2FibGVOZXRDb25uZWN0IiwiaXNNb2NrQWN0aXZlIiwic2V0IiwibW9ja09wdGlvbnMiLCJPYmplY3QiLCJhc3NpZ24iLCJjb25uZWN0aW9ucyIsInJlZiIsImtleU1hdGNoZXIiLCJub25FeHBsaWNpdFJlZiIsImZyb20iLCJub25FeHBsaWNpdERpc3BhdGNoZXIiLCJwZW5kaW5nSW50ZXJjZXB0b3JzIiwibW9ja0FnZW50Q2xpZW50cyIsImVudHJpZXMiLCJmbGF0TWFwIiwic2NvcGUiLCJtYXAiLCJmaWx0ZXIiLCJwZW5kaW5nIiwiYXNzZXJ0Tm9QZW5kaW5nSW50ZXJjZXB0b3JzIiwicGVuZGluZ0ludGVyY2VwdG9yc0Zvcm1hdHRlciIsImxlbmd0aCIsInBsdXJhbGl6ZXIiLCJwbHVyYWxpemUiLCJjb3VudCIsIm5vdW4iLCJpcyIsImZvcm1hdCIsInRyaW0iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-agent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-client.js":
/*!***************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/mock/mock-client.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst Client = __webpack_require__(/*! ../client */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/client.js\");\nconst { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-utils.js\");\nconst { kDispatches, kMockAgent, kClose, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-symbols.js\");\nconst { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-interceptor.js\");\nconst Symbols = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\n/**\n * MockClient provides an API that extends the Client to influence the mockDispatches.\n */ class MockClient extends Client {\n    constructor(origin, opts){\n        super(origin, opts);\n        if (!opts || !opts.agent || typeof opts.agent.dispatch !== \"function\") {\n            throw new InvalidArgumentError(\"Argument opts.agent must implement Agent\");\n        }\n        this[kMockAgent] = opts.agent;\n        this[kOrigin] = origin;\n        this[kDispatches] = [];\n        this[kConnected] = 1;\n        this[kOriginalDispatch] = this.dispatch;\n        this[kOriginalClose] = this.close.bind(this);\n        this.dispatch = buildMockDispatch.call(this);\n        this.close = this[kClose];\n    }\n    get [Symbols.kConnected]() {\n        return this[kConnected];\n    }\n    /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */ intercept(opts) {\n        return new MockInterceptor(opts, this[kDispatches]);\n    }\n    async [kClose]() {\n        await promisify(this[kOriginalClose])();\n        this[kConnected] = 0;\n        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);\n    }\n}\nmodule.exports = MockClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLWNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsU0FBUyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRUUsaUJBQWlCLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDdEMsTUFBTSxFQUNKRyxXQUFXLEVBQ1hDLFVBQVUsRUFDVkMsTUFBTSxFQUNOQyxjQUFjLEVBQ2RDLE9BQU8sRUFDUEMsaUJBQWlCLEVBQ2pCQyxVQUFVLEVBQ1gsR0FBR1QsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQUVVLGVBQWUsRUFBRSxHQUFHVixtQkFBT0EsQ0FBQztBQUNwQyxNQUFNVyxVQUFVWCxtQkFBT0EsQ0FBQztBQUN4QixNQUFNLEVBQUVZLG9CQUFvQixFQUFFLEdBQUdaLG1CQUFPQSxDQUFDO0FBRXpDOztDQUVDLEdBQ0QsTUFBTWEsbUJBQW1CWjtJQUN2QmEsWUFBYUMsTUFBTSxFQUFFQyxJQUFJLENBQUU7UUFDekIsS0FBSyxDQUFDRCxRQUFRQztRQUVkLElBQUksQ0FBQ0EsUUFBUSxDQUFDQSxLQUFLQyxLQUFLLElBQUksT0FBT0QsS0FBS0MsS0FBSyxDQUFDQyxRQUFRLEtBQUssWUFBWTtZQUNyRSxNQUFNLElBQUlOLHFCQUFxQjtRQUNqQztRQUVBLElBQUksQ0FBQ1IsV0FBVyxHQUFHWSxLQUFLQyxLQUFLO1FBQzdCLElBQUksQ0FBQ1YsUUFBUSxHQUFHUTtRQUNoQixJQUFJLENBQUNaLFlBQVksR0FBRyxFQUFFO1FBQ3RCLElBQUksQ0FBQ00sV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0Qsa0JBQWtCLEdBQUcsSUFBSSxDQUFDVSxRQUFRO1FBQ3ZDLElBQUksQ0FBQ1osZUFBZSxHQUFHLElBQUksQ0FBQ2EsS0FBSyxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUUzQyxJQUFJLENBQUNGLFFBQVEsR0FBR2hCLGtCQUFrQm1CLElBQUksQ0FBQyxJQUFJO1FBQzNDLElBQUksQ0FBQ0YsS0FBSyxHQUFHLElBQUksQ0FBQ2QsT0FBTztJQUMzQjtJQUVBLElBQUksQ0FBQ00sUUFBUUYsVUFBVSxDQUFDLEdBQUk7UUFDMUIsT0FBTyxJQUFJLENBQUNBLFdBQVc7SUFDekI7SUFFQTs7R0FFQyxHQUNEYSxVQUFXTixJQUFJLEVBQUU7UUFDZixPQUFPLElBQUlOLGdCQUFnQk0sTUFBTSxJQUFJLENBQUNiLFlBQVk7SUFDcEQ7SUFFQSxNQUFNLENBQUNFLE9BQU8sR0FBSTtRQUNoQixNQUFNTixVQUFVLElBQUksQ0FBQ08sZUFBZTtRQUNwQyxJQUFJLENBQUNHLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNMLFdBQVcsQ0FBQ08sUUFBUVksUUFBUSxDQUFDLENBQUNDLE1BQU0sQ0FBQyxJQUFJLENBQUNqQixRQUFRO0lBQ3pEO0FBQ0Y7QUFFQWtCLE9BQU9DLE9BQU8sR0FBR2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stY2xpZW50LmpzPzNjMmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCd1dGlsJylcbmNvbnN0IENsaWVudCA9IHJlcXVpcmUoJy4uL2NsaWVudCcpXG5jb25zdCB7IGJ1aWxkTW9ja0Rpc3BhdGNoIH0gPSByZXF1aXJlKCcuL21vY2stdXRpbHMnKVxuY29uc3Qge1xuICBrRGlzcGF0Y2hlcyxcbiAga01vY2tBZ2VudCxcbiAga0Nsb3NlLFxuICBrT3JpZ2luYWxDbG9zZSxcbiAga09yaWdpbixcbiAga09yaWdpbmFsRGlzcGF0Y2gsXG4gIGtDb25uZWN0ZWRcbn0gPSByZXF1aXJlKCcuL21vY2stc3ltYm9scycpXG5jb25zdCB7IE1vY2tJbnRlcmNlcHRvciB9ID0gcmVxdWlyZSgnLi9tb2NrLWludGVyY2VwdG9yJylcbmNvbnN0IFN5bWJvbHMgPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuXG4vKipcbiAqIE1vY2tDbGllbnQgcHJvdmlkZXMgYW4gQVBJIHRoYXQgZXh0ZW5kcyB0aGUgQ2xpZW50IHRvIGluZmx1ZW5jZSB0aGUgbW9ja0Rpc3BhdGNoZXMuXG4gKi9cbmNsYXNzIE1vY2tDbGllbnQgZXh0ZW5kcyBDbGllbnQge1xuICBjb25zdHJ1Y3RvciAob3JpZ2luLCBvcHRzKSB7XG4gICAgc3VwZXIob3JpZ2luLCBvcHRzKVxuXG4gICAgaWYgKCFvcHRzIHx8ICFvcHRzLmFnZW50IHx8IHR5cGVvZiBvcHRzLmFnZW50LmRpc3BhdGNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0FyZ3VtZW50IG9wdHMuYWdlbnQgbXVzdCBpbXBsZW1lbnQgQWdlbnQnKVxuICAgIH1cblxuICAgIHRoaXNba01vY2tBZ2VudF0gPSBvcHRzLmFnZW50XG4gICAgdGhpc1trT3JpZ2luXSA9IG9yaWdpblxuICAgIHRoaXNba0Rpc3BhdGNoZXNdID0gW11cbiAgICB0aGlzW2tDb25uZWN0ZWRdID0gMVxuICAgIHRoaXNba09yaWdpbmFsRGlzcGF0Y2hdID0gdGhpcy5kaXNwYXRjaFxuICAgIHRoaXNba09yaWdpbmFsQ2xvc2VdID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLmRpc3BhdGNoID0gYnVpbGRNb2NrRGlzcGF0Y2guY2FsbCh0aGlzKVxuICAgIHRoaXMuY2xvc2UgPSB0aGlzW2tDbG9zZV1cbiAgfVxuXG4gIGdldCBbU3ltYm9scy5rQ29ubmVjdGVkXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0Nvbm5lY3RlZF1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoZSBiYXNlIGludGVyY2VwdG9yIGZvciBtb2NraW5nIHJlcGxpZXMgZnJvbSB1bmRpY2kuXG4gICAqL1xuICBpbnRlcmNlcHQgKG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IE1vY2tJbnRlcmNlcHRvcihvcHRzLCB0aGlzW2tEaXNwYXRjaGVzXSlcbiAgfVxuXG4gIGFzeW5jIFtrQ2xvc2VdICgpIHtcbiAgICBhd2FpdCBwcm9taXNpZnkodGhpc1trT3JpZ2luYWxDbG9zZV0pKClcbiAgICB0aGlzW2tDb25uZWN0ZWRdID0gMFxuICAgIHRoaXNba01vY2tBZ2VudF1bU3ltYm9scy5rQ2xpZW50c10uZGVsZXRlKHRoaXNba09yaWdpbl0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNb2NrQ2xpZW50XG4iXSwibmFtZXMiOlsicHJvbWlzaWZ5IiwicmVxdWlyZSIsIkNsaWVudCIsImJ1aWxkTW9ja0Rpc3BhdGNoIiwia0Rpc3BhdGNoZXMiLCJrTW9ja0FnZW50Iiwia0Nsb3NlIiwia09yaWdpbmFsQ2xvc2UiLCJrT3JpZ2luIiwia09yaWdpbmFsRGlzcGF0Y2giLCJrQ29ubmVjdGVkIiwiTW9ja0ludGVyY2VwdG9yIiwiU3ltYm9scyIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiTW9ja0NsaWVudCIsImNvbnN0cnVjdG9yIiwib3JpZ2luIiwib3B0cyIsImFnZW50IiwiZGlzcGF0Y2giLCJjbG9zZSIsImJpbmQiLCJjYWxsIiwiaW50ZXJjZXB0Iiwia0NsaWVudHMiLCJkZWxldGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-errors.js":
/*!***************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/mock/mock-errors.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { UndiciError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\nclass MockNotMatchedError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, MockNotMatchedError);\n        this.name = \"MockNotMatchedError\";\n        this.message = message || \"The request does not match any registered mock dispatches\";\n        this.code = \"UND_MOCK_ERR_MOCK_NOT_MATCHED\";\n    }\n}\nmodule.exports = {\n    MockNotMatchedError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLWVycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsV0FBVyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBRWhDLE1BQU1DLDRCQUE0QkY7SUFDaENHLFlBQWFDLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBO1FBQ05DLE1BQU1DLGlCQUFpQixDQUFDLElBQUksRUFBRUo7UUFDOUIsSUFBSSxDQUFDSyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNILE9BQU8sR0FBR0EsV0FBVztRQUMxQixJQUFJLENBQUNJLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZSO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stZXJyb3JzLmpzPzI5MjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgVW5kaWNpRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcblxuY2xhc3MgTW9ja05vdE1hdGNoZWRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIE1vY2tOb3RNYXRjaGVkRXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ01vY2tOb3RNYXRjaGVkRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnVGhlIHJlcXVlc3QgZG9lcyBub3QgbWF0Y2ggYW55IHJlZ2lzdGVyZWQgbW9jayBkaXNwYXRjaGVzJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfTU9DS19FUlJfTU9DS19OT1RfTUFUQ0hFRCdcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgTW9ja05vdE1hdGNoZWRFcnJvclxufVxuIl0sIm5hbWVzIjpbIlVuZGljaUVycm9yIiwicmVxdWlyZSIsIk1vY2tOb3RNYXRjaGVkRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJFcnJvciIsImNhcHR1cmVTdGFja1RyYWNlIiwibmFtZSIsImNvZGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-interceptor.js":
/*!********************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/mock/mock-interceptor.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { getResponseData, buildKey, addMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-utils.js\");\nconst { kDispatches, kDispatchKey, kDefaultHeaders, kDefaultTrailers, kContentLength, kMockDispatch } = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-symbols.js\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\nconst { buildURL } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\n/**\n * Defines the scope API for an interceptor reply\n */ class MockScope {\n    constructor(mockDispatch){\n        this[kMockDispatch] = mockDispatch;\n    }\n    /**\n   * Delay a reply by a set amount in ms.\n   */ delay(waitInMs) {\n        if (typeof waitInMs !== \"number\" || !Number.isInteger(waitInMs) || waitInMs <= 0) {\n            throw new InvalidArgumentError(\"waitInMs must be a valid integer > 0\");\n        }\n        this[kMockDispatch].delay = waitInMs;\n        return this;\n    }\n    /**\n   * For a defined reply, never mark as consumed.\n   */ persist() {\n        this[kMockDispatch].persist = true;\n        return this;\n    }\n    /**\n   * Allow one to define a reply for a set amount of matching requests.\n   */ times(repeatTimes) {\n        if (typeof repeatTimes !== \"number\" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {\n            throw new InvalidArgumentError(\"repeatTimes must be a valid integer > 0\");\n        }\n        this[kMockDispatch].times = repeatTimes;\n        return this;\n    }\n}\n/**\n * Defines an interceptor for a Mock\n */ class MockInterceptor {\n    constructor(opts, mockDispatches){\n        if (typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"opts must be an object\");\n        }\n        if (typeof opts.path === \"undefined\") {\n            throw new InvalidArgumentError(\"opts.path must be defined\");\n        }\n        if (typeof opts.method === \"undefined\") {\n            opts.method = \"GET\";\n        }\n        // See https://github.com/nodejs/undici/issues/1245\n        // As per RFC 3986, clients are not supposed to send URI\n        // fragments to servers when they retrieve a document,\n        if (typeof opts.path === \"string\") {\n            if (opts.query) {\n                opts.path = buildURL(opts.path, opts.query);\n            } else {\n                // Matches https://github.com/nodejs/undici/blob/main/lib/fetch/index.js#L1811\n                const parsedURL = new URL(opts.path, \"data://\");\n                opts.path = parsedURL.pathname + parsedURL.search;\n            }\n        }\n        if (typeof opts.method === \"string\") {\n            opts.method = opts.method.toUpperCase();\n        }\n        this[kDispatchKey] = buildKey(opts);\n        this[kDispatches] = mockDispatches;\n        this[kDefaultHeaders] = {};\n        this[kDefaultTrailers] = {};\n        this[kContentLength] = false;\n    }\n    createMockScopeDispatchData(statusCode, data, responseOptions = {}) {\n        const responseData = getResponseData(data);\n        const contentLength = this[kContentLength] ? {\n            \"content-length\": responseData.length\n        } : {};\n        const headers = {\n            ...this[kDefaultHeaders],\n            ...contentLength,\n            ...responseOptions.headers\n        };\n        const trailers = {\n            ...this[kDefaultTrailers],\n            ...responseOptions.trailers\n        };\n        return {\n            statusCode,\n            data,\n            headers,\n            trailers\n        };\n    }\n    validateReplyParameters(statusCode, data, responseOptions) {\n        if (typeof statusCode === \"undefined\") {\n            throw new InvalidArgumentError(\"statusCode must be defined\");\n        }\n        if (typeof data === \"undefined\") {\n            throw new InvalidArgumentError(\"data must be defined\");\n        }\n        if (typeof responseOptions !== \"object\") {\n            throw new InvalidArgumentError(\"responseOptions must be an object\");\n        }\n    }\n    /**\n   * Mock an undici request with a defined reply.\n   */ reply(replyData) {\n        // Values of reply aren't available right now as they\n        // can only be available when the reply callback is invoked.\n        if (typeof replyData === \"function\") {\n            // We'll first wrap the provided callback in another function,\n            // this function will properly resolve the data from the callback\n            // when invoked.\n            const wrappedDefaultsCallback = (opts)=>{\n                // Our reply options callback contains the parameter for statusCode, data and options.\n                const resolvedData = replyData(opts);\n                // Check if it is in the right format\n                if (typeof resolvedData !== \"object\") {\n                    throw new InvalidArgumentError(\"reply options callback must return an object\");\n                }\n                const { statusCode, data = \"\", responseOptions = {} } = resolvedData;\n                this.validateReplyParameters(statusCode, data, responseOptions);\n                // Since the values can be obtained immediately we return them\n                // from this higher order function that will be resolved later.\n                return {\n                    ...this.createMockScopeDispatchData(statusCode, data, responseOptions)\n                };\n            };\n            // Add usual dispatch data, but this time set the data parameter to function that will eventually provide data.\n            const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);\n            return new MockScope(newMockDispatch);\n        }\n        // We can have either one or three parameters, if we get here,\n        // we should have 1-3 parameters. So we spread the arguments of\n        // this function to obtain the parameters, since replyData will always\n        // just be the statusCode.\n        const [statusCode, data = \"\", responseOptions = {}] = [\n            ...arguments\n        ];\n        this.validateReplyParameters(statusCode, data, responseOptions);\n        // Send in-already provided data like usual\n        const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);\n        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);\n        return new MockScope(newMockDispatch);\n    }\n    /**\n   * Mock an undici request with a defined error.\n   */ replyWithError(error) {\n        if (typeof error === \"undefined\") {\n            throw new InvalidArgumentError(\"error must be defined\");\n        }\n        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], {\n            error\n        });\n        return new MockScope(newMockDispatch);\n    }\n    /**\n   * Set default reply headers on the interceptor for subsequent replies\n   */ defaultReplyHeaders(headers) {\n        if (typeof headers === \"undefined\") {\n            throw new InvalidArgumentError(\"headers must be defined\");\n        }\n        this[kDefaultHeaders] = headers;\n        return this;\n    }\n    /**\n   * Set default reply trailers on the interceptor for subsequent replies\n   */ defaultReplyTrailers(trailers) {\n        if (typeof trailers === \"undefined\") {\n            throw new InvalidArgumentError(\"trailers must be defined\");\n        }\n        this[kDefaultTrailers] = trailers;\n        return this;\n    }\n    /**\n   * Set reply content length header for replies on the interceptor\n   */ replyContentLength() {\n        this[kContentLength] = true;\n        return this;\n    }\n}\nmodule.exports.MockInterceptor = MockInterceptor;\nmodule.exports.MockScope = MockScope;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLWludGVyY2VwdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxlQUFlLEVBQUVDLFFBQVEsRUFBRUMsZUFBZSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQy9ELE1BQU0sRUFDSkMsV0FBVyxFQUNYQyxZQUFZLEVBQ1pDLGVBQWUsRUFDZkMsZ0JBQWdCLEVBQ2hCQyxjQUFjLEVBQ2RDLGFBQWEsRUFDZCxHQUFHTixtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRU8sb0JBQW9CLEVBQUUsR0FBR1AsbUJBQU9BLENBQUM7QUFDekMsTUFBTSxFQUFFUSxRQUFRLEVBQUUsR0FBR1IsbUJBQU9BLENBQUM7QUFFN0I7O0NBRUMsR0FDRCxNQUFNUztJQUNKQyxZQUFhQyxZQUFZLENBQUU7UUFDekIsSUFBSSxDQUFDTCxjQUFjLEdBQUdLO0lBQ3hCO0lBRUE7O0dBRUMsR0FDREMsTUFBT0MsUUFBUSxFQUFFO1FBQ2YsSUFBSSxPQUFPQSxhQUFhLFlBQVksQ0FBQ0MsT0FBT0MsU0FBUyxDQUFDRixhQUFhQSxZQUFZLEdBQUc7WUFDaEYsTUFBTSxJQUFJTixxQkFBcUI7UUFDakM7UUFFQSxJQUFJLENBQUNELGNBQWMsQ0FBQ00sS0FBSyxHQUFHQztRQUM1QixPQUFPLElBQUk7SUFDYjtJQUVBOztHQUVDLEdBQ0RHLFVBQVc7UUFDVCxJQUFJLENBQUNWLGNBQWMsQ0FBQ1UsT0FBTyxHQUFHO1FBQzlCLE9BQU8sSUFBSTtJQUNiO0lBRUE7O0dBRUMsR0FDREMsTUFBT0MsV0FBVyxFQUFFO1FBQ2xCLElBQUksT0FBT0EsZ0JBQWdCLFlBQVksQ0FBQ0osT0FBT0MsU0FBUyxDQUFDRyxnQkFBZ0JBLGVBQWUsR0FBRztZQUN6RixNQUFNLElBQUlYLHFCQUFxQjtRQUNqQztRQUVBLElBQUksQ0FBQ0QsY0FBYyxDQUFDVyxLQUFLLEdBQUdDO1FBQzVC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a0M7UUFDeEIsT0FBTyxJQUFJO0lBQ2I7SUFFQTs7R0FFQyxHQUNEYSxxQkFBc0JaLFFBQVEsRUFBRTtRQUM5QixJQUFJLE9BQU9BLGFBQWEsYUFBYTtZQUNuQyxNQUFNLElBQUkvQixxQkFBcUI7UUFDakM7UUFFQSxJQUFJLENBQUNILGlCQUFpQixHQUFHa0M7UUFDekIsT0FBTyxJQUFJO0lBQ2I7SUFFQTs7R0FFQyxHQUNEYSxxQkFBc0I7UUFDcEIsSUFBSSxDQUFDOUMsZUFBZSxHQUFHO1FBQ3ZCLE9BQU8sSUFBSTtJQUNiO0FBQ0Y7QUFFQStDLDhCQUE4QixHQUFHakM7QUFDakNpQyx3QkFBd0IsR0FBRzNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1maWdodGVyLWFjYWRlbXkvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLWludGVyY2VwdG9yLmpzP2Y0MjciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgZ2V0UmVzcG9uc2VEYXRhLCBidWlsZEtleSwgYWRkTW9ja0Rpc3BhdGNoIH0gPSByZXF1aXJlKCcuL21vY2stdXRpbHMnKVxuY29uc3Qge1xuICBrRGlzcGF0Y2hlcyxcbiAga0Rpc3BhdGNoS2V5LFxuICBrRGVmYXVsdEhlYWRlcnMsXG4gIGtEZWZhdWx0VHJhaWxlcnMsXG4gIGtDb250ZW50TGVuZ3RoLFxuICBrTW9ja0Rpc3BhdGNoXG59ID0gcmVxdWlyZSgnLi9tb2NrLXN5bWJvbHMnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgeyBidWlsZFVSTCB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBzY29wZSBBUEkgZm9yIGFuIGludGVyY2VwdG9yIHJlcGx5XG4gKi9cbmNsYXNzIE1vY2tTY29wZSB7XG4gIGNvbnN0cnVjdG9yIChtb2NrRGlzcGF0Y2gpIHtcbiAgICB0aGlzW2tNb2NrRGlzcGF0Y2hdID0gbW9ja0Rpc3BhdGNoXG4gIH1cblxuICAvKipcbiAgICogRGVsYXkgYSByZXBseSBieSBhIHNldCBhbW91bnQgaW4gbXMuXG4gICAqL1xuICBkZWxheSAod2FpdEluTXMpIHtcbiAgICBpZiAodHlwZW9mIHdhaXRJbk1zICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcih3YWl0SW5NcykgfHwgd2FpdEluTXMgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd3YWl0SW5NcyBtdXN0IGJlIGEgdmFsaWQgaW50ZWdlciA+IDAnKVxuICAgIH1cblxuICAgIHRoaXNba01vY2tEaXNwYXRjaF0uZGVsYXkgPSB3YWl0SW5Nc1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogRm9yIGEgZGVmaW5lZCByZXBseSwgbmV2ZXIgbWFyayBhcyBjb25zdW1lZC5cbiAgICovXG4gIHBlcnNpc3QgKCkge1xuICAgIHRoaXNba01vY2tEaXNwYXRjaF0ucGVyc2lzdCA9IHRydWVcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93IG9uZSB0byBkZWZpbmUgYSByZXBseSBmb3IgYSBzZXQgYW1vdW50IG9mIG1hdGNoaW5nIHJlcXVlc3RzLlxuICAgKi9cbiAgdGltZXMgKHJlcGVhdFRpbWVzKSB7XG4gICAgaWYgKHR5cGVvZiByZXBlYXRUaW1lcyAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIocmVwZWF0VGltZXMpIHx8IHJlcGVhdFRpbWVzIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigncmVwZWF0VGltZXMgbXVzdCBiZSBhIHZhbGlkIGludGVnZXIgPiAwJylcbiAgICB9XG5cbiAgICB0aGlzW2tNb2NrRGlzcGF0Y2hdLnRpbWVzID0gcmVwZWF0VGltZXNcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbi8qKlxuICogRGVmaW5lcyBhbiBpbnRlcmNlcHRvciBmb3IgYSBNb2NrXG4gKi9cbmNsYXNzIE1vY2tJbnRlcmNlcHRvciB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBtb2NrRGlzcGF0Y2hlcykge1xuICAgIGlmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignb3B0cyBtdXN0IGJlIGFuIG9iamVjdCcpXG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5wYXRoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRzLnBhdGggbXVzdCBiZSBkZWZpbmVkJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLm1ldGhvZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9wdHMubWV0aG9kID0gJ0dFVCdcbiAgICB9XG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xMjQ1XG4gICAgLy8gQXMgcGVyIFJGQyAzOTg2LCBjbGllbnRzIGFyZSBub3Qgc3VwcG9zZWQgdG8gc2VuZCBVUklcbiAgICAvLyBmcmFnbWVudHMgdG8gc2VydmVycyB3aGVuIHRoZXkgcmV0cmlldmUgYSBkb2N1bWVudCxcbiAgICBpZiAodHlwZW9mIG9wdHMucGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChvcHRzLnF1ZXJ5KSB7XG4gICAgICAgIG9wdHMucGF0aCA9IGJ1aWxkVVJMKG9wdHMucGF0aCwgb3B0cy5xdWVyeSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1hdGNoZXMgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvYmxvYi9tYWluL2xpYi9mZXRjaC9pbmRleC5qcyNMMTgxMVxuICAgICAgICBjb25zdCBwYXJzZWRVUkwgPSBuZXcgVVJMKG9wdHMucGF0aCwgJ2RhdGE6Ly8nKVxuICAgICAgICBvcHRzLnBhdGggPSBwYXJzZWRVUkwucGF0aG5hbWUgKyBwYXJzZWRVUkwuc2VhcmNoXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5tZXRob2QgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRzLm1ldGhvZCA9IG9wdHMubWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICB9XG5cbiAgICB0aGlzW2tEaXNwYXRjaEtleV0gPSBidWlsZEtleShvcHRzKVxuICAgIHRoaXNba0Rpc3BhdGNoZXNdID0gbW9ja0Rpc3BhdGNoZXNcbiAgICB0aGlzW2tEZWZhdWx0SGVhZGVyc10gPSB7fVxuICAgIHRoaXNba0RlZmF1bHRUcmFpbGVyc10gPSB7fVxuICAgIHRoaXNba0NvbnRlbnRMZW5ndGhdID0gZmFsc2VcbiAgfVxuXG4gIGNyZWF0ZU1vY2tTY29wZURpc3BhdGNoRGF0YSAoc3RhdHVzQ29kZSwgZGF0YSwgcmVzcG9uc2VPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXNwb25zZURhdGEgPSBnZXRSZXNwb25zZURhdGEoZGF0YSlcbiAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gdGhpc1trQ29udGVudExlbmd0aF0gPyB7ICdjb250ZW50LWxlbmd0aCc6IHJlc3BvbnNlRGF0YS5sZW5ndGggfSA6IHt9XG4gICAgY29uc3QgaGVhZGVycyA9IHsgLi4udGhpc1trRGVmYXVsdEhlYWRlcnNdLCAuLi5jb250ZW50TGVuZ3RoLCAuLi5yZXNwb25zZU9wdGlvbnMuaGVhZGVycyB9XG4gICAgY29uc3QgdHJhaWxlcnMgPSB7IC4uLnRoaXNba0RlZmF1bHRUcmFpbGVyc10sIC4uLnJlc3BvbnNlT3B0aW9ucy50cmFpbGVycyB9XG5cbiAgICByZXR1cm4geyBzdGF0dXNDb2RlLCBkYXRhLCBoZWFkZXJzLCB0cmFpbGVycyB9XG4gIH1cblxuICB2YWxpZGF0ZVJlcGx5UGFyYW1ldGVycyAoc3RhdHVzQ29kZSwgZGF0YSwgcmVzcG9uc2VPcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBzdGF0dXNDb2RlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdzdGF0dXNDb2RlIG11c3QgYmUgZGVmaW5lZCcpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignZGF0YSBtdXN0IGJlIGRlZmluZWQnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlT3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigncmVzcG9uc2VPcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0JylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTW9jayBhbiB1bmRpY2kgcmVxdWVzdCB3aXRoIGEgZGVmaW5lZCByZXBseS5cbiAgICovXG4gIHJlcGx5IChyZXBseURhdGEpIHtcbiAgICAvLyBWYWx1ZXMgb2YgcmVwbHkgYXJlbid0IGF2YWlsYWJsZSByaWdodCBub3cgYXMgdGhleVxuICAgIC8vIGNhbiBvbmx5IGJlIGF2YWlsYWJsZSB3aGVuIHRoZSByZXBseSBjYWxsYmFjayBpcyBpbnZva2VkLlxuICAgIGlmICh0eXBlb2YgcmVwbHlEYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBXZSdsbCBmaXJzdCB3cmFwIHRoZSBwcm92aWRlZCBjYWxsYmFjayBpbiBhbm90aGVyIGZ1bmN0aW9uLFxuICAgICAgLy8gdGhpcyBmdW5jdGlvbiB3aWxsIHByb3Blcmx5IHJlc29sdmUgdGhlIGRhdGEgZnJvbSB0aGUgY2FsbGJhY2tcbiAgICAgIC8vIHdoZW4gaW52b2tlZC5cbiAgICAgIGNvbnN0IHdyYXBwZWREZWZhdWx0c0NhbGxiYWNrID0gKG9wdHMpID0+IHtcbiAgICAgICAgLy8gT3VyIHJlcGx5IG9wdGlvbnMgY2FsbGJhY2sgY29udGFpbnMgdGhlIHBhcmFtZXRlciBmb3Igc3RhdHVzQ29kZSwgZGF0YSBhbmQgb3B0aW9ucy5cbiAgICAgICAgY29uc3QgcmVzb2x2ZWREYXRhID0gcmVwbHlEYXRhKG9wdHMpXG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQgaXMgaW4gdGhlIHJpZ2h0IGZvcm1hdFxuICAgICAgICBpZiAodHlwZW9mIHJlc29sdmVkRGF0YSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3JlcGx5IG9wdGlvbnMgY2FsbGJhY2sgbXVzdCByZXR1cm4gYW4gb2JqZWN0JylcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgc3RhdHVzQ29kZSwgZGF0YSA9ICcnLCByZXNwb25zZU9wdGlvbnMgPSB7fSB9ID0gcmVzb2x2ZWREYXRhXG4gICAgICAgIHRoaXMudmFsaWRhdGVSZXBseVBhcmFtZXRlcnMoc3RhdHVzQ29kZSwgZGF0YSwgcmVzcG9uc2VPcHRpb25zKVxuICAgICAgICAvLyBTaW5jZSB0aGUgdmFsdWVzIGNhbiBiZSBvYnRhaW5lZCBpbW1lZGlhdGVseSB3ZSByZXR1cm4gdGhlbVxuICAgICAgICAvLyBmcm9tIHRoaXMgaGlnaGVyIG9yZGVyIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSByZXNvbHZlZCBsYXRlci5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi50aGlzLmNyZWF0ZU1vY2tTY29wZURpc3BhdGNoRGF0YShzdGF0dXNDb2RlLCBkYXRhLCByZXNwb25zZU9wdGlvbnMpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHVzdWFsIGRpc3BhdGNoIGRhdGEsIGJ1dCB0aGlzIHRpbWUgc2V0IHRoZSBkYXRhIHBhcmFtZXRlciB0byBmdW5jdGlvbiB0aGF0IHdpbGwgZXZlbnR1YWxseSBwcm92aWRlIGRhdGEuXG4gICAgICBjb25zdCBuZXdNb2NrRGlzcGF0Y2ggPSBhZGRNb2NrRGlzcGF0Y2godGhpc1trRGlzcGF0Y2hlc10sIHRoaXNba0Rpc3BhdGNoS2V5XSwgd3JhcHBlZERlZmF1bHRzQ2FsbGJhY2spXG4gICAgICByZXR1cm4gbmV3IE1vY2tTY29wZShuZXdNb2NrRGlzcGF0Y2gpXG4gICAgfVxuXG4gICAgLy8gV2UgY2FuIGhhdmUgZWl0aGVyIG9uZSBvciB0aHJlZSBwYXJhbWV0ZXJzLCBpZiB3ZSBnZXQgaGVyZSxcbiAgICAvLyB3ZSBzaG91bGQgaGF2ZSAxLTMgcGFyYW1ldGVycy4gU28gd2Ugc3ByZWFkIHRoZSBhcmd1bWVudHMgb2ZcbiAgICAvLyB0aGlzIGZ1bmN0aW9uIHRvIG9idGFpbiB0aGUgcGFyYW1ldGVycywgc2luY2UgcmVwbHlEYXRhIHdpbGwgYWx3YXlzXG4gICAgLy8ganVzdCBiZSB0aGUgc3RhdHVzQ29kZS5cbiAgICBjb25zdCBbc3RhdHVzQ29kZSwgZGF0YSA9ICcnLCByZXNwb25zZU9wdGlvbnMgPSB7fV0gPSBbLi4uYXJndW1lbnRzXVxuICAgIHRoaXMudmFsaWRhdGVSZXBseVBhcmFtZXRlcnMoc3RhdHVzQ29kZSwgZGF0YSwgcmVzcG9uc2VPcHRpb25zKVxuXG4gICAgLy8gU2VuZCBpbi1hbHJlYWR5IHByb3ZpZGVkIGRhdGEgbGlrZSB1c3VhbFxuICAgIGNvbnN0IGRpc3BhdGNoRGF0YSA9IHRoaXMuY3JlYXRlTW9ja1Njb3BlRGlzcGF0Y2hEYXRhKHN0YXR1c0NvZGUsIGRhdGEsIHJlc3BvbnNlT3B0aW9ucylcbiAgICBjb25zdCBuZXdNb2NrRGlzcGF0Y2ggPSBhZGRNb2NrRGlzcGF0Y2godGhpc1trRGlzcGF0Y2hlc10sIHRoaXNba0Rpc3BhdGNoS2V5XSwgZGlzcGF0Y2hEYXRhKVxuICAgIHJldHVybiBuZXcgTW9ja1Njb3BlKG5ld01vY2tEaXNwYXRjaClcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2NrIGFuIHVuZGljaSByZXF1ZXN0IHdpdGggYSBkZWZpbmVkIGVycm9yLlxuICAgKi9cbiAgcmVwbHlXaXRoRXJyb3IgKGVycm9yKSB7XG4gICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignZXJyb3IgbXVzdCBiZSBkZWZpbmVkJylcbiAgICB9XG5cbiAgICBjb25zdCBuZXdNb2NrRGlzcGF0Y2ggPSBhZGRNb2NrRGlzcGF0Y2godGhpc1trRGlzcGF0Y2hlc10sIHRoaXNba0Rpc3BhdGNoS2V5XSwgeyBlcnJvciB9KVxuICAgIHJldHVybiBuZXcgTW9ja1Njb3BlKG5ld01vY2tEaXNwYXRjaClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgZGVmYXVsdCByZXBseSBoZWFkZXJzIG9uIHRoZSBpbnRlcmNlcHRvciBmb3Igc3Vic2VxdWVudCByZXBsaWVzXG4gICAqL1xuICBkZWZhdWx0UmVwbHlIZWFkZXJzIChoZWFkZXJzKSB7XG4gICAgaWYgKHR5cGVvZiBoZWFkZXJzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdoZWFkZXJzIG11c3QgYmUgZGVmaW5lZCcpXG4gICAgfVxuXG4gICAgdGhpc1trRGVmYXVsdEhlYWRlcnNdID0gaGVhZGVyc1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2V0IGRlZmF1bHQgcmVwbHkgdHJhaWxlcnMgb24gdGhlIGludGVyY2VwdG9yIGZvciBzdWJzZXF1ZW50IHJlcGxpZXNcbiAgICovXG4gIGRlZmF1bHRSZXBseVRyYWlsZXJzICh0cmFpbGVycykge1xuICAgIGlmICh0eXBlb2YgdHJhaWxlcnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3RyYWlsZXJzIG11c3QgYmUgZGVmaW5lZCcpXG4gICAgfVxuXG4gICAgdGhpc1trRGVmYXVsdFRyYWlsZXJzXSA9IHRyYWlsZXJzXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcmVwbHkgY29udGVudCBsZW5ndGggaGVhZGVyIGZvciByZXBsaWVzIG9uIHRoZSBpbnRlcmNlcHRvclxuICAgKi9cbiAgcmVwbHlDb250ZW50TGVuZ3RoICgpIHtcbiAgICB0aGlzW2tDb250ZW50TGVuZ3RoXSA9IHRydWVcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLk1vY2tJbnRlcmNlcHRvciA9IE1vY2tJbnRlcmNlcHRvclxubW9kdWxlLmV4cG9ydHMuTW9ja1Njb3BlID0gTW9ja1Njb3BlXG4iXSwibmFtZXMiOlsiZ2V0UmVzcG9uc2VEYXRhIiwiYnVpbGRLZXkiLCJhZGRNb2NrRGlzcGF0Y2giLCJyZXF1aXJlIiwia0Rpc3BhdGNoZXMiLCJrRGlzcGF0Y2hLZXkiLCJrRGVmYXVsdEhlYWRlcnMiLCJrRGVmYXVsdFRyYWlsZXJzIiwia0NvbnRlbnRMZW5ndGgiLCJrTW9ja0Rpc3BhdGNoIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJidWlsZFVSTCIsIk1vY2tTY29wZSIsImNvbnN0cnVjdG9yIiwibW9ja0Rpc3BhdGNoIiwiZGVsYXkiLCJ3YWl0SW5NcyIsIk51bWJlciIsImlzSW50ZWdlciIsInBlcnNpc3QiLCJ0aW1lcyIsInJlcGVhdFRpbWVzIiwiTW9ja0ludGVyY2VwdG9yIiwib3B0cyIsIm1vY2tEaXNwYXRjaGVzIiwicGF0aCIsIm1ldGhvZCIsInF1ZXJ5IiwicGFyc2VkVVJMIiwiVVJMIiwicGF0aG5hbWUiLCJzZWFyY2giLCJ0b1VwcGVyQ2FzZSIsImNyZWF0ZU1vY2tTY29wZURpc3BhdGNoRGF0YSIsInN0YXR1c0NvZGUiLCJkYXRhIiwicmVzcG9uc2VPcHRpb25zIiwicmVzcG9uc2VEYXRhIiwiY29udGVudExlbmd0aCIsImxlbmd0aCIsImhlYWRlcnMiLCJ0cmFpbGVycyIsInZhbGlkYXRlUmVwbHlQYXJhbWV0ZXJzIiwicmVwbHkiLCJyZXBseURhdGEiLCJ3cmFwcGVkRGVmYXVsdHNDYWxsYmFjayIsInJlc29sdmVkRGF0YSIsIm5ld01vY2tEaXNwYXRjaCIsImFyZ3VtZW50cyIsImRpc3BhdGNoRGF0YSIsInJlcGx5V2l0aEVycm9yIiwiZXJyb3IiLCJkZWZhdWx0UmVwbHlIZWFkZXJzIiwiZGVmYXVsdFJlcGx5VHJhaWxlcnMiLCJyZXBseUNvbnRlbnRMZW5ndGgiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-interceptor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-pool.js":
/*!*************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/mock/mock-pool.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst Pool = __webpack_require__(/*! ../pool */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/pool.js\");\nconst { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-utils.js\");\nconst { kDispatches, kMockAgent, kClose, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-symbols.js\");\nconst { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-interceptor.js\");\nconst Symbols = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\n/**\n * MockPool provides an API that extends the Pool to influence the mockDispatches.\n */ class MockPool extends Pool {\n    constructor(origin, opts){\n        super(origin, opts);\n        if (!opts || !opts.agent || typeof opts.agent.dispatch !== \"function\") {\n            throw new InvalidArgumentError(\"Argument opts.agent must implement Agent\");\n        }\n        this[kMockAgent] = opts.agent;\n        this[kOrigin] = origin;\n        this[kDispatches] = [];\n        this[kConnected] = 1;\n        this[kOriginalDispatch] = this.dispatch;\n        this[kOriginalClose] = this.close.bind(this);\n        this.dispatch = buildMockDispatch.call(this);\n        this.close = this[kClose];\n    }\n    get [Symbols.kConnected]() {\n        return this[kConnected];\n    }\n    /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */ intercept(opts) {\n        return new MockInterceptor(opts, this[kDispatches]);\n    }\n    async [kClose]() {\n        await promisify(this[kOriginalClose])();\n        this[kConnected] = 0;\n        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);\n    }\n}\nmodule.exports = MockPool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLXBvb2wuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFNBQVMsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUM5QixNQUFNQyxPQUFPRCxtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQUVFLGlCQUFpQixFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBQ3RDLE1BQU0sRUFDSkcsV0FBVyxFQUNYQyxVQUFVLEVBQ1ZDLE1BQU0sRUFDTkMsY0FBYyxFQUNkQyxPQUFPLEVBQ1BDLGlCQUFpQixFQUNqQkMsVUFBVSxFQUNYLEdBQUdULG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFVSxlQUFlLEVBQUUsR0FBR1YsbUJBQU9BLENBQUM7QUFDcEMsTUFBTVcsVUFBVVgsbUJBQU9BLENBQUM7QUFDeEIsTUFBTSxFQUFFWSxvQkFBb0IsRUFBRSxHQUFHWixtQkFBT0EsQ0FBQztBQUV6Qzs7Q0FFQyxHQUNELE1BQU1hLGlCQUFpQlo7SUFDckJhLFlBQWFDLE1BQU0sRUFBRUMsSUFBSSxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0QsUUFBUUM7UUFFZCxJQUFJLENBQUNBLFFBQVEsQ0FBQ0EsS0FBS0MsS0FBSyxJQUFJLE9BQU9ELEtBQUtDLEtBQUssQ0FBQ0MsUUFBUSxLQUFLLFlBQVk7WUFDckUsTUFBTSxJQUFJTixxQkFBcUI7UUFDakM7UUFFQSxJQUFJLENBQUNSLFdBQVcsR0FBR1ksS0FBS0MsS0FBSztRQUM3QixJQUFJLENBQUNWLFFBQVEsR0FBR1E7UUFDaEIsSUFBSSxDQUFDWixZQUFZLEdBQUcsRUFBRTtRQUN0QixJQUFJLENBQUNNLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNELGtCQUFrQixHQUFHLElBQUksQ0FBQ1UsUUFBUTtRQUN2QyxJQUFJLENBQUNaLGVBQWUsR0FBRyxJQUFJLENBQUNhLEtBQUssQ0FBQ0MsSUFBSSxDQUFDLElBQUk7UUFFM0MsSUFBSSxDQUFDRixRQUFRLEdBQUdoQixrQkFBa0JtQixJQUFJLENBQUMsSUFBSTtRQUMzQyxJQUFJLENBQUNGLEtBQUssR0FBRyxJQUFJLENBQUNkLE9BQU87SUFDM0I7SUFFQSxJQUFJLENBQUNNLFFBQVFGLFVBQVUsQ0FBQyxHQUFJO1FBQzFCLE9BQU8sSUFBSSxDQUFDQSxXQUFXO0lBQ3pCO0lBRUE7O0dBRUMsR0FDRGEsVUFBV04sSUFBSSxFQUFFO1FBQ2YsT0FBTyxJQUFJTixnQkFBZ0JNLE1BQU0sSUFBSSxDQUFDYixZQUFZO0lBQ3BEO0lBRUEsTUFBTSxDQUFDRSxPQUFPLEdBQUk7UUFDaEIsTUFBTU4sVUFBVSxJQUFJLENBQUNPLGVBQWU7UUFDcEMsSUFBSSxDQUFDRyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDTCxXQUFXLENBQUNPLFFBQVFZLFFBQVEsQ0FBQyxDQUFDQyxNQUFNLENBQUMsSUFBSSxDQUFDakIsUUFBUTtJQUN6RDtBQUNGO0FBRUFrQixPQUFPQyxPQUFPLEdBQUdiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1maWdodGVyLWFjYWRlbXkvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLXBvb2wuanM/ZTZhOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ3V0aWwnKVxuY29uc3QgUG9vbCA9IHJlcXVpcmUoJy4uL3Bvb2wnKVxuY29uc3QgeyBidWlsZE1vY2tEaXNwYXRjaCB9ID0gcmVxdWlyZSgnLi9tb2NrLXV0aWxzJylcbmNvbnN0IHtcbiAga0Rpc3BhdGNoZXMsXG4gIGtNb2NrQWdlbnQsXG4gIGtDbG9zZSxcbiAga09yaWdpbmFsQ2xvc2UsXG4gIGtPcmlnaW4sXG4gIGtPcmlnaW5hbERpc3BhdGNoLFxuICBrQ29ubmVjdGVkXG59ID0gcmVxdWlyZSgnLi9tb2NrLXN5bWJvbHMnKVxuY29uc3QgeyBNb2NrSW50ZXJjZXB0b3IgfSA9IHJlcXVpcmUoJy4vbW9jay1pbnRlcmNlcHRvcicpXG5jb25zdCBTeW1ib2xzID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcblxuLyoqXG4gKiBNb2NrUG9vbCBwcm92aWRlcyBhbiBBUEkgdGhhdCBleHRlbmRzIHRoZSBQb29sIHRvIGluZmx1ZW5jZSB0aGUgbW9ja0Rpc3BhdGNoZXMuXG4gKi9cbmNsYXNzIE1vY2tQb29sIGV4dGVuZHMgUG9vbCB7XG4gIGNvbnN0cnVjdG9yIChvcmlnaW4sIG9wdHMpIHtcbiAgICBzdXBlcihvcmlnaW4sIG9wdHMpXG5cbiAgICBpZiAoIW9wdHMgfHwgIW9wdHMuYWdlbnQgfHwgdHlwZW9mIG9wdHMuYWdlbnQuZGlzcGF0Y2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignQXJndW1lbnQgb3B0cy5hZ2VudCBtdXN0IGltcGxlbWVudCBBZ2VudCcpXG4gICAgfVxuXG4gICAgdGhpc1trTW9ja0FnZW50XSA9IG9wdHMuYWdlbnRcbiAgICB0aGlzW2tPcmlnaW5dID0gb3JpZ2luXG4gICAgdGhpc1trRGlzcGF0Y2hlc10gPSBbXVxuICAgIHRoaXNba0Nvbm5lY3RlZF0gPSAxXG4gICAgdGhpc1trT3JpZ2luYWxEaXNwYXRjaF0gPSB0aGlzLmRpc3BhdGNoXG4gICAgdGhpc1trT3JpZ2luYWxDbG9zZV0gPSB0aGlzLmNsb3NlLmJpbmQodGhpcylcblxuICAgIHRoaXMuZGlzcGF0Y2ggPSBidWlsZE1vY2tEaXNwYXRjaC5jYWxsKHRoaXMpXG4gICAgdGhpcy5jbG9zZSA9IHRoaXNba0Nsb3NlXVxuICB9XG5cbiAgZ2V0IFtTeW1ib2xzLmtDb25uZWN0ZWRdICgpIHtcbiAgICByZXR1cm4gdGhpc1trQ29ubmVjdGVkXVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgdGhlIGJhc2UgaW50ZXJjZXB0b3IgZm9yIG1vY2tpbmcgcmVwbGllcyBmcm9tIHVuZGljaS5cbiAgICovXG4gIGludGVyY2VwdCAob3B0cykge1xuICAgIHJldHVybiBuZXcgTW9ja0ludGVyY2VwdG9yKG9wdHMsIHRoaXNba0Rpc3BhdGNoZXNdKVxuICB9XG5cbiAgYXN5bmMgW2tDbG9zZV0gKCkge1xuICAgIGF3YWl0IHByb21pc2lmeSh0aGlzW2tPcmlnaW5hbENsb3NlXSkoKVxuICAgIHRoaXNba0Nvbm5lY3RlZF0gPSAwXG4gICAgdGhpc1trTW9ja0FnZW50XVtTeW1ib2xzLmtDbGllbnRzXS5kZWxldGUodGhpc1trT3JpZ2luXSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vY2tQb29sXG4iXSwibmFtZXMiOlsicHJvbWlzaWZ5IiwicmVxdWlyZSIsIlBvb2wiLCJidWlsZE1vY2tEaXNwYXRjaCIsImtEaXNwYXRjaGVzIiwia01vY2tBZ2VudCIsImtDbG9zZSIsImtPcmlnaW5hbENsb3NlIiwia09yaWdpbiIsImtPcmlnaW5hbERpc3BhdGNoIiwia0Nvbm5lY3RlZCIsIk1vY2tJbnRlcmNlcHRvciIsIlN5bWJvbHMiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIk1vY2tQb29sIiwiY29uc3RydWN0b3IiLCJvcmlnaW4iLCJvcHRzIiwiYWdlbnQiLCJkaXNwYXRjaCIsImNsb3NlIiwiYmluZCIsImNhbGwiLCJpbnRlcmNlcHQiLCJrQ2xpZW50cyIsImRlbGV0ZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-pool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-symbols.js":
/*!****************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/mock/mock-symbols.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    kAgent: Symbol(\"agent\"),\n    kOptions: Symbol(\"options\"),\n    kFactory: Symbol(\"factory\"),\n    kDispatches: Symbol(\"dispatches\"),\n    kDispatchKey: Symbol(\"dispatch key\"),\n    kDefaultHeaders: Symbol(\"default headers\"),\n    kDefaultTrailers: Symbol(\"default trailers\"),\n    kContentLength: Symbol(\"content length\"),\n    kMockAgent: Symbol(\"mock agent\"),\n    kMockAgentSet: Symbol(\"mock agent set\"),\n    kMockAgentGet: Symbol(\"mock agent get\"),\n    kMockDispatch: Symbol(\"mock dispatch\"),\n    kClose: Symbol(\"close\"),\n    kOriginalClose: Symbol(\"original agent close\"),\n    kOrigin: Symbol(\"origin\"),\n    kIsMockActive: Symbol(\"is mock active\"),\n    kNetConnect: Symbol(\"net connect\"),\n    kGetNetConnect: Symbol(\"get net connect\"),\n    kConnected: Symbol(\"connected\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLXN5bWJvbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZDLFFBQVFDLE9BQU87SUFDZkMsVUFBVUQsT0FBTztJQUNqQkUsVUFBVUYsT0FBTztJQUNqQkcsYUFBYUgsT0FBTztJQUNwQkksY0FBY0osT0FBTztJQUNyQkssaUJBQWlCTCxPQUFPO0lBQ3hCTSxrQkFBa0JOLE9BQU87SUFDekJPLGdCQUFnQlAsT0FBTztJQUN2QlEsWUFBWVIsT0FBTztJQUNuQlMsZUFBZVQsT0FBTztJQUN0QlUsZUFBZVYsT0FBTztJQUN0QlcsZUFBZVgsT0FBTztJQUN0QlksUUFBUVosT0FBTztJQUNmYSxnQkFBZ0JiLE9BQU87SUFDdkJjLFNBQVNkLE9BQU87SUFDaEJlLGVBQWVmLE9BQU87SUFDdEJnQixhQUFhaEIsT0FBTztJQUNwQmlCLGdCQUFnQmpCLE9BQU87SUFDdkJrQixZQUFZbEIsT0FBTztBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay1zeW1ib2xzLmpzP2NlMzciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrQWdlbnQ6IFN5bWJvbCgnYWdlbnQnKSxcbiAga09wdGlvbnM6IFN5bWJvbCgnb3B0aW9ucycpLFxuICBrRmFjdG9yeTogU3ltYm9sKCdmYWN0b3J5JyksXG4gIGtEaXNwYXRjaGVzOiBTeW1ib2woJ2Rpc3BhdGNoZXMnKSxcbiAga0Rpc3BhdGNoS2V5OiBTeW1ib2woJ2Rpc3BhdGNoIGtleScpLFxuICBrRGVmYXVsdEhlYWRlcnM6IFN5bWJvbCgnZGVmYXVsdCBoZWFkZXJzJyksXG4gIGtEZWZhdWx0VHJhaWxlcnM6IFN5bWJvbCgnZGVmYXVsdCB0cmFpbGVycycpLFxuICBrQ29udGVudExlbmd0aDogU3ltYm9sKCdjb250ZW50IGxlbmd0aCcpLFxuICBrTW9ja0FnZW50OiBTeW1ib2woJ21vY2sgYWdlbnQnKSxcbiAga01vY2tBZ2VudFNldDogU3ltYm9sKCdtb2NrIGFnZW50IHNldCcpLFxuICBrTW9ja0FnZW50R2V0OiBTeW1ib2woJ21vY2sgYWdlbnQgZ2V0JyksXG4gIGtNb2NrRGlzcGF0Y2g6IFN5bWJvbCgnbW9jayBkaXNwYXRjaCcpLFxuICBrQ2xvc2U6IFN5bWJvbCgnY2xvc2UnKSxcbiAga09yaWdpbmFsQ2xvc2U6IFN5bWJvbCgnb3JpZ2luYWwgYWdlbnQgY2xvc2UnKSxcbiAga09yaWdpbjogU3ltYm9sKCdvcmlnaW4nKSxcbiAga0lzTW9ja0FjdGl2ZTogU3ltYm9sKCdpcyBtb2NrIGFjdGl2ZScpLFxuICBrTmV0Q29ubmVjdDogU3ltYm9sKCduZXQgY29ubmVjdCcpLFxuICBrR2V0TmV0Q29ubmVjdDogU3ltYm9sKCdnZXQgbmV0IGNvbm5lY3QnKSxcbiAga0Nvbm5lY3RlZDogU3ltYm9sKCdjb25uZWN0ZWQnKVxufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJrQWdlbnQiLCJTeW1ib2wiLCJrT3B0aW9ucyIsImtGYWN0b3J5Iiwia0Rpc3BhdGNoZXMiLCJrRGlzcGF0Y2hLZXkiLCJrRGVmYXVsdEhlYWRlcnMiLCJrRGVmYXVsdFRyYWlsZXJzIiwia0NvbnRlbnRMZW5ndGgiLCJrTW9ja0FnZW50Iiwia01vY2tBZ2VudFNldCIsImtNb2NrQWdlbnRHZXQiLCJrTW9ja0Rpc3BhdGNoIiwia0Nsb3NlIiwia09yaWdpbmFsQ2xvc2UiLCJrT3JpZ2luIiwia0lzTW9ja0FjdGl2ZSIsImtOZXRDb25uZWN0Iiwia0dldE5ldENvbm5lY3QiLCJrQ29ubmVjdGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-utils.js":
/*!**************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/mock/mock-utils.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { MockNotMatchedError } = __webpack_require__(/*! ./mock-errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-errors.js\");\nconst { kDispatches, kMockAgent, kOriginalDispatch, kOrigin, kGetNetConnect } = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-symbols.js\");\nconst { buildURL, nop } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst { STATUS_CODES } = __webpack_require__(/*! http */ \"http\");\nconst { types: { isPromise } } = __webpack_require__(/*! util */ \"util\");\nfunction matchValue(match, value) {\n    if (typeof match === \"string\") {\n        return match === value;\n    }\n    if (match instanceof RegExp) {\n        return match.test(value);\n    }\n    if (typeof match === \"function\") {\n        return match(value) === true;\n    }\n    return false;\n}\nfunction lowerCaseEntries(headers) {\n    return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue])=>{\n        return [\n            headerName.toLocaleLowerCase(),\n            headerValue\n        ];\n    }));\n}\n/**\n * @param {import('../../index').Headers|string[]|Record<string, string>} headers\n * @param {string} key\n */ function getHeaderByName(headers, key) {\n    if (Array.isArray(headers)) {\n        for(let i = 0; i < headers.length; i += 2){\n            if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {\n                return headers[i + 1];\n            }\n        }\n        return undefined;\n    } else if (typeof headers.get === \"function\") {\n        return headers.get(key);\n    } else {\n        return lowerCaseEntries(headers)[key.toLocaleLowerCase()];\n    }\n}\n/** @param {string[]} headers */ function buildHeadersFromArray(headers) {\n    const clone = headers.slice();\n    const entries = [];\n    for(let index = 0; index < clone.length; index += 2){\n        entries.push([\n            clone[index],\n            clone[index + 1]\n        ]);\n    }\n    return Object.fromEntries(entries);\n}\nfunction matchHeaders(mockDispatch, headers) {\n    if (typeof mockDispatch.headers === \"function\") {\n        if (Array.isArray(headers)) {\n            headers = buildHeadersFromArray(headers);\n        }\n        return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {});\n    }\n    if (typeof mockDispatch.headers === \"undefined\") {\n        return true;\n    }\n    if (typeof headers !== \"object\" || typeof mockDispatch.headers !== \"object\") {\n        return false;\n    }\n    for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)){\n        const headerValue = getHeaderByName(headers, matchHeaderName);\n        if (!matchValue(matchHeaderValue, headerValue)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction safeUrl(path) {\n    if (typeof path !== \"string\") {\n        return path;\n    }\n    const pathSegments = path.split(\"?\");\n    if (pathSegments.length !== 2) {\n        return path;\n    }\n    const qp = new URLSearchParams(pathSegments.pop());\n    qp.sort();\n    return [\n        ...pathSegments,\n        qp.toString()\n    ].join(\"?\");\n}\nfunction matchKey(mockDispatch, { path, method, body, headers }) {\n    const pathMatch = matchValue(mockDispatch.path, path);\n    const methodMatch = matchValue(mockDispatch.method, method);\n    const bodyMatch = typeof mockDispatch.body !== \"undefined\" ? matchValue(mockDispatch.body, body) : true;\n    const headersMatch = matchHeaders(mockDispatch, headers);\n    return pathMatch && methodMatch && bodyMatch && headersMatch;\n}\nfunction getResponseData(data) {\n    if (Buffer.isBuffer(data)) {\n        return data;\n    } else if (typeof data === \"object\") {\n        return JSON.stringify(data);\n    } else {\n        return data.toString();\n    }\n}\nfunction getMockDispatch(mockDispatches, key) {\n    const basePath = key.query ? buildURL(key.path, key.query) : key.path;\n    const resolvedPath = typeof basePath === \"string\" ? safeUrl(basePath) : basePath;\n    // Match path\n    let matchedMockDispatches = mockDispatches.filter(({ consumed })=>!consumed).filter(({ path })=>matchValue(safeUrl(path), resolvedPath));\n    if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);\n    }\n    // Match method\n    matchedMockDispatches = matchedMockDispatches.filter(({ method })=>matchValue(method, key.method));\n    if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);\n    }\n    // Match body\n    matchedMockDispatches = matchedMockDispatches.filter(({ body })=>typeof body !== \"undefined\" ? matchValue(body, key.body) : true);\n    if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);\n    }\n    // Match headers\n    matchedMockDispatches = matchedMockDispatches.filter((mockDispatch)=>matchHeaders(mockDispatch, key.headers));\n    if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === \"object\" ? JSON.stringify(key.headers) : key.headers}'`);\n    }\n    return matchedMockDispatches[0];\n}\nfunction addMockDispatch(mockDispatches, key, data) {\n    const baseData = {\n        timesInvoked: 0,\n        times: 1,\n        persist: false,\n        consumed: false\n    };\n    const replyData = typeof data === \"function\" ? {\n        callback: data\n    } : {\n        ...data\n    };\n    const newMockDispatch = {\n        ...baseData,\n        ...key,\n        pending: true,\n        data: {\n            error: null,\n            ...replyData\n        }\n    };\n    mockDispatches.push(newMockDispatch);\n    return newMockDispatch;\n}\nfunction deleteMockDispatch(mockDispatches, key) {\n    const index = mockDispatches.findIndex((dispatch)=>{\n        if (!dispatch.consumed) {\n            return false;\n        }\n        return matchKey(dispatch, key);\n    });\n    if (index !== -1) {\n        mockDispatches.splice(index, 1);\n    }\n}\nfunction buildKey(opts) {\n    const { path, method, body, headers, query } = opts;\n    return {\n        path,\n        method,\n        body,\n        headers,\n        query\n    };\n}\nfunction generateKeyValues(data) {\n    return Object.entries(data).reduce((keyValuePairs, [key, value])=>[\n            ...keyValuePairs,\n            Buffer.from(`${key}`),\n            Array.isArray(value) ? value.map((x)=>Buffer.from(`${x}`)) : Buffer.from(`${value}`)\n        ], []);\n}\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n * @param {number} statusCode\n */ function getStatusText(statusCode) {\n    return STATUS_CODES[statusCode] || \"unknown\";\n}\nasync function getResponse(body) {\n    const buffers = [];\n    for await (const data of body){\n        buffers.push(data);\n    }\n    return Buffer.concat(buffers).toString(\"utf8\");\n}\n/**\n * Mock dispatch function used to simulate undici dispatches\n */ function mockDispatch(opts, handler) {\n    // Get mock dispatch from built key\n    const key = buildKey(opts);\n    const mockDispatch = getMockDispatch(this[kDispatches], key);\n    mockDispatch.timesInvoked++;\n    // Here's where we resolve a callback if a callback is present for the dispatch data.\n    if (mockDispatch.data.callback) {\n        mockDispatch.data = {\n            ...mockDispatch.data,\n            ...mockDispatch.data.callback(opts)\n        };\n    }\n    // Parse mockDispatch data\n    const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch;\n    const { timesInvoked, times } = mockDispatch;\n    // If it's used up and not persistent, mark as consumed\n    mockDispatch.consumed = !persist && timesInvoked >= times;\n    mockDispatch.pending = timesInvoked < times;\n    // If specified, trigger dispatch error\n    if (error !== null) {\n        deleteMockDispatch(this[kDispatches], key);\n        handler.onError(error);\n        return true;\n    }\n    // Handle the request with a delay if necessary\n    if (typeof delay === \"number\" && delay > 0) {\n        setTimeout(()=>{\n            handleReply(this[kDispatches]);\n        }, delay);\n    } else {\n        handleReply(this[kDispatches]);\n    }\n    function handleReply(mockDispatches, _data = data) {\n        // fetch's HeadersList is a 1D string array\n        const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;\n        const body = typeof _data === \"function\" ? _data({\n            ...opts,\n            headers: optsHeaders\n        }) : _data;\n        // util.types.isPromise is likely needed for jest.\n        if (isPromise(body)) {\n            // If handleReply is asynchronous, throwing an error\n            // in the callback will reject the promise, rather than\n            // synchronously throw the error, which breaks some tests.\n            // Rather, we wait for the callback to resolve if it is a\n            // promise, and then re-run handleReply with the new body.\n            body.then((newData)=>handleReply(mockDispatches, newData));\n            return;\n        }\n        const responseData = getResponseData(body);\n        const responseHeaders = generateKeyValues(headers);\n        const responseTrailers = generateKeyValues(trailers);\n        handler.abort = nop;\n        handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));\n        handler.onData(Buffer.from(responseData));\n        handler.onComplete(responseTrailers);\n        deleteMockDispatch(mockDispatches, key);\n    }\n    function resume() {}\n    return true;\n}\nfunction buildMockDispatch() {\n    const agent = this[kMockAgent];\n    const origin = this[kOrigin];\n    const originalDispatch = this[kOriginalDispatch];\n    return function dispatch(opts, handler) {\n        if (agent.isMockActive) {\n            try {\n                mockDispatch.call(this, opts, handler);\n            } catch (error) {\n                if (error instanceof MockNotMatchedError) {\n                    const netConnect = agent[kGetNetConnect]();\n                    if (netConnect === false) {\n                        throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);\n                    }\n                    if (checkNetConnect(netConnect, origin)) {\n                        originalDispatch.call(this, opts, handler);\n                    } else {\n                        throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);\n                    }\n                } else {\n                    throw error;\n                }\n            }\n        } else {\n            originalDispatch.call(this, opts, handler);\n        }\n    };\n}\nfunction checkNetConnect(netConnect, origin) {\n    const url = new URL(origin);\n    if (netConnect === true) {\n        return true;\n    } else if (Array.isArray(netConnect) && netConnect.some((matcher)=>matchValue(matcher, url.host))) {\n        return true;\n    }\n    return false;\n}\nfunction buildMockOptions(opts) {\n    if (opts) {\n        const { agent, ...mockOptions } = opts;\n        return mockOptions;\n    }\n}\nmodule.exports = {\n    getResponseData,\n    getMockDispatch,\n    addMockDispatch,\n    deleteMockDispatch,\n    buildKey,\n    generateKeyValues,\n    matchValue,\n    getResponse,\n    getStatusText,\n    mockDispatch,\n    buildMockDispatch,\n    checkNetConnect,\n    buildMockOptions,\n    getHeaderByName\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLXV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxtQkFBbUIsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUN4QyxNQUFNLEVBQ0pDLFdBQVcsRUFDWEMsVUFBVSxFQUNWQyxpQkFBaUIsRUFDakJDLE9BQU8sRUFDUEMsY0FBYyxFQUNmLEdBQUdMLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFTSxRQUFRLEVBQUVDLEdBQUcsRUFBRSxHQUFHUCxtQkFBT0EsQ0FBQztBQUNsQyxNQUFNLEVBQUVRLFlBQVksRUFBRSxHQUFHUixtQkFBT0EsQ0FBQztBQUNqQyxNQUFNLEVBQ0pTLE9BQU8sRUFDTEMsU0FBUyxFQUNWLEVBQ0YsR0FBR1YsbUJBQU9BLENBQUM7QUFFWixTQUFTVyxXQUFZQyxLQUFLLEVBQUVDLEtBQUs7SUFDL0IsSUFBSSxPQUFPRCxVQUFVLFVBQVU7UUFDN0IsT0FBT0EsVUFBVUM7SUFDbkI7SUFDQSxJQUFJRCxpQkFBaUJFLFFBQVE7UUFDM0IsT0FBT0YsTUFBTUcsSUFBSSxDQUFDRjtJQUNwQjtJQUNBLElBQUksT0FBT0QsVUFBVSxZQUFZO1FBQy9CLE9BQU9BLE1BQU1DLFdBQVc7SUFDMUI7SUFDQSxPQUFPO0FBQ1Q7QUFFQSxTQUFTRyxpQkFBa0JDLE9BQU87SUFDaEMsT0FBT0MsT0FBT0MsV0FBVyxDQUN2QkQsT0FBT0UsT0FBTyxDQUFDSCxTQUFTSSxHQUFHLENBQUMsQ0FBQyxDQUFDQyxZQUFZQyxZQUFZO1FBQ3BELE9BQU87WUFBQ0QsV0FBV0UsaUJBQWlCO1lBQUlEO1NBQVk7SUFDdEQ7QUFFSjtBQUVBOzs7Q0FHQyxHQUNELFNBQVNFLGdCQUFpQlIsT0FBTyxFQUFFUyxHQUFHO0lBQ3BDLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ1gsVUFBVTtRQUMxQixJQUFLLElBQUlZLElBQUksR0FBR0EsSUFBSVos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SU0sZ0JBQWdCRixZQUFZSixTQUFTO3dCQUN2Q0MsaUJBQWlCRSxJQUFJLENBQUMsSUFBSSxFQUFFbEMsTUFBTVc7b0JBQ3BDLE9BQU87d0JBQ0wsTUFBTSxJQUFJcEcsb0JBQW9CLENBQUMsRUFBRW1GLE1BQU0wQyxPQUFPLENBQUMsK0JBQStCLEVBQUVMLE9BQU8sNkRBQTZELENBQUM7b0JBQ3ZKO2dCQUNGLE9BQU87b0JBQ0wsTUFBTXJDO2dCQUNSO1lBQ0Y7UUFDRixPQUFPO1lBQ0xzQyxpQkFBaUJFLElBQUksQ0FBQyxJQUFJLEVBQUVsQyxNQUFNVztRQUNwQztJQUNGO0FBQ0Y7QUFFQSxTQUFTMEIsZ0JBQWlCRixVQUFVLEVBQUVKLE1BQU07SUFDMUMsTUFBTU8sTUFBTSxJQUFJQyxJQUFJUjtJQUNwQixJQUFJSSxlQUFlLE1BQU07UUFDdkIsT0FBTztJQUNULE9BQU8sSUFBSWhHLE1BQU1DLE9BQU8sQ0FBQytGLGVBQWVBLFdBQVdLLElBQUksQ0FBQyxDQUFDQyxVQUFZdEgsV0FBV3NILFNBQVNILElBQUlJLElBQUksSUFBSTtRQUNuRyxPQUFPO0lBQ1Q7SUFDQSxPQUFPO0FBQ1Q7QUFFQSxTQUFTQyxpQkFBa0IzQyxJQUFJO0lBQzdCLElBQUlBLE1BQU07UUFDUixNQUFNLEVBQUU4QixLQUFLLEVBQUUsR0FBR2MsYUFBYSxHQUFHNUM7UUFDbEMsT0FBTzRDO0lBQ1Q7QUFDRjtBQUVBQyxPQUFPQyxPQUFPLEdBQUc7SUFDZjNFO0lBQ0FNO0lBQ0FRO0lBQ0FVO0lBQ0FJO0lBQ0FFO0lBQ0E5RTtJQUNBcUY7SUFDQUY7SUFDQXZEO0lBQ0E4RTtJQUNBUTtJQUNBTTtJQUNBMUc7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay11dGlscy5qcz9hYzhjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IE1vY2tOb3RNYXRjaGVkRXJyb3IgfSA9IHJlcXVpcmUoJy4vbW9jay1lcnJvcnMnKVxuY29uc3Qge1xuICBrRGlzcGF0Y2hlcyxcbiAga01vY2tBZ2VudCxcbiAga09yaWdpbmFsRGlzcGF0Y2gsXG4gIGtPcmlnaW4sXG4gIGtHZXROZXRDb25uZWN0XG59ID0gcmVxdWlyZSgnLi9tb2NrLXN5bWJvbHMnKVxuY29uc3QgeyBidWlsZFVSTCwgbm9wIH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBTVEFUVVNfQ09ERVMgfSA9IHJlcXVpcmUoJ2h0dHAnKVxuY29uc3Qge1xuICB0eXBlczoge1xuICAgIGlzUHJvbWlzZVxuICB9XG59ID0gcmVxdWlyZSgndXRpbCcpXG5cbmZ1bmN0aW9uIG1hdGNoVmFsdWUgKG1hdGNoLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIG1hdGNoID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBtYXRjaCA9PT0gdmFsdWVcbiAgfVxuICBpZiAobWF0Y2ggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gbWF0Y2gudGVzdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIG1hdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1hdGNoKHZhbHVlKSA9PT0gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBsb3dlckNhc2VFbnRyaWVzIChoZWFkZXJzKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMoaGVhZGVycykubWFwKChbaGVhZGVyTmFtZSwgaGVhZGVyVmFsdWVdKSA9PiB7XG4gICAgICByZXR1cm4gW2hlYWRlck5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKSwgaGVhZGVyVmFsdWVdXG4gICAgfSlcbiAgKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9pbmRleCcpLkhlYWRlcnN8c3RyaW5nW118UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gaGVhZGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5mdW5jdGlvbiBnZXRIZWFkZXJCeU5hbWUgKGhlYWRlcnMsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgaWYgKGhlYWRlcnNbaV0udG9Mb2NhbGVMb3dlckNhc2UoKSA9PT0ga2V5LnRvTG9jYWxlTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnNbaSArIDFdXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9IGVsc2UgaWYgKHR5cGVvZiBoZWFkZXJzLmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBoZWFkZXJzLmdldChrZXkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxvd2VyQ2FzZUVudHJpZXMoaGVhZGVycylba2V5LnRvTG9jYWxlTG93ZXJDYXNlKCldXG4gIH1cbn1cblxuLyoqIEBwYXJhbSB7c3RyaW5nW119IGhlYWRlcnMgKi9cbmZ1bmN0aW9uIGJ1aWxkSGVhZGVyc0Zyb21BcnJheSAoaGVhZGVycykgeyAvLyBmZXRjaCBIZWFkZXJzTGlzdFxuICBjb25zdCBjbG9uZSA9IGhlYWRlcnMuc2xpY2UoKVxuICBjb25zdCBlbnRyaWVzID0gW11cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGNsb25lLmxlbmd0aDsgaW5kZXggKz0gMikge1xuICAgIGVudHJpZXMucHVzaChbY2xvbmVbaW5kZXhdLCBjbG9uZVtpbmRleCArIDFdXSlcbiAgfVxuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKGVudHJpZXMpXG59XG5cbmZ1bmN0aW9uIG1hdGNoSGVhZGVycyAobW9ja0Rpc3BhdGNoLCBoZWFkZXJzKSB7XG4gIGlmICh0eXBlb2YgbW9ja0Rpc3BhdGNoLmhlYWRlcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkgeyAvLyBmZXRjaCBIZWFkZXJzTGlzdFxuICAgICAgaGVhZGVycyA9IGJ1aWxkSGVhZGVyc0Zyb21BcnJheShoZWFkZXJzKVxuICAgIH1cbiAgICByZXR1cm4gbW9ja0Rpc3BhdGNoLmhlYWRlcnMoaGVhZGVycyA/IGxvd2VyQ2FzZUVudHJpZXMoaGVhZGVycykgOiB7fSlcbiAgfVxuICBpZiAodHlwZW9mIG1vY2tEaXNwYXRjaC5oZWFkZXJzID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKHR5cGVvZiBoZWFkZXJzICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgbW9ja0Rpc3BhdGNoLmhlYWRlcnMgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmb3IgKGNvbnN0IFttYXRjaEhlYWRlck5hbWUsIG1hdGNoSGVhZGVyVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG1vY2tEaXNwYXRjaC5oZWFkZXJzKSkge1xuICAgIGNvbnN0IGhlYWRlclZhbHVlID0gZ2V0SGVhZGVyQnlOYW1lKGhlYWRlcnMsIG1hdGNoSGVhZGVyTmFtZSlcblxuICAgIGlmICghbWF0Y2hWYWx1ZShtYXRjaEhlYWRlclZhbHVlLCBoZWFkZXJWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBzYWZlVXJsIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0aFxuICB9XG5cbiAgY29uc3QgcGF0aFNlZ21lbnRzID0gcGF0aC5zcGxpdCgnPycpXG5cbiAgaWYgKHBhdGhTZWdtZW50cy5sZW5ndGggIT09IDIpIHtcbiAgICByZXR1cm4gcGF0aFxuICB9XG5cbiAgY29uc3QgcXAgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhdGhTZWdtZW50cy5wb3AoKSlcbiAgcXAuc29ydCgpXG4gIHJldHVybiBbLi4ucGF0aFNlZ21lbnRzLCBxcC50b1N0cmluZygpXS5qb2luKCc/Jylcbn1cblxuZnVuY3Rpb24gbWF0Y2hLZXkgKG1vY2tEaXNwYXRjaCwgeyBwYXRoLCBtZXRob2QsIGJvZHksIGhlYWRlcnMgfSkge1xuICBjb25zdCBwYXRoTWF0Y2ggPSBtYXRjaFZhbHVlKG1vY2tEaXNwYXRjaC5wYXRoLCBwYXRoKVxuICBjb25zdCBtZXRob2RNYXRjaCA9IG1hdGNoVmFsdWUobW9ja0Rpc3BhdGNoLm1ldGhvZCwgbWV0aG9kKVxuICBjb25zdCBib2R5TWF0Y2ggPSB0eXBlb2YgbW9ja0Rpc3BhdGNoLmJvZHkgIT09ICd1bmRlZmluZWQnID8gbWF0Y2hWYWx1ZShtb2NrRGlzcGF0Y2guYm9keSwgYm9keSkgOiB0cnVlXG4gIGNvbnN0IGhlYWRlcnNNYXRjaCA9IG1hdGNoSGVhZGVycyhtb2NrRGlzcGF0Y2gsIGhlYWRlcnMpXG4gIHJldHVybiBwYXRoTWF0Y2ggJiYgbWV0aG9kTWF0Y2ggJiYgYm9keU1hdGNoICYmIGhlYWRlcnNNYXRjaFxufVxuXG5mdW5jdGlvbiBnZXRSZXNwb25zZURhdGEgKGRhdGEpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgIHJldHVybiBkYXRhXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1vY2tEaXNwYXRjaCAobW9ja0Rpc3BhdGNoZXMsIGtleSkge1xuICBjb25zdCBiYXNlUGF0aCA9IGtleS5xdWVyeSA/IGJ1aWxkVVJMKGtleS5wYXRoLCBrZXkucXVlcnkpIDoga2V5LnBhdGhcbiAgY29uc3QgcmVzb2x2ZWRQYXRoID0gdHlwZW9mIGJhc2VQYXRoID09PSAnc3RyaW5nJyA/IHNhZmVVcmwoYmFzZVBhdGgpIDogYmFzZVBhdGhcblxuICAvLyBNYXRjaCBwYXRoXG4gIGxldCBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMgPSBtb2NrRGlzcGF0Y2hlcy5maWx0ZXIoKHsgY29uc3VtZWQgfSkgPT4gIWNvbnN1bWVkKS5maWx0ZXIoKHsgcGF0aCB9KSA9PiBtYXRjaFZhbHVlKHNhZmVVcmwocGF0aCksIHJlc29sdmVkUGF0aCkpXG4gIGlmIChtYXRjaGVkTW9ja0Rpc3BhdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYE1vY2sgZGlzcGF0Y2ggbm90IG1hdGNoZWQgZm9yIHBhdGggJyR7cmVzb2x2ZWRQYXRofSdgKVxuICB9XG5cbiAgLy8gTWF0Y2ggbWV0aG9kXG4gIG1hdGNoZWRNb2NrRGlzcGF0Y2hlcyA9IG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5maWx0ZXIoKHsgbWV0aG9kIH0pID0+IG1hdGNoVmFsdWUobWV0aG9kLCBrZXkubWV0aG9kKSlcbiAgaWYgKG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgTW9jayBkaXNwYXRjaCBub3QgbWF0Y2hlZCBmb3IgbWV0aG9kICcke2tleS5tZXRob2R9J2ApXG4gIH1cblxuICAvLyBNYXRjaCBib2R5XG4gIG1hdGNoZWRNb2NrRGlzcGF0Y2hlcyA9IG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5maWx0ZXIoKHsgYm9keSB9KSA9PiB0eXBlb2YgYm9keSAhPT0gJ3VuZGVmaW5lZCcgPyBtYXRjaFZhbHVlKGJvZHksIGtleS5ib2R5KSA6IHRydWUpXG4gIGlmIChtYXRjaGVkTW9ja0Rpc3BhdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYE1vY2sgZGlzcGF0Y2ggbm90IG1hdGNoZWQgZm9yIGJvZHkgJyR7a2V5LmJvZHl9J2ApXG4gIH1cblxuICAvLyBNYXRjaCBoZWFkZXJzXG4gIG1hdGNoZWRNb2NrRGlzcGF0Y2hlcyA9IG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5maWx0ZXIoKG1vY2tEaXNwYXRjaCkgPT4gbWF0Y2hIZWFkZXJzKG1vY2tEaXNwYXRjaCwga2V5LmhlYWRlcnMpKVxuICBpZiAobWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBNb2NrTm90TWF0Y2hlZEVycm9yKGBNb2NrIGRpc3BhdGNoIG5vdCBtYXRjaGVkIGZvciBoZWFkZXJzICcke3R5cGVvZiBrZXkuaGVhZGVycyA9PT0gJ29iamVjdCcgPyBKU09OLnN0cmluZ2lmeShrZXkuaGVhZGVycykgOiBrZXkuaGVhZGVyc30nYClcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVkTW9ja0Rpc3BhdGNoZXNbMF1cbn1cblxuZnVuY3Rpb24gYWRkTW9ja0Rpc3BhdGNoIChtb2NrRGlzcGF0Y2hlcywga2V5LCBkYXRhKSB7XG4gIGNvbnN0IGJhc2VEYXRhID0geyB0aW1lc0ludm9rZWQ6IDAsIHRpbWVzOiAxLCBwZXJzaXN0OiBmYWxzZSwgY29uc3VtZWQ6IGZhbHNlIH1cbiAgY29uc3QgcmVwbHlEYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicgPyB7IGNhbGxiYWNrOiBkYXRhIH0gOiB7IC4uLmRhdGEgfVxuICBjb25zdCBuZXdNb2NrRGlzcGF0Y2ggPSB7IC4uLmJhc2VEYXRhLCAuLi5rZXksIHBlbmRpbmc6IHRydWUsIGRhdGE6IHsgZXJyb3I6IG51bGwsIC4uLnJlcGx5RGF0YSB9IH1cbiAgbW9ja0Rpc3BhdGNoZXMucHVzaChuZXdNb2NrRGlzcGF0Y2gpXG4gIHJldHVybiBuZXdNb2NrRGlzcGF0Y2hcbn1cblxuZnVuY3Rpb24gZGVsZXRlTW9ja0Rpc3BhdGNoIChtb2NrRGlzcGF0Y2hlcywga2V5KSB7XG4gIGNvbnN0IGluZGV4ID0gbW9ja0Rpc3BhdGNoZXMuZmluZEluZGV4KGRpc3BhdGNoID0+IHtcbiAgICBpZiAoIWRpc3BhdGNoLmNvbnN1bWVkKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoS2V5KGRpc3BhdGNoLCBrZXkpXG4gIH0pXG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBtb2NrRGlzcGF0Y2hlcy5zcGxpY2UoaW5kZXgsIDEpXG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRLZXkgKG9wdHMpIHtcbiAgY29uc3QgeyBwYXRoLCBtZXRob2QsIGJvZHksIGhlYWRlcnMsIHF1ZXJ5IH0gPSBvcHRzXG4gIHJldHVybiB7XG4gICAgcGF0aCxcbiAgICBtZXRob2QsXG4gICAgYm9keSxcbiAgICBoZWFkZXJzLFxuICAgIHF1ZXJ5XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVLZXlWYWx1ZXMgKGRhdGEpIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGRhdGEpLnJlZHVjZSgoa2V5VmFsdWVQYWlycywgW2tleSwgdmFsdWVdKSA9PiBbXG4gICAgLi4ua2V5VmFsdWVQYWlycyxcbiAgICBCdWZmZXIuZnJvbShgJHtrZXl9YCksXG4gICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAoeCA9PiBCdWZmZXIuZnJvbShgJHt4fWApKSA6IEJ1ZmZlci5mcm9tKGAke3ZhbHVlfWApXG4gIF0sIFtdKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXNDb2RlXG4gKi9cbmZ1bmN0aW9uIGdldFN0YXR1c1RleHQgKHN0YXR1c0NvZGUpIHtcbiAgcmV0dXJuIFNUQVRVU19DT0RFU1tzdGF0dXNDb2RlXSB8fCAndW5rbm93bidcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0UmVzcG9uc2UgKGJvZHkpIHtcbiAgY29uc3QgYnVmZmVycyA9IFtdXG4gIGZvciBhd2FpdCAoY29uc3QgZGF0YSBvZiBib2R5KSB7XG4gICAgYnVmZmVycy5wdXNoKGRhdGEpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoYnVmZmVycykudG9TdHJpbmcoJ3V0ZjgnKVxufVxuXG4vKipcbiAqIE1vY2sgZGlzcGF0Y2ggZnVuY3Rpb24gdXNlZCB0byBzaW11bGF0ZSB1bmRpY2kgZGlzcGF0Y2hlc1xuICovXG5mdW5jdGlvbiBtb2NrRGlzcGF0Y2ggKG9wdHMsIGhhbmRsZXIpIHtcbiAgLy8gR2V0IG1vY2sgZGlzcGF0Y2ggZnJvbSBidWlsdCBrZXlcbiAgY29uc3Qga2V5ID0gYnVpbGRLZXkob3B0cylcbiAgY29uc3QgbW9ja0Rpc3BhdGNoID0gZ2V0TW9ja0Rpc3BhdGNoKHRoaXNba0Rpc3BhdGNoZXNdLCBrZXkpXG5cbiAgbW9ja0Rpc3BhdGNoLnRpbWVzSW52b2tlZCsrXG5cbiAgLy8gSGVyZSdzIHdoZXJlIHdlIHJlc29sdmUgYSBjYWxsYmFjayBpZiBhIGNhbGxiYWNrIGlzIHByZXNlbnQgZm9yIHRoZSBkaXNwYXRjaCBkYXRhLlxuICBpZiAobW9ja0Rpc3BhdGNoLmRhdGEuY2FsbGJhY2spIHtcbiAgICBtb2NrRGlzcGF0Y2guZGF0YSA9IHsgLi4ubW9ja0Rpc3BhdGNoLmRhdGEsIC4uLm1vY2tEaXNwYXRjaC5kYXRhLmNhbGxiYWNrKG9wdHMpIH1cbiAgfVxuXG4gIC8vIFBhcnNlIG1vY2tEaXNwYXRjaCBkYXRhXG4gIGNvbnN0IHsgZGF0YTogeyBzdGF0dXNDb2RlLCBkYXRhLCBoZWFkZXJzLCB0cmFpbGVycywgZXJyb3IgfSwgZGVsYXksIHBlcnNpc3QgfSA9IG1vY2tEaXNwYXRjaFxuICBjb25zdCB7IHRpbWVzSW52b2tlZCwgdGltZXMgfSA9IG1vY2tEaXNwYXRjaFxuXG4gIC8vIElmIGl0J3MgdXNlZCB1cCBhbmQgbm90IHBlcnNpc3RlbnQsIG1hcmsgYXMgY29uc3VtZWRcbiAgbW9ja0Rpc3BhdGNoLmNvbnN1bWVkID0gIXBlcnNpc3QgJiYgdGltZXNJbnZva2VkID49IHRpbWVzXG4gIG1vY2tEaXNwYXRjaC5wZW5kaW5nID0gdGltZXNJbnZva2VkIDwgdGltZXNcblxuICAvLyBJZiBzcGVjaWZpZWQsIHRyaWdnZXIgZGlzcGF0Y2ggZXJyb3JcbiAgaWYgKGVycm9yICE9PSBudWxsKSB7XG4gICAgZGVsZXRlTW9ja0Rpc3BhdGNoKHRoaXNba0Rpc3BhdGNoZXNdLCBrZXkpXG4gICAgaGFuZGxlci5vbkVycm9yKGVycm9yKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBIYW5kbGUgdGhlIHJlcXVlc3Qgd2l0aCBhIGRlbGF5IGlmIG5lY2Vzc2FyeVxuICBpZiAodHlwZW9mIGRlbGF5ID09PSAnbnVtYmVyJyAmJiBkZWxheSA+IDApIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGhhbmRsZVJlcGx5KHRoaXNba0Rpc3BhdGNoZXNdKVxuICAgIH0sIGRlbGF5KVxuICB9IGVsc2Uge1xuICAgIGhhbmRsZVJlcGx5KHRoaXNba0Rpc3BhdGNoZXNdKVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUmVwbHkgKG1vY2tEaXNwYXRjaGVzLCBfZGF0YSA9IGRhdGEpIHtcbiAgICAvLyBmZXRjaCdzIEhlYWRlcnNMaXN0IGlzIGEgMUQgc3RyaW5nIGFycmF5XG4gICAgY29uc3Qgb3B0c0hlYWRlcnMgPSBBcnJheS5pc0FycmF5KG9wdHMuaGVhZGVycylcbiAgICAgID8gYnVpbGRIZWFkZXJzRnJvbUFycmF5KG9wdHMuaGVhZGVycylcbiAgICAgIDogb3B0cy5oZWFkZXJzXG4gICAgY29uc3QgYm9keSA9IHR5cGVvZiBfZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBfZGF0YSh7IC4uLm9wdHMsIGhlYWRlcnM6IG9wdHNIZWFkZXJzIH0pXG4gICAgICA6IF9kYXRhXG5cbiAgICAvLyB1dGlsLnR5cGVzLmlzUHJvbWlzZSBpcyBsaWtlbHkgbmVlZGVkIGZvciBqZXN0LlxuICAgIGlmIChpc1Byb21pc2UoYm9keSkpIHtcbiAgICAgIC8vIElmIGhhbmRsZVJlcGx5IGlzIGFzeW5jaHJvbm91cywgdGhyb3dpbmcgYW4gZXJyb3JcbiAgICAgIC8vIGluIHRoZSBjYWxsYmFjayB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZSwgcmF0aGVyIHRoYW5cbiAgICAgIC8vIHN5bmNocm9ub3VzbHkgdGhyb3cgdGhlIGVycm9yLCB3aGljaCBicmVha3Mgc29tZSB0ZXN0cy5cbiAgICAgIC8vIFJhdGhlciwgd2Ugd2FpdCBmb3IgdGhlIGNhbGxiYWNrIHRvIHJlc29sdmUgaWYgaXQgaXMgYVxuICAgICAgLy8gcHJvbWlzZSwgYW5kIHRoZW4gcmUtcnVuIGhhbmRsZVJlcGx5IHdpdGggdGhlIG5ldyBib2R5LlxuICAgICAgYm9keS50aGVuKChuZXdEYXRhKSA9PiBoYW5kbGVSZXBseShtb2NrRGlzcGF0Y2hlcywgbmV3RGF0YSkpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZURhdGEgPSBnZXRSZXNwb25zZURhdGEoYm9keSlcbiAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBnZW5lcmF0ZUtleVZhbHVlcyhoZWFkZXJzKVxuICAgIGNvbnN0IHJlc3BvbnNlVHJhaWxlcnMgPSBnZW5lcmF0ZUtleVZhbHVlcyh0cmFpbGVycylcblxuICAgIGhhbmRsZXIuYWJvcnQgPSBub3BcbiAgICBoYW5kbGVyLm9uSGVhZGVycyhzdGF0dXNDb2RlLCByZXNwb25zZUhlYWRlcnMsIHJlc3VtZSwgZ2V0U3RhdHVzVGV4dChzdGF0dXNDb2RlKSlcbiAgICBoYW5kbGVyLm9uRGF0YShCdWZmZXIuZnJvbShyZXNwb25zZURhdGEpKVxuICAgIGhhbmRsZXIub25Db21wbGV0ZShyZXNwb25zZVRyYWlsZXJzKVxuICAgIGRlbGV0ZU1vY2tEaXNwYXRjaChtb2NrRGlzcGF0Y2hlcywga2V5KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzdW1lICgpIHt9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gYnVpbGRNb2NrRGlzcGF0Y2ggKCkge1xuICBjb25zdCBhZ2VudCA9IHRoaXNba01vY2tBZ2VudF1cbiAgY29uc3Qgb3JpZ2luID0gdGhpc1trT3JpZ2luXVxuICBjb25zdCBvcmlnaW5hbERpc3BhdGNoID0gdGhpc1trT3JpZ2luYWxEaXNwYXRjaF1cblxuICByZXR1cm4gZnVuY3Rpb24gZGlzcGF0Y2ggKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBpZiAoYWdlbnQuaXNNb2NrQWN0aXZlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBtb2NrRGlzcGF0Y2guY2FsbCh0aGlzLCBvcHRzLCBoYW5kbGVyKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgTW9ja05vdE1hdGNoZWRFcnJvcikge1xuICAgICAgICAgIGNvbnN0IG5ldENvbm5lY3QgPSBhZ2VudFtrR2V0TmV0Q29ubmVjdF0oKVxuICAgICAgICAgIGlmIChuZXRDb25uZWN0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYCR7ZXJyb3IubWVzc2FnZX06IHN1YnNlcXVlbnQgcmVxdWVzdCB0byBvcmlnaW4gJHtvcmlnaW59IHdhcyBub3QgYWxsb3dlZCAobmV0LmNvbm5lY3QgZGlzYWJsZWQpYClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoZWNrTmV0Q29ubmVjdChuZXRDb25uZWN0LCBvcmlnaW4pKSB7XG4gICAgICAgICAgICBvcmlnaW5hbERpc3BhdGNoLmNhbGwodGhpcywgb3B0cywgaGFuZGxlcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYCR7ZXJyb3IubWVzc2FnZX06IHN1YnNlcXVlbnQgcmVxdWVzdCB0byBvcmlnaW4gJHtvcmlnaW59IHdhcyBub3QgYWxsb3dlZCAobmV0LmNvbm5lY3QgaXMgbm90IGVuYWJsZWQgZm9yIHRoaXMgb3JpZ2luKWApXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3JpZ2luYWxEaXNwYXRjaC5jYWxsKHRoaXMsIG9wdHMsIGhhbmRsZXIpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrTmV0Q29ubmVjdCAobmV0Q29ubmVjdCwgb3JpZ2luKSB7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwob3JpZ2luKVxuICBpZiAobmV0Q29ubmVjdCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShuZXRDb25uZWN0KSAmJiBuZXRDb25uZWN0LnNvbWUoKG1hdGNoZXIpID0+IG1hdGNoVmFsdWUobWF0Y2hlciwgdXJsLmhvc3QpKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGJ1aWxkTW9ja09wdGlvbnMgKG9wdHMpIHtcbiAgaWYgKG9wdHMpIHtcbiAgICBjb25zdCB7IGFnZW50LCAuLi5tb2NrT3B0aW9ucyB9ID0gb3B0c1xuICAgIHJldHVybiBtb2NrT3B0aW9uc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRSZXNwb25zZURhdGEsXG4gIGdldE1vY2tEaXNwYXRjaCxcbiAgYWRkTW9ja0Rpc3BhdGNoLFxuICBkZWxldGVNb2NrRGlzcGF0Y2gsXG4gIGJ1aWxkS2V5LFxuICBnZW5lcmF0ZUtleVZhbHVlcyxcbiAgbWF0Y2hWYWx1ZSxcbiAgZ2V0UmVzcG9uc2UsXG4gIGdldFN0YXR1c1RleHQsXG4gIG1vY2tEaXNwYXRjaCxcbiAgYnVpbGRNb2NrRGlzcGF0Y2gsXG4gIGNoZWNrTmV0Q29ubmVjdCxcbiAgYnVpbGRNb2NrT3B0aW9ucyxcbiAgZ2V0SGVhZGVyQnlOYW1lXG59XG4iXSwibmFtZXMiOlsiTW9ja05vdE1hdGNoZWRFcnJvciIsInJlcXVpcmUiLCJrRGlzcGF0Y2hlcyIsImtNb2NrQWdlbnQiLCJrT3JpZ2luYWxEaXNwYXRjaCIsImtPcmlnaW4iLCJrR2V0TmV0Q29ubmVjdCIsImJ1aWxkVVJMIiwibm9wIiwiU1RBVFVTX0NPREVTIiwidHlwZXMiLCJpc1Byb21pc2UiLCJtYXRjaFZhbHVlIiwibWF0Y2giLCJ2YWx1ZSIsIlJlZ0V4cCIsInRlc3QiLCJsb3dlckNhc2VFbnRyaWVzIiwiaGVhZGVycyIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsIm1hcCIsImhlYWRlck5hbWUiLCJoZWFkZXJWYWx1ZSIsInRvTG9jYWxlTG93ZXJDYXNlIiwiZ2V0SGVhZGVyQnlOYW1lIiwia2V5IiwiQXJyYXkiLCJpc0FycmF5IiwiaSIsImxlbmd0aCIsInVuZGVmaW5lZCIsImdldCIsImJ1aWxkSGVhZGVyc0Zyb21BcnJheSIsImNsb25lIiwic2xpY2UiLCJpbmRleCIsInB1c2giLCJtYXRjaEhlYWRlcnMiLCJtb2NrRGlzcGF0Y2giLCJtYXRjaEhlYWRlck5hbWUiLCJtYXRjaEhlYWRlclZhbHVlIiwic2FmZVVybCIsInBhdGgiLCJwYXRoU2VnbWVudHMiLCJzcGxpdCIsInFwIiwiVVJMU2VhcmNoUGFyYW1zIiwicG9wIiwic29ydCIsInRvU3RyaW5nIiwiam9pbiIsIm1hdGNoS2V5IiwibWV0aG9kIiwiYm9keSIsInBhdGhNYXRjaCIsIm1ldGhvZE1hdGNoIiwiYm9keU1hdGNoIiwiaGVhZGVyc01hdGNoIiwiZ2V0UmVzcG9uc2VEYXRhIiwiZGF0YSIsIkJ1ZmZlciIsImlzQnVmZmVyIiwiSlNPTiIsInN0cmluZ2lmeSIsImdldE1vY2tEaXNwYXRjaCIsIm1vY2tEaXNwYXRjaGVzIiwiYmFzZVBhdGgiLCJxdWVyeSIsInJlc29sdmVkUGF0aCIsIm1hdGNoZWRNb2NrRGlzcGF0Y2hlcyIsImZpbHRlciIsImNvbnN1bWVkIiwiYWRkTW9ja0Rpc3BhdGNoIiwiYmFzZURhdGEiLCJ0aW1lc0ludm9rZWQiLCJ0aW1lcyIsInBlcnNpc3QiLCJyZXBseURhdGEiLCJjYWxsYmFjayIsIm5ld01vY2tEaXNwYXRjaCIsInBlbmRpbmciLCJlcnJvciIsImRlbGV0ZU1vY2tEaXNwYXRjaCIsImZpbmRJbmRleCIsImRpc3BhdGNoIiwic3BsaWNlIiwiYnVpbGRLZXkiLCJvcHRzIiwiZ2VuZXJhdGVLZXlWYWx1ZXMiLCJyZWR1Y2UiLCJrZXlWYWx1ZVBhaXJzIiwiZnJvbSIsIngiLCJnZXRTdGF0dXNUZXh0Iiwic3RhdHVzQ29kZSIsImdldFJlc3BvbnNlIiwiYnVmZmVycyIsImNvbmNhdCIsImhhbmRsZXIiLCJ0cmFpbGVycyIsImRlbGF5Iiwib25FcnJvciIsInNldFRpbWVvdXQiLCJoYW5kbGVSZXBseSIsIl9kYXRhIiwib3B0c0hlYWRlcnMiLCJ0aGVuIiwibmV3RGF0YSIsInJlc3BvbnNlRGF0YSIsInJlc3BvbnNlSGVhZGVycyIsInJlc3BvbnNlVHJhaWxlcnMiLCJhYm9ydCIsIm9uSGVhZGVycyIsInJlc3VtZSIsIm9uRGF0YSIsIm9uQ29tcGxldGUiLCJidWlsZE1vY2tEaXNwYXRjaCIsImFnZW50Iiwib3JpZ2luIiwib3JpZ2luYWxEaXNwYXRjaCIsImlzTW9ja0FjdGl2ZSIsImNhbGwiLCJuZXRDb25uZWN0IiwibWVzc2FnZSIsImNoZWNrTmV0Q29ubmVjdCIsInVybCIsIlVSTCIsInNvbWUiLCJtYXRjaGVyIiwiaG9zdCIsImJ1aWxkTW9ja09wdGlvbnMiLCJtb2NrT3B0aW9ucyIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/mock-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/pending-interceptors-formatter.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/mock/pending-interceptors-formatter.js ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Transform } = __webpack_require__(/*! stream */ \"stream\");\nconst { Console } = __webpack_require__(/*! console */ \"console\");\n/**\n * Gets the output of `console.table()` as a string.\n */ module.exports = class PendingInterceptorsFormatter {\n    constructor({ disableColors } = {}){\n        this.transform = new Transform({\n            transform (chunk, _enc, cb) {\n                cb(null, chunk);\n            }\n        });\n        this.logger = new Console({\n            stdout: this.transform,\n            inspectOptions: {\n                colors: !disableColors && !process.env.CI\n            }\n        });\n    }\n    format(pendingInterceptors) {\n        const withPrettyHeaders = pendingInterceptors.map(({ method, path, data: { statusCode }, persist, times, timesInvoked, origin })=>({\n                Method: method,\n                Origin: origin,\n                Path: path,\n                \"Status code\": statusCode,\n                Persistent: persist ? \"\" : \"\",\n                Invocations: timesInvoked,\n                Remaining: persist ? Infinity : times - timesInvoked\n            }));\n        this.logger.table(withPrettyHeaders);\n        return this.transform.read().toString();\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9wZW5kaW5nLWludGVyY2VwdG9ycy1mb3JtYXR0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFNBQVMsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUM5QixNQUFNLEVBQUVDLE9BQU8sRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUU1Qjs7Q0FFQyxHQUNERSxPQUFPQyxPQUFPLEdBQUcsTUFBTUM7SUFDckJDLFlBQWEsRUFBRUMsYUFBYSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDbkMsSUFBSSxDQUFDQyxTQUFTLEdBQUcsSUFBSVIsVUFBVTtZQUM3QlEsV0FBV0MsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLEVBQUU7Z0JBQ3hCQSxHQUFHLE1BQU1GO1lBQ1g7UUFDRjtRQUVBLElBQUksQ0FBQ0csTUFBTSxHQUFHLElBQUlWLFFBQVE7WUFDeEJXLFFBQVEsSUFBSSxDQUFDTCxTQUFTO1lBQ3RCTSxnQkFBZ0I7Z0JBQ2RDLFFBQVEsQ0FBQ1IsaUJBQWlCLENBQUNTLFFBQVFDLEdBQUcsQ0FBQ0MsRUFBRTtZQUMzQztRQUNGO0lBQ0Y7SUFFQUMsT0FBUUMsbUJBQW1CLEVBQUU7UUFDM0IsTUFBTUMsb0JBQW9CRCxvQkFBb0JFLEdBQUcsQ0FDL0MsQ0FBQyxFQUFFQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFQyxVQUFVLEVBQUUsRUFBRUMsT0FBTyxFQUFFQyxLQUFLLEVBQUVDLFlBQVksRUFBRUMsTUFBTSxFQUFFLEdBQU07Z0JBQ2pGQyxRQUFRUjtnQkFDUlMsUUFBUUY7Z0JBQ1JHLE1BQU1UO2dCQUNOLGVBQWVFO2dCQUNmUSxZQUFZUCxVQUFVLE1BQU07Z0JBQzVCUSxhQUFhTjtnQkFDYk8sV0FBV1QsVUFBVVUsV0FBV1QsUUFBUUM7WUFDMUM7UUFFRixJQUFJLENBQUNqQixNQUFNLENBQUMwQixLQUFLLENBQUNqQjtRQUNsQixPQUFPLElBQUksQ0FBQ2IsU0FBUyxDQUFDK0IsSUFBSSxHQUFHQyxRQUFRO0lBQ3ZDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3BlbmRpbmctaW50ZXJjZXB0b3JzLWZvcm1hdHRlci5qcz85ZDNkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IFRyYW5zZm9ybSB9ID0gcmVxdWlyZSgnc3RyZWFtJylcbmNvbnN0IHsgQ29uc29sZSB9ID0gcmVxdWlyZSgnY29uc29sZScpXG5cbi8qKlxuICogR2V0cyB0aGUgb3V0cHV0IG9mIGBjb25zb2xlLnRhYmxlKOKApilgIGFzIGEgc3RyaW5nLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFBlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoeyBkaXNhYmxlQ29sb3JzIH0gPSB7fSkge1xuICAgIHRoaXMudHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybSh7XG4gICAgICB0cmFuc2Zvcm0gKGNodW5rLCBfZW5jLCBjYikge1xuICAgICAgICBjYihudWxsLCBjaHVuaylcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5sb2dnZXIgPSBuZXcgQ29uc29sZSh7XG4gICAgICBzdGRvdXQ6IHRoaXMudHJhbnNmb3JtLFxuICAgICAgaW5zcGVjdE9wdGlvbnM6IHtcbiAgICAgICAgY29sb3JzOiAhZGlzYWJsZUNvbG9ycyAmJiAhcHJvY2Vzcy5lbnYuQ0lcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZm9ybWF0IChwZW5kaW5nSW50ZXJjZXB0b3JzKSB7XG4gICAgY29uc3Qgd2l0aFByZXR0eUhlYWRlcnMgPSBwZW5kaW5nSW50ZXJjZXB0b3JzLm1hcChcbiAgICAgICh7IG1ldGhvZCwgcGF0aCwgZGF0YTogeyBzdGF0dXNDb2RlIH0sIHBlcnNpc3QsIHRpbWVzLCB0aW1lc0ludm9rZWQsIG9yaWdpbiB9KSA9PiAoe1xuICAgICAgICBNZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgT3JpZ2luOiBvcmlnaW4sXG4gICAgICAgIFBhdGg6IHBhdGgsXG4gICAgICAgICdTdGF0dXMgY29kZSc6IHN0YXR1c0NvZGUsXG4gICAgICAgIFBlcnNpc3RlbnQ6IHBlcnNpc3QgPyAn4pyFJyA6ICfinYwnLFxuICAgICAgICBJbnZvY2F0aW9uczogdGltZXNJbnZva2VkLFxuICAgICAgICBSZW1haW5pbmc6IHBlcnNpc3QgPyBJbmZpbml0eSA6IHRpbWVzIC0gdGltZXNJbnZva2VkXG4gICAgICB9KSlcblxuICAgIHRoaXMubG9nZ2VyLnRhYmxlKHdpdGhQcmV0dHlIZWFkZXJzKVxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5yZWFkKCkudG9TdHJpbmcoKVxuICB9XG59XG4iXSwibmFtZXMiOlsiVHJhbnNmb3JtIiwicmVxdWlyZSIsIkNvbnNvbGUiLCJtb2R1bGUiLCJleHBvcnRzIiwiUGVuZGluZ0ludGVyY2VwdG9yc0Zvcm1hdHRlciIsImNvbnN0cnVjdG9yIiwiZGlzYWJsZUNvbG9ycyIsInRyYW5zZm9ybSIsImNodW5rIiwiX2VuYyIsImNiIiwibG9nZ2VyIiwic3Rkb3V0IiwiaW5zcGVjdE9wdGlvbnMiLCJjb2xvcnMiLCJwcm9jZXNzIiwiZW52IiwiQ0kiLCJmb3JtYXQiLCJwZW5kaW5nSW50ZXJjZXB0b3JzIiwid2l0aFByZXR0eUhlYWRlcnMiLCJtYXAiLCJtZXRob2QiLCJwYXRoIiwiZGF0YSIsInN0YXR1c0NvZGUiLCJwZXJzaXN0IiwidGltZXMiLCJ0aW1lc0ludm9rZWQiLCJvcmlnaW4iLCJNZXRob2QiLCJPcmlnaW4iLCJQYXRoIiwiUGVyc2lzdGVudCIsIkludm9jYXRpb25zIiwiUmVtYWluaW5nIiwiSW5maW5pdHkiLCJ0YWJsZSIsInJlYWQiLCJ0b1N0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/pending-interceptors-formatter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/pluralizer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/mock/pluralizer.js ***!
  \**************************************************************************/
/***/ ((module) => {

eval("\nconst singulars = {\n    pronoun: \"it\",\n    is: \"is\",\n    was: \"was\",\n    this: \"this\"\n};\nconst plurals = {\n    pronoun: \"they\",\n    is: \"are\",\n    was: \"were\",\n    this: \"these\"\n};\nmodule.exports = class Pluralizer {\n    constructor(singular, plural){\n        this.singular = singular;\n        this.plural = plural;\n    }\n    pluralize(count) {\n        const one = count === 1;\n        const keys = one ? singulars : plurals;\n        const noun = one ? this.singular : this.plural;\n        return {\n            ...keys,\n            count,\n            noun\n        };\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9wbHVyYWxpemVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsWUFBWTtJQUNoQkMsU0FBUztJQUNUQyxJQUFJO0lBQ0pDLEtBQUs7SUFDTEMsTUFBTTtBQUNSO0FBRUEsTUFBTUMsVUFBVTtJQUNkSixTQUFTO0lBQ1RDLElBQUk7SUFDSkMsS0FBSztJQUNMQyxNQUFNO0FBQ1I7QUFFQUUsT0FBT0MsT0FBTyxHQUFHLE1BQU1DO0lBQ3JCQyxZQUFhQyxRQUFRLEVBQUVDLE1BQU0sQ0FBRTtRQUM3QixJQUFJLENBQUNELFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO0lBQ2hCO0lBRUFDLFVBQVdDLEtBQUssRUFBRTtRQUNoQixNQUFNQyxNQUFNRCxVQUFVO1FBQ3RCLE1BQU1FLE9BQU9ELE1BQU1kLFlBQVlLO1FBQy9CLE1BQU1XLE9BQU9GLE1BQU0sSUFBSSxDQUFDSixRQUFRLEdBQUcsSUFBSSxDQUFDQyxNQUFNO1FBQzlDLE9BQU87WUFBRSxHQUFHSSxJQUFJO1lBQUVGO1lBQU9HO1FBQUs7SUFDaEM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svcGx1cmFsaXplci5qcz9mNGRmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBzaW5ndWxhcnMgPSB7XG4gIHByb25vdW46ICdpdCcsXG4gIGlzOiAnaXMnLFxuICB3YXM6ICd3YXMnLFxuICB0aGlzOiAndGhpcydcbn1cblxuY29uc3QgcGx1cmFscyA9IHtcbiAgcHJvbm91bjogJ3RoZXknLFxuICBpczogJ2FyZScsXG4gIHdhczogJ3dlcmUnLFxuICB0aGlzOiAndGhlc2UnXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUGx1cmFsaXplciB7XG4gIGNvbnN0cnVjdG9yIChzaW5ndWxhciwgcGx1cmFsKSB7XG4gICAgdGhpcy5zaW5ndWxhciA9IHNpbmd1bGFyXG4gICAgdGhpcy5wbHVyYWwgPSBwbHVyYWxcbiAgfVxuXG4gIHBsdXJhbGl6ZSAoY291bnQpIHtcbiAgICBjb25zdCBvbmUgPSBjb3VudCA9PT0gMVxuICAgIGNvbnN0IGtleXMgPSBvbmUgPyBzaW5ndWxhcnMgOiBwbHVyYWxzXG4gICAgY29uc3Qgbm91biA9IG9uZSA/IHRoaXMuc2luZ3VsYXIgOiB0aGlzLnBsdXJhbFxuICAgIHJldHVybiB7IC4uLmtleXMsIGNvdW50LCBub3VuIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbInNpbmd1bGFycyIsInByb25vdW4iLCJpcyIsIndhcyIsInRoaXMiLCJwbHVyYWxzIiwibW9kdWxlIiwiZXhwb3J0cyIsIlBsdXJhbGl6ZXIiLCJjb25zdHJ1Y3RvciIsInNpbmd1bGFyIiwicGx1cmFsIiwicGx1cmFsaXplIiwiY291bnQiLCJvbmUiLCJrZXlzIiwibm91biJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/mock/pluralizer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/node/fixed-queue.js":
/*!***************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/node/fixed-queue.js ***!
  \***************************************************************************/
/***/ ((module) => {

eval("/* eslint-disable */ \n// Extracted from node/lib/internal/fixed_queue.js\n// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048;\nconst kMask = kSize - 1;\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or, if there is only one circular buffer, it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one, removing means\n// moving `bottom` forward by one. After reaching the end, the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\nclass FixedCircularBuffer {\n    constructor(){\n        this.bottom = 0;\n        this.top = 0;\n        this.list = new Array(kSize);\n        this.next = null;\n    }\n    isEmpty() {\n        return this.top === this.bottom;\n    }\n    isFull() {\n        return (this.top + 1 & kMask) === this.bottom;\n    }\n    push(data) {\n        this.list[this.top] = data;\n        this.top = this.top + 1 & kMask;\n    }\n    shift() {\n        const nextItem = this.list[this.bottom];\n        if (nextItem === undefined) return null;\n        this.list[this.bottom] = undefined;\n        this.bottom = this.bottom + 1 & kMask;\n        return nextItem;\n    }\n}\nmodule.exports = class FixedQueue {\n    constructor(){\n        this.head = this.tail = new FixedCircularBuffer();\n    }\n    isEmpty() {\n        return this.head.isEmpty();\n    }\n    push(data) {\n        if (this.head.isFull()) {\n            // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n            // and sets it as the new main queue.\n            this.head = this.head.next = new FixedCircularBuffer();\n        }\n        this.head.push(data);\n    }\n    shift() {\n        const tail = this.tail;\n        const next = tail.shift();\n        if (tail.isEmpty() && tail.next !== null) {\n            // If there is another queue, it forms the new tail.\n            this.tail = tail.next;\n        }\n        return next;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbm9kZS9maXhlZC1xdWV1ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsR0FFbEI7QUFFQSxrREFBa0Q7QUFFbEQsOEVBQThFO0FBQzlFLE1BQU1BLFFBQVE7QUFDZCxNQUFNQyxRQUFRRCxRQUFRO0FBRXRCLHNFQUFzRTtBQUN0RSxrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLG1FQUFtRTtBQUNuRSxrRUFBa0U7QUFDbEUsa0VBQWtFO0FBQ2xFLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLDJFQUEyRTtBQUMzRSxFQUFFO0FBQ0YsK0RBQStEO0FBQy9ELHdCQUF3QjtBQUN4QixFQUFFO0FBQ0YsMkRBQTJEO0FBQzNELHlEQUF5RDtBQUN6RCx5REFBeUQ7QUFDekQsNERBQTREO0FBQzVELDREQUE0RDtBQUM1RCw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVELDREQUE0RDtBQUM1RCw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVELDREQUE0RDtBQUM1RCw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVELEVBQUU7QUFDRixtRUFBbUU7QUFDbkUsb0VBQW9FO0FBQ3BFLGdCQUFnQjtBQUNoQixFQUFFO0FBQ0YsNERBQTREO0FBQzVELHdFQUF3RTtBQUN4RSxrQ0FBa0M7QUFFbEMsTUFBTUU7SUFDSkMsYUFBYztRQUNaLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDQyxHQUFHLEdBQUc7UUFDWCxJQUFJLENBQUNDLElBQUksR0FBRyxJQUFJQyxNQUFNUDtRQUN0QixJQUFJLENBQUNRLElBQUksR0FBRztJQUNkO0lBRUFDLFVBQVU7UUFDUixPQUFPLElBQUksQ0FBQ0osR0FBRyxLQUFLLElBQUksQ0FBQ0QsTUFBTTtJQUNqQztJQUVBTSxTQUFTO1FBQ1AsT0FBTyxDQUFDLElBQUssQ0FBQ0wsR0FBRyxHQUFHLElBQUtKLEtBQUksTUFBTyxJQUFJLENBQUNHLE1BQU07SUFDakQ7SUFFQU8sS0FBS0MsSUFBSSxFQUFFO1FBQ1QsSUFBSSxDQUFDTixJQUFJLENBQUMsSUFBSSxDQUFDRCxHQUFHLENBQUMsR0FBR087UUFDdEIsSUFBSSxDQUFDUCxHQUFHLEdBQUcsSUFBSyxDQUFDQSxHQUFHLEdBQUcsSUFBS0o7SUFDOUI7SUFFQVksUUFBUTtRQUNOLE1BQU1DLFdBQVcsSUFBSSxDQUFDUixJQUFJLENBQUMsSUFBSSxDQUFDRixNQUFNLENBQUM7UUFDdkMsSUFBSVUsYUFBYUMsV0FDZixPQUFPO1FBQ1QsSUFBSSxDQUFDVCxJQUFJLENBQUMsSUFBSSxDQUFDRixNQUFNLENBQUMsR0FBR1c7UUFDekIsSUFBSSxDQUFDWCxNQUFNLEdBQUcsSUFBSyxDQUFDQSxNQUFNLEdBQUcsSUFBS0g7UUFDbEMsT0FBT2E7SUFDVDtBQUNGO0FBRUFFLE9BQU9DLE9BQU8sR0FBRyxNQUFNQztJQUNyQmYsYUFBYztRQUNaLElBQUksQ0FBQ2dCLElBQUksR0FBRyxJQUFJLENBQUNDLElBQUksR0FBRyxJQUFJbEI7SUFDOUI7SUFFQU8sVUFBVTtRQUNSLE9BQU8sSUFBSSxDQUFDVSxJQUFJLENBQUNWLE9BQU87SUFDMUI7SUFFQUUsS0FBS0MsSUFBSSxFQUFFO1FBQ1QsSUFBSSxJQUFJLENBQUNPLElBQUksQ0FBQ1QsTUFBTSxJQUFJO1lBQ3RCLHlFQUF5RTtZQUN6RSxxQ0FBcUM7WUFDckMsSUFBSSxDQUFDUyxJQUFJLEdBQUcsSUFBSSxDQUFDQSxJQUFJLENBQUNYLElBQUksR0FBRyxJQUFJTjtRQUNuQztRQUNBLElBQUksQ0FBQ2lCLElBQUksQ0FBQ1IsSUFBSSxDQUFDQztJQUNqQjtJQUVBQyxRQUFRO1FBQ04sTUFBTU8sT0FBTyxJQUFJLENBQUNBLElBQUk7UUFDdEIsTUFBTVosT0FBT1ksS0FBS1AsS0FBSztRQUN2QixJQUFJTyxLQUFLWCxPQUFPLE1BQU1XLEtBQUtaLElBQUksS0FBSyxNQUFNO1lBQ3hDLG9EQUFvRDtZQUNwRCxJQUFJLENBQUNZLElBQUksR0FBR0EsS0FBS1osSUFBSTtRQUN2QjtRQUNBLE9BQU9BO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL25vZGUvZml4ZWQtcXVldWUuanM/MDA0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4ndXNlIHN0cmljdCdcblxuLy8gRXh0cmFjdGVkIGZyb20gbm9kZS9saWIvaW50ZXJuYWwvZml4ZWRfcXVldWUuanNcblxuLy8gQ3VycmVudGx5IG9wdGltYWwgcXVldWUgc2l6ZSwgdGVzdGVkIG9uIFY4IDYuMCAtIDYuNi4gTXVzdCBiZSBwb3dlciBvZiB0d28uXG5jb25zdCBrU2l6ZSA9IDIwNDg7XG5jb25zdCBrTWFzayA9IGtTaXplIC0gMTtcblxuLy8gVGhlIEZpeGVkUXVldWUgaXMgaW1wbGVtZW50ZWQgYXMgYSBzaW5nbHktbGlua2VkIGxpc3Qgb2YgZml4ZWQtc2l6ZVxuLy8gY2lyY3VsYXIgYnVmZmVycy4gSXQgbG9va3Mgc29tZXRoaW5nIGxpa2UgdGhpczpcbi8vXG4vLyAgaGVhZCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWlsXG4vLyAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbi8vICAgIHYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdlxuLy8gKy0tLS0tLS0tLS0tKyA8LS0tLS1cXCAgICAgICArLS0tLS0tLS0tLS0rIDwtLS0tLS1cXCAgICAgICAgICstLS0tLS0tLS0tLStcbi8vIHwgIFtudWxsXSAgIHwgICAgICAgIFxcLS0tLS0gfCAgIG5leHQgICAgfCAgICAgICAgIFxcLS0tLS0tLSB8ICAgbmV4dCAgICB8XG4vLyArLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbi8vIHwgICBpdGVtICAgIHwgPC0tIGJvdHRvbSAgICB8ICAgaXRlbSAgICB8IDwtLSBib3R0b20gICAgICAgfCAgW2VtcHR5XSAgfFxuLy8gfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8ICBbZW1wdHldICB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgIFtlbXB0eV0gIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgW2VtcHR5XSAgfFxuLy8gfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgYm90dG9tIC0tPiB8ICAgaXRlbSAgICB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vIHwgICAgLi4uICAgIHwgICAgICAgICAgICAgICB8ICAgIC4uLiAgICB8ICAgICAgICAgICAgICAgICAgfCAgICAuLi4gICAgfFxuLy8gfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vIHwgIFtlbXB0eV0gIHwgPC0tIHRvcCAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCAgW2VtcHR5XSAgfCAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyB8ICBbZW1wdHldICB8ICAgICAgICAgICAgICAgfCAgW2VtcHR5XSAgfCA8LS0gdG9wICB0b3AgLS0+IHwgIFtlbXB0eV0gIHxcbi8vICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy9cbi8vIE9yLCBpZiB0aGVyZSBpcyBvbmx5IG9uZSBjaXJjdWxhciBidWZmZXIsIGl0IGxvb2tzIHNvbWV0aGluZ1xuLy8gbGlrZSBlaXRoZXIgb2YgdGhlc2U6XG4vL1xuLy8gIGhlYWQgICB0YWlsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZCAgIHRhaWxcbi8vICAgIHwgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfFxuLy8gICAgdiAgICAgdiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ICAgICB2XG4vLyArLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbi8vIHwgIFtudWxsXSAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgW251bGxdICAgfFxuLy8gKy0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4vLyB8ICBbZW1wdHldICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vIHwgIFtlbXB0eV0gIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCAgIGl0ZW0gICAgfCA8LS0gYm90dG9tICAgICAgICAgICAgdG9wIC0tPiB8ICBbZW1wdHldICB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIFtlbXB0eV0gIHxcbi8vIHwgIFtlbXB0eV0gIHwgPC0tIHRvcCAgICAgICAgICAgIGJvdHRvbSAtLT4gfCAgIGl0ZW0gICAgfFxuLy8gfCAgW2VtcHR5XSAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyArLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbi8vXG4vLyBBZGRpbmcgYSB2YWx1ZSBtZWFucyBtb3ZpbmcgYHRvcGAgZm9yd2FyZCBieSBvbmUsIHJlbW92aW5nIG1lYW5zXG4vLyBtb3ZpbmcgYGJvdHRvbWAgZm9yd2FyZCBieSBvbmUuIEFmdGVyIHJlYWNoaW5nIHRoZSBlbmQsIHRoZSBxdWV1ZVxuLy8gd3JhcHMgYXJvdW5kLlxuLy9cbi8vIFdoZW4gYHRvcCA9PT0gYm90dG9tYCB0aGUgY3VycmVudCBxdWV1ZSBpcyBlbXB0eSBhbmQgd2hlblxuLy8gYHRvcCArIDEgPT09IGJvdHRvbWAgaXQncyBmdWxsLiBUaGlzIHdhc3RlcyBhIHNpbmdsZSBzcGFjZSBvZiBzdG9yYWdlXG4vLyBidXQgYWxsb3dzIG11Y2ggcXVpY2tlciBjaGVja3MuXG5cbmNsYXNzIEZpeGVkQ2lyY3VsYXJCdWZmZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmJvdHRvbSA9IDA7XG4gICAgdGhpcy50b3AgPSAwO1xuICAgIHRoaXMubGlzdCA9IG5ldyBBcnJheShrU2l6ZSk7XG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgfVxuXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9wID09PSB0aGlzLmJvdHRvbTtcbiAgfVxuXG4gIGlzRnVsbCgpIHtcbiAgICByZXR1cm4gKCh0aGlzLnRvcCArIDEpICYga01hc2spID09PSB0aGlzLmJvdHRvbTtcbiAgfVxuXG4gIHB1c2goZGF0YSkge1xuICAgIHRoaXMubGlzdFt0aGlzLnRvcF0gPSBkYXRhO1xuICAgIHRoaXMudG9wID0gKHRoaXMudG9wICsgMSkgJiBrTWFzaztcbiAgfVxuXG4gIHNoaWZ0KCkge1xuICAgIGNvbnN0IG5leHRJdGVtID0gdGhpcy5saXN0W3RoaXMuYm90dG9tXTtcbiAgICBpZiAobmV4dEl0ZW0gPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHRoaXMubGlzdFt0aGlzLmJvdHRvbV0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSAodGhpcy5ib3R0b20gKyAxKSAmIGtNYXNrO1xuICAgIHJldHVybiBuZXh0SXRlbTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEZpeGVkUXVldWUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgRml4ZWRDaXJjdWxhckJ1ZmZlcigpO1xuICB9XG5cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5oZWFkLmlzRW1wdHkoKTtcbiAgfVxuXG4gIHB1c2goZGF0YSkge1xuICAgIGlmICh0aGlzLmhlYWQuaXNGdWxsKCkpIHtcbiAgICAgIC8vIEhlYWQgaXMgZnVsbDogQ3JlYXRlcyBhIG5ldyBxdWV1ZSwgc2V0cyB0aGUgb2xkIHF1ZXVlJ3MgYC5uZXh0YCB0byBpdCxcbiAgICAgIC8vIGFuZCBzZXRzIGl0IGFzIHRoZSBuZXcgbWFpbiBxdWV1ZS5cbiAgICAgIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0ID0gbmV3IEZpeGVkQ2lyY3VsYXJCdWZmZXIoKTtcbiAgICB9XG4gICAgdGhpcy5oZWFkLnB1c2goZGF0YSk7XG4gIH1cblxuICBzaGlmdCgpIHtcbiAgICBjb25zdCB0YWlsID0gdGhpcy50YWlsO1xuICAgIGNvbnN0IG5leHQgPSB0YWlsLnNoaWZ0KCk7XG4gICAgaWYgKHRhaWwuaXNFbXB0eSgpICYmIHRhaWwubmV4dCAhPT0gbnVsbCkge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgYW5vdGhlciBxdWV1ZSwgaXQgZm9ybXMgdGhlIG5ldyB0YWlsLlxuICAgICAgdGhpcy50YWlsID0gdGFpbC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gbmV4dDtcbiAgfVxufTtcbiJdLCJuYW1lcyI6WyJrU2l6ZSIsImtNYXNrIiwiRml4ZWRDaXJjdWxhckJ1ZmZlciIsImNvbnN0cnVjdG9yIiwiYm90dG9tIiwidG9wIiwibGlzdCIsIkFycmF5IiwibmV4dCIsImlzRW1wdHkiLCJpc0Z1bGwiLCJwdXNoIiwiZGF0YSIsInNoaWZ0IiwibmV4dEl0ZW0iLCJ1bmRlZmluZWQiLCJtb2R1bGUiLCJleHBvcnRzIiwiRml4ZWRRdWV1ZSIsImhlYWQiLCJ0YWlsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/node/fixed-queue.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/pool-base.js":
/*!********************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/pool-base.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/dispatcher-base.js\");\nconst FixedQueue = __webpack_require__(/*! ./node/fixed-queue */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/node/fixed-queue.js\");\nconst { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = __webpack_require__(/*! ./core/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\");\nconst PoolStats = __webpack_require__(/*! ./pool-stats */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/pool-stats.js\");\nconst kClients = Symbol(\"clients\");\nconst kNeedDrain = Symbol(\"needDrain\");\nconst kQueue = Symbol(\"queue\");\nconst kClosedResolve = Symbol(\"closed resolve\");\nconst kOnDrain = Symbol(\"onDrain\");\nconst kOnConnect = Symbol(\"onConnect\");\nconst kOnDisconnect = Symbol(\"onDisconnect\");\nconst kOnConnectionError = Symbol(\"onConnectionError\");\nconst kGetDispatcher = Symbol(\"get dispatcher\");\nconst kAddClient = Symbol(\"add client\");\nconst kRemoveClient = Symbol(\"remove client\");\nconst kStats = Symbol(\"stats\");\nclass PoolBase extends DispatcherBase {\n    constructor(){\n        super();\n        this[kQueue] = new FixedQueue();\n        this[kClients] = [];\n        this[kQueued] = 0;\n        const pool = this;\n        this[kOnDrain] = function onDrain(origin, targets) {\n            const queue = pool[kQueue];\n            let needDrain = false;\n            while(!needDrain){\n                const item = queue.shift();\n                if (!item) {\n                    break;\n                }\n                pool[kQueued]--;\n                needDrain = !this.dispatch(item.opts, item.handler);\n            }\n            this[kNeedDrain] = needDrain;\n            if (!this[kNeedDrain] && pool[kNeedDrain]) {\n                pool[kNeedDrain] = false;\n                pool.emit(\"drain\", origin, [\n                    pool,\n                    ...targets\n                ]);\n            }\n            if (pool[kClosedResolve] && queue.isEmpty()) {\n                Promise.all(pool[kClients].map((c)=>c.close())).then(pool[kClosedResolve]);\n            }\n        };\n        this[kOnConnect] = (origin, targets)=>{\n            pool.emit(\"connect\", origin, [\n                pool,\n                ...targets\n            ]);\n        };\n        this[kOnDisconnect] = (origin, targets, err)=>{\n            pool.emit(\"disconnect\", origin, [\n                pool,\n                ...targets\n            ], err);\n        };\n        this[kOnConnectionError] = (origin, targets, err)=>{\n            pool.emit(\"connectionError\", origin, [\n                pool,\n                ...targets\n            ], err);\n        };\n        this[kStats] = new PoolStats(this);\n    }\n    get [kBusy]() {\n        return this[kNeedDrain];\n    }\n    get [kConnected]() {\n        return this[kClients].filter((client)=>client[kConnected]).length;\n    }\n    get [kFree]() {\n        return this[kClients].filter((client)=>client[kConnected] && !client[kNeedDrain]).length;\n    }\n    get [kPending]() {\n        let ret = this[kQueued];\n        for (const { [kPending]: pending } of this[kClients]){\n            ret += pending;\n        }\n        return ret;\n    }\n    get [kRunning]() {\n        let ret = 0;\n        for (const { [kRunning]: running } of this[kClients]){\n            ret += running;\n        }\n        return ret;\n    }\n    get [kSize]() {\n        let ret = this[kQueued];\n        for (const { [kSize]: size } of this[kClients]){\n            ret += size;\n        }\n        return ret;\n    }\n    get stats() {\n        return this[kStats];\n    }\n    async [kClose]() {\n        if (this[kQueue].isEmpty()) {\n            return Promise.all(this[kClients].map((c)=>c.close()));\n        } else {\n            return new Promise((resolve)=>{\n                this[kClosedResolve] = resolve;\n            });\n        }\n    }\n    async [kDestroy](err) {\n        while(true){\n            const item = this[kQueue].shift();\n            if (!item) {\n                break;\n            }\n            item.handler.onError(err);\n        }\n        return Promise.all(this[kClients].map((c)=>c.destroy(err)));\n    }\n    [kDispatch](opts, handler) {\n        const dispatcher = this[kGetDispatcher]();\n        if (!dispatcher) {\n            this[kNeedDrain] = true;\n            this[kQueue].push({\n                opts,\n                handler\n            });\n            this[kQueued]++;\n        } else if (!dispatcher.dispatch(opts, handler)) {\n            dispatcher[kNeedDrain] = true;\n            this[kNeedDrain] = !this[kGetDispatcher]();\n        }\n        return !this[kNeedDrain];\n    }\n    [kAddClient](client) {\n        client.on(\"drain\", this[kOnDrain]).on(\"connect\", this[kOnConnect]).on(\"disconnect\", this[kOnDisconnect]).on(\"connectionError\", this[kOnConnectionError]);\n        this[kClients].push(client);\n        if (this[kNeedDrain]) {\n            process.nextTick(()=>{\n                if (this[kNeedDrain]) {\n                    this[kOnDrain](client[kUrl], [\n                        this,\n                        client\n                    ]);\n                }\n            });\n        }\n        return this;\n    }\n    [kRemoveClient](client) {\n        client.close(()=>{\n            const idx = this[kClients].indexOf(client);\n            if (idx !== -1) {\n                this[kClients].splice(idx, 1);\n            }\n        });\n        this[kNeedDrain] = this[kClients].some((dispatcher)=>!dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);\n    }\n}\nmodule.exports = {\n    PoolBase,\n    kClients,\n    kNeedDrain,\n    kAddClient,\n    kRemoveClient,\n    kGetDispatcher\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvcG9vbC1iYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsaUJBQWlCQyxtQkFBT0EsQ0FBQztBQUMvQixNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUVFLFVBQVUsRUFBRUMsS0FBSyxFQUFFQyxRQUFRLEVBQUVDLFFBQVEsRUFBRUMsT0FBTyxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFLEdBQUdaLG1CQUFPQSxDQUFDO0FBQ3BILE1BQU1hLFlBQVliLG1CQUFPQSxDQUFDO0FBRTFCLE1BQU1jLFdBQVdDLE9BQU87QUFDeEIsTUFBTUMsYUFBYUQsT0FBTztBQUMxQixNQUFNRSxTQUFTRixPQUFPO0FBQ3RCLE1BQU1HLGlCQUFpQkgsT0FBTztBQUM5QixNQUFNSSxXQUFXSixPQUFPO0FBQ3hCLE1BQU1LLGFBQWFMLE9BQU87QUFDMUIsTUFBTU0sZ0JBQWdCTixPQUFPO0FBQzdCLE1BQU1PLHFCQUFxQlAsT0FBTztBQUNsQyxNQUFNUSxpQkFBaUJSLE9BQU87QUFDOUIsTUFBTVMsYUFBYVQsT0FBTztBQUMxQixNQUFNVSxnQkFBZ0JWLE9BQU87QUFDN0IsTUFBTVcsU0FBU1gsT0FBTztBQUV0QixNQUFNWSxpQkFBaUI1QjtJQUNyQjZCLGFBQWU7UUFDYixLQUFLO1FBRUwsSUFBSSxDQUFDWCxPQUFPLEdBQUcsSUFBSWhCO1FBQ25CLElBQUksQ0FBQ2EsU0FBUyxHQUFHLEVBQUU7UUFDbkIsSUFBSSxDQUFDUixRQUFRLEdBQUc7UUFFaEIsTUFBTXVCLE9BQU8sSUFBSTtRQUVqQixJQUFJLENBQUNWLFNBQVMsR0FBRyxTQUFTVyxRQUFTQyxNQUFNLEVBQUVDLE9BQU87WUFDaEQsTUFBTUMsUUFBUUosSUFBSSxDQUFDWixPQUFPO1lBRTFCLElBQUlpQixZ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ZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3Bvb2wtYmFzZS5qcz83YTY2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBEaXNwYXRjaGVyQmFzZSA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hlci1iYXNlJylcbmNvbnN0IEZpeGVkUXVldWUgPSByZXF1aXJlKCcuL25vZGUvZml4ZWQtcXVldWUnKVxuY29uc3QgeyBrQ29ubmVjdGVkLCBrU2l6ZSwga1J1bm5pbmcsIGtQZW5kaW5nLCBrUXVldWVkLCBrQnVzeSwga0ZyZWUsIGtVcmwsIGtDbG9zZSwga0Rlc3Ryb3ksIGtEaXNwYXRjaCB9ID0gcmVxdWlyZSgnLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgUG9vbFN0YXRzID0gcmVxdWlyZSgnLi9wb29sLXN0YXRzJylcblxuY29uc3Qga0NsaWVudHMgPSBTeW1ib2woJ2NsaWVudHMnKVxuY29uc3Qga05lZWREcmFpbiA9IFN5bWJvbCgnbmVlZERyYWluJylcbmNvbnN0IGtRdWV1ZSA9IFN5bWJvbCgncXVldWUnKVxuY29uc3Qga0Nsb3NlZFJlc29sdmUgPSBTeW1ib2woJ2Nsb3NlZCByZXNvbHZlJylcbmNvbnN0IGtPbkRyYWluID0gU3ltYm9sKCdvbkRyYWluJylcbmNvbnN0IGtPbkNvbm5lY3QgPSBTeW1ib2woJ29uQ29ubmVjdCcpXG5jb25zdCBrT25EaXNjb25uZWN0ID0gU3ltYm9sKCdvbkRpc2Nvbm5lY3QnKVxuY29uc3Qga09uQ29ubmVjdGlvbkVycm9yID0gU3ltYm9sKCdvbkNvbm5lY3Rpb25FcnJvcicpXG5jb25zdCBrR2V0RGlzcGF0Y2hlciA9IFN5bWJvbCgnZ2V0IGRpc3BhdGNoZXInKVxuY29uc3Qga0FkZENsaWVudCA9IFN5bWJvbCgnYWRkIGNsaWVudCcpXG5jb25zdCBrUmVtb3ZlQ2xpZW50ID0gU3ltYm9sKCdyZW1vdmUgY2xpZW50JylcbmNvbnN0IGtTdGF0cyA9IFN5bWJvbCgnc3RhdHMnKVxuXG5jbGFzcyBQb29sQmFzZSBleHRlbmRzIERpc3BhdGNoZXJCYXNlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXNba1F1ZXVlXSA9IG5ldyBGaXhlZFF1ZXVlKClcbiAgICB0aGlzW2tDbGllbnRzXSA9IFtdXG4gICAgdGhpc1trUXVldWVkXSA9IDBcblxuICAgIGNvbnN0IHBvb2wgPSB0aGlzXG5cbiAgICB0aGlzW2tPbkRyYWluXSA9IGZ1bmN0aW9uIG9uRHJhaW4gKG9yaWdpbiwgdGFyZ2V0cykge1xuICAgICAgY29uc3QgcXVldWUgPSBwb29sW2tRdWV1ZV1cblxuICAgICAgbGV0IG5lZWREcmFpbiA9IGZhbHNlXG5cbiAgICAgIHdoaWxlICghbmVlZERyYWluKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBxdWV1ZS5zaGlmdCgpXG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgcG9vbFtrUXVldWVkXS0tXG4gICAgICAgIG5lZWREcmFpbiA9ICF0aGlzLmRpc3BhdGNoKGl0ZW0ub3B0cywgaXRlbS5oYW5kbGVyKVxuICAgICAgfVxuXG4gICAgICB0aGlzW2tOZWVkRHJhaW5dID0gbmVlZERyYWluXG5cbiAgICAgIGlmICghdGhpc1trTmVlZERyYWluXSAmJiBwb29sW2tOZWVkRHJhaW5dKSB7XG4gICAgICAgIHBvb2xba05lZWREcmFpbl0gPSBmYWxzZVxuICAgICAgICBwb29sLmVtaXQoJ2RyYWluJywgb3JpZ2luLCBbcG9vbCwgLi4udGFyZ2V0c10pXG4gICAgICB9XG5cbiAgICAgIGlmIChwb29sW2tDbG9zZWRSZXNvbHZlXSAmJiBxdWV1ZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgUHJvbWlzZVxuICAgICAgICAgIC5hbGwocG9vbFtrQ2xpZW50c10ubWFwKGMgPT4gYy5jbG9zZSgpKSlcbiAgICAgICAgICAudGhlbihwb29sW2tDbG9zZWRSZXNvbHZlXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzW2tPbkNvbm5lY3RdID0gKG9yaWdpbiwgdGFyZ2V0cykgPT4ge1xuICAgICAgcG9vbC5lbWl0KCdjb25uZWN0Jywgb3JpZ2luLCBbcG9vbCwgLi4udGFyZ2V0c10pXG4gICAgfVxuXG4gICAgdGhpc1trT25EaXNjb25uZWN0XSA9IChvcmlnaW4sIHRhcmdldHMsIGVycikgPT4ge1xuICAgICAgcG9vbC5lbWl0KCdkaXNjb25uZWN0Jywgb3JpZ2luLCBbcG9vbCwgLi4udGFyZ2V0c10sIGVycilcbiAgICB9XG5cbiAgICB0aGlzW2tPbkNvbm5lY3Rpb25FcnJvcl0gPSAob3JpZ2luLCB0YXJnZXRzLCBlcnIpID0+IHtcbiAgICAgIHBvb2wuZW1pdCgnY29ubmVjdGlvbkVycm9yJywgb3JpZ2luLCBbcG9vbCwgLi4udGFyZ2V0c10sIGVycilcbiAgICB9XG5cbiAgICB0aGlzW2tTdGF0c10gPSBuZXcgUG9vbFN0YXRzKHRoaXMpXG4gIH1cblxuICBnZXQgW2tCdXN5XSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba05lZWREcmFpbl1cbiAgfVxuXG4gIGdldCBba0Nvbm5lY3RlZF0gKCkge1xuICAgIHJldHVybiB0aGlzW2tDbGllbnRzXS5maWx0ZXIoY2xpZW50ID0+IGNsaWVudFtrQ29ubmVjdGVkXSkubGVuZ3RoXG4gIH1cblxuICBnZXQgW2tGcmVlXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0NsaWVudHNdLmZpbHRlcihjbGllbnQgPT4gY2xpZW50W2tDb25uZWN0ZWRdICYmICFjbGllbnRba05lZWREcmFpbl0pLmxlbmd0aFxuICB9XG5cbiAgZ2V0IFtrUGVuZGluZ10gKCkge1xuICAgIGxldCByZXQgPSB0aGlzW2tRdWV1ZWRdXG4gICAgZm9yIChjb25zdCB7IFtrUGVuZGluZ106IHBlbmRpbmcgfSBvZiB0aGlzW2tDbGllbnRzXSkge1xuICAgICAgcmV0ICs9IHBlbmRpbmdcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgZ2V0IFtrUnVubmluZ10gKCkge1xuICAgIGxldCByZXQgPSAwXG4gICAgZm9yIChjb25zdCB7IFtrUnVubmluZ106IHJ1bm5pbmcgfSBvZiB0aGlzW2tDbGllbnRzXSkge1xuICAgICAgcmV0ICs9IHJ1bm5pbmdcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgZ2V0IFtrU2l6ZV0gKCkge1xuICAgIGxldCByZXQgPSB0aGlzW2tRdWV1ZWRdXG4gICAgZm9yIChjb25zdCB7IFtrU2l6ZV06IHNpemUgfSBvZiB0aGlzW2tDbGllbnRzXSkge1xuICAgICAgcmV0ICs9IHNpemVcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgZ2V0IHN0YXRzICgpIHtcbiAgICByZXR1cm4gdGhpc1trU3RhdHNdXG4gIH1cblxuICBhc3luYyBba0Nsb3NlXSAoKSB7XG4gICAgaWYgKHRoaXNba1F1ZXVlXS5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzW2tDbGllbnRzXS5tYXAoYyA9PiBjLmNsb3NlKCkpKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgdGhpc1trQ2xvc2VkUmVzb2x2ZV0gPSByZXNvbHZlXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIFtrRGVzdHJveV0gKGVycikge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBpdGVtID0gdGhpc1trUXVldWVdLnNoaWZ0KClcbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaXRlbS5oYW5kbGVyLm9uRXJyb3IoZXJyKVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzW2tDbGllbnRzXS5tYXAoYyA9PiBjLmRlc3Ryb3koZXJyKSkpXG4gIH1cblxuICBba0Rpc3BhdGNoXSAob3B0cywgaGFuZGxlcikge1xuICAgIGNvbnN0IGRpc3BhdGNoZXIgPSB0aGlzW2tHZXREaXNwYXRjaGVyXSgpXG5cbiAgICBpZiAoIWRpc3BhdGNoZXIpIHtcbiAgICAgIHRoaXNba05lZWREcmFpbl0gPSB0cnVlXG4gICAgICB0aGlzW2tRdWV1ZV0ucHVzaCh7IG9wdHMsIGhhbmRsZXIgfSlcbiAgICAgIHRoaXNba1F1ZXVlZF0rK1xuICAgIH0gZWxzZSBpZiAoIWRpc3BhdGNoZXIuZGlzcGF0Y2gob3B0cywgaGFuZGxlcikpIHtcbiAgICAgIGRpc3BhdGNoZXJba05lZWREcmFpbl0gPSB0cnVlXG4gICAgICB0aGlzW2tOZWVkRHJhaW5dID0gIXRoaXNba0dldERpc3BhdGNoZXJdKClcbiAgICB9XG5cbiAgICByZXR1cm4gIXRoaXNba05lZWREcmFpbl1cbiAgfVxuXG4gIFtrQWRkQ2xpZW50XSAoY2xpZW50KSB7XG4gICAgY2xpZW50XG4gICAgICAub24oJ2RyYWluJywgdGhpc1trT25EcmFpbl0pXG4gICAgICAub24oJ2Nvbm5lY3QnLCB0aGlzW2tPbkNvbm5lY3RdKVxuICAgICAgLm9uKCdkaXNjb25uZWN0JywgdGhpc1trT25EaXNjb25uZWN0XSlcbiAgICAgIC5vbignY29ubmVjdGlvbkVycm9yJywgdGhpc1trT25Db25uZWN0aW9uRXJyb3JdKVxuXG4gICAgdGhpc1trQ2xpZW50c10ucHVzaChjbGllbnQpXG5cbiAgICBpZiAodGhpc1trTmVlZERyYWluXSkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzW2tOZWVkRHJhaW5dKSB7XG4gICAgICAgICAgdGhpc1trT25EcmFpbl0oY2xpZW50W2tVcmxdLCBbdGhpcywgY2xpZW50XSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgW2tSZW1vdmVDbGllbnRdIChjbGllbnQpIHtcbiAgICBjbGllbnQuY2xvc2UoKCkgPT4ge1xuICAgICAgY29uc3QgaWR4ID0gdGhpc1trQ2xpZW50c10uaW5kZXhPZihjbGllbnQpXG4gICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICB0aGlzW2tDbGllbnRzXS5zcGxpY2UoaWR4LCAxKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzW2tOZWVkRHJhaW5dID0gdGhpc1trQ2xpZW50c10uc29tZShkaXNwYXRjaGVyID0+IChcbiAgICAgICFkaXNwYXRjaGVyW2tOZWVkRHJhaW5dICYmXG4gICAgICBkaXNwYXRjaGVyLmNsb3NlZCAhPT0gdHJ1ZSAmJlxuICAgICAgZGlzcGF0Y2hlci5kZXN0cm95ZWQgIT09IHRydWVcbiAgICApKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBQb29sQmFzZSxcbiAga0NsaWVudHMsXG4gIGtOZWVkRHJhaW4sXG4gIGtBZGRDbGllbnQsXG4gIGtSZW1vdmVDbGllbnQsXG4gIGtHZXREaXNwYXRjaGVyXG59XG4iXSwibmFtZXMiOlsiRGlzcGF0Y2hlckJhc2UiLCJyZXF1aXJlIiwiRml4ZWRRdWV1ZSIsImtDb25uZWN0ZWQiLCJrU2l6ZSIsImtSdW5uaW5nIiwia1BlbmRpbmciLCJrUXVldWVkIiwia0J1c3kiLCJrRnJlZSIsImtVcmwiLCJrQ2xvc2UiLCJrRGVzdHJveSIsImtEaXNwYXRjaCIsIlBvb2xTdGF0cyIsImtDbGllbnRzIiwiU3ltYm9sIiwia05lZWREcmFpbiIsImtRdWV1ZSIsImtDbG9zZWRSZXNvbHZlIiwia09uRHJhaW4iLCJrT25Db25uZWN0Iiwia09uRGlzY29ubmVjdCIsImtPbkNvbm5lY3Rpb25FcnJvciIsImtHZXREaXNwYXRjaGVyIiwia0FkZENsaWVudCIsImtSZW1vdmVDbGllbnQiLCJrU3RhdHMiLCJQb29sQmFzZSIsImNvbnN0cnVjdG9yIiwicG9vbCIsIm9uRHJhaW4iLCJvcmlnaW4iLCJ0YXJnZXRzIiwicXVldWUiLCJuZWVkRHJhaW4iLCJpdGVtIiwic2hpZnQiLCJkaXNwYXRjaCIsIm9wdHMiLCJoYW5kbGVyIiwiZW1pdCIsImlzRW1wdHkiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwiYyIsImNsb3NlIiwidGhlbiIsImVyciIsImZpbHRlciIsImNsaWVudCIsImxlbmd0aCIsInJldCIsInBlbmRpbmciLCJydW5uaW5nIiwic2l6ZSIsInN0YXRzIiwicmVzb2x2ZSIsIm9uRXJyb3IiLCJkZXN0cm95IiwiZGlzcGF0Y2hlciIsInB1c2giLCJvbiIsInByb2Nlc3MiLCJuZXh0VGljayIsImlkeCIsImluZGV4T2YiLCJzcGxpY2UiLCJzb21lIiwiY2xvc2VkIiwiZGVzdHJveWVkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/pool-base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/pool-stats.js":
/*!*********************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/pool-stats.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kFree, kConnected, kPending, kQueued, kRunning, kSize } = __webpack_require__(/*! ./core/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\");\nconst kPool = Symbol(\"pool\");\nclass PoolStats {\n    constructor(pool){\n        this[kPool] = pool;\n    }\n    get connected() {\n        return this[kPool][kConnected];\n    }\n    get free() {\n        return this[kPool][kFree];\n    }\n    get pending() {\n        return this[kPool][kPending];\n    }\n    get queued() {\n        return this[kPool][kQueued];\n    }\n    get running() {\n        return this[kPool][kRunning];\n    }\n    get size() {\n        return this[kPool][kSize];\n    }\n}\nmodule.exports = PoolStats;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvcG9vbC1zdGF0cy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxFQUFFQSxLQUFLLEVBQUVDLFVBQVUsRUFBRUMsUUFBUSxFQUFFQyxPQUFPLEVBQUVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzFFLE1BQU1DLFFBQVFDLE9BQU87QUFFckIsTUFBTUM7SUFDSkMsWUFBYUMsSUFBSSxDQUFFO1FBQ2pCLElBQUksQ0FBQ0osTUFBTSxHQUFHSTtJQUNoQjtJQUVBLElBQUlDLFlBQWE7UUFDZixPQUFPLElBQUksQ0FBQ0wsTUFBTSxDQUFDTixXQUFXO0lBQ2hDO0lBRUEsSUFBSVksT0FBUTtRQUNWLE9BQU8sSUFBSSxDQUFDTixNQUFNLENBQUNQLE1BQU07SUFDM0I7SUFFQSxJQUFJYyxVQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUNQLE1BQU0sQ0FBQ0wsU0FBUztJQUM5QjtJQUVBLElBQUlhLFNBQVU7UUFDWixPQUFPLElBQUksQ0FBQ1IsTUFBTSxDQUFDSixRQUFRO0lBQzdCO0lBRUEsSUFBSWEsVUFBVztRQUNiLE9BQU8sSUFBSSxDQUFDVCxNQUFNLENBQUNILFNBQVM7SUFDOUI7SUFFQSxJQUFJYSxPQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUNWLE1BQU0sQ0FBQ0YsTUFBTTtJQUMzQjtBQUNGO0FBRUFhLE9BQU9DLE9BQU8sR0FBR1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9wb29sLXN0YXRzLmpzPzYwZTUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBrRnJlZSwga0Nvbm5lY3RlZCwga1BlbmRpbmcsIGtRdWV1ZWQsIGtSdW5uaW5nLCBrU2l6ZSB9ID0gcmVxdWlyZSgnLi9jb3JlL3N5bWJvbHMnKVxuY29uc3Qga1Bvb2wgPSBTeW1ib2woJ3Bvb2wnKVxuXG5jbGFzcyBQb29sU3RhdHMge1xuICBjb25zdHJ1Y3RvciAocG9vbCkge1xuICAgIHRoaXNba1Bvb2xdID0gcG9vbFxuICB9XG5cbiAgZ2V0IGNvbm5lY3RlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1Bvb2xdW2tDb25uZWN0ZWRdXG4gIH1cblxuICBnZXQgZnJlZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1Bvb2xdW2tGcmVlXVxuICB9XG5cbiAgZ2V0IHBlbmRpbmcgKCkge1xuICAgIHJldHVybiB0aGlzW2tQb29sXVtrUGVuZGluZ11cbiAgfVxuXG4gIGdldCBxdWV1ZWQgKCkge1xuICAgIHJldHVybiB0aGlzW2tQb29sXVtrUXVldWVkXVxuICB9XG5cbiAgZ2V0IHJ1bm5pbmcgKCkge1xuICAgIHJldHVybiB0aGlzW2tQb29sXVtrUnVubmluZ11cbiAgfVxuXG4gIGdldCBzaXplICgpIHtcbiAgICByZXR1cm4gdGhpc1trUG9vbF1ba1NpemVdXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQb29sU3RhdHNcbiJdLCJuYW1lcyI6WyJrRnJlZSIsImtDb25uZWN0ZWQiLCJrUGVuZGluZyIsImtRdWV1ZWQiLCJrUnVubmluZyIsImtTaXplIiwicmVxdWlyZSIsImtQb29sIiwiU3ltYm9sIiwiUG9vbFN0YXRzIiwiY29uc3RydWN0b3IiLCJwb29sIiwiY29ubmVjdGVkIiwiZnJlZSIsInBlbmRpbmciLCJxdWV1ZWQiLCJydW5uaW5nIiwic2l6ZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/pool-stats.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/pool.js":
/*!***************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/pool.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { PoolBase, kClients, kNeedDrain, kAddClient, kGetDispatcher } = __webpack_require__(/*! ./pool-base */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/pool-base.js\");\nconst Client = __webpack_require__(/*! ./client */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/client.js\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ./core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst { kUrl, kInterceptors } = __webpack_require__(/*! ./core/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\");\nconst buildConnector = __webpack_require__(/*! ./core/connect */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/connect.js\");\nconst kOptions = Symbol(\"options\");\nconst kConnections = Symbol(\"connections\");\nconst kFactory = Symbol(\"factory\");\nfunction defaultFactory(origin, opts) {\n    return new Client(origin, opts);\n}\nclass Pool extends PoolBase {\n    constructor(origin, { connections, factory = defaultFactory, connect, connectTimeout, tls, maxCachedSessions, socketPath, autoSelectFamily, autoSelectFamilyAttemptTimeout, allowH2, ...options } = {}){\n        super();\n        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {\n            throw new InvalidArgumentError(\"invalid connections\");\n        }\n        if (typeof factory !== \"function\") {\n            throw new InvalidArgumentError(\"factory must be a function.\");\n        }\n        if (connect != null && typeof connect !== \"function\" && typeof connect !== \"object\") {\n            throw new InvalidArgumentError(\"connect must be a function or an object\");\n        }\n        if (typeof connect !== \"function\") {\n            connect = buildConnector({\n                ...tls,\n                maxCachedSessions,\n                allowH2,\n                socketPath,\n                timeout: connectTimeout,\n                ...util.nodeHasAutoSelectFamily && autoSelectFamily ? {\n                    autoSelectFamily,\n                    autoSelectFamilyAttemptTimeout\n                } : undefined,\n                ...connect\n            });\n        }\n        this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];\n        this[kConnections] = connections || null;\n        this[kUrl] = util.parseOrigin(origin);\n        this[kOptions] = {\n            ...util.deepClone(options),\n            connect,\n            allowH2\n        };\n        this[kOptions].interceptors = options.interceptors ? {\n            ...options.interceptors\n        } : undefined;\n        this[kFactory] = factory;\n    }\n    [kGetDispatcher]() {\n        let dispatcher = this[kClients].find((dispatcher)=>!dispatcher[kNeedDrain]);\n        if (dispatcher) {\n            return dispatcher;\n        }\n        if (!this[kConnections] || this[kClients].length < this[kConnections]) {\n            dispatcher = this[kFactory](this[kUrl], this[kOptions]);\n            this[kAddClient](dispatcher);\n        }\n        return dispatcher;\n    }\n}\nmodule.exports = Pool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvcG9vbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFDSkEsUUFBUSxFQUNSQyxRQUFRLEVBQ1JDLFVBQVUsRUFDVkMsVUFBVSxFQUNWQyxjQUFjLEVBQ2YsR0FBR0MsbUJBQU9BLENBQUM7QUFDWixNQUFNQyxTQUFTRCxtQkFBT0EsQ0FBQztBQUN2QixNQUFNLEVBQ0pFLG9CQUFvQixFQUNyQixHQUFHRixtQkFBT0EsQ0FBQztBQUNaLE1BQU1HLE9BQU9ILG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRUksSUFBSSxFQUFFQyxhQUFhLEVBQUUsR0FBR0wsbUJBQU9BLENBQUM7QUFDeEMsTUFBTU0saUJBQWlCTixtQkFBT0EsQ0FBQztBQUUvQixNQUFNTyxXQUFXQyxPQUFPO0FBQ3hCLE1BQU1DLGVBQWVELE9BQU87QUFDNUIsTUFBTUUsV0FBV0YsT0FBTztBQUV4QixTQUFTRyxlQUFnQkMsTUFBTSxFQUFFQyxJQUFJO0lBQ25DLE9BQU8sSUFBSVosT0FBT1csUUFBUUM7QUFDNUI7QUFFQSxNQUFNQyxhQUFhbkI7SUFDakJvQixZQUFhSCxNQUFNLEVBQUUsRUFDbkJJLFdBQVcsRUFDWEMsVUFBVU4sY0FBYyxFQUN4Qk8sT0FBTyxFQUNQQyxjQUFjLEVBQ2RDLEdBQUcsRUFDSEMsaUJBQWlCLEVBQ2pCQyxVQUFVLEVBQ1ZDLGdCQUFnQixFQUNoQkMsOEJBQThCLEVBQzlCQyxPQUFPLEVBQ1AsR0FBR0MsU0FDSixHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQ04sS0FBSztRQUVMLElBQUlWLGVBQWUsUUFBUyxFQUFDVyxPQUFPQyxRQUFRLENBQUNaLGdCQUFnQkEsY0FBYyxJQUFJO1lBQzdFLE1BQU0sSUFBSWQscUJBQXFCO1FBQ2pDO1FBRUEsSUFBSSxPQUFPZSxZQUFZLFlBQVk7WUFDakMsTUFBTSxJQUFJZixxQkFBcUI7UUFDakM7UUFFQSxJQUFJZ0IsV0FBVyxRQUFRLE9BQU9BLFlBQVksY0FBYyxPQUFPQSxZQUFZLFVBQVU7WUFDbkYsTUFBTSxJQUFJaEIscUJBQXFCO1FBQ2pDO1FBRUEsSUFBSSxPQUFPZ0IsWUFBWSxZQUFZO1lBQ2pDQSxVQUFVWixlQUFlO2dCQUN2QixHQUFHYyxHQUFHO2dCQUNOQztnQkFDQUk7Z0JBQ0FIO2dCQUNBTyxTQUFTVjtnQkFDVCxHQUFJaEIsS0FBSzJCLHVCQUF1QixJQUFJUCxtQkFBbUI7b0JBQUVBO29CQUFrQkM7Z0JBQStCLElBQUlPLFNBQVM7Z0JBQ3ZILEdBQUdiLE9BQU87WUFDWjtRQUNGO1FBRUEsSUFBSSxDQUFDYixjQUFjLEdBQUdxQixRQUFRTSxZQUFZLElBQUlOLFFBQVFNLFlBQVksQ0FBQ2xCLElBQUksSUFBSW1CLE1BQU1DLE9BQU8sQ0FBQ1IsUUFBUU0sWUFBWSxDQUFDbEIsSUFBSSxJQUM5R1ksUUFBUU0sWUFBWSxDQUFDbEIsSUFBSSxHQUN6QixFQUFFO1FBQ04sSUFBSSxDQUFDTCxhQUFhLEdBQUdPLGVBQWU7UUFDcEMsSUFBSSxDQUFDWixLQUFLLEdBQUdELEtBQUtnQyxXQUFXLENBQUN2QjtRQUM5QixJQUFJLENBQUNMLFNBQVMsR0FBRztZQUFFLEdBQUdKLEtBQUtpQyxTQUFTLENBQUNWLFFBQVE7WUFBRVI7WUFBU087UUFBUTtRQUNoRSxJQUFJLENBQUNsQixTQUFTLENBQUN5QixZQUFZLEdBQUdOLFFBQVFNLFlBQVksR0FDOUM7WUFBRSxHQUFHTixRQUFRTSxZQUFZO1FBQUMsSUFDMUJEO1FBQ0osSUFBSSxDQUFDckIsU0FBUyxHQUFHTztJQUNuQjtJQUVBLENBQUNsQixlQUFlLEdBQUk7UUFDbEIsSUFBSXNDLGFBQWEsSUFBSSxDQUFDekMsU0FBUyxDQUFDMEMsSUFBSSxDQUFDRCxDQUFBQSxhQUFjLENBQUNBLFVBQVUsQ0FBQ3hDLFdBQVc7UUFFMUUsSUFBSXdDLFlBQVk7WUFDZCxPQUFPQTtRQUNUO1FBRUEsSUFBSSxDQUFDLElBQUksQ0FBQzVCLGFBQWEsSUFBSSxJQUFJLENBQUNiLFNBQVMsQ0FBQzJDLE1BQU0sR0FBRyxJQUFJLENBQUM5QixhQUFhLEVBQUU7WUFDckU0QixhQUFhLElBQUksQ0FBQzNCLFNBQVMsQ0FBQyxJQUFJLENBQUNOLEtBQUssRUFBRSxJQUFJLENBQUNHLFNBQVM7WUFDdEQsSUFBSSxDQUFDVCxXQUFXLENBQUN1QztRQUNuQjtRQUVBLE9BQU9BO0lBQ1Q7QUFDRjtBQUVBRyxPQUFPQyxPQUFPLEdBQUczQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3Bvb2wuanM/MjllMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBQb29sQmFzZSxcbiAga0NsaWVudHMsXG4gIGtOZWVkRHJhaW4sXG4gIGtBZGRDbGllbnQsXG4gIGtHZXREaXNwYXRjaGVyXG59ID0gcmVxdWlyZSgnLi9wb29sLWJhc2UnKVxuY29uc3QgQ2xpZW50ID0gcmVxdWlyZSgnLi9jbGllbnQnKVxuY29uc3Qge1xuICBJbnZhbGlkQXJndW1lbnRFcnJvclxufSA9IHJlcXVpcmUoJy4vY29yZS9lcnJvcnMnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJylcbmNvbnN0IHsga1VybCwga0ludGVyY2VwdG9ycyB9ID0gcmVxdWlyZSgnLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgYnVpbGRDb25uZWN0b3IgPSByZXF1aXJlKCcuL2NvcmUvY29ubmVjdCcpXG5cbmNvbnN0IGtPcHRpb25zID0gU3ltYm9sKCdvcHRpb25zJylcbmNvbnN0IGtDb25uZWN0aW9ucyA9IFN5bWJvbCgnY29ubmVjdGlvbnMnKVxuY29uc3Qga0ZhY3RvcnkgPSBTeW1ib2woJ2ZhY3RvcnknKVxuXG5mdW5jdGlvbiBkZWZhdWx0RmFjdG9yeSAob3JpZ2luLCBvcHRzKSB7XG4gIHJldHVybiBuZXcgQ2xpZW50KG9yaWdpbiwgb3B0cylcbn1cblxuY2xhc3MgUG9vbCBleHRlbmRzIFBvb2xCYXNlIHtcbiAgY29uc3RydWN0b3IgKG9yaWdpbiwge1xuICAgIGNvbm5lY3Rpb25zLFxuICAgIGZhY3RvcnkgPSBkZWZhdWx0RmFjdG9yeSxcbiAgICBjb25uZWN0LFxuICAgIGNvbm5lY3RUaW1lb3V0LFxuICAgIHRscyxcbiAgICBtYXhDYWNoZWRTZXNzaW9ucyxcbiAgICBzb2NrZXRQYXRoLFxuICAgIGF1dG9TZWxlY3RGYW1pbHksXG4gICAgYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0LFxuICAgIGFsbG93SDIsXG4gICAgLi4ub3B0aW9uc1xuICB9ID0ge30pIHtcbiAgICBzdXBlcigpXG5cbiAgICBpZiAoY29ubmVjdGlvbnMgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShjb25uZWN0aW9ucykgfHwgY29ubmVjdGlvbnMgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNvbm5lY3Rpb25zJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZhY3RvcnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignZmFjdG9yeSBtdXN0IGJlIGEgZnVuY3Rpb24uJylcbiAgICB9XG5cbiAgICBpZiAoY29ubmVjdCAhPSBudWxsICYmIHR5cGVvZiBjb25uZWN0ICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjb25uZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdjb25uZWN0IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3QnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29ubmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29ubmVjdCA9IGJ1aWxkQ29ubmVjdG9yKHtcbiAgICAgICAgLi4udGxzLFxuICAgICAgICBtYXhDYWNoZWRTZXNzaW9ucyxcbiAgICAgICAgYWxsb3dIMixcbiAgICAgICAgc29ja2V0UGF0aCxcbiAgICAgICAgdGltZW91dDogY29ubmVjdFRpbWVvdXQsXG4gICAgICAgIC4uLih1dGlsLm5vZGVIYXNBdXRvU2VsZWN0RmFtaWx5ICYmIGF1dG9TZWxlY3RGYW1pbHkgPyB7IGF1dG9TZWxlY3RGYW1pbHksIGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCB9IDogdW5kZWZpbmVkKSxcbiAgICAgICAgLi4uY29ubmVjdFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzW2tJbnRlcmNlcHRvcnNdID0gb3B0aW9ucy5pbnRlcmNlcHRvcnMgJiYgb3B0aW9ucy5pbnRlcmNlcHRvcnMuUG9vbCAmJiBBcnJheS5pc0FycmF5KG9wdGlvbnMuaW50ZXJjZXB0b3JzLlBvb2wpXG4gICAgICA/IG9wdGlvbnMuaW50ZXJjZXB0b3JzLlBvb2xcbiAgICAgIDogW11cbiAgICB0aGlzW2tDb25uZWN0aW9uc10gPSBjb25uZWN0aW9ucyB8fCBudWxsXG4gICAgdGhpc1trVXJsXSA9IHV0aWwucGFyc2VPcmlnaW4ob3JpZ2luKVxuICAgIHRoaXNba09wdGlvbnNdID0geyAuLi51dGlsLmRlZXBDbG9uZShvcHRpb25zKSwgY29ubmVjdCwgYWxsb3dIMiB9XG4gICAgdGhpc1trT3B0aW9uc10uaW50ZXJjZXB0b3JzID0gb3B0aW9ucy5pbnRlcmNlcHRvcnNcbiAgICAgID8geyAuLi5vcHRpb25zLmludGVyY2VwdG9ycyB9XG4gICAgICA6IHVuZGVmaW5lZFxuICAgIHRoaXNba0ZhY3RvcnldID0gZmFjdG9yeVxuICB9XG5cbiAgW2tHZXREaXNwYXRjaGVyXSAoKSB7XG4gICAgbGV0IGRpc3BhdGNoZXIgPSB0aGlzW2tDbGllbnRzXS5maW5kKGRpc3BhdGNoZXIgPT4gIWRpc3BhdGNoZXJba05lZWREcmFpbl0pXG5cbiAgICBpZiAoZGlzcGF0Y2hlcikge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoZXJcbiAgICB9XG5cbiAgICBpZiAoIXRoaXNba0Nvbm5lY3Rpb25zXSB8fCB0aGlzW2tDbGllbnRzXS5sZW5ndGggPCB0aGlzW2tDb25uZWN0aW9uc10pIHtcbiAgICAgIGRpc3BhdGNoZXIgPSB0aGlzW2tGYWN0b3J5XSh0aGlzW2tVcmxdLCB0aGlzW2tPcHRpb25zXSlcbiAgICAgIHRoaXNba0FkZENsaWVudF0oZGlzcGF0Y2hlcilcbiAgICB9XG5cbiAgICByZXR1cm4gZGlzcGF0Y2hlclxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUG9vbFxuIl0sIm5hbWVzIjpbIlBvb2xCYXNlIiwia0NsaWVudHMiLCJrTmVlZERyYWluIiwia0FkZENsaWVudCIsImtHZXREaXNwYXRjaGVyIiwicmVxdWlyZSIsIkNsaWVudCIsIkludmFsaWRBcmd1bWVudEVycm9yIiwidXRpbCIsImtVcmwiLCJrSW50ZXJjZXB0b3JzIiwiYnVpbGRDb25uZWN0b3IiLCJrT3B0aW9ucyIsIlN5bWJvbCIsImtDb25uZWN0aW9ucyIsImtGYWN0b3J5IiwiZGVmYXVsdEZhY3RvcnkiLCJvcmlnaW4iLCJvcHRzIiwiUG9vbCIsImNvbnN0cnVjdG9yIiwiY29ubmVjdGlvbnMiLCJmYWN0b3J5IiwiY29ubmVjdCIsImNvbm5lY3RUaW1lb3V0IiwidGxzIiwibWF4Q2FjaGVkU2Vzc2lvbnMiLCJzb2NrZXRQYXRoIiwiYXV0b1NlbGVjdEZhbWlseSIsImF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCIsImFsbG93SDIiLCJvcHRpb25zIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJ0aW1lb3V0Iiwibm9kZUhhc0F1dG9TZWxlY3RGYW1pbHkiLCJ1bmRlZmluZWQiLCJpbnRlcmNlcHRvcnMiLCJBcnJheSIsImlzQXJyYXkiLCJwYXJzZU9yaWdpbiIsImRlZXBDbG9uZSIsImRpc3BhdGNoZXIiLCJmaW5kIiwibGVuZ3RoIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/pool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/proxy-agent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/proxy-agent.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kProxy, kClose, kDestroy, kInterceptors } = __webpack_require__(/*! ./core/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\nconst Agent = __webpack_require__(/*! ./agent */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/agent.js\");\nconst Pool = __webpack_require__(/*! ./pool */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/pool.js\");\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/dispatcher-base.js\");\nconst { InvalidArgumentError, RequestAbortedError } = __webpack_require__(/*! ./core/errors */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/errors.js\");\nconst buildConnector = __webpack_require__(/*! ./core/connect */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/connect.js\");\nconst kAgent = Symbol(\"proxy agent\");\nconst kClient = Symbol(\"proxy client\");\nconst kProxyHeaders = Symbol(\"proxy headers\");\nconst kRequestTls = Symbol(\"request tls settings\");\nconst kProxyTls = Symbol(\"proxy tls settings\");\nconst kConnectEndpoint = Symbol(\"connect endpoint function\");\nfunction defaultProtocolPort(protocol) {\n    return protocol === \"https:\" ? 443 : 80;\n}\nfunction buildProxyOptions(opts) {\n    if (typeof opts === \"string\") {\n        opts = {\n            uri: opts\n        };\n    }\n    if (!opts || !opts.uri) {\n        throw new InvalidArgumentError(\"Proxy opts.uri is mandatory\");\n    }\n    return {\n        uri: opts.uri,\n        protocol: opts.protocol || \"https\"\n    };\n}\nfunction defaultFactory(origin, opts) {\n    return new Pool(origin, opts);\n}\nclass ProxyAgent extends DispatcherBase {\n    constructor(opts){\n        super(opts);\n        this[kProxy] = buildProxyOptions(opts);\n        this[kAgent] = new Agent(opts);\n        this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];\n        if (typeof opts === \"string\") {\n            opts = {\n                uri: opts\n            };\n        }\n        if (!opts || !opts.uri) {\n            throw new InvalidArgumentError(\"Proxy opts.uri is mandatory\");\n        }\n        const { clientFactory = defaultFactory } = opts;\n        if (typeof clientFactory !== \"function\") {\n            throw new InvalidArgumentError(\"Proxy opts.clientFactory must be a function.\");\n        }\n        this[kRequestTls] = opts.requestTls;\n        this[kProxyTls] = opts.proxyTls;\n        this[kProxyHeaders] = opts.headers || {};\n        const resolvedUrl = new URL(opts.uri);\n        const { origin, port, host, username, password } = resolvedUrl;\n        if (opts.auth && opts.token) {\n            throw new InvalidArgumentError(\"opts.auth cannot be used in combination with opts.token\");\n        } else if (opts.auth) {\n            /* @deprecated in favour of opts.token */ this[kProxyHeaders][\"proxy-authorization\"] = `Basic ${opts.auth}`;\n        } else if (opts.token) {\n            this[kProxyHeaders][\"proxy-authorization\"] = opts.token;\n        } else if (username && password) {\n            this[kProxyHeaders][\"proxy-authorization\"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString(\"base64\")}`;\n        }\n        const connect = buildConnector({\n            ...opts.proxyTls\n        });\n        this[kConnectEndpoint] = buildConnector({\n            ...opts.requestTls\n        });\n        this[kClient] = clientFactory(resolvedUrl, {\n            connect\n        });\n        this[kAgent] = new Agent({\n            ...opts,\n            connect: async (opts, callback)=>{\n                let requestedHost = opts.host;\n                if (!opts.port) {\n                    requestedHost += `:${defaultProtocolPort(opts.protocol)}`;\n                }\n                try {\n                    const { socket, statusCode } = await this[kClient].connect({\n                        origin,\n                        port,\n                        path: requestedHost,\n                        signal: opts.signal,\n                        headers: {\n                            ...this[kProxyHeaders],\n                            host\n                        }\n                    });\n                    if (statusCode !== 200) {\n                        socket.on(\"error\", ()=>{}).destroy();\n                        callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));\n                    }\n                    if (opts.protocol !== \"https:\") {\n                        callback(null, socket);\n                        return;\n                    }\n                    let servername;\n                    if (this[kRequestTls]) {\n                        servername = this[kRequestTls].servername;\n                    } else {\n                        servername = opts.servername;\n                    }\n                    this[kConnectEndpoint]({\n                        ...opts,\n                        servername,\n                        httpSocket: socket\n                    }, callback);\n                } catch (err) {\n                    callback(err);\n                }\n            }\n        });\n    }\n    dispatch(opts, handler) {\n        const { host } = new URL(opts.origin);\n        const headers = buildHeaders(opts.headers);\n        throwIfProxyAuthIsSent(headers);\n        return this[kAgent].dispatch({\n            ...opts,\n            headers: {\n                ...headers,\n                host\n            }\n        }, handler);\n    }\n    async [kClose]() {\n        await this[kAgent].close();\n        await this[kClient].close();\n    }\n    async [kDestroy]() {\n        await this[kAgent].destroy();\n        await this[kClient].destroy();\n    }\n}\n/**\n * @param {string[] | Record<string, string>} headers\n * @returns {Record<string, string>}\n */ function buildHeaders(headers) {\n    // When using undici.fetch, the headers list is stored\n    // as an array.\n    if (Array.isArray(headers)) {\n        /** @type {Record<string, string>} */ const headersPair = {};\n        for(let i = 0; i < headers.length; i += 2){\n            headersPair[headers[i]] = headers[i + 1];\n        }\n        return headersPair;\n    }\n    return headers;\n}\n/**\n * @param {Record<string, string>} headers\n *\n * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers\n * Nevertheless, it was changed and to avoid a security vulnerability by end users\n * this check was created.\n * It should be removed in the next major version for performance reasons\n */ function throwIfProxyAuthIsSent(headers) {\n    const existProxyAuth = headers && Object.keys(headers).find((key)=>key.toLowerCase() === \"proxy-authorization\");\n    if (existProxyAuth) {\n        throw new InvalidArgumentError(\"Proxy-Authorization should be sent in ProxyAgent constructor\");\n    }\n}\nmodule.exports = ProxyAgent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvcHJveHktYWdlbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLGFBQWEsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUM1RCxNQUFNLEVBQUVDLEdBQUcsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUN4QixNQUFNRSxRQUFRRixtQkFBT0EsQ0FBQztBQUN0QixNQUFNRyxPQUFPSCxtQkFBT0EsQ0FBQztBQUNyQixNQUFNSSxpQkFBaUJKLG1CQUFPQSxDQUFDO0FBQy9CLE1BQU0sRUFBRUssb0JBQW9CLEVBQUVDLG1CQUFtQixFQUFFLEdBQUdOLG1CQUFPQSxDQUFDO0FBQzlELE1BQU1PLGlCQUFpQlAsbUJBQU9BLENBQUM7QUFFL0IsTUFBTVEsU0FBU0MsT0FBTztBQUN0QixNQUFNQyxVQUFVRCxPQUFPO0FBQ3ZCLE1BQU1FLGdCQUFnQkYsT0FBTztBQUM3QixNQUFNRyxjQUFjSCxPQUFPO0FBQzNCLE1BQU1JLFlBQVlKLE9BQU87QUFDekIsTUFBTUssbUJBQW1CTCxPQUFPO0FBRWhDLFNBQVNNLG9CQUFxQkMsUUFBUTtJQUNwQyxPQUFPQSxhQUFhLFdBQVcsTUFBTTtBQUN2QztBQUVBLFNBQVNDLGtCQUFtQkMsSUFBSTtJQUM5QixJQUFJLE9BQU9BLFNBQVMsVUFBVTtRQUM1QkEsT0FBTztZQUFFQyxLQUFLRDtRQUFLO0lBQ3JCO0lBRUEsSUFBSSxDQUFDQSxRQUFRLENBQUNBLEtBQUtDLEdBQUcsRUFBRTtRQUN0QixNQUFNLElBQUlkLHFCQUFxQjtJQUNqQztJQUVBLE9BQU87UUFDTGMsS0FBS0QsS0FBS0MsR0FBRztRQUNiSCxVQUFVRSxLQUFLRixRQUFRLElBQUk7SUFDN0I7QUFDRjtBQUVBLFNBQVNJLGVBQWdCQyxNQUFNLEVBQUVILElBQUk7SUFDbkMsT0FBTyxJQUFJZixLQUFL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SUFDM0I7SUFFQSxNQUFNLENBQUM1RCxTQUFTLEdBQUk7UUFDbEIsTUFBTSxJQUFJLENBQUNVLE9BQU8sQ0FBQzBDLE9BQU87UUFDMUIsTUFBTSxJQUFJLENBQUN4QyxRQUFRLENBQUN3QyxPQUFPO0lBQzdCO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxTQUFTTSxhQUFjMUIsT0FBTztJQUM1QixzREFBc0Q7SUFDdEQsZUFBZTtJQUNmLElBQUlMLE1BQU1DLE9BQU8sQ0FBQ0ksVUFBVTtRQUMxQixtQ0FBbUMsR0FDbkMsTUFBTTZCLGNBQWMsQ0FBQztRQUVyQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSTlCLFFBQVErQixNQUFNLEVBQUVELEtBQUssRUFBRztZQUMxQ0QsV0FBVyxDQUFDN0IsT0FBTyxDQUFDOEIsRUFBRSxDQUFDLEdBQUc5QixPQUFPLENBQUM4QixJQUFJLEVBQUU7UUFDMUM7UUFFQSxPQUFPRDtJQUNUO0lBRUEsT0FBTzdCO0FBQ1Q7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBUzJCLHVCQUF3QjNCLE9BQU87SUFDdEMsTUFBTWdDLGlCQUFpQmhDLFdBQVdpQyxPQUFPQyxJQUFJLENBQUNsQyxTQUMzQ21DLElBQUksQ0FBQyxDQUFDQyxNQUFRQSxJQUFJQyxXQUFXLE9BQU87SUFDdkMsSUFBSUwsZ0JBQWdCO1FBQ2xCLE1BQU0sSUFBSXpELHFCQUFxQjtJQUNqQztBQUNGO0FBRUErRCxPQUFPQyxPQUFPLEdBQUcvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3Byb3h5LWFnZW50LmpzPzI4NzQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsga1Byb3h5LCBrQ2xvc2UsIGtEZXN0cm95LCBrSW50ZXJjZXB0b3JzIH0gPSByZXF1aXJlKCcuL2NvcmUvc3ltYm9scycpXG5jb25zdCB7IFVSTCB9ID0gcmVxdWlyZSgndXJsJylcbmNvbnN0IEFnZW50ID0gcmVxdWlyZSgnLi9hZ2VudCcpXG5jb25zdCBQb29sID0gcmVxdWlyZSgnLi9wb29sJylcbmNvbnN0IERpc3BhdGNoZXJCYXNlID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyLWJhc2UnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgUmVxdWVzdEFib3J0ZWRFcnJvciB9ID0gcmVxdWlyZSgnLi9jb3JlL2Vycm9ycycpXG5jb25zdCBidWlsZENvbm5lY3RvciA9IHJlcXVpcmUoJy4vY29yZS9jb25uZWN0JylcblxuY29uc3Qga0FnZW50ID0gU3ltYm9sKCdwcm94eSBhZ2VudCcpXG5jb25zdCBrQ2xpZW50ID0gU3ltYm9sKCdwcm94eSBjbGllbnQnKVxuY29uc3Qga1Byb3h5SGVhZGVycyA9IFN5bWJvbCgncHJveHkgaGVhZGVycycpXG5jb25zdCBrUmVxdWVzdFRscyA9IFN5bWJvbCgncmVxdWVzdCB0bHMgc2V0dGluZ3MnKVxuY29uc3Qga1Byb3h5VGxzID0gU3ltYm9sKCdwcm94eSB0bHMgc2V0dGluZ3MnKVxuY29uc3Qga0Nvbm5lY3RFbmRwb2ludCA9IFN5bWJvbCgnY29ubmVjdCBlbmRwb2ludCBmdW5jdGlvbicpXG5cbmZ1bmN0aW9uIGRlZmF1bHRQcm90b2NvbFBvcnQgKHByb3RvY29sKSB7XG4gIHJldHVybiBwcm90b2NvbCA9PT0gJ2h0dHBzOicgPyA0NDMgOiA4MFxufVxuXG5mdW5jdGlvbiBidWlsZFByb3h5T3B0aW9ucyAob3B0cykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0cyA9IHsgdXJpOiBvcHRzIH1cbiAgfVxuXG4gIGlmICghb3B0cyB8fCAhb3B0cy51cmkpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ1Byb3h5IG9wdHMudXJpIGlzIG1hbmRhdG9yeScpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHVyaTogb3B0cy51cmksXG4gICAgcHJvdG9jb2w6IG9wdHMucHJvdG9jb2wgfHwgJ2h0dHBzJ1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRGYWN0b3J5IChvcmlnaW4sIG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBQb29sKG9yaWdpbiwgb3B0cylcbn1cblxuY2xhc3MgUHJveHlBZ2VudCBleHRlbmRzIERpc3BhdGNoZXJCYXNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKVxuICAgIHRoaXNba1Byb3h5XSA9IGJ1aWxkUHJveHlPcHRpb25zKG9wdHMpXG4gICAgdGhpc1trQWdlbnRdID0gbmV3IEFnZW50KG9wdHMpXG4gICAgdGhpc1trSW50ZXJjZXB0b3JzXSA9IG9wdHMuaW50ZXJjZXB0b3JzICYmIG9wdHMuaW50ZXJjZXB0b3JzLlByb3h5QWdlbnQgJiYgQXJyYXkuaXNBcnJheShvcHRzLmludGVyY2VwdG9ycy5Qcm94eUFnZW50KVxuICAgICAgPyBvcHRzLmludGVyY2VwdG9ycy5Qcm94eUFnZW50XG4gICAgICA6IFtdXG5cbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRzID0geyB1cmk6IG9wdHMgfVxuICAgIH1cblxuICAgIGlmICghb3B0cyB8fCAhb3B0cy51cmkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignUHJveHkgb3B0cy51cmkgaXMgbWFuZGF0b3J5JylcbiAgICB9XG5cbiAgICBjb25zdCB7IGNsaWVudEZhY3RvcnkgPSBkZWZhdWx0RmFjdG9yeSB9ID0gb3B0c1xuXG4gICAgaWYgKHR5cGVvZiBjbGllbnRGYWN0b3J5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ1Byb3h5IG9wdHMuY2xpZW50RmFjdG9yeSBtdXN0IGJlIGEgZnVuY3Rpb24uJylcbiAgICB9XG5cbiAgICB0aGlzW2tSZXF1ZXN0VGxzXSA9IG9wdHMucmVxdWVzdFRsc1xuICAgIHRoaXNba1Byb3h5VGxzXSA9IG9wdHMucHJveHlUbHNcbiAgICB0aGlzW2tQcm94eUhlYWRlcnNdID0gb3B0cy5oZWFkZXJzIHx8IHt9XG5cbiAgICBjb25zdCByZXNvbHZlZFVybCA9IG5ldyBVUkwob3B0cy51cmkpXG4gICAgY29uc3QgeyBvcmlnaW4sIHBvcnQsIGhvc3QsIHVzZXJuYW1lLCBwYXNzd29yZCB9ID0gcmVzb2x2ZWRVcmxcblxuICAgIGlmIChvcHRzLmF1dGggJiYgb3B0cy50b2tlbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRzLmF1dGggY2Fubm90IGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBvcHRzLnRva2VuJylcbiAgICB9IGVsc2UgaWYgKG9wdHMuYXV0aCkge1xuICAgICAgLyogQGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIG9wdHMudG9rZW4gKi9cbiAgICAgIHRoaXNba1Byb3h5SGVhZGVyc11bJ3Byb3h5LWF1dGhvcml6YXRpb24nXSA9IGBCYXNpYyAke29wdHMuYXV0aH1gXG4gICAgfSBlbHNlIGlmIChvcHRzLnRva2VuKSB7XG4gICAgICB0aGlzW2tQcm94eUhlYWRlcnNdWydwcm94eS1hdXRob3JpemF0aW9uJ10gPSBvcHRzLnRva2VuXG4gICAgfSBlbHNlIGlmICh1c2VybmFtZSAmJiBwYXNzd29yZCkge1xuICAgICAgdGhpc1trUHJveHlIZWFkZXJzXVsncHJveHktYXV0aG9yaXphdGlvbiddID0gYEJhc2ljICR7QnVmZmVyLmZyb20oYCR7ZGVjb2RlVVJJQ29tcG9uZW50KHVzZXJuYW1lKX06JHtkZWNvZGVVUklDb21wb25lbnQocGFzc3dvcmQpfWApLnRvU3RyaW5nKCdiYXNlNjQnKX1gXG4gICAgfVxuXG4gICAgY29uc3QgY29ubmVjdCA9IGJ1aWxkQ29ubmVjdG9yKHsgLi4ub3B0cy5wcm94eVRscyB9KVxuICAgIHRoaXNba0Nvbm5lY3RFbmRwb2ludF0gPSBidWlsZENvbm5lY3Rvcih7IC4uLm9wdHMucmVxdWVzdFRscyB9KVxuICAgIHRoaXNba0NsaWVudF0gPSBjbGllbnRGYWN0b3J5KHJlc29sdmVkVXJsLCB7IGNvbm5lY3QgfSlcbiAgICB0aGlzW2tBZ2VudF0gPSBuZXcgQWdlbnQoe1xuICAgICAgLi4ub3B0cyxcbiAgICAgIGNvbm5lY3Q6IGFzeW5jIChvcHRzLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBsZXQgcmVxdWVzdGVkSG9zdCA9IG9wdHMuaG9zdFxuICAgICAgICBpZiAoIW9wdHMucG9ydCkge1xuICAgICAgICAgIHJlcXVlc3RlZEhvc3QgKz0gYDoke2RlZmF1bHRQcm90b2NvbFBvcnQob3B0cy5wcm90b2NvbCl9YFxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyBzb2NrZXQsIHN0YXR1c0NvZGUgfSA9IGF3YWl0IHRoaXNba0NsaWVudF0uY29ubmVjdCh7XG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICBwb3J0LFxuICAgICAgICAgICAgcGF0aDogcmVxdWVzdGVkSG9zdCxcbiAgICAgICAgICAgIHNpZ25hbDogb3B0cy5zaWduYWwsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgIC4uLnRoaXNba1Byb3h5SGVhZGVyc10sXG4gICAgICAgICAgICAgIGhvc3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIGlmIChzdGF0dXNDb2RlICE9PSAyMDApIHtcbiAgICAgICAgICAgIHNvY2tldC5vbignZXJyb3InLCAoKSA9PiB7fSkuZGVzdHJveSgpXG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcihgUHJveHkgcmVzcG9uc2UgKCR7c3RhdHVzQ29kZX0pICE9PSAyMDAgd2hlbiBIVFRQIFR1bm5lbGluZ2ApKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0cy5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHNvY2tldClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgc2VydmVybmFtZVxuICAgICAgICAgIGlmICh0aGlzW2tSZXF1ZXN0VGxzXSkge1xuICAgICAgICAgICAgc2VydmVybmFtZSA9IHRoaXNba1JlcXVlc3RUbHNdLnNlcnZlcm5hbWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VydmVybmFtZSA9IG9wdHMuc2VydmVybmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzW2tDb25uZWN0RW5kcG9pbnRdKHsgLi4ub3B0cywgc2VydmVybmFtZSwgaHR0cFNvY2tldDogc29ja2V0IH0sIGNhbGxiYWNrKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZGlzcGF0Y2ggKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBjb25zdCB7IGhvc3QgfSA9IG5ldyBVUkwob3B0cy5vcmlnaW4pXG4gICAgY29uc3QgaGVhZGVycyA9IGJ1aWxkSGVhZGVycyhvcHRzLmhlYWRlcnMpXG4gICAgdGhyb3dJZlByb3h5QXV0aElzU2VudChoZWFkZXJzKVxuICAgIHJldHVybiB0aGlzW2tBZ2VudF0uZGlzcGF0Y2goXG4gICAgICB7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgICAgIGhvc3RcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhhbmRsZXJcbiAgICApXG4gIH1cblxuICBhc3luYyBba0Nsb3NlXSAoKSB7XG4gICAgYXdhaXQgdGhpc1trQWdlbnRdLmNsb3NlKClcbiAgICBhd2FpdCB0aGlzW2tDbGllbnRdLmNsb3NlKClcbiAgfVxuXG4gIGFzeW5jIFtrRGVzdHJveV0gKCkge1xuICAgIGF3YWl0IHRoaXNba0FnZW50XS5kZXN0cm95KClcbiAgICBhd2FpdCB0aGlzW2tDbGllbnRdLmRlc3Ryb3koKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmdbXSB8IFJlY29yZDxzdHJpbmcsIHN0cmluZz59IGhlYWRlcnNcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5mdW5jdGlvbiBidWlsZEhlYWRlcnMgKGhlYWRlcnMpIHtcbiAgLy8gV2hlbiB1c2luZyB1bmRpY2kuZmV0Y2gsIHRoZSBoZWFkZXJzIGxpc3QgaXMgc3RvcmVkXG4gIC8vIGFzIGFuIGFycmF5LlxuICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gKi9cbiAgICBjb25zdCBoZWFkZXJzUGFpciA9IHt9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGhlYWRlcnNQYWlyW2hlYWRlcnNbaV1dID0gaGVhZGVyc1tpICsgMV1cbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVyc1BhaXJcbiAgfVxuXG4gIHJldHVybiBoZWFkZXJzXG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBoZWFkZXJzXG4gKlxuICogUHJldmlvdXMgdmVyc2lvbnMgb2YgUHJveHlBZ2VudCBzdWdnZXN0cyB0aGUgUHJveHktQXV0aG9yaXphdGlvbiBpbiByZXF1ZXN0IGhlYWRlcnNcbiAqIE5ldmVydGhlbGVzcywgaXQgd2FzIGNoYW5nZWQgYW5kIHRvIGF2b2lkIGEgc2VjdXJpdHkgdnVsbmVyYWJpbGl0eSBieSBlbmQgdXNlcnNcbiAqIHRoaXMgY2hlY2sgd2FzIGNyZWF0ZWQuXG4gKiBJdCBzaG91bGQgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZQcm94eUF1dGhJc1NlbnQgKGhlYWRlcnMpIHtcbiAgY29uc3QgZXhpc3RQcm94eUF1dGggPSBoZWFkZXJzICYmIE9iamVjdC5rZXlzKGhlYWRlcnMpXG4gICAgLmZpbmQoKGtleSkgPT4ga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdwcm94eS1hdXRob3JpemF0aW9uJylcbiAgaWYgKGV4aXN0UHJveHlBdXRoKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdQcm94eS1BdXRob3JpemF0aW9uIHNob3VsZCBiZSBzZW50IGluIFByb3h5QWdlbnQgY29uc3RydWN0b3InKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHJveHlBZ2VudFxuIl0sIm5hbWVzIjpbImtQcm94eSIsImtDbG9zZSIsImtEZXN0cm95Iiwia0ludGVyY2VwdG9ycyIsInJlcXVpcmUiLCJVUkwiLCJBZ2VudCIsIlBvb2wiLCJEaXNwYXRjaGVyQmFzZSIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiUmVxdWVzdEFib3J0ZWRFcnJvciIsImJ1aWxkQ29ubmVjdG9yIiwia0FnZW50IiwiU3ltYm9sIiwia0NsaWVudCIsImtQcm94eUhlYWRlcnMiLCJrUmVxdWVzdFRscyIsImtQcm94eVRscyIsImtDb25uZWN0RW5kcG9pbnQiLCJkZWZhdWx0UHJvdG9jb2xQb3J0IiwicHJvdG9jb2wiLCJidWlsZFByb3h5T3B0aW9ucyIsIm9wdHMiLCJ1cmkiLCJkZWZhdWx0RmFjdG9yeSIsIm9yaWdpbiIsIlByb3h5QWdlbnQiLCJjb25zdHJ1Y3RvciIsImludGVyY2VwdG9ycyIsIkFycmF5IiwiaXNBcnJheSIsImNsaWVudEZhY3RvcnkiLCJyZXF1ZXN0VGxzIiwicHJveHlUbHMiLCJoZWFkZXJzIiwicmVzb2x2ZWRVcmwiLCJwb3J0IiwiaG9zdCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJhdXRoIiwidG9rZW4iLCJCdWZmZXIiLCJmcm9tIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwidG9TdHJpbmciLCJjb25uZWN0IiwiY2FsbGJhY2siLCJyZXF1ZXN0ZWRIb3N0Iiwic29ja2V0Iiwic3RhdHVzQ29kZSIsInBhdGgiLCJzaWduYWwiLCJvbiIsImRlc3Ryb3kiLCJzZXJ2ZXJuYW1lIiwiaHR0cFNvY2tldCIsImVyciIsImRpc3BhdGNoIiwiaGFuZGxlciIsImJ1aWxkSGVhZGVycyIsInRocm93SWZQcm94eUF1dGhJc1NlbnQiLCJjbG9zZSIsImhlYWRlcnNQYWlyIiwiaSIsImxlbmd0aCIsImV4aXN0UHJveHlBdXRoIiwiT2JqZWN0Iiwia2V5cyIsImZpbmQiLCJrZXkiLCJ0b0xvd2VyQ2FzZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/proxy-agent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/timers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/timers.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("\nlet fastNow = Date.now();\nlet fastNowTimeout;\nconst fastTimers = [];\nfunction onTimeout() {\n    fastNow = Date.now();\n    let len = fastTimers.length;\n    let idx = 0;\n    while(idx < len){\n        const timer = fastTimers[idx];\n        if (timer.state === 0) {\n            timer.state = fastNow + timer.delay;\n        } else if (timer.state > 0 && fastNow >= timer.state) {\n            timer.state = -1;\n            timer.callback(timer.opaque);\n        }\n        if (timer.state === -1) {\n            timer.state = -2;\n            if (idx !== len - 1) {\n                fastTimers[idx] = fastTimers.pop();\n            } else {\n                fastTimers.pop();\n            }\n            len -= 1;\n        } else {\n            idx += 1;\n        }\n    }\n    if (fastTimers.length > 0) {\n        refreshTimeout();\n    }\n}\nfunction refreshTimeout() {\n    if (fastNowTimeout && fastNowTimeout.refresh) {\n        fastNowTimeout.refresh();\n    } else {\n        clearTimeout(fastNowTimeout);\n        fastNowTimeout = setTimeout(onTimeout, 1e3);\n        if (fastNowTimeout.unref) {\n            fastNowTimeout.unref();\n        }\n    }\n}\nclass Timeout {\n    constructor(callback, delay, opaque){\n        this.callback = callback;\n        this.delay = delay;\n        this.opaque = opaque;\n        //  -2 not in timer list\n        //  -1 in timer list but inactive\n        //   0 in timer list waiting for time\n        // > 0 in timer list waiting for time to expire\n        this.state = -2;\n        this.refresh();\n    }\n    refresh() {\n        if (this.state === -2) {\n            fastTimers.push(this);\n            if (!fastNowTimeout || fastTimers.length === 1) {\n                refreshTimeout();\n            }\n        }\n        this.state = 0;\n    }\n    clear() {\n        this.state = -1;\n    }\n}\nmodule.exports = {\n    setTimeout (callback, delay, opaque) {\n        return delay < 1e3 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);\n    },\n    clearTimeout (timeout) {\n        if (timeout instanceof Timeout) {\n            timeout.clear();\n        } else {\n            clearTimeout(timeout);\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvdGltZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsVUFBVUMsS0FBS0MsR0FBRztBQUN0QixJQUFJQztBQUVKLE1BQU1DLGFBQWEsRUFBRTtBQUVyQixTQUFTQztJQUNQTCxVQUFVQyxLQUFLQyxHQUFHO0lBRWxCLElBQUlJLE1BQU1GLFdBQVdHLE1BQU07SUFDM0IsSUFBSUMsTUFBTTtJQUNWLE1BQU9BLE1BQU1GLElBQUs7UUFDaEIsTUFBTUcsUUFBUUwsVUFBVSxDQUFDSSxJQUFJO1FBRTdCLElBQUlDLE1BQU1DLEtBQUssS0FBSyxHQUFHO1lBQ3JCRCxNQUFNQyxLQUFLLEdBQUdWLFVBQVVTLE1BQU1FLEtBQUs7UUFDckMsT0FBTyxJQUFJRixNQUFNQyxLQUFLLEdBQUcsS0FBS1YsV0FBV1MsTUFBTUMsS0FBSyxFQUFFO1lBQ3BERCxNQUFNQyxLQUFLLEdBQUcsQ0FBQztZQUNmRCxNQUFNRyxRQUFRLENBQUNILE1BQU1JLE1BQU07UUFDN0I7UUFFQSxJQUFJSixNQUFNQyxLQUFLLEtBQUssQ0FBQyxHQUFHO1lBQ3RCRCxNQUFNQyxLQUFLLEdBQUcsQ0FBQztZQUNmLElBQUlGLFFBQVFGLE1BQU0sR0FBRztnQkFDbkJGLFVBQVUsQ0FBQ0ksSUFBSSxHQUFHSixXQUFXVSxHQUFHO1lBQ2xDLE9BQU87Z0JBQ0xWLFdBQVdVLEdBQUc7WUFDaEI7WUFDQVIsT0FBTztRQUNULE9BQU87WUFDTEUsT0FBTztRQUNUO0lBQ0Y7SUFFQSxJQUFJSixXQUFXRyxNQUFNLEdBQUcsR0FBRztRQUN6QlE7SUFDRjtBQUNGO0FBRUEsU0FBU0E7SUFDUCxJQUFJWixrQkFBa0JBLGVBQWVhLE9BQU8sRUFBRTtRQUM1Q2IsZUFBZWEsT0FBTztJQUN4QixPQUFPO1FBQ0xDLGFBQWFkO1FBQ2JBLGlCQUFpQmUsV0FBV2IsV0FBVztRQUN2QyxJQUFJRixlQUFlZ0IsS0FBSyxFQUFFO1lBQ3hCaEIsZUFBZWdCLEtBQUs7UUFDdEI7SUFDRjtBQUNGO0FBRUEsTUFBTUM7SUFDSkMsWUFBYVQsUUFBUSxFQUFFRCxLQUFLLEVBQUVFLE1BQU0sQ0FBRTtRQUNwQyxJQUFJLENBQUNELFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDRCxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDRSxNQUFNLEdBQUdBO1FBRWQsd0JBQXdCO1FBQ3hCLGlDQUFpQztRQUNqQyxxQ0FBcUM7UUFDckMsK0NBQStDO1FBQy9DLElBQUksQ0FBQ0gsS0FBSyxHQUFHLENBQUM7UUFFZCxJQUFJLENBQUNNLE9BQU87SUFDZDtJQUVBQSxVQUFXO1FBQ1QsSUFBSSxJQUFJLENBQUNOLEtBQUssS0FBSyxDQUFDLEdBQUc7WUFDckJOLFdBQVdrQixJQUFJLENBQUMsSUFBSTtZQUNwQixJQUFJLENBQUNuQixrQkFBa0JDLFdBQVdHLE1BQU0sS0FBSyxHQUFHO2dCQUM5Q1E7WUFDRjtRQUNGO1FBRUEsSUFBSSxDQUFDTCxLQUFLLEdBQUc7SUFDZjtJQUVBYSxRQUFTO1FBQ1AsSUFBSSxDQUFDYixLQUFLLEdBQUcsQ0FBQztJQUNoQjtBQUNGO0FBRUFjLE9BQU9DLE9BQU8sR0FBRztJQUNmUCxZQUFZTixRQUFRLEVBQUVELEtBQUssRUFBRUUsTUFBTTtRQUNqQyxPQUFPRixRQUFRLE1BQ1hPLFdBQVdOLFVBQVVELE9BQU9FLFVBQzVCLElBQUlPLFFBQVFSLFVBQVVELE9BQU9FO0lBQ25DO0lBQ0FJLGNBQWNTLE9BQU87UUFDbkIsSUFBSUEsbUJBQW1CTixTQUFTO1lBQzlCTSxRQUFRSCxLQUFLO1FBQ2YsT0FBTztZQUNMTixhQUFhUztRQUNmO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3RpbWVycy5qcz8yMTE5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5sZXQgZmFzdE5vdyA9IERhdGUubm93KClcbmxldCBmYXN0Tm93VGltZW91dFxuXG5jb25zdCBmYXN0VGltZXJzID0gW11cblxuZnVuY3Rpb24gb25UaW1lb3V0ICgpIHtcbiAgZmFzdE5vdyA9IERhdGUubm93KClcblxuICBsZXQgbGVuID0gZmFzdFRpbWVycy5sZW5ndGhcbiAgbGV0IGlkeCA9IDBcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGNvbnN0IHRpbWVyID0gZmFzdFRpbWVyc1tpZHhdXG5cbiAgICBpZiAodGltZXIuc3RhdGUgPT09IDApIHtcbiAgICAgIHRpbWVyLnN0YXRlID0gZmFzdE5vdyArIHRpbWVyLmRlbGF5XG4gICAgfSBlbHNlIGlmICh0aW1lci5zdGF0ZSA+IDAgJiYgZmFzdE5vdyA+PSB0aW1lci5zdGF0ZSkge1xuICAgICAgdGltZXIuc3RhdGUgPSAtMVxuICAgICAgdGltZXIuY2FsbGJhY2sodGltZXIub3BhcXVlKVxuICAgIH1cblxuICAgIGlmICh0aW1lci5zdGF0ZSA9PT0gLTEpIHtcbiAgICAgIHRpbWVyLnN0YXRlID0gLTJcbiAgICAgIGlmIChpZHggIT09IGxlbiAtIDEpIHtcbiAgICAgICAgZmFzdFRpbWVyc1tpZHhdID0gZmFzdFRpbWVycy5wb3AoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmFzdFRpbWVycy5wb3AoKVxuICAgICAgfVxuICAgICAgbGVuIC09IDFcbiAgICB9IGVsc2Uge1xuICAgICAgaWR4ICs9IDFcbiAgICB9XG4gIH1cblxuICBpZiAoZmFzdFRpbWVycy5sZW5ndGggPiAwKSB7XG4gICAgcmVmcmVzaFRpbWVvdXQoKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlZnJlc2hUaW1lb3V0ICgpIHtcbiAgaWYgKGZhc3ROb3dUaW1lb3V0ICYmIGZhc3ROb3dUaW1lb3V0LnJlZnJlc2gpIHtcbiAgICBmYXN0Tm93VGltZW91dC5yZWZyZXNoKClcbiAgfSBlbHNlIHtcbiAgICBjbGVhclRpbWVvdXQoZmFzdE5vd1RpbWVvdXQpXG4gICAgZmFzdE5vd1RpbWVvdXQgPSBzZXRUaW1lb3V0KG9uVGltZW91dCwgMWUzKVxuICAgIGlmIChmYXN0Tm93VGltZW91dC51bnJlZikge1xuICAgICAgZmFzdE5vd1RpbWVvdXQudW5yZWYoKVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBUaW1lb3V0IHtcbiAgY29uc3RydWN0b3IgKGNhbGxiYWNrLCBkZWxheSwgb3BhcXVlKSB7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy5kZWxheSA9IGRlbGF5XG4gICAgdGhpcy5vcGFxdWUgPSBvcGFxdWVcblxuICAgIC8vICAtMiBub3QgaW4gdGltZXIgbGlzdFxuICAgIC8vICAtMSBpbiB0aW1lciBsaXN0IGJ1dCBpbmFjdGl2ZVxuICAgIC8vICAgMCBpbiB0aW1lciBsaXN0IHdhaXRpbmcgZm9yIHRpbWVcbiAgICAvLyA+IDAgaW4gdGltZXIgbGlzdCB3YWl0aW5nIGZvciB0aW1lIHRvIGV4cGlyZVxuICAgIHRoaXMuc3RhdGUgPSAtMlxuXG4gICAgdGhpcy5yZWZyZXNoKClcbiAgfVxuXG4gIHJlZnJlc2ggKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSAtMikge1xuICAgICAgZmFzdFRpbWVycy5wdXNoKHRoaXMpXG4gICAgICBpZiAoIWZhc3ROb3dUaW1lb3V0IHx8IGZhc3RUaW1lcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJlZnJlc2hUaW1lb3V0KClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gMFxuICB9XG5cbiAgY2xlYXIgKCkge1xuICAgIHRoaXMuc3RhdGUgPSAtMVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXRUaW1lb3V0IChjYWxsYmFjaywgZGVsYXksIG9wYXF1ZSkge1xuICAgIHJldHVybiBkZWxheSA8IDFlM1xuICAgICAgPyBzZXRUaW1lb3V0KGNhbGxiYWNrLCBkZWxheSwgb3BhcXVlKVxuICAgICAgOiBuZXcgVGltZW91dChjYWxsYmFjaywgZGVsYXksIG9wYXF1ZSlcbiAgfSxcbiAgY2xlYXJUaW1lb3V0ICh0aW1lb3V0KSB7XG4gICAgaWYgKHRpbWVvdXQgaW5zdGFuY2VvZiBUaW1lb3V0KSB7XG4gICAgICB0aW1lb3V0LmNsZWFyKClcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiZmFzdE5vdyIsIkRhdGUiLCJub3ciLCJmYXN0Tm93VGltZW91dCIsImZhc3RUaW1lcnMiLCJvblRpbWVvdXQiLCJsZW4iLCJsZW5ndGgiLCJpZHgiLCJ0aW1lciIsInN0YXRlIiwiZGVsYXkiLCJjYWxsYmFjayIsIm9wYXF1ZSIsInBvcCIsInJlZnJlc2hUaW1lb3V0IiwicmVmcmVzaCIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJ1bnJlZiIsIlRpbWVvdXQiLCJjb25zdHJ1Y3RvciIsInB1c2giLCJjbGVhciIsIm1vZHVsZSIsImV4cG9ydHMiLCJ0aW1lb3V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/timers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/connection.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/websocket/connection.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst diagnosticsChannel = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\");\nconst { uid, states } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/constants.js\");\nconst { kReadyState, kSentClose, kByteParser, kReceivedClose } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/symbols.js\");\nconst { fireEvent, failWebsocketConnection } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/util.js\");\nconst { CloseEvent } = __webpack_require__(/*! ./events */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/events.js\");\nconst { makeRequest } = __webpack_require__(/*! ../fetch/request */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/request.js\");\nconst { fetching } = __webpack_require__(/*! ../fetch/index */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/index.js\");\nconst { Headers } = __webpack_require__(/*! ../fetch/headers */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/headers.js\");\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../global */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/global.js\");\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/symbols.js\");\nconst channels = {};\nchannels.open = diagnosticsChannel.channel(\"undici:websocket:open\");\nchannels.close = diagnosticsChannel.channel(\"undici:websocket:close\");\nchannels.socketError = diagnosticsChannel.channel(\"undici:websocket:socket_error\");\n/** @type {import('crypto')} */ let crypto;\ntry {\n    crypto = __webpack_require__(/*! crypto */ \"crypto\");\n} catch  {}\n/**\n * @see https://websockets.spec.whatwg.org/#concept-websocket-establish\n * @param {URL} url\n * @param {string|string[]} protocols\n * @param {import('./websocket').WebSocket} ws\n * @param {(response: any) => void} onEstablish\n * @param {Partial<import('../../types/websocket').WebSocketInit>} options\n */ function establishWebSocketConnection(url, protocols, ws, onEstablish, options) {\n    // 1. Let requestURL be a copy of url, with its scheme set to \"http\", if urls\n    //    scheme is \"ws\", and to \"https\" otherwise.\n    const requestURL = url;\n    requestURL.protocol = url.protocol === \"ws:\" ? \"http:\" : \"https:\";\n    // 2. Let request be a new request, whose URL is requestURL, client is client,\n    //    service-workers mode is \"none\", referrer is \"no-referrer\", mode is\n    //    \"websocket\", credentials mode is \"include\", cache mode is \"no-store\" ,\n    //    and redirect mode is \"error\".\n    const request = makeRequest({\n        urlList: [\n            requestURL\n        ],\n        serviceWorkers: \"none\",\n        referrer: \"no-referrer\",\n        mode: \"websocket\",\n        credentials: \"include\",\n        cache: \"no-store\",\n        redirect: \"error\"\n    });\n    // Note: undici extension, allow setting custom headers.\n    if (options.headers) {\n        const headersList = new Headers(options.headers)[kHeadersList];\n        request.headersList = headersList;\n    }\n    // 3. Append (`Upgrade`, `websocket`) to requests header list.\n    // 4. Append (`Connection`, `Upgrade`) to requests header list.\n    // Note: both of these are handled by undici currently.\n    // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397\n    // 5. Let keyValue be a nonce consisting of a randomly selected\n    //    16-byte value that has been forgiving-base64-encoded and\n    //    isomorphic encoded.\n    const keyValue = crypto.randomBytes(16).toString(\"base64\");\n    // 6. Append (`Sec-WebSocket-Key`, keyValue) to requests\n    //    header list.\n    request.headersList.append(\"sec-websocket-key\", keyValue);\n    // 7. Append (`Sec-WebSocket-Version`, `13`) to requests\n    //    header list.\n    request.headersList.append(\"sec-websocket-version\", \"13\");\n    // 8. For each protocol in protocols, combine\n    //    (`Sec-WebSocket-Protocol`, protocol) in requests header\n    //    list.\n    for (const protocol of protocols){\n        request.headersList.append(\"sec-websocket-protocol\", protocol);\n    }\n    // 9. Let permessageDeflate be a user-agent defined\n    //    \"permessage-deflate\" extension header value.\n    // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673\n    // TODO: enable once permessage-deflate is supported\n    const permessageDeflate = \"\" // 'permessage-deflate; 15'\n    ;\n    // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to\n    //     requests header list.\n    // request.headersList.append('sec-websocket-extensions', permessageDeflate)\n    // 11. Fetch request with useParallelQueue set to true, and\n    //     processResponse given response being these steps:\n    const controller = fetching({\n        request,\n        useParallelQueue: true,\n        dispatcher: options.dispatcher ?? getGlobalDispatcher(),\n        processResponse (response) {\n            // 1. If response is a network error or its status is not 101,\n            //    fail the WebSocket connection.\n            if (response.type === \"error\" || response.status !== 101) {\n                failWebsocketConnection(ws, \"Received network error or non-101 status code.\");\n                return;\n            }\n            // 2. If protocols is not the empty list and extracting header\n            //    list values given `Sec-WebSocket-Protocol` and responses\n            //    header list results in null, failure, or the empty byte\n            //    sequence, then fail the WebSocket connection.\n            if (protocols.length !== 0 && !response.headersList.get(\"Sec-WebSocket-Protocol\")) {\n                failWebsocketConnection(ws, \"Server did not respond with sent protocols.\");\n                return;\n            }\n            // 3. Follow the requirements stated step 2 to step 6, inclusive,\n            //    of the last set of steps in section 4.1 of The WebSocket\n            //    Protocol to validate response. This either results in fail\n            //    the WebSocket connection or the WebSocket connection is\n            //    established.\n            // 2. If the response lacks an |Upgrade| header field or the |Upgrade|\n            //    header field contains a value that is not an ASCII case-\n            //    insensitive match for the value \"websocket\", the client MUST\n            //    _Fail the WebSocket Connection_.\n            if (response.headersList.get(\"Upgrade\")?.toLowerCase() !== \"websocket\") {\n                failWebsocketConnection(ws, 'Server did not set Upgrade header to \"websocket\".');\n                return;\n            }\n            // 3. If the response lacks a |Connection| header field or the\n            //    |Connection| header field doesn't contain a token that is an\n            //    ASCII case-insensitive match for the value \"Upgrade\", the client\n            //    MUST _Fail the WebSocket Connection_.\n            if (response.headersList.get(\"Connection\")?.toLowerCase() !== \"upgrade\") {\n                failWebsocketConnection(ws, 'Server did not set Connection header to \"upgrade\".');\n                return;\n            }\n            // 4. If the response lacks a |Sec-WebSocket-Accept| header field or\n            //    the |Sec-WebSocket-Accept| contains a value other than the\n            //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-\n            //    Key| (as a string, not base64-decoded) with the string \"258EAFA5-\n            //    E914-47DA-95CA-C5AB0DC85B11\" but ignoring any leading and\n            //    trailing whitespace, the client MUST _Fail the WebSocket\n            //    Connection_.\n            const secWSAccept = response.headersList.get(\"Sec-WebSocket-Accept\");\n            const digest = crypto.createHash(\"sha1\").update(keyValue + uid).digest(\"base64\");\n            if (secWSAccept !== digest) {\n                failWebsocketConnection(ws, \"Incorrect hash received in Sec-WebSocket-Accept header.\");\n                return;\n            }\n            // 5. If the response includes a |Sec-WebSocket-Extensions| header\n            //    field and this header field indicates the use of an extension\n            //    that was not present in the client's handshake (the server has\n            //    indicated an extension not requested by the client), the client\n            //    MUST _Fail the WebSocket Connection_.  (The parsing of this\n            //    header field to determine which extensions are requested is\n            //    discussed in Section 9.1.)\n            const secExtension = response.headersList.get(\"Sec-WebSocket-Extensions\");\n            if (secExtension !== null && secExtension !== permessageDeflate) {\n                failWebsocketConnection(ws, \"Received different permessage-deflate than the one set.\");\n                return;\n            }\n            // 6. If the response includes a |Sec-WebSocket-Protocol| header field\n            //    and this header field indicates the use of a subprotocol that was\n            //    not present in the client's handshake (the server has indicated a\n            //    subprotocol not requested by the client), the client MUST _Fail\n            //    the WebSocket Connection_.\n            const secProtocol = response.headersList.get(\"Sec-WebSocket-Protocol\");\n            if (secProtocol !== null && secProtocol !== request.headersList.get(\"Sec-WebSocket-Protocol\")) {\n                failWebsocketConnection(ws, \"Protocol was not set in the opening handshake.\");\n                return;\n            }\n            response.socket.on(\"data\", onSocketData);\n            response.socket.on(\"close\", onSocketClose);\n            response.socket.on(\"error\", onSocketError);\n            if (channels.open.hasSubscribers) {\n                channels.open.publish({\n                    address: response.socket.address(),\n                    protocol: secProtocol,\n                    extensions: secExtension\n                });\n            }\n            onEstablish(response);\n        }\n    });\n    return controller;\n}\n/**\n * @param {Buffer} chunk\n */ function onSocketData(chunk) {\n    if (!this.ws[kByteParser].write(chunk)) {\n        this.pause();\n    }\n}\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4\n */ function onSocketClose() {\n    const { ws } = this;\n    // If the TCP connection was closed after the\n    // WebSocket closing handshake was completed, the WebSocket connection\n    // is said to have been closed _cleanly_.\n    const wasClean = ws[kSentClose] && ws[kReceivedClose];\n    let code = 1005;\n    let reason = \"\";\n    const result = ws[kByteParser].closingInfo;\n    if (result) {\n        code = result.code ?? 1005;\n        reason = result.reason;\n    } else if (!ws[kSentClose]) {\n        // If _The WebSocket\n        // Connection is Closed_ and no Close control frame was received by the\n        // endpoint (such as could occur if the underlying transport connection\n        // is lost), _The WebSocket Connection Close Code_ is considered to be\n        // 1006.\n        code = 1006;\n    }\n    // 1. Change the ready state to CLOSED (3).\n    ws[kReadyState] = states.CLOSED;\n    // 2. If the user agent was required to fail the WebSocket\n    //    connection, or if the WebSocket connection was closed\n    //    after being flagged as full, fire an event named error\n    //    at the WebSocket object.\n    // TODO\n    // 3. Fire an event named close at the WebSocket object,\n    //    using CloseEvent, with the wasClean attribute\n    //    initialized to true if the connection closed cleanly\n    //    and false otherwise, the code attribute initialized to\n    //    the WebSocket connection close code, and the reason\n    //    attribute initialized to the result of applying UTF-8\n    //    decode without BOM to the WebSocket connection close\n    //    reason.\n    fireEvent(\"close\", ws, CloseEvent, {\n        wasClean,\n        code,\n        reason\n    });\n    if (channels.close.hasSubscribers) {\n        channels.close.publish({\n            websocket: ws,\n            code,\n            reason\n        });\n    }\n}\nfunction onSocketError(error) {\n    const { ws } = this;\n    ws[kReadyState] = states.CLOSING;\n    if (channels.socketError.hasSubscribers) {\n        channels.socketError.publish(error);\n    }\n    this.destroy();\n}\nmodule.exports = {\n    establishWebSocketConnection\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L2Nvbm5lY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxxQkFBcUJDLG1CQUFPQSxDQUFDO0FBQ25DLE1BQU0sRUFBRUMsR0FBRyxFQUFFQyxNQUFNLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDaEMsTUFBTSxFQUNKRyxXQUFXLEVBQ1hDLFVBQVUsRUFDVkMsV0FBVyxFQUNYQyxjQUFjLEVBQ2YsR0FBR04sbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQUVPLFNBQVMsRUFBRUMsdUJBQXVCLEVBQUUsR0FBR1IsbUJBQU9BLENBQUM7QUFDdkQsTUFBTSxFQUFFUyxVQUFVLEVBQUUsR0FBR1QsbUJBQU9BLENBQUM7QUFDL0IsTUFBTSxFQUFFVSxXQUFXLEVBQUUsR0FBR1YsbUJBQU9BLENBQUM7QUFDaEMsTUFBTSxFQUFFVyxRQUFRLEVBQUUsR0FBR1gsbUJBQU9BLENBQUM7QUFDN0IsTUFBTSxFQUFFWSxPQUFPLEVBQUUsR0FBR1osbUJBQU9BLENBQUM7QUFDNUIsTUFBTSxFQUFFYSxtQkFBbUIsRUFBRSxHQUFHYixtQkFBT0EsQ0FBQztBQUN4QyxNQUFNLEVBQUVjLFlBQVksRUFBRSxHQUFHZCxtQkFBT0EsQ0FBQztBQUVqQyxNQUFNZSxXQUFXLENBQUM7QUFDbEJBLFNBQVNDLElBQUksR0FBR2pCLG1CQUFtQmtCLE9BQU8sQ0FBQztBQUMzQ0YsU0FBU0csS0FBSyxHQUFHbkIsbUJBQW1Ca0IsT0FBTyxDQUFDO0FBQzVDRixTQUFTSSxXQUFXLEdBQUdwQixtQkFBbUJrQixPQUFPLENBQUM7QUFFbEQsNkJBQTZCLEdBQzdCLElBQUlHO0FBQ0osSUFBSTtJQUNGQSxTQUFTcEIsbUJBQU9BLENBQUM7QUFDbkIsRUFBRSxPQUFNLENBRVI7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU3FCLDZCQUE4QkMsR0FBRyxFQUFFQyxTQUFTLEVB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QUFTRyxLQUFLLENBQUNnRCxPQUFPLENBQUM7WUFDckJZLFdBQVd0RDtZQUNYaUQ7WUFDQUM7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxTQUFTVixjQUFlZSxLQUFLO0lBQzNCLE1BQU0sRUFBRXZELEVBQUUsRUFBRSxHQUFHLElBQUk7SUFFbkJBLEVBQUUsQ0FBQ3JCLFlBQVksR0FBR0QsT0FBTzhFLE9BQU87SUFFaEMsSUFBSWpFLFNBQVNJLFdBQVcsQ0FBQzhDLGNBQWMsRUFBRTtRQUN2Q2xELFNBQVNJLFdBQVcsQ0FBQytDLE9BQU8sQ0FBQ2E7SUFDL0I7SUFFQSxJQUFJLENBQUNFLE9BQU87QUFDZDtBQUVBQyxPQUFPQyxPQUFPLEdBQUc7SUFDZjlEO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvY29ubmVjdGlvbi5qcz9jZTMwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBkaWFnbm9zdGljc0NoYW5uZWwgPSByZXF1aXJlKCdkaWFnbm9zdGljc19jaGFubmVsJylcbmNvbnN0IHsgdWlkLCBzdGF0ZXMgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHtcbiAga1JlYWR5U3RhdGUsXG4gIGtTZW50Q2xvc2UsXG4gIGtCeXRlUGFyc2VyLFxuICBrUmVjZWl2ZWRDbG9zZVxufSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IGZpcmVFdmVudCwgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24gfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IENsb3NlRXZlbnQgfSA9IHJlcXVpcmUoJy4vZXZlbnRzJylcbmNvbnN0IHsgbWFrZVJlcXVlc3QgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3JlcXVlc3QnKVxuY29uc3QgeyBmZXRjaGluZyB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvaW5kZXgnKVxuY29uc3QgeyBIZWFkZXJzIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9oZWFkZXJzJylcbmNvbnN0IHsgZ2V0R2xvYmFsRGlzcGF0Y2hlciB9ID0gcmVxdWlyZSgnLi4vZ2xvYmFsJylcbmNvbnN0IHsga0hlYWRlcnNMaXN0IH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuXG5jb25zdCBjaGFubmVscyA9IHt9XG5jaGFubmVscy5vcGVuID0gZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTp3ZWJzb2NrZXQ6b3BlbicpXG5jaGFubmVscy5jbG9zZSA9IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0OmNsb3NlJylcbmNoYW5uZWxzLnNvY2tldEVycm9yID0gZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTp3ZWJzb2NrZXQ6c29ja2V0X2Vycm9yJylcblxuLyoqIEB0eXBlIHtpbXBvcnQoJ2NyeXB0bycpfSAqL1xubGV0IGNyeXB0b1xudHJ5IHtcbiAgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcbn0gY2F0Y2gge1xuXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXdlYnNvY2tldC1lc3RhYmxpc2hcbiAqIEBwYXJhbSB7VVJMfSB1cmxcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwcm90b2NvbHNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3dlYnNvY2tldCcpLldlYlNvY2tldH0gd3NcbiAqIEBwYXJhbSB7KHJlc3BvbnNlOiBhbnkpID0+IHZvaWR9IG9uRXN0YWJsaXNoXG4gKiBAcGFyYW0ge1BhcnRpYWw8aW1wb3J0KCcuLi8uLi90eXBlcy93ZWJzb2NrZXQnKS5XZWJTb2NrZXRJbml0Pn0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBlc3RhYmxpc2hXZWJTb2NrZXRDb25uZWN0aW9uICh1cmwsIHByb3RvY29scywgd3MsIG9uRXN0YWJsaXNoLCBvcHRpb25zKSB7XG4gIC8vIDEuIExldCByZXF1ZXN0VVJMIGJlIGEgY29weSBvZiB1cmwsIHdpdGggaXRzIHNjaGVtZSBzZXQgdG8gXCJodHRwXCIsIGlmIHVybOKAmXNcbiAgLy8gICAgc2NoZW1lIGlzIFwid3NcIiwgYW5kIHRvIFwiaHR0cHNcIiBvdGhlcndpc2UuXG4gIGNvbnN0IHJlcXVlc3RVUkwgPSB1cmxcblxuICByZXF1ZXN0VVJMLnByb3RvY29sID0gdXJsLnByb3RvY29sID09PSAnd3M6JyA/ICdodHRwOicgOiAnaHR0cHM6J1xuXG4gIC8vIDIuIExldCByZXF1ZXN0IGJlIGEgbmV3IHJlcXVlc3QsIHdob3NlIFVSTCBpcyByZXF1ZXN0VVJMLCBjbGllbnQgaXMgY2xpZW50LFxuICAvLyAgICBzZXJ2aWNlLXdvcmtlcnMgbW9kZSBpcyBcIm5vbmVcIiwgcmVmZXJyZXIgaXMgXCJuby1yZWZlcnJlclwiLCBtb2RlIGlzXG4gIC8vICAgIFwid2Vic29ja2V0XCIsIGNyZWRlbnRpYWxzIG1vZGUgaXMgXCJpbmNsdWRlXCIsIGNhY2hlIG1vZGUgaXMgXCJuby1zdG9yZVwiICxcbiAgLy8gICAgYW5kIHJlZGlyZWN0IG1vZGUgaXMgXCJlcnJvclwiLlxuICBjb25zdCByZXF1ZXN0ID0gbWFrZVJlcXVlc3Qoe1xuICAgIHVybExpc3Q6IFtyZXF1ZXN0VVJMXSxcbiAgICBzZXJ2aWNlV29ya2VyczogJ25vbmUnLFxuICAgIHJlZmVycmVyOiAnbm8tcmVmZXJyZXInLFxuICAgIG1vZGU6ICd3ZWJzb2NrZXQnLFxuICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG4gICAgY2FjaGU6ICduby1zdG9yZScsXG4gICAgcmVkaXJlY3Q6ICdlcnJvcidcbiAgfSlcblxuICAvLyBOb3RlOiB1bmRpY2kgZXh0ZW5zaW9uLCBhbGxvdyBzZXR0aW5nIGN1c3RvbSBoZWFkZXJzLlxuICBpZiAob3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgY29uc3QgaGVhZGVyc0xpc3QgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpW2tIZWFkZXJzTGlzdF1cblxuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QgPSBoZWFkZXJzTGlzdFxuICB9XG5cbiAgLy8gMy4gQXBwZW5kIChgVXBncmFkZWAsIGB3ZWJzb2NrZXRgKSB0byByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgLy8gNC4gQXBwZW5kIChgQ29ubmVjdGlvbmAsIGBVcGdyYWRlYCkgdG8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIC8vIE5vdGU6IGJvdGggb2YgdGhlc2UgYXJlIGhhbmRsZWQgYnkgdW5kaWNpIGN1cnJlbnRseS5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvYmxvYi82OGMyNjljNDE0NGM0NDZmM2YxMjIwOTUxMzM4ZGFlZjRhNmI1ZWM0L2xpYi9jbGllbnQuanMjTDEzOTdcblxuICAvLyA1LiBMZXQga2V5VmFsdWUgYmUgYSBub25jZSBjb25zaXN0aW5nIG9mIGEgcmFuZG9tbHkgc2VsZWN0ZWRcbiAgLy8gICAgMTYtYnl0ZSB2YWx1ZSB0aGF0IGhhcyBiZWVuIGZvcmdpdmluZy1iYXNlNjQtZW5jb2RlZCBhbmRcbiAgLy8gICAgaXNvbW9ycGhpYyBlbmNvZGVkLlxuICBjb25zdCBrZXlWYWx1ZSA9IGNyeXB0by5yYW5kb21CeXRlcygxNikudG9TdHJpbmcoJ2Jhc2U2NCcpXG5cbiAgLy8gNi4gQXBwZW5kIChgU2VjLVdlYlNvY2tldC1LZXlgLCBrZXlWYWx1ZSkgdG8gcmVxdWVzdOKAmXNcbiAgLy8gICAgaGVhZGVyIGxpc3QuXG4gIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdzZWMtd2Vic29ja2V0LWtleScsIGtleVZhbHVlKVxuXG4gIC8vIDcuIEFwcGVuZCAoYFNlYy1XZWJTb2NrZXQtVmVyc2lvbmAsIGAxM2ApIHRvIHJlcXVlc3TigJlzXG4gIC8vICAgIGhlYWRlciBsaXN0LlxuICByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnc2VjLXdlYnNvY2tldC12ZXJzaW9uJywgJzEzJylcblxuICAvLyA4LiBGb3IgZWFjaCBwcm90b2NvbCBpbiBwcm90b2NvbHMsIGNvbWJpbmVcbiAgLy8gICAgKGBTZWMtV2ViU29ja2V0LVByb3RvY29sYCwgcHJvdG9jb2wpIGluIHJlcXVlc3TigJlzIGhlYWRlclxuICAvLyAgICBsaXN0LlxuICBmb3IgKGNvbnN0IHByb3RvY29sIG9mIHByb3RvY29scykge1xuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdzZWMtd2Vic29ja2V0LXByb3RvY29sJywgcHJvdG9jb2wpXG4gIH1cblxuICAvLyA5LiBMZXQgcGVybWVzc2FnZURlZmxhdGUgYmUgYSB1c2VyLWFnZW50IGRlZmluZWRcbiAgLy8gICAgXCJwZXJtZXNzYWdlLWRlZmxhdGVcIiBleHRlbnNpb24gaGVhZGVyIHZhbHVlLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9nZWNrby1kZXYvYmxvYi9jZTc4MjM0ZjVlNjUzYTVkMzkxNjgxM2ZmOTkwZjA1MzUxMDIyN2JjL25ldHdlcmsvcHJvdG9jb2wvd2Vic29ja2V0L1dlYlNvY2tldENoYW5uZWwuY3BwI0wyNjczXG4gIC8vIFRPRE86IGVuYWJsZSBvbmNlIHBlcm1lc3NhZ2UtZGVmbGF0ZSBpcyBzdXBwb3J0ZWRcbiAgY29uc3QgcGVybWVzc2FnZURlZmxhdGUgPSAnJyAvLyAncGVybWVzc2FnZS1kZWZsYXRlOyAxNSdcblxuICAvLyAxMC4gQXBwZW5kIChgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zYCwgcGVybWVzc2FnZURlZmxhdGUpIHRvXG4gIC8vICAgICByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgLy8gcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucycsIHBlcm1lc3NhZ2VEZWZsYXRlKVxuXG4gIC8vIDExLiBGZXRjaCByZXF1ZXN0IHdpdGggdXNlUGFyYWxsZWxRdWV1ZSBzZXQgdG8gdHJ1ZSwgYW5kXG4gIC8vICAgICBwcm9jZXNzUmVzcG9uc2UgZ2l2ZW4gcmVzcG9uc2UgYmVpbmcgdGhlc2Ugc3RlcHM6XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBmZXRjaGluZyh7XG4gICAgcmVxdWVzdCxcbiAgICB1c2VQYXJhbGxlbFF1ZXVlOiB0cnVlLFxuICAgIGRpc3BhdGNoZXI6IG9wdGlvbnMuZGlzcGF0Y2hlciA/PyBnZXRHbG9iYWxEaXNwYXRjaGVyKCksXG4gICAgcHJvY2Vzc1Jlc3BvbnNlIChyZXNwb25zZSkge1xuICAgICAgLy8gMS4gSWYgcmVzcG9uc2UgaXMgYSBuZXR3b3JrIGVycm9yIG9yIGl0cyBzdGF0dXMgaXMgbm90IDEwMSxcbiAgICAgIC8vICAgIGZhaWwgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT09ICdlcnJvcicgfHwgcmVzcG9uc2Uuc3RhdHVzICE9PSAxMDEpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdSZWNlaXZlZCBuZXR3b3JrIGVycm9yIG9yIG5vbi0xMDEgc3RhdHVzIGNvZGUuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIElmIHByb3RvY29scyBpcyBub3QgdGhlIGVtcHR5IGxpc3QgYW5kIGV4dHJhY3RpbmcgaGVhZGVyXG4gICAgICAvLyAgICBsaXN0IHZhbHVlcyBnaXZlbiBgU2VjLVdlYlNvY2tldC1Qcm90b2NvbGAgYW5kIHJlc3BvbnNl4oCZc1xuICAgICAgLy8gICAgaGVhZGVyIGxpc3QgcmVzdWx0cyBpbiBudWxsLCBmYWlsdXJlLCBvciB0aGUgZW1wdHkgYnl0ZVxuICAgICAgLy8gICAgc2VxdWVuY2UsIHRoZW4gZmFpbCB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAgICBpZiAocHJvdG9jb2xzLmxlbmd0aCAhPT0gMCAmJiAhcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdTZWMtV2ViU29ja2V0LVByb3RvY29sJykpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdTZXJ2ZXIgZGlkIG5vdCByZXNwb25kIHdpdGggc2VudCBwcm90b2NvbHMuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIEZvbGxvdyB0aGUgcmVxdWlyZW1lbnRzIHN0YXRlZCBzdGVwIDIgdG8gc3RlcCA2LCBpbmNsdXNpdmUsXG4gICAgICAvLyAgICBvZiB0aGUgbGFzdCBzZXQgb2Ygc3RlcHMgaW4gc2VjdGlvbiA0LjEgb2YgVGhlIFdlYlNvY2tldFxuICAgICAgLy8gICAgUHJvdG9jb2wgdG8gdmFsaWRhdGUgcmVzcG9uc2UuIFRoaXMgZWl0aGVyIHJlc3VsdHMgaW4gZmFpbFxuICAgICAgLy8gICAgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIG9yIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpc1xuICAgICAgLy8gICAgZXN0YWJsaXNoZWQuXG5cbiAgICAgIC8vIDIuIElmIHRoZSByZXNwb25zZSBsYWNrcyBhbiB8VXBncmFkZXwgaGVhZGVyIGZpZWxkIG9yIHRoZSB8VXBncmFkZXxcbiAgICAgIC8vICAgIGhlYWRlciBmaWVsZCBjb250YWlucyBhIHZhbHVlIHRoYXQgaXMgbm90IGFuIEFTQ0lJIGNhc2UtXG4gICAgICAvLyAgICBpbnNlbnNpdGl2ZSBtYXRjaCBmb3IgdGhlIHZhbHVlIFwid2Vic29ja2V0XCIsIHRoZSBjbGllbnQgTVVTVFxuICAgICAgLy8gICAgX0ZhaWwgdGhlIFdlYlNvY2tldCBDb25uZWN0aW9uXy5cbiAgICAgIGlmIChyZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ1VwZ3JhZGUnKT8udG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdTZXJ2ZXIgZGlkIG5vdCBzZXQgVXBncmFkZSBoZWFkZXIgdG8gXCJ3ZWJzb2NrZXRcIi4nKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gMy4gSWYgdGhlIHJlc3BvbnNlIGxhY2tzIGEgfENvbm5lY3Rpb258IGhlYWRlciBmaWVsZCBvciB0aGVcbiAgICAgIC8vICAgIHxDb25uZWN0aW9ufCBoZWFkZXIgZmllbGQgZG9lc24ndCBjb250YWluIGEgdG9rZW4gdGhhdCBpcyBhblxuICAgICAgLy8gICAgQVNDSUkgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3IgdGhlIHZhbHVlIFwiVXBncmFkZVwiLCB0aGUgY2xpZW50XG4gICAgICAvLyAgICBNVVNUIF9GYWlsIHRoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbl8uXG4gICAgICBpZiAocmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdDb25uZWN0aW9uJyk/LnRvTG93ZXJDYXNlKCkgIT09ICd1cGdyYWRlJykge1xuICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih3cywgJ1NlcnZlciBkaWQgbm90IHNldCBDb25uZWN0aW9uIGhlYWRlciB0byBcInVwZ3JhZGVcIi4nKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gNC4gSWYgdGhlIHJlc3BvbnNlIGxhY2tzIGEgfFNlYy1XZWJTb2NrZXQtQWNjZXB0fCBoZWFkZXIgZmllbGQgb3JcbiAgICAgIC8vICAgIHRoZSB8U2VjLVdlYlNvY2tldC1BY2NlcHR8IGNvbnRhaW5zIGEgdmFsdWUgb3RoZXIgdGhhbiB0aGVcbiAgICAgIC8vICAgIGJhc2U2NC1lbmNvZGVkIFNIQS0xIG9mIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZSB8U2VjLVdlYlNvY2tldC1cbiAgICAgIC8vICAgIEtleXwgKGFzIGEgc3RyaW5nLCBub3QgYmFzZTY0LWRlY29kZWQpIHdpdGggdGhlIHN0cmluZyBcIjI1OEVBRkE1LVxuICAgICAgLy8gICAgRTkxNC00N0RBLTk1Q0EtQzVBQjBEQzg1QjExXCIgYnV0IGlnbm9yaW5nIGFueSBsZWFkaW5nIGFuZFxuICAgICAgLy8gICAgdHJhaWxpbmcgd2hpdGVzcGFjZSwgdGhlIGNsaWVudCBNVVNUIF9GYWlsIHRoZSBXZWJTb2NrZXRcbiAgICAgIC8vICAgIENvbm5lY3Rpb25fLlxuICAgICAgY29uc3Qgc2VjV1NBY2NlcHQgPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ1NlYy1XZWJTb2NrZXQtQWNjZXB0JylcbiAgICAgIGNvbnN0IGRpZ2VzdCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKGtleVZhbHVlICsgdWlkKS5kaWdlc3QoJ2Jhc2U2NCcpXG4gICAgICBpZiAoc2VjV1NBY2NlcHQgIT09IGRpZ2VzdCkge1xuICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih3cywgJ0luY29ycmVjdCBoYXNoIHJlY2VpdmVkIGluIFNlYy1XZWJTb2NrZXQtQWNjZXB0IGhlYWRlci4nKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gNS4gSWYgdGhlIHJlc3BvbnNlIGluY2x1ZGVzIGEgfFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc3wgaGVhZGVyXG4gICAgICAvLyAgICBmaWVsZCBhbmQgdGhpcyBoZWFkZXIgZmllbGQgaW5kaWNhdGVzIHRoZSB1c2Ugb2YgYW4gZXh0ZW5zaW9uXG4gICAgICAvLyAgICB0aGF0IHdhcyBub3QgcHJlc2VudCBpbiB0aGUgY2xpZW50J3MgaGFuZHNoYWtlICh0aGUgc2VydmVyIGhhc1xuICAgICAgLy8gICAgaW5kaWNhdGVkIGFuIGV4dGVuc2lvbiBub3QgcmVxdWVzdGVkIGJ5IHRoZSBjbGllbnQpLCB0aGUgY2xpZW50XG4gICAgICAvLyAgICBNVVNUIF9GYWlsIHRoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbl8uICAoVGhlIHBhcnNpbmcgb2YgdGhpc1xuICAgICAgLy8gICAgaGVhZGVyIGZpZWxkIHRvIGRldGVybWluZSB3aGljaCBleHRlbnNpb25zIGFyZSByZXF1ZXN0ZWQgaXNcbiAgICAgIC8vICAgIGRpc2N1c3NlZCBpbiBTZWN0aW9uIDkuMS4pXG4gICAgICBjb25zdCBzZWNFeHRlbnNpb24gPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ1NlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucycpXG5cbiAgICAgIGlmIChzZWNFeHRlbnNpb24gIT09IG51bGwgJiYgc2VjRXh0ZW5zaW9uICE9PSBwZXJtZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih3cywgJ1JlY2VpdmVkIGRpZmZlcmVudCBwZXJtZXNzYWdlLWRlZmxhdGUgdGhhbiB0aGUgb25lIHNldC4nKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gNi4gSWYgdGhlIHJlc3BvbnNlIGluY2x1ZGVzIGEgfFNlYy1XZWJTb2NrZXQtUHJvdG9jb2x8IGhlYWRlciBmaWVsZFxuICAgICAgLy8gICAgYW5kIHRoaXMgaGVhZGVyIGZpZWxkIGluZGljYXRlcyB0aGUgdXNlIG9mIGEgc3VicHJvdG9jb2wgdGhhdCB3YXNcbiAgICAgIC8vICAgIG5vdCBwcmVzZW50IGluIHRoZSBjbGllbnQncyBoYW5kc2hha2UgKHRoZSBzZXJ2ZXIgaGFzIGluZGljYXRlZCBhXG4gICAgICAvLyAgICBzdWJwcm90b2NvbCBub3QgcmVxdWVzdGVkIGJ5IHRoZSBjbGllbnQpLCB0aGUgY2xpZW50IE1VU1QgX0ZhaWxcbiAgICAgIC8vICAgIHRoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbl8uXG4gICAgICBjb25zdCBzZWNQcm90b2NvbCA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnU2VjLVdlYlNvY2tldC1Qcm90b2NvbCcpXG5cbiAgICAgIGlmIChzZWNQcm90b2NvbCAhPT0gbnVsbCAmJiBzZWNQcm90b2NvbCAhPT0gcmVxdWVzdC5oZWFkZXJzTGlzdC5nZXQoJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnKSkge1xuICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih3cywgJ1Byb3RvY29sIHdhcyBub3Qgc2V0IGluIHRoZSBvcGVuaW5nIGhhbmRzaGFrZS4nKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgcmVzcG9uc2Uuc29ja2V0Lm9uKCdkYXRhJywgb25Tb2NrZXREYXRhKVxuICAgICAgcmVzcG9uc2Uuc29ja2V0Lm9uKCdjbG9zZScsIG9uU29ja2V0Q2xvc2UpXG4gICAgICByZXNwb25zZS5zb2NrZXQub24oJ2Vycm9yJywgb25Tb2NrZXRFcnJvcilcblxuICAgICAgaWYgKGNoYW5uZWxzLm9wZW4uaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgY2hhbm5lbHMub3Blbi5wdWJsaXNoKHtcbiAgICAgICAgICBhZGRyZXNzOiByZXNwb25zZS5zb2NrZXQuYWRkcmVzcygpLFxuICAgICAgICAgIHByb3RvY29sOiBzZWNQcm90b2NvbCxcbiAgICAgICAgICBleHRlbnNpb25zOiBzZWNFeHRlbnNpb25cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgb25Fc3RhYmxpc2gocmVzcG9uc2UpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBjb250cm9sbGVyXG59XG5cbi8qKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rXG4gKi9cbmZ1bmN0aW9uIG9uU29ja2V0RGF0YSAoY2h1bmspIHtcbiAgaWYgKCF0aGlzLndzW2tCeXRlUGFyc2VyXS53cml0ZShjaHVuaykpIHtcbiAgICB0aGlzLnBhdXNlKClcbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZmVlZGJhY2stZnJvbS10aGUtcHJvdG9jb2xcbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNy4xLjRcbiAqL1xuZnVuY3Rpb24gb25Tb2NrZXRDbG9zZSAoKSB7XG4gIGNvbnN0IHsgd3MgfSA9IHRoaXNcblxuICAvLyBJZiB0aGUgVENQIGNvbm5lY3Rpb24gd2FzIGNsb3NlZCBhZnRlciB0aGVcbiAgLy8gV2ViU29ja2V0IGNsb3NpbmcgaGFuZHNoYWtlIHdhcyBjb21wbGV0ZWQsIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAvLyBpcyBzYWlkIHRvIGhhdmUgYmVlbiBjbG9zZWQgX2NsZWFubHlfLlxuICBjb25zdCB3YXNDbGVhbiA9IHdzW2tTZW50Q2xvc2VdICYmIHdzW2tSZWNlaXZlZENsb3NlXVxuXG4gIGxldCBjb2RlID0gMTAwNVxuICBsZXQgcmVhc29uID0gJydcblxuICBjb25zdCByZXN1bHQgPSB3c1trQnl0ZVBhcnNlcl0uY2xvc2luZ0luZm9cblxuICBpZiAocmVzdWx0KSB7XG4gICAgY29kZSA9IHJlc3VsdC5jb2RlID8/IDEwMDVcbiAgICByZWFzb24gPSByZXN1bHQucmVhc29uXG4gIH0gZWxzZSBpZiAoIXdzW2tTZW50Q2xvc2VdKSB7XG4gICAgLy8gSWYgX1RoZSBXZWJTb2NrZXRcbiAgICAvLyBDb25uZWN0aW9uIGlzIENsb3NlZF8gYW5kIG5vIENsb3NlIGNvbnRyb2wgZnJhbWUgd2FzIHJlY2VpdmVkIGJ5IHRoZVxuICAgIC8vIGVuZHBvaW50IChzdWNoIGFzIGNvdWxkIG9jY3VyIGlmIHRoZSB1bmRlcmx5aW5nIHRyYW5zcG9ydCBjb25uZWN0aW9uXG4gICAgLy8gaXMgbG9zdCksIF9UaGUgV2ViU29ja2V0IENvbm5lY3Rpb24gQ2xvc2UgQ29kZV8gaXMgY29uc2lkZXJlZCB0byBiZVxuICAgIC8vIDEwMDYuXG4gICAgY29kZSA9IDEwMDZcbiAgfVxuXG4gIC8vIDEuIENoYW5nZSB0aGUgcmVhZHkgc3RhdGUgdG8gQ0xPU0VEICgzKS5cbiAgd3Nba1JlYWR5U3RhdGVdID0gc3RhdGVzLkNMT1NFRFxuXG4gIC8vIDIuIElmIHRoZSB1c2VyIGFnZW50IHdhcyByZXF1aXJlZCB0byBmYWlsIHRoZSBXZWJTb2NrZXRcbiAgLy8gICAgY29ubmVjdGlvbiwgb3IgaWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIHdhcyBjbG9zZWRcbiAgLy8gICAgYWZ0ZXIgYmVpbmcgZmxhZ2dlZCBhcyBmdWxsLCBmaXJlIGFuIGV2ZW50IG5hbWVkIGVycm9yXG4gIC8vICAgIGF0IHRoZSBXZWJTb2NrZXQgb2JqZWN0LlxuICAvLyBUT0RPXG5cbiAgLy8gMy4gRmlyZSBhbiBldmVudCBuYW1lZCBjbG9zZSBhdCB0aGUgV2ViU29ja2V0IG9iamVjdCxcbiAgLy8gICAgdXNpbmcgQ2xvc2VFdmVudCwgd2l0aCB0aGUgd2FzQ2xlYW4gYXR0cmlidXRlXG4gIC8vICAgIGluaXRpYWxpemVkIHRvIHRydWUgaWYgdGhlIGNvbm5lY3Rpb24gY2xvc2VkIGNsZWFubHlcbiAgLy8gICAgYW5kIGZhbHNlIG90aGVyd2lzZSwgdGhlIGNvZGUgYXR0cmlidXRlIGluaXRpYWxpemVkIHRvXG4gIC8vICAgIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBjbG9zZSBjb2RlLCBhbmQgdGhlIHJlYXNvblxuICAvLyAgICBhdHRyaWJ1dGUgaW5pdGlhbGl6ZWQgdG8gdGhlIHJlc3VsdCBvZiBhcHBseWluZyBVVEYtOFxuICAvLyAgICBkZWNvZGUgd2l0aG91dCBCT00gdG8gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGNsb3NlXG4gIC8vICAgIHJlYXNvbi5cbiAgZmlyZUV2ZW50KCdjbG9zZScsIHdzLCBDbG9zZUV2ZW50LCB7XG4gICAgd2FzQ2xlYW4sIGNvZGUsIHJlYXNvblxuICB9KVxuXG4gIGlmIChjaGFubmVscy5jbG9zZS5oYXNTdWJzY3JpYmVycykge1xuICAgIGNoYW5uZWxzLmNsb3NlLnB1Ymxpc2goe1xuICAgICAgd2Vic29ja2V0OiB3cyxcbiAgICAgIGNvZGUsXG4gICAgICByZWFzb25cbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uU29ja2V0RXJyb3IgKGVycm9yKSB7XG4gIGNvbnN0IHsgd3MgfSA9IHRoaXNcblxuICB3c1trUmVhZHlTdGF0ZV0gPSBzdGF0ZXMuQ0xPU0lOR1xuXG4gIGlmIChjaGFubmVscy5zb2NrZXRFcnJvci5oYXNTdWJzY3JpYmVycykge1xuICAgIGNoYW5uZWxzLnNvY2tldEVycm9yLnB1Ymxpc2goZXJyb3IpXG4gIH1cblxuICB0aGlzLmRlc3Ryb3koKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZXN0YWJsaXNoV2ViU29ja2V0Q29ubmVjdGlvblxufVxuIl0sIm5hbWVzIjpbImRpYWdub3N0aWNzQ2hhbm5lbCIsInJlcXVpcmUiLCJ1aWQiLCJzdGF0ZXMiLCJrUmVhZHlTdGF0ZSIsImtTZW50Q2xvc2UiLCJrQnl0ZVBhcnNlciIsImtSZWNlaXZlZENsb3NlIiwiZmlyZUV2ZW50IiwiZmFpbFdlYnNvY2tldENvbm5lY3Rpb24iLCJDbG9zZUV2ZW50IiwibWFrZVJlcXVlc3QiLCJmZXRjaGluZyIsIkhlYWRlcnMiLCJnZXRHbG9iYWxEaXNwYXRjaGVyIiwia0hlYWRlcnNMaXN0IiwiY2hhbm5lbHMiLCJvcGVuIiwiY2hhbm5lbCIsImNsb3NlIiwic29ja2V0RXJyb3IiLCJjcnlwdG8iLCJlc3RhYmxpc2hXZWJTb2NrZXRDb25uZWN0aW9uIiwidXJsIiwicHJvdG9jb2xzIiwid3MiLCJvbkVzdGFibGlzaCIsIm9wdGlvbnMiLCJyZXF1ZXN0VVJMIiwicHJvdG9jb2wiLCJyZXF1ZXN0IiwidXJsTGlzdCIsInNlcnZpY2VXb3JrZXJzIiwicmVmZXJyZXIiLCJtb2RlIiwiY3JlZGVudGlhbHMiLCJjYWNoZSIsInJlZGlyZWN0IiwiaGVhZGVycyIsImhlYWRlcnNMaXN0Iiwia2V5VmFsdWUiLCJyYW5kb21CeXRlcyIsInRvU3RyaW5nIiwiYXBwZW5kIiwicGVybWVzc2FnZURlZmxhdGUiLCJjb250cm9sbGVyIiwidXNlUGFyYWxsZWxRdWV1ZSIsImRpc3BhdGNoZXIiLCJwcm9jZXNzUmVzcG9uc2UiLCJyZXNwb25zZSIsInR5cGUiLCJzdGF0dXMiLCJsZW5ndGgiLCJnZXQiLCJ0b0xvd2VyQ2FzZSIsInNlY1dTQWNjZXB0IiwiZGlnZXN0IiwiY3JlYXRlSGFzaCIsInVwZGF0ZSIsInNlY0V4dGVuc2lvbiIsInNlY1Byb3RvY29sIiwic29ja2V0Iiwib24iLCJvblNvY2tldERhdGEiLCJvblNvY2tldENsb3NlIiwib25Tb2NrZXRFcnJvciIsImhhc1N1YnNjcmliZXJzIiwicHVibGlzaCIsImFkZHJlc3MiLCJleHRlbnNpb25zIiwiY2h1bmsiLCJ3cml0ZSIsInBhdXNlIiwid2FzQ2xlYW4iLCJjb2RlIiwicmVhc29uIiwicmVzdWx0IiwiY2xvc2luZ0luZm8iLCJDTE9TRUQiLCJ3ZWJzb2NrZXQiLCJlcnJvciIsIkNMT1NJTkciLCJkZXN0cm95IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/connection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/constants.js":
/*!******************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/websocket/constants.js ***!
  \******************************************************************************/
/***/ ((module) => {

eval("\n// This is a Globally Unique Identifier unique used\n// to validate that the endpoint accepts websocket\n// connections.\n// See https://www.rfc-editor.org/rfc/rfc6455.html#section-1.3\nconst uid = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n/** @type {PropertyDescriptor} */ const staticPropertyDescriptors = {\n    enumerable: true,\n    writable: false,\n    configurable: false\n};\nconst states = {\n    CONNECTING: 0,\n    OPEN: 1,\n    CLOSING: 2,\n    CLOSED: 3\n};\nconst opcodes = {\n    CONTINUATION: 0x0,\n    TEXT: 0x1,\n    BINARY: 0x2,\n    CLOSE: 0x8,\n    PING: 0x9,\n    PONG: 0xA\n};\nconst maxUnsigned16Bit = 2 ** 16 - 1 // 65535\n;\nconst parserStates = {\n    INFO: 0,\n    PAYLOADLENGTH_16: 2,\n    PAYLOADLENGTH_64: 3,\n    READ_DATA: 4\n};\nconst emptyBuffer = Buffer.allocUnsafe(0);\nmodule.exports = {\n    uid,\n    staticPropertyDescriptors,\n    states,\n    opcodes,\n    maxUnsigned16Bit,\n    parserStates,\n    emptyBuffer\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLG1EQUFtRDtBQUNuRCxrREFBa0Q7QUFDbEQsZUFBZTtBQUNmLDhEQUE4RDtBQUM5RCxNQUFNQSxNQUFNO0FBRVosK0JBQStCLEdBQy9CLE1BQU1DLDRCQUE0QjtJQUNoQ0MsWUFBWTtJQUNaQyxVQUFVO0lBQ1ZDLGNBQWM7QUFDaEI7QUFFQSxNQUFNQyxTQUFTO0lBQ2JDLFlBQVk7SUFDWkMsTUFBTTtJQUNOQyxTQUFTO0lBQ1RDLFFBQVE7QUFDVjtBQUVBLE1BQU1DLFVBQVU7SUFDZEMsY0FBYztJQUNkQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsT0FBTztJQUNQQyxNQUFNO0lBQ05DLE1BQU07QUFDUjtBQUVBLE1BQU1DLG1CQUFtQixLQUFLLEtBQUssRUFBRSxRQUFROztBQUU3QyxNQUFNQyxlQUFlO0lBQ25CQyxNQUFNO0lBQ05DLGtCQUFrQjtJQUNsQkMsa0JBQWtCO0lBQ2xCQyxXQUFXO0FBQ2I7QUFFQSxNQUFNQyxjQUFjQyxPQUFPQyxXQUFXLENBQUM7QUFFdkNDLE9BQU9DLE9BQU8sR0FBRztJQUNmM0I7SUFDQUM7SUFDQUk7SUFDQUs7SUFDQU87SUFDQUM7SUFDQUs7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYnNvY2tldC9jb25zdGFudHMuanM/ZTQ4MiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gVGhpcyBpcyBhIEdsb2JhbGx5IFVuaXF1ZSBJZGVudGlmaWVyIHVuaXF1ZSB1c2VkXG4vLyB0byB2YWxpZGF0ZSB0aGF0IHRoZSBlbmRwb2ludCBhY2NlcHRzIHdlYnNvY2tldFxuLy8gY29ubmVjdGlvbnMuXG4vLyBTZWUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzY0NTUuaHRtbCNzZWN0aW9uLTEuM1xuY29uc3QgdWlkID0gJzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMSdcblxuLyoqIEB0eXBlIHtQcm9wZXJ0eURlc2NyaXB0b3J9ICovXG5jb25zdCBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogZmFsc2UsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2Vcbn1cblxuY29uc3Qgc3RhdGVzID0ge1xuICBDT05ORUNUSU5HOiAwLFxuICBPUEVOOiAxLFxuICBDTE9TSU5HOiAyLFxuICBDTE9TRUQ6IDNcbn1cblxuY29uc3Qgb3Bjb2RlcyA9IHtcbiAgQ09OVElOVUFUSU9OOiAweDAsXG4gIFRFWFQ6IDB4MSxcbiAgQklOQVJZOiAweDIsXG4gIENMT1NFOiAweDgsXG4gIFBJTkc6IDB4OSxcbiAgUE9ORzogMHhBXG59XG5cbmNvbnN0IG1heFVuc2lnbmVkMTZCaXQgPSAyICoqIDE2IC0gMSAvLyA2NTUzNVxuXG5jb25zdCBwYXJzZXJTdGF0ZXMgPSB7XG4gIElORk86IDAsXG4gIFBBWUxPQURMRU5HVEhfMTY6IDIsXG4gIFBBWUxPQURMRU5HVEhfNjQ6IDMsXG4gIFJFQURfREFUQTogNFxufVxuXG5jb25zdCBlbXB0eUJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdWlkLFxuICBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBzdGF0ZXMsXG4gIG9wY29kZXMsXG4gIG1heFVuc2lnbmVkMTZCaXQsXG4gIHBhcnNlclN0YXRlcyxcbiAgZW1wdHlCdWZmZXJcbn1cbiJdLCJuYW1lcyI6WyJ1aWQiLCJzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwic3RhdGVzIiwiQ09OTkVDVElORyIsIk9QRU4iLCJDTE9TSU5HIiwiQ0xPU0VEIiwib3Bjb2RlcyIsIkNPTlRJTlVBVElPTiIsIlRFWFQiLCJCSU5BUlkiLCJDTE9TRSIsIlBJTkciLCJQT05HIiwibWF4VW5zaWduZWQxNkJpdCIsInBhcnNlclN0YXRlcyIsIklORk8iLCJQQVlMT0FETEVOR1RIXzE2IiwiUEFZTE9BRExFTkdUSF82NCIsIlJFQURfREFUQSIsImVtcHR5QnVmZmVyIiwiQnVmZmVyIiwiYWxsb2NVbnNhZmUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/events.js":
/*!***************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/websocket/events.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/webidl.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst { MessagePort } = __webpack_require__(/*! worker_threads */ \"worker_threads\");\n/**\n * @see https://html.spec.whatwg.org/multipage/comms.html#messageevent\n */ class MessageEvent extends Event {\n    #eventInit;\n    constructor(type, eventInitDict = {}){\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"MessageEvent constructor\"\n        });\n        type = webidl.converters.DOMString(type);\n        eventInitDict = webidl.converters.MessageEventInit(eventInitDict);\n        super(type, eventInitDict);\n        this.#eventInit = eventInitDict;\n    }\n    get data() {\n        webidl.brandCheck(this, MessageEvent);\n        return this.#eventInit.data;\n    }\n    get origin() {\n        webidl.brandCheck(this, MessageEvent);\n        return this.#eventInit.origin;\n    }\n    get lastEventId() {\n        webidl.brandCheck(this, MessageEvent);\n        return this.#eventInit.lastEventId;\n    }\n    get source() {\n        webidl.brandCheck(this, MessageEvent);\n        return this.#eventInit.source;\n    }\n    get ports() {\n        webidl.brandCheck(this, MessageEvent);\n        if (!Object.isFrozen(this.#eventInit.ports)) {\n            Object.freeze(this.#eventInit.ports);\n        }\n        return this.#eventInit.ports;\n    }\n    initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = \"\", lastEventId = \"\", source = null, ports = []) {\n        webidl.brandCheck(this, MessageEvent);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"MessageEvent.initMessageEvent\"\n        });\n        return new MessageEvent(type, {\n            bubbles,\n            cancelable,\n            data,\n            origin,\n            lastEventId,\n            source,\n            ports\n        });\n    }\n}\n/**\n * @see https://websockets.spec.whatwg.org/#the-closeevent-interface\n */ class CloseEvent extends Event {\n    #eventInit;\n    constructor(type, eventInitDict = {}){\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"CloseEvent constructor\"\n        });\n        type = webidl.converters.DOMString(type);\n        eventInitDict = webidl.converters.CloseEventInit(eventInitDict);\n        super(type, eventInitDict);\n        this.#eventInit = eventInitDict;\n    }\n    get wasClean() {\n        webidl.brandCheck(this, CloseEvent);\n        return this.#eventInit.wasClean;\n    }\n    get code() {\n        webidl.brandCheck(this, CloseEvent);\n        return this.#eventInit.code;\n    }\n    get reason() {\n        webidl.brandCheck(this, CloseEvent);\n        return this.#eventInit.reason;\n    }\n}\n// https://html.spec.whatwg.org/multipage/webappapis.html#the-errorevent-interface\nclass ErrorEvent extends Event {\n    #eventInit;\n    constructor(type, eventInitDict){\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"ErrorEvent constructor\"\n        });\n        super(type, eventInitDict);\n        type = webidl.converters.DOMString(type);\n        eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});\n        this.#eventInit = eventInitDict;\n    }\n    get message() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.message;\n    }\n    get filename() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.filename;\n    }\n    get lineno() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.lineno;\n    }\n    get colno() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.colno;\n    }\n    get error() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.error;\n    }\n}\nObject.defineProperties(MessageEvent.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"MessageEvent\",\n        configurable: true\n    },\n    data: kEnumerableProperty,\n    origin: kEnumerableProperty,\n    lastEventId: kEnumerableProperty,\n    source: kEnumerableProperty,\n    ports: kEnumerableProperty,\n    initMessageEvent: kEnumerableProperty\n});\nObject.defineProperties(CloseEvent.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"CloseEvent\",\n        configurable: true\n    },\n    reason: kEnumerableProperty,\n    code: kEnumerableProperty,\n    wasClean: kEnumerableProperty\n});\nObject.defineProperties(ErrorEvent.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"ErrorEvent\",\n        configurable: true\n    },\n    message: kEnumerableProperty,\n    filename: kEnumerableProperty,\n    lineno: kEnumerableProperty,\n    colno: kEnumerableProperty,\n    error: kEnumerableProperty\n});\nwebidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);\nwebidl.converters[\"sequence<MessagePort>\"] = webidl.sequenceConverter(webidl.converters.MessagePort);\nconst eventInit = [\n    {\n        key: \"bubbles\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: \"cancelable\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: \"composed\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    }\n];\nwebidl.converters.MessageEventInit = webidl.dictionaryConverter([\n    ...eventInit,\n    {\n        key: \"data\",\n        converter: webidl.converters.any,\n        defaultValue: null\n    },\n    {\n        key: \"origin\",\n        converter: webidl.converters.USVString,\n        defaultValue: \"\"\n    },\n    {\n        key: \"lastEventId\",\n        converter: webidl.converters.DOMString,\n        defaultValue: \"\"\n    },\n    {\n        key: \"source\",\n        // Node doesn't implement WindowProxy or ServiceWorker, so the only\n        // valid value for source is a MessagePort.\n        converter: webidl.nullableConverter(webidl.converters.MessagePort),\n        defaultValue: null\n    },\n    {\n        key: \"ports\",\n        converter: webidl.converters[\"sequence<MessagePort>\"],\n        get defaultValue () {\n            return [];\n        }\n    }\n]);\nwebidl.converters.CloseEventInit = webidl.dictionaryConverter([\n    ...eventInit,\n    {\n        key: \"wasClean\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: \"code\",\n        converter: webidl.converters[\"unsigned short\"],\n        defaultValue: 0\n    },\n    {\n        key: \"reason\",\n        converter: webidl.converters.USVString,\n        defaultValue: \"\"\n    }\n]);\nwebidl.converters.ErrorEventInit = webidl.dictionaryConverter([\n    ...eventInit,\n    {\n        key: \"message\",\n        converter: webidl.converters.DOMString,\n        defaultValue: \"\"\n    },\n    {\n        key: \"filename\",\n        converter: webidl.converters.USVString,\n        defaultValue: \"\"\n    },\n    {\n        key: \"lineno\",\n        converter: webidl.converters[\"unsigned long\"],\n        defaultValue: 0\n    },\n    {\n        key: \"colno\",\n        converter: webidl.converters[\"unsigned long\"],\n        defaultValue: 0\n    },\n    {\n        key: \"error\",\n        converter: webidl.converters.any\n    }\n]);\nmodule.exports = {\n    MessageEvent,\n    CloseEvent,\n    ErrorEvent\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L2V2ZW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsTUFBTSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRUMsbUJBQW1CLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFDeEMsTUFBTSxFQUFFRSxXQUFXLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFFaEM7O0NBRUMsR0FDRCxNQUFNRyxxQkFBcUJDO0lBQ3pCLENBQUNDLFNBQVM7SUFFVkMsWUFBYUMsSUFBSSxFQUFFQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUU7UUFDckNULE9BQU9VLG1CQUFtQixDQUFDQyxXQUFXLEdBQUc7WUFBRUMsUUFBUTtRQUEyQjtRQUU5RUosT0FBT1IsT0FBT2EsVUFBVSxDQUFDQyxTQUFTLENBQUNOO1FBQ25DQyxnQkFBZ0JULE9BQU9hLFVBQVUsQ0FBQ0UsZ0JBQWdCLENBQUNOO1FBRW5ELEtBQUssQ0FBQ0QsTUFBTUM7UUFFWixJQUFJLENBQUMsQ0FBQ0gsU0FBUyxHQUFHRztJQUNwQjtJQUVBLElBQUlPLE9BQVE7UUFDVmhCLE9BQU9pQixVQUFVLENBQUMsSUFBSSxFQUFFYjtRQUV4QixPQUFPLElBQUksQ0FBQyxDQUFDRSxTQUFTLENBQUNVLElBQUk7SUFDN0I7SUFFQSxJQUFJRSxTQUFVO1FBQ1psQixPQUFPaUIsVUFBVSxDQUFDLElBQUksRUFBRWI7UUFFeEIsT0FBTyxJQUFJLENBQUMsQ0FBQ0UsU0FBUyxDQUFDWSxNQUFNO0lBQy9CO0lBRUEsSUFBSUMsY0FBZTtRQUNqQm5CLE9BQU9pQixVQUFVLENBQUMsSUFBSSxFQUFFYjtRQUV4QixPQUFPLElBQUksQ0FBQyxDQUFDRSxTQUFTLENBQUNhLFdBQVc7SUFDcEM7SUFFQSxJQUFJQyxTQUFVO1FBQ1pwQixPQUFPaUIsVUFBVSxDQUFDLElBQUksRUFBRWI7UUFFeEIs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QUFjO0lBQ2hCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXakQsT0FBT2EsVUFBVSxDQUFDeUMsU0FBUztRQUN0Q0gsY0FBYztJQUNoQjtDQUNEO0FBRURuRCxPQUFPYSxVQUFVLENBQUNxQixjQUFjLEdBQUdsQyxPQUFPb0QsbUJBQW1CLENBQUM7T0FDekQ5QztJQUNIO1FBQ0UwQyxLQUFLO1FBQ0xDLFdBQVdqRCxPQUFPYSxVQUFVLENBQUNDLFNBQVM7UUFDdENxQyxjQUFjO0lBQ2hCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXakQsT0FBT2EsVUFBVSxDQUFDeUMsU0FBUztRQUN0Q0gsY0FBYztJQUNoQjtJQUNBO1FBQ0VILEtBQUs7UUFDTEMsV0FBV2pELE9BQU9hLFVBQVUsQ0FBQyxnQkFBZ0I7UUFDN0NzQyxjQUFjO0lBQ2hCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXakQsT0FBT2EsVUFBVSxDQUFDLGdCQUFnQjtRQUM3Q3NDLGNBQWM7SUFDaEI7SUFDQTtRQUNFSCxLQUFLO1FBQ0xDLFdBQVdqRCxPQUFPYSxVQUFVLENBQUN3QyxHQUFHO0lBQ2xDO0NBQ0Q7QUFFREcsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZyRDtJQUNBd0I7SUFDQUs7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYnNvY2tldC9ldmVudHMuanM/ZTA4NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3dlYmlkbCcpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IE1lc3NhZ2VQb3J0IH0gPSByZXF1aXJlKCd3b3JrZXJfdGhyZWFkcycpXG5cbi8qKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9jb21tcy5odG1sI21lc3NhZ2VldmVudFxuICovXG5jbGFzcyBNZXNzYWdlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICNldmVudEluaXRcblxuICBjb25zdHJ1Y3RvciAodHlwZSwgZXZlbnRJbml0RGljdCA9IHt9KSB7XG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ01lc3NhZ2VFdmVudCBjb25zdHJ1Y3RvcicgfSlcblxuICAgIHR5cGUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcodHlwZSlcbiAgICBldmVudEluaXREaWN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuTWVzc2FnZUV2ZW50SW5pdChldmVudEluaXREaWN0KVxuXG4gICAgc3VwZXIodHlwZSwgZXZlbnRJbml0RGljdClcblxuICAgIHRoaXMuI2V2ZW50SW5pdCA9IGV2ZW50SW5pdERpY3RcbiAgfVxuXG4gIGdldCBkYXRhICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBNZXNzYWdlRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LmRhdGFcbiAgfVxuXG4gIGdldCBvcmlnaW4gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIE1lc3NhZ2VFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQub3JpZ2luXG4gIH1cblxuICBnZXQgbGFzdEV2ZW50SWQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIE1lc3NhZ2VFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQubGFzdEV2ZW50SWRcbiAgfVxuXG4gIGdldCBzb3VyY2UgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIE1lc3NhZ2VFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQuc291cmNlXG4gIH1cblxuICBnZXQgcG9ydHMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIE1lc3NhZ2VFdmVudClcblxuICAgIGlmICghT2JqZWN0LmlzRnJvemVuKHRoaXMuI2V2ZW50SW5pdC5wb3J0cykpIHtcbiAgICAgIE9iamVjdC5mcmVlemUodGhpcy4jZXZlbnRJbml0LnBvcnRzKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQucG9ydHNcbiAgfVxuXG4gIGluaXRNZXNzYWdlRXZlbnQgKFxuICAgIHR5cGUsXG4gICAgYnViYmxlcyA9IGZhbHNlLFxuICAgIGNhbmNlbGFibGUgPSBmYWxzZSxcbiAgICBkYXRhID0gbnVsbCxcbiAgICBvcmlnaW4gPSAnJyxcbiAgICBsYXN0RXZlbnRJZCA9ICcnLFxuICAgIHNvdXJjZSA9IG51bGwsXG4gICAgcG9ydHMgPSBbXVxuICApIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBNZXNzYWdlRXZlbnQpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnTWVzc2FnZUV2ZW50LmluaXRNZXNzYWdlRXZlbnQnIH0pXG5cbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VFdmVudCh0eXBlLCB7XG4gICAgICBidWJibGVzLCBjYW5jZWxhYmxlLCBkYXRhLCBvcmlnaW4sIGxhc3RFdmVudElkLCBzb3VyY2UsIHBvcnRzXG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jdGhlLWNsb3NlZXZlbnQtaW50ZXJmYWNlXG4gKi9cbmNsYXNzIENsb3NlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICNldmVudEluaXRcblxuICBjb25zdHJ1Y3RvciAodHlwZSwgZXZlbnRJbml0RGljdCA9IHt9KSB7XG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0Nsb3NlRXZlbnQgY29uc3RydWN0b3InIH0pXG5cbiAgICB0eXBlID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKHR5cGUpXG4gICAgZXZlbnRJbml0RGljdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLkNsb3NlRXZlbnRJbml0KGV2ZW50SW5pdERpY3QpXG5cbiAgICBzdXBlcih0eXBlLCBldmVudEluaXREaWN0KVxuXG4gICAgdGhpcy4jZXZlbnRJbml0ID0gZXZlbnRJbml0RGljdFxuICB9XG5cbiAgZ2V0IHdhc0NsZWFuICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDbG9zZUV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC53YXNDbGVhblxuICB9XG5cbiAgZ2V0IGNvZGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENsb3NlRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LmNvZGVcbiAgfVxuXG4gIGdldCByZWFzb24gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENsb3NlRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LnJlYXNvblxuICB9XG59XG5cbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3dlYmFwcGFwaXMuaHRtbCN0aGUtZXJyb3JldmVudC1pbnRlcmZhY2VcbmNsYXNzIEVycm9yRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICNldmVudEluaXRcblxuICBjb25zdHJ1Y3RvciAodHlwZSwgZXZlbnRJbml0RGljdCkge1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdFcnJvckV2ZW50IGNvbnN0cnVjdG9yJyB9KVxuXG4gICAgc3VwZXIodHlwZSwgZXZlbnRJbml0RGljdClcblxuICAgIHR5cGUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcodHlwZSlcbiAgICBldmVudEluaXREaWN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuRXJyb3JFdmVudEluaXQoZXZlbnRJbml0RGljdCA/PyB7fSlcblxuICAgIHRoaXMuI2V2ZW50SW5pdCA9IGV2ZW50SW5pdERpY3RcbiAgfVxuXG4gIGdldCBtZXNzYWdlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBFcnJvckV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5tZXNzYWdlXG4gIH1cblxuICBnZXQgZmlsZW5hbWUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEVycm9yRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LmZpbGVuYW1lXG4gIH1cblxuICBnZXQgbGluZW5vICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBFcnJvckV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5saW5lbm9cbiAgfVxuXG4gIGdldCBjb2xubyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRXJyb3JFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQuY29sbm9cbiAgfVxuXG4gIGdldCBlcnJvciAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRXJyb3JFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQuZXJyb3JcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhNZXNzYWdlRXZlbnQucHJvdG90eXBlLCB7XG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdNZXNzYWdlRXZlbnQnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9LFxuICBkYXRhOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvcmlnaW46IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGxhc3RFdmVudElkOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBzb3VyY2U6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHBvcnRzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBpbml0TWVzc2FnZUV2ZW50OiBrRW51bWVyYWJsZVByb3BlcnR5XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDbG9zZUV2ZW50LnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnQ2xvc2VFdmVudCcsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0sXG4gIHJlYXNvbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY29kZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgd2FzQ2xlYW46IGtFbnVtZXJhYmxlUHJvcGVydHlcbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEVycm9yRXZlbnQucHJvdG90eXBlLCB7XG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdFcnJvckV2ZW50JyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSxcbiAgbWVzc2FnZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZmlsZW5hbWU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGxpbmVubzoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY29sbm86IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGVycm9yOiBrRW51bWVyYWJsZVByb3BlcnR5XG59KVxuXG53ZWJpZGwuY29udmVydGVycy5NZXNzYWdlUG9ydCA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoTWVzc2FnZVBvcnQpXG5cbndlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxNZXNzYWdlUG9ydD4nXSA9IHdlYmlkbC5zZXF1ZW5jZUNvbnZlcnRlcihcbiAgd2ViaWRsLmNvbnZlcnRlcnMuTWVzc2FnZVBvcnRcbilcblxuY29uc3QgZXZlbnRJbml0ID0gW1xuICB7XG4gICAga2V5OiAnYnViYmxlcycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2NhbmNlbGFibGUnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6IGZhbHNlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjb21wb3NlZCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogZmFsc2VcbiAgfVxuXVxuXG53ZWJpZGwuY29udmVydGVycy5NZXNzYWdlRXZlbnRJbml0ID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICAuLi5ldmVudEluaXQsXG4gIHtcbiAgICBrZXk6ICdkYXRhJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmFueSxcbiAgICBkZWZhdWx0VmFsdWU6IG51bGxcbiAgfSxcbiAge1xuICAgIGtleTogJ29yaWdpbicsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcsXG4gICAgZGVmYXVsdFZhbHVlOiAnJ1xuICB9LFxuICB7XG4gICAga2V5OiAnbGFzdEV2ZW50SWQnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogJydcbiAgfSxcbiAge1xuICAgIGtleTogJ3NvdXJjZScsXG4gICAgLy8gTm9kZSBkb2Vzbid0IGltcGxlbWVudCBXaW5kb3dQcm94eSBvciBTZXJ2aWNlV29ya2VyLCBzbyB0aGUgb25seVxuICAgIC8vIHZhbGlkIHZhbHVlIGZvciBzb3VyY2UgaXMgYSBNZXNzYWdlUG9ydC5cbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5NZXNzYWdlUG9ydCksXG4gICAgZGVmYXVsdFZhbHVlOiBudWxsXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdwb3J0cycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8TWVzc2FnZVBvcnQ+J10sXG4gICAgZ2V0IGRlZmF1bHRWYWx1ZSAoKSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gIH1cbl0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkNsb3NlRXZlbnRJbml0ID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICAuLi5ldmVudEluaXQsXG4gIHtcbiAgICBrZXk6ICd3YXNDbGVhbicsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2NvZGUnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIHNob3J0J10sXG4gICAgZGVmYXVsdFZhbHVlOiAwXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdyZWFzb24nLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogJydcbiAgfVxuXSlcblxud2ViaWRsLmNvbnZlcnRlcnMuRXJyb3JFdmVudEluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIC4uLmV2ZW50SW5pdCxcbiAge1xuICAgIGtleTogJ21lc3NhZ2UnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogJydcbiAgfSxcbiAge1xuICAgIGtleTogJ2ZpbGVuYW1lJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyxcbiAgICBkZWZhdWx0VmFsdWU6ICcnXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdsaW5lbm8nLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIGxvbmcnXSxcbiAgICBkZWZhdWx0VmFsdWU6IDBcbiAgfSxcbiAge1xuICAgIGtleTogJ2NvbG5vJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nJ10sXG4gICAgZGVmYXVsdFZhbHVlOiAwXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdlcnJvcicsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5hbnlcbiAgfVxuXSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIE1lc3NhZ2VFdmVudCxcbiAgQ2xvc2VFdmVudCxcbiAgRXJyb3JFdmVudFxufVxuIl0sIm5hbWVzIjpbIndlYmlkbCIsInJlcXVpcmUiLCJrRW51bWVyYWJsZVByb3BlcnR5IiwiTWVzc2FnZVBvcnQiLCJNZXNzYWdlRXZlbnQiLCJFdmVudCIsImV2ZW50SW5pdCIsImNvbnN0cnVjdG9yIiwidHlwZSIsImV2ZW50SW5pdERpY3QiLCJhcmd1bWVudExlbmd0aENoZWNrIiwiYXJndW1lbnRzIiwiaGVhZGVyIiwiY29udmVydGVycyIsIkRPTVN0cmluZyIsIk1lc3NhZ2VFdmVudEluaXQiLCJkYXRhIiwiYnJhbmRDaGVjayIsIm9yaWdpbiIsImxhc3RFdmVudElkIiwic291cmNlIiwicG9ydHMiLCJPYmplY3QiLCJpc0Zyb3plbiIsImZyZWV6ZSIsImluaXRNZXNzYWdlRXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsIkNsb3NlRXZlbnQiLCJDbG9zZUV2ZW50SW5pdCIsIndhc0NsZWFuIiwiY29kZSIsInJlYXNvbiIsIkVycm9yRXZlbnQiLCJFcnJvckV2ZW50SW5pdCIsIm1lc3NhZ2UiLCJmaWxlbmFtZSIsImxpbmVubyIsImNvbG5vIiwiZXJyb3IiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJvdG90eXBlIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsImNvbmZpZ3VyYWJsZSIsImludGVyZmFjZUNvbnZlcnRlciIsInNlcXVlbmNlQ29udmVydGVyIiwia2V5IiwiY29udmVydGVyIiwiYm9vbGVhbiIsImRlZmF1bHRWYWx1ZSIsImRpY3Rpb25hcnlDb252ZXJ0ZXIiLCJhbnkiLCJVU1ZTdHJpbmciLCJudWxsYWJsZUNvbnZlcnRlciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/events.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/frame.js":
/*!**************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/websocket/frame.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { maxUnsigned16Bit } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/constants.js\");\n/** @type {import('crypto')} */ let crypto;\ntry {\n    crypto = __webpack_require__(/*! crypto */ \"crypto\");\n} catch  {}\nclass WebsocketFrameSend {\n    /**\n   * @param {Buffer|undefined} data\n   */ constructor(data){\n        this.frameData = data;\n        this.maskKey = crypto.randomBytes(4);\n    }\n    createFrame(opcode) {\n        const bodyLength = this.frameData?.byteLength ?? 0;\n        /** @type {number} */ let payloadLength = bodyLength // 0-125\n        ;\n        let offset = 6;\n        if (bodyLength > maxUnsigned16Bit) {\n            offset += 8 // payload length is next 8 bytes\n            ;\n            payloadLength = 127;\n        } else if (bodyLength > 125) {\n            offset += 2 // payload length is next 2 bytes\n            ;\n            payloadLength = 126;\n        }\n        const buffer = Buffer.allocUnsafe(bodyLength + offset);\n        // Clear first 2 bytes, everything else is overwritten\n        buffer[0] = buffer[1] = 0;\n        buffer[0] |= 0x80 // FIN\n        ;\n        buffer[0] = (buffer[0] & 0xF0) + opcode // opcode\n        ;\n        /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */ buffer[offset - 4] = this.maskKey[0];\n        buffer[offset - 3] = this.maskKey[1];\n        buffer[offset - 2] = this.maskKey[2];\n        buffer[offset - 1] = this.maskKey[3];\n        buffer[1] = payloadLength;\n        if (payloadLength === 126) {\n            buffer.writeUInt16BE(bodyLength, 2);\n        } else if (payloadLength === 127) {\n            // Clear extended payload length\n            buffer[2] = buffer[3] = 0;\n            buffer.writeUIntBE(bodyLength, 4, 6);\n        }\n        buffer[1] |= 0x80 // MASK\n        ;\n        // mask body\n        for(let i = 0; i < bodyLength; i++){\n            buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];\n        }\n        return buffer;\n    }\n}\nmodule.exports = {\n    WebsocketFrameSend\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L2ZyYW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxnQkFBZ0IsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUVyQyw2QkFBNkIsR0FDN0IsSUFBSUM7QUFDSixJQUFJO0lBQ0ZBLFNBQVNELG1CQUFPQSxDQUFDO0FBQ25CLEVBQUUsT0FBTSxDQUVSO0FBRUEsTUFBTUU7SUFDSjs7R0FFQyxHQUNEQyxZQUFhQyxJQUFJLENBQUU7UUFDakIsSUFBSSxDQUFDQyxTQUFTLEdBQUdEO1FBQ2pCLElBQUksQ0FBQ0UsT0FBTyxHQUFHTCxPQUFPTSxXQUFXLENBQUM7SUFDcEM7SUFFQUMsWUFBYUMsTUFBTSxFQUFFO1FBQ25CLE1BQU1DLGFBQWEsSUFBSSxDQUFDTCxTQUFTLEVBQUVNLGNBQWM7UUFFakQsbUJBQW1CLEdBQ25CLElBQUlDLGdCQUFnQkYsV0FBVyxRQUFROztRQUN2QyxJQUFJRyxTQUFTO1FBRWIsSUFBSUgsYUFBYVgsa0JBQWtCO1lBQ2pDYyxVQUFVLEVBQUUsaUNBQWlDOztZQUM3Q0QsZ0JBQWdCO1FBQ2xCLE9BQU8sSUFBSUYsYUFBYSxLQUFLO1lBQzNCRyxVQUFVLEVBQUUsaUNBQWlDOztZQUM3Q0QsZ0JBQWdCO1FBQ2xCO1FBRUEsTUFBTUUsU0FBU0MsT0FBT0MsV0FBVyxDQUFDTixhQUFhRztRQUUvQyxzREFBc0Q7UUFDdERDLE1BQU0sQ0FBQyxFQUFFLEdBQUdBLE1BQU0sQ0FBQyxFQUFFLEdBQUc7UUFDeEJBLE1BQU0sQ0FBQyxFQUFFLElBQUksS0FBSyxNQUFNOztRQUN4QkEsTUFBTSxDQUFDLEVBQUUsR0FBRyxDQUFDQSxNQUFNLENBQUMsRUFBRSxHQUFHLElBQUcsSUFBS0wsT0FBTyxTQUFTOztRQUVqRCw2REFBNkQsR0FDN0RLLE1BQU0sQ0FBQ0QsU0FBUyxFQUFFLEdBQUcsSUFBSSxDQUFDUCxPQUFPLENBQUMsRUFBRTtRQUNwQ1EsTUFBTSxDQUFDRCxTQUFTLEVBQUUsR0FBRyxJQUFJLENBQUNQLE9BQU8sQ0FBQyxFQUFFO1FBQ3BDUSxNQUFNLENBQUNELFNBQVMsRUFBRSxHQUFHLElBQUksQ0FBQ1AsT0FBTyxDQUFDLEVBQUU7UUFDcENRLE1BQU0sQ0FBQ0QsU0FBUyxFQUFFLEdBQUcsSUFBSSxDQUFDUCxPQUFPLENBQUMsRUFBRTtRQUVwQ1EsTUFBTSxDQUFDLEVBQUUsR0FBR0Y7UUFFWixJQUFJQSxrQkFBa0IsS0FBSztZQUN6QkUsT0FBT0csYUFBYSxDQUFDUCxZQUFZO1FBQ25DLE9BQU8sSUFBSUUsa0JBQWtCLEtBQUs7WUFDaEMsZ0NBQWdDO1lBQ2hDRSxNQUFNLENBQUMsRUFBRSxHQUFHQSxNQUFNLENBQUMsRUFBRSxHQUFHO1lBQ3hCQSxPQUFPSSxXQUFXLENBQUNSLFlBQVksR0FBRztRQUNwQztRQUVBSSxNQUFNLENBQUMsRUFBRSxJQUFJLEtBQUssT0FBTzs7UUFFekIsWUFBWTtRQUNaLElBQUssSUFBSUssSUFBSSxHQUFHQSxJQUFJVCxZQUFZUyxJQUFLO1lBQ25DTCxNQUFNLENBQUNELFNBQVNNLEVBQUUsR0FBRyxJQUFJLENBQUNkLFNBQVMsQ0FBQ2MsRUFBRSxHQUFHLElBQUksQ0FBQ2IsT0FBTyxDQUFDYSxJQUFJLEVBQUU7UUFDOUQ7UUFFQSxPQUFPTDtJQUNUO0FBQ0Y7QUFFQU0sT0FBT0MsT0FBTyxHQUFHO0lBQ2ZuQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGh5c2ljcy1maWdodGVyLWFjYWRlbXkvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L2ZyYW1lLmpzP2JlYWIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgbWF4VW5zaWduZWQxNkJpdCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuXG4vKiogQHR5cGUge2ltcG9ydCgnY3J5cHRvJyl9ICovXG5sZXQgY3J5cHRvXG50cnkge1xuICBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxufSBjYXRjaCB7XG5cbn1cblxuY2xhc3MgV2Vic29ja2V0RnJhbWVTZW5kIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QnVmZmVyfHVuZGVmaW5lZH0gZGF0YVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRhdGEpIHtcbiAgICB0aGlzLmZyYW1lRGF0YSA9IGRhdGFcbiAgICB0aGlzLm1hc2tLZXkgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoNClcbiAgfVxuXG4gIGNyZWF0ZUZyYW1lIChvcGNvZGUpIHtcbiAgICBjb25zdCBib2R5TGVuZ3RoID0gdGhpcy5mcmFtZURhdGE/LmJ5dGVMZW5ndGggPz8gMFxuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgbGV0IHBheWxvYWRMZW5ndGggPSBib2R5TGVuZ3RoIC8vIDAtMTI1XG4gICAgbGV0IG9mZnNldCA9IDZcblxuICAgIGlmIChib2R5TGVuZ3RoID4gbWF4VW5zaWduZWQxNkJpdCkge1xuICAgICAgb2Zmc2V0ICs9IDggLy8gcGF5bG9hZCBsZW5ndGggaXMgbmV4dCA4IGJ5dGVzXG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI3XG4gICAgfSBlbHNlIGlmIChib2R5TGVuZ3RoID4gMTI1KSB7XG4gICAgICBvZmZzZXQgKz0gMiAvLyBwYXlsb2FkIGxlbmd0aCBpcyBuZXh0IDIgYnl0ZXNcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjZcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYm9keUxlbmd0aCArIG9mZnNldClcblxuICAgIC8vIENsZWFyIGZpcnN0IDIgYnl0ZXMsIGV2ZXJ5dGhpbmcgZWxzZSBpcyBvdmVyd3JpdHRlblxuICAgIGJ1ZmZlclswXSA9IGJ1ZmZlclsxXSA9IDBcbiAgICBidWZmZXJbMF0gfD0gMHg4MCAvLyBGSU5cbiAgICBidWZmZXJbMF0gPSAoYnVmZmVyWzBdICYgMHhGMCkgKyBvcGNvZGUgLy8gb3Bjb2RlXG5cbiAgICAvKiEgd3MuIE1JVCBMaWNlbnNlLiBFaW5hciBPdHRvIFN0YW5ndmlrIDxlaW5hcm9zQGdtYWlsLmNvbT4gKi9cbiAgICBidWZmZXJbb2Zmc2V0IC0gNF0gPSB0aGlzLm1hc2tLZXlbMF1cbiAgICBidWZmZXJbb2Zmc2V0IC0gM10gPSB0aGlzLm1hc2tLZXlbMV1cbiAgICBidWZmZXJbb2Zmc2V0IC0gMl0gPSB0aGlzLm1hc2tLZXlbMl1cbiAgICBidWZmZXJbb2Zmc2V0IC0gMV0gPSB0aGlzLm1hc2tLZXlbM11cblxuICAgIGJ1ZmZlclsxXSA9IHBheWxvYWRMZW5ndGhcblxuICAgIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjYpIHtcbiAgICAgIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGJvZHlMZW5ndGgsIDIpXG4gICAgfSBlbHNlIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjcpIHtcbiAgICAgIC8vIENsZWFyIGV4dGVuZGVkIHBheWxvYWQgbGVuZ3RoXG4gICAgICBidWZmZXJbMl0gPSBidWZmZXJbM10gPSAwXG4gICAgICBidWZmZXIud3JpdGVVSW50QkUoYm9keUxlbmd0aCwgNCwgNilcbiAgICB9XG5cbiAgICBidWZmZXJbMV0gfD0gMHg4MCAvLyBNQVNLXG5cbiAgICAvLyBtYXNrIGJvZHlcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvZHlMZW5ndGg7IGkrKykge1xuICAgICAgYnVmZmVyW29mZnNldCArIGldID0gdGhpcy5mcmFtZURhdGFbaV0gXiB0aGlzLm1hc2tLZXlbaSAlIDRdXG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJzb2NrZXRGcmFtZVNlbmRcbn1cbiJdLCJuYW1lcyI6WyJtYXhVbnNpZ25lZDE2Qml0IiwicmVxdWlyZSIsImNyeXB0byIsIldlYnNvY2tldEZyYW1lU2VuZCIsImNvbnN0cnVjdG9yIiwiZGF0YSIsImZyYW1lRGF0YSIsIm1hc2tLZXkiLCJyYW5kb21CeXRlcyIsImNyZWF0ZUZyYW1lIiwib3Bjb2RlIiwiYm9keUxlbmd0aCIsImJ5dGVMZW5ndGgiLCJwYXlsb2FkTGVuZ3RoIiwib2Zmc2V0IiwiYnVmZmVyIiwiQnVmZmVyIiwiYWxsb2NVbnNhZmUiLCJ3cml0ZVVJbnQxNkJFIiwid3JpdGVVSW50QkUiLCJpIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/frame.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/receiver.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/websocket/receiver.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\nconst diagnosticsChannel = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\");\nconst { parserStates, opcodes, states, emptyBuffer } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/constants.js\");\nconst { kReadyState, kSentClose, kResponse, kReceivedClose } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/symbols.js\");\nconst { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/util.js\");\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/frame.js\");\n// This code was influenced by ws released under the MIT license.\n// Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n// Copyright (c) 2013 Arnout Kazemier and contributors\n// Copyright (c) 2016 Luigi Pinca and contributors\nconst channels = {};\nchannels.ping = diagnosticsChannel.channel(\"undici:websocket:ping\");\nchannels.pong = diagnosticsChannel.channel(\"undici:websocket:pong\");\nclass ByteParser extends Writable {\n    #buffers;\n    #byteOffset;\n    #state;\n    #info;\n    #fragments;\n    constructor(ws){\n        super();\n        this.#buffers = [];\n        this.#byteOffset = 0;\n        this.#state = parserStates.INFO;\n        this.#info = {};\n        this.#fragments = [];\n        this.ws = ws;\n    }\n    /**\n   * @param {Buffer} chunk\n   * @param {() => void} callback\n   */ _write(chunk, _, callback) {\n        this.#buffers.push(chunk);\n        this.#byteOffset += chunk.length;\n        this.run(callback);\n    }\n    /**\n   * Runs whenever a new chunk is received.\n   * Callback is called whenever there are no more chunks buffering,\n   * or not enough bytes are buffered to parse.\n   */ run(callback) {\n        while(true){\n            if (this.#state === parserStates.INFO) {\n                // If there aren't enough bytes to parse the payload length, etc.\n                if (this.#byteOffset < 2) {\n                    return callback();\n                }\n                const buffer = this.consume(2);\n                this.#info.fin = (buffer[0] & 0x80) !== 0;\n                this.#info.opcode = buffer[0] & 0x0F;\n                // If we receive a fragmented message, we use the type of the first\n                // frame to parse the full message as binary/text, when it's terminated\n                this.#info.originalOpcode ??= this.#info.opcode;\n                this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION;\n                if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {\n                    // Only text and binary frames can be fragmented\n                    failWebsocketConnection(this.ws, \"Invalid frame type was fragmented.\");\n                    return;\n                }\n                const payloadLength = buffer[1] & 0x7F;\n                if (payloadLength <= 125) {\n                    this.#info.payloadLength = payloadLength;\n                    this.#state = parserStates.READ_DATA;\n                } else if (payloadLength === 126) {\n                    this.#state = parserStates.PAYLOADLENGTH_16;\n                } else if (payloadLength === 127) {\n                    this.#state = parserStates.PAYLOADLENGTH_64;\n                }\n                if (this.#info.fragmented && payloadLength > 125) {\n                    // A fragmented frame can't be fragmented itself\n                    failWebsocketConnection(this.ws, \"Fragmented frame exceeded 125 bytes.\");\n                    return;\n                } else if ((this.#info.opcode === opcodes.PING || this.#info.opcode === opcodes.PONG || this.#info.opcode === opcodes.CLOSE) && payloadLength > 125) {\n                    // Control frames can have a payload length of 125 bytes MAX\n                    failWebsocketConnection(this.ws, \"Payload length for control frame exceeded 125 bytes.\");\n                    return;\n                } else if (this.#info.opcode === opcodes.CLOSE) {\n                    if (payloadLength === 1) {\n                        failWebsocketConnection(this.ws, \"Received close frame with a 1-byte body.\");\n                        return;\n                    }\n                    const body = this.consume(payloadLength);\n                    this.#info.closeInfo = this.parseCloseBody(false, body);\n                    if (!this.ws[kSentClose]) {\n                        // If an endpoint receives a Close frame and did not previously send a\n                        // Close frame, the endpoint MUST send a Close frame in response.  (When\n                        // sending a Close frame in response, the endpoint typically echos the\n                        // status code it received.)\n                        const body = Buffer.allocUnsafe(2);\n                        body.writeUInt16BE(this.#info.closeInfo.code, 0);\n                        const closeFrame = new WebsocketFrameSend(body);\n                        this.ws[kResponse].socket.write(closeFrame.createFrame(opcodes.CLOSE), (err)=>{\n                            if (!err) {\n                                this.ws[kSentClose] = true;\n                            }\n                        });\n                    }\n                    // Upon either sending or receiving a Close control frame, it is said\n                    // that _The WebSocket Closing Handshake is Started_ and that the\n                    // WebSocket connection is in the CLOSING state.\n                    this.ws[kReadyState] = states.CLOSING;\n                    this.ws[kReceivedClose] = true;\n                    this.end();\n                    return;\n                } else if (this.#info.opcode === opcodes.PING) {\n                    // Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in\n                    // response, unless it already received a Close frame.\n                    // A Pong frame sent in response to a Ping frame must have identical\n                    // \"Application data\"\n                    const body = this.consume(payloadLength);\n                    if (!this.ws[kReceivedClose]) {\n                        const frame = new WebsocketFrameSend(body);\n                        this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));\n                        if (channels.ping.hasSubscribers) {\n                            channels.ping.publish({\n                                payload: body\n                            });\n                        }\n                    }\n                    this.#state = parserStates.INFO;\n                    if (this.#byteOffset > 0) {\n                        continue;\n                    } else {\n                        callback();\n                        return;\n                    }\n                } else if (this.#info.opcode === opcodes.PONG) {\n                    // A Pong frame MAY be sent unsolicited.  This serves as a\n                    // unidirectional heartbeat.  A response to an unsolicited Pong frame is\n                    // not expected.\n                    const body = this.consume(payloadLength);\n                    if (channels.pong.hasSubscribers) {\n                        channels.pong.publish({\n                            payload: body\n                        });\n                    }\n                    if (this.#byteOffset > 0) {\n                        continue;\n                    } else {\n                        callback();\n                        return;\n                    }\n                }\n            } else if (this.#state === parserStates.PAYLOADLENGTH_16) {\n                if (this.#byteOffset < 2) {\n                    return callback();\n                }\n                const buffer = this.consume(2);\n                this.#info.payloadLength = buffer.readUInt16BE(0);\n                this.#state = parserStates.READ_DATA;\n            } else if (this.#state === parserStates.PAYLOADLENGTH_64) {\n                if (this.#byteOffset < 8) {\n                    return callback();\n                }\n                const buffer = this.consume(8);\n                const upper = buffer.readUInt32BE(0);\n                // 2^31 is the maxinimum bytes an arraybuffer can contain\n                // on 32-bit systems. Although, on 64-bit systems, this is\n                // 2^53-1 bytes.\n                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length\n                // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/common/globals.h;drc=1946212ac0100668f14eb9e2843bdd846e510a1e;bpv=1;bpt=1;l=1275\n                // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-array-buffer.h;l=34;drc=1946212ac0100668f14eb9e2843bdd846e510a1e\n                if (upper > 2 ** 31 - 1) {\n                    failWebsocketConnection(this.ws, \"Received payload length > 2^31 bytes.\");\n                    return;\n                }\n                const lower = buffer.readUInt32BE(4);\n                this.#info.payloadLength = (upper << 8) + lower;\n                this.#state = parserStates.READ_DATA;\n            } else if (this.#state === parserStates.READ_DATA) {\n                if (this.#byteOffset < this.#info.payloadLength) {\n                    // If there is still more data in this chunk that needs to be read\n                    return callback();\n                } else if (this.#byteOffset >= this.#info.payloadLength) {\n                    // If the server sent multiple frames in a single chunk\n                    const body = this.consume(this.#info.payloadLength);\n                    this.#fragments.push(body);\n                    // If the frame is unfragmented, or a fragmented frame was terminated,\n                    // a message was received\n                    if (!this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes.CONTINUATION) {\n                        const fullMessage = Buffer.concat(this.#fragments);\n                        websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);\n                        this.#info = {};\n                        this.#fragments.length = 0;\n                    }\n                    this.#state = parserStates.INFO;\n                }\n            }\n            if (this.#byteOffset > 0) {\n                continue;\n            } else {\n                callback();\n                break;\n            }\n        }\n    }\n    /**\n   * Take n bytes from the buffered Buffers\n   * @param {number} n\n   * @returns {Buffer|null}\n   */ consume(n) {\n        if (n > this.#byteOffset) {\n            return null;\n        } else if (n === 0) {\n            return emptyBuffer;\n        }\n        if (this.#buffers[0].length === n) {\n            this.#byteOffset -= this.#buffers[0].length;\n            return this.#buffers.shift();\n        }\n        const buffer = Buffer.allocUnsafe(n);\n        let offset = 0;\n        while(offset !== n){\n            const next = this.#buffers[0];\n            const { length } = next;\n            if (length + offset === n) {\n                buffer.set(this.#buffers.shift(), offset);\n                break;\n            } else if (length + offset > n) {\n                buffer.set(next.subarray(0, n - offset), offset);\n                this.#buffers[0] = next.subarray(n - offset);\n                break;\n            } else {\n                buffer.set(this.#buffers.shift(), offset);\n                offset += next.length;\n            }\n        }\n        this.#byteOffset -= n;\n        return buffer;\n    }\n    parseCloseBody(onlyCode, data) {\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5\n        /** @type {number|undefined} */ let code;\n        if (data.length >= 2) {\n            // _The WebSocket Connection Close Code_ is\n            // defined as the status code (Section 7.4) contained in the first Close\n            // control frame received by the application\n            code = data.readUInt16BE(0);\n        }\n        if (onlyCode) {\n            if (!isValidStatusCode(code)) {\n                return null;\n            }\n            return {\n                code\n            };\n        }\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6\n        /** @type {Buffer} */ let reason = data.subarray(2);\n        // Remove BOM\n        if (reason[0] === 0xEF && reason[1] === 0xBB && reason[2] === 0xBF) {\n            reason = reason.subarray(3);\n        }\n        if (code !== undefined && !isValidStatusCode(code)) {\n            return null;\n        }\n        try {\n            // TODO: optimize this\n            reason = new TextDecoder(\"utf-8\", {\n                fatal: true\n            }).decode(reason);\n        } catch  {\n            return null;\n        }\n        return {\n            code,\n            reason\n        };\n    }\n    get closingInfo() {\n        return this.#info.closeInfo;\n    }\n}\nmodule.exports = {\n    ByteParser\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L3JlY2VpdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxRQUFRLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDN0IsTUFBTUMscUJBQXFCRCxtQkFBT0EsQ0FBQztBQUNuQyxNQUFNLEVBQUVFLFlBQVksRUFBRUMsT0FBTyxFQUFFQyxNQUFNLEVBQUVDLFdBQVcsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUMvRCxNQUFNLEVBQUVNLFdBQVcsRUFBRUMsVUFBVSxFQUFFQyxTQUFTLEVBQUVDLGNBQWMsRUFBRSxHQUFHVCxtQkFBT0EsQ0FBQztBQUN2RSxNQUFNLEVBQUVVLGlCQUFpQixFQUFFQyx1QkFBdUIsRUFBRUMsd0JBQXdCLEVBQUUsR0FBR1osbUJBQU9BLENBQUM7QUFDekYsTUFBTSxFQUFFYSxrQkFBa0IsRUFBRSxHQUFHYixtQkFBT0EsQ0FBQztBQUV2QyxpRUFBaUU7QUFDakUsNkRBQTZEO0FBQzdELHNEQUFzRDtBQUN0RCxrREFBa0Q7QUFFbEQsTUFBTWMsV0FBVyxDQUFDO0FBQ2xCQSxTQUFTQyxJQUFJLEdBQUdkLG1CQUFtQmUsT0FBTyxDQUFDO0FBQzNDRixTQUFTRyxJQUFJLEdBQUdoQixtQkFBbUJlLE9BQU8sQ0FBQztBQUUzQyxNQUFNRSxtQkFBbUJuQjtJQUN2QixDQUFDb0IsT0FBTyxDQUFLO0lBQ2IsQ0FBQ0MsVUFBVSxDQUFJO0lBRWYsQ0FBQ0MsS0FBSyxDQUFvQjtJQUUxQixDQUFDQyxJQUFJLENBQUs7SUFDVixDQUFDQyxTQUFTLENBQUs7SUFFZkMsWUFBYUMsRUFBRSxDQUFFO1FBQ2YsS0FBSzthQVRQLENBQUNOLE9BQU8sR0FBRyxFQUFFO2FBQ2IsQ0FBQ0MsVUFBVSxHQUFHO2FBRWQsQ0FBQ0MsS0FBSyxHQUFHbkIsYUFBYXdCLElBQUk7YUFFMUIsQ0FBQ0osSUFBSSxHQUFHLENBQUM7YUFD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O1FBRUosSUFBSXlCLEtBQUtqRCxNQUFNLElBQUksR0FBRztZQUNwQiwyQ0FBMkM7WUFDM0Msd0VBQXdFO1lBQ3hFLDRDQUE0QztZQUM1Q3dCLE9BQU95QixLQUFLYixZQUFZLENBQUM7UUFDM0I7UUFFQSxJQUFJWSxVQUFVO1lBQ1osSUFBSSxDQUFDdEUsa0JBQWtCOEMsT0FBTztnQkFDNUIsT0FBTztZQUNUO1lBRUEsT0FBTztnQkFBRUE7WUFBSztRQUNoQjtRQUVBLDhEQUE4RDtRQUM5RCxtQkFBbUIsR0FDbkIsSUFBSTBCLFNBQVNELEtBQUtGLFFBQVEsQ0FBQztRQUUzQixhQUFhO1FBQ2IsSUFBSUcsTUFBTSxDQUFDLEVBQUUsS0FBSyxRQUFRQSxNQUFNLENBQUMsRUFBRSxLQUFLLFFBQVFBLE1BQU0sQ0FBQyxFQUFFLEtBQUssTUFBTTtZQUNsRUEsU0FBU0EsT0FBT0gsUUFBUSxDQUFDO1FBQzNCO1FBRUEsSUFBSXZCLFNBQVMyQixhQUFhLENBQUN6RSxrQkFBa0I4QyxPQUFPO1lBQ2xELE9BQU87UUFDVDtRQUVBLElBQUk7WUFDRixzQkFBc0I7WUFDdEIwQixTQUFTLElBQUlFLFlBQVksU0FBUztnQkFBRUMsT0FBTztZQUFLLEdBQUdDLE1BQU0sQ0FBQ0o7UUFDNUQsRUFBRSxPQUFNO1lBQ04sT0FBTztRQUNUO1FBRUEsT0FBTztZQUFFMUI7WUFBTTBCO1FBQU87SUFDeEI7SUFFQSxJQUFJSyxjQUFlO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLENBQUNqRSxJQUFJLENBQUM2QixTQUFTO0lBQzdCO0FBQ0Y7QUFFQXFDLE9BQU9DLE9BQU8sR0FBRztJQUNmdkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYnNvY2tldC9yZWNlaXZlci5qcz84ZGZhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IFdyaXRhYmxlIH0gPSByZXF1aXJlKCdzdHJlYW0nKVxuY29uc3QgZGlhZ25vc3RpY3NDaGFubmVsID0gcmVxdWlyZSgnZGlhZ25vc3RpY3NfY2hhbm5lbCcpXG5jb25zdCB7IHBhcnNlclN0YXRlcywgb3Bjb2Rlcywgc3RhdGVzLCBlbXB0eUJ1ZmZlciB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBrUmVhZHlTdGF0ZSwga1NlbnRDbG9zZSwga1Jlc3BvbnNlLCBrUmVjZWl2ZWRDbG9zZSB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgaXNWYWxpZFN0YXR1c0NvZGUsIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uLCB3ZWJzb2NrZXRNZXNzYWdlUmVjZWl2ZWQgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IFdlYnNvY2tldEZyYW1lU2VuZCB9ID0gcmVxdWlyZSgnLi9mcmFtZScpXG5cbi8vIFRoaXMgY29kZSB3YXMgaW5mbHVlbmNlZCBieSB3cyByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTEgRWluYXIgT3R0byBTdGFuZ3ZpayA8ZWluYXJvc0BnbWFpbC5jb20+XG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQXJub3V0IEthemVtaWVyIGFuZCBjb250cmlidXRvcnNcbi8vIENvcHlyaWdodCAoYykgMjAxNiBMdWlnaSBQaW5jYSBhbmQgY29udHJpYnV0b3JzXG5cbmNvbnN0IGNoYW5uZWxzID0ge31cbmNoYW5uZWxzLnBpbmcgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOndlYnNvY2tldDpwaW5nJylcbmNoYW5uZWxzLnBvbmcgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOndlYnNvY2tldDpwb25nJylcblxuY2xhc3MgQnl0ZVBhcnNlciBleHRlbmRzIFdyaXRhYmxlIHtcbiAgI2J1ZmZlcnMgPSBbXVxuICAjYnl0ZU9mZnNldCA9IDBcblxuICAjc3RhdGUgPSBwYXJzZXJTdGF0ZXMuSU5GT1xuXG4gICNpbmZvID0ge31cbiAgI2ZyYWdtZW50cyA9IFtdXG5cbiAgY29uc3RydWN0b3IgKHdzKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy53cyA9IHdzXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rXG4gICAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAgICovXG4gIF93cml0ZSAoY2h1bmssIF8sIGNhbGxiYWNrKSB7XG4gICAgdGhpcy4jYnVmZmVycy5wdXNoKGNodW5rKVxuICAgIHRoaXMuI2J5dGVPZmZzZXQgKz0gY2h1bmsubGVuZ3RoXG5cbiAgICB0aGlzLnJ1bihjYWxsYmFjaylcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIHdoZW5ldmVyIGEgbmV3IGNodW5rIGlzIHJlY2VpdmVkLlxuICAgKiBDYWxsYmFjayBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlcmUgYXJlIG5vIG1vcmUgY2h1bmtzIGJ1ZmZlcmluZyxcbiAgICogb3Igbm90IGVub3VnaCBieXRlcyBhcmUgYnVmZmVyZWQgdG8gcGFyc2UuXG4gICAqL1xuICBydW4gKGNhbGxiYWNrKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICh0aGlzLiNzdGF0ZSA9PT0gcGFyc2VyU3RhdGVzLklORk8pIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlbid0IGVub3VnaCBieXRlcyB0byBwYXJzZSB0aGUgcGF5bG9hZCBsZW5ndGgsIGV0Yy5cbiAgICAgICAgaWYgKHRoaXMuI2J5dGVPZmZzZXQgPCAyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuY29uc3VtZSgyKVxuXG4gICAgICAgIHRoaXMuI2luZm8uZmluID0gKGJ1ZmZlclswXSAmIDB4ODApICE9PSAwXG4gICAgICAgIHRoaXMuI2luZm8ub3Bjb2RlID0gYnVmZmVyWzBdICYgMHgwRlxuXG4gICAgICAgIC8vIElmIHdlIHJlY2VpdmUgYSBmcmFnbWVudGVkIG1lc3NhZ2UsIHdlIHVzZSB0aGUgdHlwZSBvZiB0aGUgZmlyc3RcbiAgICAgICAgLy8gZnJhbWUgdG8gcGFyc2UgdGhlIGZ1bGwgbWVzc2FnZSBhcyBiaW5hcnkvdGV4dCwgd2hlbiBpdCdzIHRlcm1pbmF0ZWRcbiAgICAgICAgdGhpcy4jaW5mby5vcmlnaW5hbE9wY29kZSA/Pz0gdGhpcy4jaW5mby5vcGNvZGVcblxuICAgICAgICB0aGlzLiNpbmZvLmZyYWdtZW50ZWQgPSAhdGhpcy4jaW5mby5maW4gJiYgdGhpcy4jaW5mby5vcGNvZGUgIT09IG9wY29kZXMuQ09OVElOVUFUSU9OXG5cbiAgICAgICAgaWYgKHRoaXMuI2luZm8uZnJhZ21lbnRlZCAmJiB0aGlzLiNpbmZvLm9wY29kZSAhPT0gb3Bjb2Rlcy5CSU5BUlkgJiYgdGhpcy4jaW5mby5vcGNvZGUgIT09IG9wY29kZXMuVEVYVCkge1xuICAgICAgICAgIC8vIE9ubHkgdGV4dCBhbmQgYmluYXJ5IGZyYW1lcyBjYW4gYmUgZnJhZ21lbnRlZFxuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMud3MsICdJbnZhbGlkIGZyYW1lIHR5cGUgd2FzIGZyYWdtZW50ZWQuJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBheWxvYWRMZW5ndGggPSBidWZmZXJbMV0gJiAweDdGXG5cbiAgICAgICAgaWYgKHBheWxvYWRMZW5ndGggPD0gMTI1KSB7XG4gICAgICAgICAgdGhpcy4jaW5mby5wYXlsb2FkTGVuZ3RoID0gcGF5bG9hZExlbmd0aFxuICAgICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLlJFQURfREFUQVxuICAgICAgICB9IGVsc2UgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNikge1xuICAgICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLlBBWUxPQURMRU5HVEhfMTZcbiAgICAgICAgfSBlbHNlIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjcpIHtcbiAgICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5QQVlMT0FETEVOR1RIXzY0XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy4jaW5mby5mcmFnbWVudGVkICYmIHBheWxvYWRMZW5ndGggPiAxMjUpIHtcbiAgICAgICAgICAvLyBBIGZyYWdtZW50ZWQgZnJhbWUgY2FuJ3QgYmUgZnJhZ21lbnRlZCBpdHNlbGZcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLndzLCAnRnJhZ21lbnRlZCBmcmFtZSBleGNlZWRlZCAxMjUgYnl0ZXMuJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAodGhpcy4jaW5mby5vcGNvZGUgPT09IG9wY29kZXMuUElORyB8fFxuICAgICAgICAgICAgdGhpcy4jaW5mby5vcGNvZGUgPT09IG9wY29kZXMuUE9ORyB8fFxuICAgICAgICAgICAgdGhpcy4jaW5mby5vcGNvZGUgPT09IG9wY29kZXMuQ0xPU0UpICYmXG4gICAgICAgICAgcGF5bG9hZExlbmd0aCA+IDEyNVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBDb250cm9sIGZyYW1lcyBjYW4gaGF2ZSBhIHBheWxvYWQgbGVuZ3RoIG9mIDEyNSBieXRlcyBNQVhcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLndzLCAnUGF5bG9hZCBsZW5ndGggZm9yIGNvbnRyb2wgZnJhbWUgZXhjZWVkZWQgMTI1IGJ5dGVzLicpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy4jaW5mby5vcGNvZGUgPT09IG9wY29kZXMuQ0xPU0UpIHtcbiAgICAgICAgICBpZiAocGF5bG9hZExlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgJ1JlY2VpdmVkIGNsb3NlIGZyYW1lIHdpdGggYSAxLWJ5dGUgYm9keS4nKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgYm9keSA9IHRoaXMuY29uc3VtZShwYXlsb2FkTGVuZ3RoKVxuXG4gICAgICAgICAgdGhpcy4jaW5mby5jbG9zZUluZm8gPSB0aGlzLnBhcnNlQ2xvc2VCb2R5KGZhbHNlLCBib2R5KVxuXG4gICAgICAgICAgaWYgKCF0aGlzLndzW2tTZW50Q2xvc2VdKSB7XG4gICAgICAgICAgICAvLyBJZiBhbiBlbmRwb2ludCByZWNlaXZlcyBhIENsb3NlIGZyYW1lIGFuZCBkaWQgbm90IHByZXZpb3VzbHkgc2VuZCBhXG4gICAgICAgICAgICAvLyBDbG9zZSBmcmFtZSwgdGhlIGVuZHBvaW50IE1VU1Qgc2VuZCBhIENsb3NlIGZyYW1lIGluIHJlc3BvbnNlLiAgKFdoZW5cbiAgICAgICAgICAgIC8vIHNlbmRpbmcgYSBDbG9zZSBmcmFtZSBpbiByZXNwb25zZSwgdGhlIGVuZHBvaW50IHR5cGljYWxseSBlY2hvcyB0aGVcbiAgICAgICAgICAgIC8vIHN0YXR1cyBjb2RlIGl0IHJlY2VpdmVkLilcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMilcbiAgICAgICAgICAgIGJvZHkud3JpdGVVSW50MTZCRSh0aGlzLiNpbmZvLmNsb3NlSW5mby5jb2RlLCAwKVxuICAgICAgICAgICAgY29uc3QgY2xvc2VGcmFtZSA9IG5ldyBXZWJzb2NrZXRGcmFtZVNlbmQoYm9keSlcblxuICAgICAgICAgICAgdGhpcy53c1trUmVzcG9uc2VdLnNvY2tldC53cml0ZShcbiAgICAgICAgICAgICAgY2xvc2VGcmFtZS5jcmVhdGVGcmFtZShvcGNvZGVzLkNMT1NFKSxcbiAgICAgICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLndzW2tTZW50Q2xvc2VdID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFVwb24gZWl0aGVyIHNlbmRpbmcgb3IgcmVjZWl2aW5nIGEgQ2xvc2UgY29udHJvbCBmcmFtZSwgaXQgaXMgc2FpZFxuICAgICAgICAgIC8vIHRoYXQgX1RoZSBXZWJTb2NrZXQgQ2xvc2luZyBIYW5kc2hha2UgaXMgU3RhcnRlZF8gYW5kIHRoYXQgdGhlXG4gICAgICAgICAgLy8gV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgaW4gdGhlIENMT1NJTkcgc3RhdGUuXG4gICAgICAgICAgdGhpcy53c1trUmVhZHlTdGF0ZV0gPSBzdGF0ZXMuQ0xPU0lOR1xuICAgICAgICAgIHRoaXMud3Nba1JlY2VpdmVkQ2xvc2VdID0gdHJ1ZVxuXG4gICAgICAgICAgdGhpcy5lbmQoKVxuXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy4jaW5mby5vcGNvZGUgPT09IG9wY29kZXMuUElORykge1xuICAgICAgICAgIC8vIFVwb24gcmVjZWlwdCBvZiBhIFBpbmcgZnJhbWUsIGFuIGVuZHBvaW50IE1VU1Qgc2VuZCBhIFBvbmcgZnJhbWUgaW5cbiAgICAgICAgICAvLyByZXNwb25zZSwgdW5sZXNzIGl0IGFscmVhZHkgcmVjZWl2ZWQgYSBDbG9zZSBmcmFtZS5cbiAgICAgICAgICAvLyBBIFBvbmcgZnJhbWUgc2VudCBpbiByZXNwb25zZSB0byBhIFBpbmcgZnJhbWUgbXVzdCBoYXZlIGlkZW50aWNhbFxuICAgICAgICAgIC8vIFwiQXBwbGljYXRpb24gZGF0YVwiXG5cbiAgICAgICAgICBjb25zdCBib2R5ID0gdGhpcy5jb25zdW1lKHBheWxvYWRMZW5ndGgpXG5cbiAgICAgICAgICBpZiAoIXRoaXMud3Nba1JlY2VpdmVkQ2xvc2VdKSB7XG4gICAgICAgICAgICBjb25zdCBmcmFtZSA9IG5ldyBXZWJzb2NrZXRGcmFtZVNlbmQoYm9keSlcblxuICAgICAgICAgICAgdGhpcy53c1trUmVzcG9uc2VdLnNvY2tldC53cml0ZShmcmFtZS5jcmVhdGVGcmFtZShvcGNvZGVzLlBPTkcpKVxuXG4gICAgICAgICAgICBpZiAoY2hhbm5lbHMucGluZy5oYXNTdWJzY3JpYmVycykge1xuICAgICAgICAgICAgICBjaGFubmVscy5waW5nLnB1Ymxpc2goe1xuICAgICAgICAgICAgICAgIHBheWxvYWQ6IGJvZHlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5JTkZPXG5cbiAgICAgICAgICBpZiAodGhpcy4jYnl0ZU9mZnNldCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLiNpbmZvLm9wY29kZSA9PT0gb3Bjb2Rlcy5QT05HKSB7XG4gICAgICAgICAgLy8gQSBQb25nIGZyYW1lIE1BWSBiZSBzZW50IHVuc29saWNpdGVkLiAgVGhpcyBzZXJ2ZXMgYXMgYVxuICAgICAgICAgIC8vIHVuaWRpcmVjdGlvbmFsIGhlYXJ0YmVhdC4gIEEgcmVzcG9uc2UgdG8gYW4gdW5zb2xpY2l0ZWQgUG9uZyBmcmFtZSBpc1xuICAgICAgICAgIC8vIG5vdCBleHBlY3RlZC5cblxuICAgICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmNvbnN1bWUocGF5bG9hZExlbmd0aClcblxuICAgICAgICAgIGlmIChjaGFubmVscy5wb25nLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICAgICAgICBjaGFubmVscy5wb25nLnB1Ymxpc2goe1xuICAgICAgICAgICAgICBwYXlsb2FkOiBib2R5XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLiNieXRlT2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI3N0YXRlID09PSBwYXJzZXJTdGF0ZXMuUEFZTE9BRExFTkdUSF8xNikge1xuICAgICAgICBpZiAodGhpcy4jYnl0ZU9mZnNldCA8IDIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5jb25zdW1lKDIpXG5cbiAgICAgICAgdGhpcy4jaW5mby5wYXlsb2FkTGVuZ3RoID0gYnVmZmVyLnJlYWRVSW50MTZCRSgwKVxuICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5SRUFEX0RBVEFcbiAgICAgIH0gZWxzZSBpZiAodGhpcy4jc3RhdGUgPT09IHBhcnNlclN0YXRlcy5QQVlMT0FETEVOR1RIXzY0KSB7XG4gICAgICAgIGlmICh0aGlzLiNieXRlT2Zmc2V0IDwgOCkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLmNvbnN1bWUoOClcbiAgICAgICAgY29uc3QgdXBwZXIgPSBidWZmZXIucmVhZFVJbnQzMkJFKDApXG5cbiAgICAgICAgLy8gMl4zMSBpcyB0aGUgbWF4aW5pbXVtIGJ5dGVzIGFuIGFycmF5YnVmZmVyIGNhbiBjb250YWluXG4gICAgICAgIC8vIG9uIDMyLWJpdCBzeXN0ZW1zLiBBbHRob3VnaCwgb24gNjQtYml0IHN5c3RlbXMsIHRoaXMgaXNcbiAgICAgICAgLy8gMl41My0xIGJ5dGVzLlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9FcnJvcnMvSW52YWxpZF9hcnJheV9sZW5ndGhcbiAgICAgICAgLy8gaHR0cHM6Ly9zb3VyY2UuY2hyb21pdW0ub3JnL2Nocm9taXVtL2Nocm9taXVtL3NyYy8rL21haW46djgvc3JjL2NvbW1vbi9nbG9iYWxzLmg7ZHJjPTE5NDYyMTJhYzAxMDA2NjhmMTRlYjllMjg0M2JkZDg0NmU1MTBhMWU7YnB2PTE7YnB0PTE7bD0xMjc1XG4gICAgICAgIC8vIGh0dHBzOi8vc291cmNlLmNocm9taXVtLm9yZy9jaHJvbWl1bS9jaHJvbWl1bS9zcmMvKy9tYWluOnY4L3NyYy9vYmplY3RzL2pzLWFycmF5LWJ1ZmZlci5oO2w9MzQ7ZHJjPTE5NDYyMTJhYzAxMDA2NjhmMTRlYjllMjg0M2JkZDg0NmU1MTBhMWVcbiAgICAgICAgaWYgKHVwcGVyID4gMiAqKiAzMSAtIDEpIHtcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLndzLCAnUmVjZWl2ZWQgcGF5bG9hZCBsZW5ndGggPiAyXjMxIGJ5dGVzLicpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsb3dlciA9IGJ1ZmZlci5yZWFkVUludDMyQkUoNClcblxuICAgICAgICB0aGlzLiNpbmZvLnBheWxvYWRMZW5ndGggPSAodXBwZXIgPDwgOCkgKyBsb3dlclxuICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5SRUFEX0RBVEFcbiAgICAgIH0gZWxzZSBpZiAodGhpcy4jc3RhdGUgPT09IHBhcnNlclN0YXRlcy5SRUFEX0RBVEEpIHtcbiAgICAgICAgaWYgKHRoaXMuI2J5dGVPZmZzZXQgPCB0aGlzLiNpbmZvLnBheWxvYWRMZW5ndGgpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBzdGlsbCBtb3JlIGRhdGEgaW4gdGhpcyBjaHVuayB0aGF0IG5lZWRzIHRvIGJlIHJlYWRcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuI2J5dGVPZmZzZXQgPj0gdGhpcy4jaW5mby5wYXlsb2FkTGVuZ3RoKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHNlcnZlciBzZW50IG11bHRpcGxlIGZyYW1lcyBpbiBhIHNpbmdsZSBjaHVua1xuXG4gICAgICAgICAgY29uc3QgYm9keSA9IHRoaXMuY29uc3VtZSh0aGlzLiNpbmZvLnBheWxvYWRMZW5ndGgpXG5cbiAgICAgICAgICB0aGlzLiNmcmFnbWVudHMucHVzaChib2R5KVxuXG4gICAgICAgICAgLy8gSWYgdGhlIGZyYW1lIGlzIHVuZnJhZ21lbnRlZCwgb3IgYSBmcmFnbWVudGVkIGZyYW1lIHdhcyB0ZXJtaW5hdGVkLFxuICAgICAgICAgIC8vIGEgbWVzc2FnZSB3YXMgcmVjZWl2ZWRcbiAgICAgICAgICBpZiAoIXRoaXMuI2luZm8uZnJhZ21lbnRlZCB8fCAodGhpcy4jaW5mby5maW4gJiYgdGhpcy4jaW5mby5vcGNvZGUgPT09IG9wY29kZXMuQ09OVElOVUFUSU9OKSkge1xuICAgICAgICAgICAgY29uc3QgZnVsbE1lc3NhZ2UgPSBCdWZmZXIuY29uY2F0KHRoaXMuI2ZyYWdtZW50cylcblxuICAgICAgICAgICAgd2Vic29ja2V0TWVzc2FnZVJlY2VpdmVkKHRoaXMud3MsIHRoaXMuI2luZm8ub3JpZ2luYWxPcGNvZGUsIGZ1bGxNZXNzYWdlKVxuXG4gICAgICAgICAgICB0aGlzLiNpbmZvID0ge31cbiAgICAgICAgICAgIHRoaXMuI2ZyYWdtZW50cy5sZW5ndGggPSAwXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuSU5GT1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLiNieXRlT2Zmc2V0ID4gMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUYWtlIG4gYnl0ZXMgZnJvbSB0aGUgYnVmZmVyZWQgQnVmZmVyc1xuICAgKiBAcGFyYW0ge251bWJlcn0gblxuICAgKiBAcmV0dXJucyB7QnVmZmVyfG51bGx9XG4gICAqL1xuICBjb25zdW1lIChuKSB7XG4gICAgaWYgKG4gPiB0aGlzLiNieXRlT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0gZWxzZSBpZiAobiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGVtcHR5QnVmZmVyXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuI2J1ZmZlcnNbMF0ubGVuZ3RoID09PSBuKSB7XG4gICAgICB0aGlzLiNieXRlT2Zmc2V0IC09IHRoaXMuI2J1ZmZlcnNbMF0ubGVuZ3RoXG4gICAgICByZXR1cm4gdGhpcy4jYnVmZmVycy5zaGlmdCgpXG4gICAgfVxuXG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pXG4gICAgbGV0IG9mZnNldCA9IDBcblxuICAgIHdoaWxlIChvZmZzZXQgIT09IG4pIHtcbiAgICAgIGNvbnN0IG5leHQgPSB0aGlzLiNidWZmZXJzWzBdXG4gICAgICBjb25zdCB7IGxlbmd0aCB9ID0gbmV4dFxuXG4gICAgICBpZiAobGVuZ3RoICsgb2Zmc2V0ID09PSBuKSB7XG4gICAgICAgIGJ1ZmZlci5zZXQodGhpcy4jYnVmZmVycy5zaGlmdCgpLCBvZmZzZXQpXG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYgKGxlbmd0aCArIG9mZnNldCA+IG4pIHtcbiAgICAgICAgYnVmZmVyLnNldChuZXh0LnN1YmFycmF5KDAsIG4gLSBvZmZzZXQpLCBvZmZzZXQpXG4gICAgICAgIHRoaXMuI2J1ZmZlcnNbMF0gPSBuZXh0LnN1YmFycmF5KG4gLSBvZmZzZXQpXG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXIuc2V0KHRoaXMuI2J1ZmZlcnMuc2hpZnQoKSwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gbmV4dC5sZW5ndGhcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLiNieXRlT2Zmc2V0IC09IG5cblxuICAgIHJldHVybiBidWZmZXJcbiAgfVxuXG4gIHBhcnNlQ2xvc2VCb2R5IChvbmx5Q29kZSwgZGF0YSkge1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTcuMS41XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuICAgIGxldCBjb2RlXG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPj0gMikge1xuICAgICAgLy8gX1RoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbiBDbG9zZSBDb2RlXyBpc1xuICAgICAgLy8gZGVmaW5lZCBhcyB0aGUgc3RhdHVzIGNvZGUgKFNlY3Rpb24gNy40KSBjb250YWluZWQgaW4gdGhlIGZpcnN0IENsb3NlXG4gICAgICAvLyBjb250cm9sIGZyYW1lIHJlY2VpdmVkIGJ5IHRoZSBhcHBsaWNhdGlvblxuICAgICAgY29kZSA9IGRhdGEucmVhZFVJbnQxNkJFKDApXG4gICAgfVxuXG4gICAgaWYgKG9ubHlDb2RlKSB7XG4gICAgICBpZiAoIWlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGNvZGUgfVxuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTcuMS42XG4gICAgLyoqIEB0eXBlIHtCdWZmZXJ9ICovXG4gICAgbGV0IHJlYXNvbiA9IGRhdGEuc3ViYXJyYXkoMilcblxuICAgIC8vIFJlbW92ZSBCT01cbiAgICBpZiAocmVhc29uWzBdID09PSAweEVGICYmIHJlYXNvblsxXSA9PT0gMHhCQiAmJiByZWFzb25bMl0gPT09IDB4QkYpIHtcbiAgICAgIHJlYXNvbiA9IHJlYXNvbi5zdWJhcnJheSgzKVxuICAgIH1cblxuICAgIGlmIChjb2RlICE9PSB1bmRlZmluZWQgJiYgIWlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBUT0RPOiBvcHRpbWl6ZSB0aGlzXG4gICAgICByZWFzb24gPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JywgeyBmYXRhbDogdHJ1ZSB9KS5kZWNvZGUocmVhc29uKVxuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4geyBjb2RlLCByZWFzb24gfVxuICB9XG5cbiAgZ2V0IGNsb3NpbmdJbmZvICgpIHtcbiAgICByZXR1cm4gdGhpcy4jaW5mby5jbG9zZUluZm9cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQnl0ZVBhcnNlclxufVxuIl0sIm5hbWVzIjpbIldyaXRhYmxlIiwicmVxdWlyZSIsImRpYWdub3N0aWNzQ2hhbm5lbCIsInBhcnNlclN0YXRlcyIsIm9wY29kZXMiLCJzdGF0ZXMiLCJlbXB0eUJ1ZmZlciIsImtSZWFkeVN0YXRlIiwia1NlbnRDbG9zZSIsImtSZXNwb25zZSIsImtSZWNlaXZlZENsb3NlIiwiaXNWYWxpZFN0YXR1c0NvZGUiLCJmYWlsV2Vic29ja2V0Q29ubmVjdGlvbiIsIndlYnNvY2tldE1lc3NhZ2VSZWNlaXZlZCIsIldlYnNvY2tldEZyYW1lU2VuZCIsImNoYW5uZWxzIiwicGluZyIsImNoYW5uZWwiLCJwb25nIiwiQnl0ZVBhcnNlciIsImJ1ZmZlcnMiLCJieXRlT2Zmc2V0Iiwic3RhdGUiLCJpbmZvIiwiZnJhZ21lbnRzIiwiY29uc3RydWN0b3IiLCJ3cyIsIklORk8iLCJfd3JpdGUiLCJjaHVuayIsIl8iLCJjYWxsYmFjayIsInB1c2giLCJsZW5ndGgiLCJydW4iLCJidWZmZXIiLCJjb25zdW1lIiwiZmluIiwib3Bjb2RlIiwib3JpZ2luYWxPcGNvZGUiLCJmcmFnbWVudGVkIiwiQ09OVElOVUFUSU9OIiwiQklOQVJZIiwiVEVYVCIsInBheWxvYWRMZW5ndGgiLCJSRUFEX0RBVEEiLCJQQVlMT0FETEVOR1RIXzE2IiwiUEFZTE9BRExFTkdUSF82NCIsIlBJTkciLCJQT05HIiwiQ0xPU0UiLCJib2R5IiwiY2xvc2VJbmZvIiwicGFyc2VDbG9zZUJvZHkiLCJCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsIndyaXRlVUludDE2QkUiLCJjb2RlIiwiY2xvc2VGcmFtZSIsInNvY2tldCIsIndyaXRlIiwiY3JlYXRlRnJhbWUiLCJlcnIiLCJDTE9TSU5HIiwiZW5kIiwiZnJhbWUiLCJoYXNTdWJzY3JpYmVycyIsInB1Ymxpc2giLCJwYXlsb2FkIiwicmVhZFVJbnQxNkJFIiwidXBwZXIiLCJyZWFkVUludDMyQkUiLCJsb3dlciIsImZ1bGxNZXNzYWdlIiwiY29uY2F0IiwibiIsInNoaWZ0Iiwib2Zmc2V0IiwibmV4dCIsInNldCIsInN1YmFycmF5Iiwib25seUNvZGUiLCJkYXRhIiwicmVhc29uIiwidW5kZWZpbmVkIiwiVGV4dERlY29kZXIiLCJmYXRhbCIsImRlY29kZSIsImNsb3NpbmdJbmZvIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/receiver.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/symbols.js":
/*!****************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/websocket/symbols.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    kWebSocketURL: Symbol(\"url\"),\n    kReadyState: Symbol(\"ready state\"),\n    kController: Symbol(\"controller\"),\n    kResponse: Symbol(\"response\"),\n    kBinaryType: Symbol(\"binary type\"),\n    kSentClose: Symbol(\"sent close\"),\n    kReceivedClose: Symbol(\"received close\"),\n    kByteParser: Symbol(\"byte parser\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L3N5bWJvbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZDLGVBQWVDLE9BQU87SUFDdEJDLGFBQWFELE9BQU87SUFDcEJFLGFBQWFGLE9BQU87SUFDcEJHLFdBQVdILE9BQU87SUFDbEJJLGFBQWFKLE9BQU87SUFDcEJLLFlBQVlMLE9BQU87SUFDbkJNLGdCQUFnQk4sT0FBTztJQUN2Qk8sYUFBYVAsT0FBTztBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYnNvY2tldC9zeW1ib2xzLmpzP2Y1OWIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrV2ViU29ja2V0VVJMOiBTeW1ib2woJ3VybCcpLFxuICBrUmVhZHlTdGF0ZTogU3ltYm9sKCdyZWFkeSBzdGF0ZScpLFxuICBrQ29udHJvbGxlcjogU3ltYm9sKCdjb250cm9sbGVyJyksXG4gIGtSZXNwb25zZTogU3ltYm9sKCdyZXNwb25zZScpLFxuICBrQmluYXJ5VHlwZTogU3ltYm9sKCdiaW5hcnkgdHlwZScpLFxuICBrU2VudENsb3NlOiBTeW1ib2woJ3NlbnQgY2xvc2UnKSxcbiAga1JlY2VpdmVkQ2xvc2U6IFN5bWJvbCgncmVjZWl2ZWQgY2xvc2UnKSxcbiAga0J5dGVQYXJzZXI6IFN5bWJvbCgnYnl0ZSBwYXJzZXInKVxufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJrV2ViU29ja2V0VVJMIiwiU3ltYm9sIiwia1JlYWR5U3RhdGUiLCJrQ29udHJvbGxlciIsImtSZXNwb25zZSIsImtCaW5hcnlUeXBlIiwia1NlbnRDbG9zZSIsImtSZWNlaXZlZENsb3NlIiwia0J5dGVQYXJzZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/util.js":
/*!*************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/websocket/util.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/symbols.js\");\nconst { states, opcodes } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/constants.js\");\nconst { MessageEvent, ErrorEvent } = __webpack_require__(/*! ./events */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/events.js\");\n/* globals Blob */ /**\n * @param {import('./websocket').WebSocket} ws\n */ function isEstablished(ws) {\n    // If the server's response is validated as provided for above, it is\n    // said that _The WebSocket Connection is Established_ and that the\n    // WebSocket Connection is in the OPEN state.\n    return ws[kReadyState] === states.OPEN;\n}\n/**\n * @param {import('./websocket').WebSocket} ws\n */ function isClosing(ws) {\n    // Upon either sending or receiving a Close control frame, it is said\n    // that _The WebSocket Closing Handshake is Started_ and that the\n    // WebSocket connection is in the CLOSING state.\n    return ws[kReadyState] === states.CLOSING;\n}\n/**\n * @param {import('./websocket').WebSocket} ws\n */ function isClosed(ws) {\n    return ws[kReadyState] === states.CLOSED;\n}\n/**\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e\n * @param {EventTarget} target\n * @param {EventInit | undefined} eventInitDict\n */ function fireEvent(e, target, eventConstructor = Event, eventInitDict) {\n    // 1. If eventConstructor is not given, then let eventConstructor be Event.\n    // 2. Let event be the result of creating an event given eventConstructor,\n    //    in the relevant realm of target.\n    // 3. Initialize events type attribute to e.\n    const event = new eventConstructor(e, eventInitDict) // eslint-disable-line new-cap\n    ;\n    // 4. Initialize any other IDL attributes of event as described in the\n    //    invocation of this algorithm.\n    // 5. Return the result of dispatching event at target, with legacy target\n    //    override flag set if set.\n    target.dispatchEvent(event);\n}\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @param {import('./websocket').WebSocket} ws\n * @param {number} type Opcode\n * @param {Buffer} data application data\n */ function websocketMessageReceived(ws, type, data) {\n    // 1. If ready state is not OPEN (1), then return.\n    if (ws[kReadyState] !== states.OPEN) {\n        return;\n    }\n    // 2. Let dataForEvent be determined by switching on type and binary type:\n    let dataForEvent;\n    if (type === opcodes.TEXT) {\n        // -> type indicates that the data is Text\n        //      a new DOMString containing data\n        try {\n            dataForEvent = new TextDecoder(\"utf-8\", {\n                fatal: true\n            }).decode(data);\n        } catch  {\n            failWebsocketConnection(ws, \"Received invalid UTF-8 in text frame.\");\n            return;\n        }\n    } else if (type === opcodes.BINARY) {\n        if (ws[kBinaryType] === \"blob\") {\n            // -> type indicates that the data is Binary and binary type is \"blob\"\n            //      a new Blob object, created in the relevant Realm of the WebSocket\n            //      object, that represents data as its raw data\n            dataForEvent = new Blob([\n                data\n            ]);\n        } else {\n            // -> type indicates that the data is Binary and binary type is \"arraybuffer\"\n            //      a new ArrayBuffer object, created in the relevant Realm of the\n            //      WebSocket object, whose contents are data\n            dataForEvent = new Uint8Array(data).buffer;\n        }\n    }\n    // 3. Fire an event named message at the WebSocket object, using MessageEvent,\n    //    with the origin attribute initialized to the serialization of the WebSocket\n    //    objects url's origin, and the data attribute initialized to dataForEvent.\n    fireEvent(\"message\", ws, MessageEvent, {\n        origin: ws[kWebSocketURL].origin,\n        data: dataForEvent\n    });\n}\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455\n * @see https://datatracker.ietf.org/doc/html/rfc2616\n * @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407\n * @param {string} protocol\n */ function isValidSubprotocol(protocol) {\n    // If present, this value indicates one\n    // or more comma-separated subprotocol the client wishes to speak,\n    // ordered by preference.  The elements that comprise this value\n    // MUST be non-empty strings with characters in the range U+0021 to\n    // U+007E not including separator characters as defined in\n    // [RFC2616] and MUST all be unique strings.\n    if (protocol.length === 0) {\n        return false;\n    }\n    for (const char of protocol){\n        const code = char.charCodeAt(0);\n        if (code < 0x21 || code > 0x7E || char === \"(\" || char === \")\" || char === \"<\" || char === \">\" || char === \"@\" || char === \",\" || char === \";\" || char === \":\" || char === \"\\\\\" || char === '\"' || char === \"/\" || char === \"[\" || char === \"]\" || char === \"?\" || char === \"=\" || char === \"{\" || char === \"}\" || code === 32 || // SP\n        code === 9 // HT\n        ) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4\n * @param {number} code\n */ function isValidStatusCode(code) {\n    if (code >= 1000 && code < 1015) {\n        return code !== 1004 && // reserved\n        code !== 1005 && // \"MUST NOT be set as a status code\"\n        code !== 1006 // \"MUST NOT be set as a status code\"\n        ;\n    }\n    return code >= 3000 && code <= 4999;\n}\n/**\n * @param {import('./websocket').WebSocket} ws\n * @param {string|undefined} reason\n */ function failWebsocketConnection(ws, reason) {\n    const { [kController]: controller, [kResponse]: response } = ws;\n    controller.abort();\n    if (response?.socket && !response.socket.destroyed) {\n        response.socket.destroy();\n    }\n    if (reason) {\n        fireEvent(\"error\", ws, ErrorEvent, {\n            error: new Error(reason)\n        });\n    }\n}\nmodule.exports = {\n    isEstablished,\n    isClosing,\n    isClosed,\n    fireEvent,\n    isValidSubprotocol,\n    isValidStatusCode,\n    failWebsocketConnection,\n    websocketMessageReceived\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxTQUFTLEVBQUVDLFdBQVcsRUFBRUMsYUFBYSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ3BGLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDcEMsTUFBTSxFQUFFRyxZQUFZLEVBQUVDLFVBQVUsRUFBRSxHQUFHSixtQkFBT0EsQ0FBQztBQUU3QyxnQkFBZ0IsR0FFaEI7O0NBRUMsR0FDRCxTQUFTSyxjQUFlQyxFQUFFO0lBQ3hCLHFFQUFxRTtJQUNyRSxtRUFBbUU7SUFDbkUsNkNBQTZDO0lBQzdDLE9BQU9BLEVBQUUsQ0FBQ1gsWUFBWSxLQUFLTSxPQUFPTSxJQUFJO0FBQ3hDO0FBRUE7O0NBRUMsR0FDRCxTQUFTQyxVQUFXRixFQUFFO0lBQ3BCLHFFQUFxRTtJQUNyRSxpRUFBaUU7SUFDakUsZ0RBQWdEO0lBQ2hELE9BQU9BLEVBQUUsQ0FBQ1gsWUFBWSxLQUFLTSxPQUFPUSxPQUFPO0FBQzNDO0FBRUE7O0NBRUMsR0FDRCxTQUFTQyxTQUFVSixFQUFFO0lBQ25CLE9BQU9BLEVBQUUsQ0FBQ1gsWUFBWSxLQUFLTSxPQUFPVSxNQUFNO0FBQzFDO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTQyxVQUFXQyxDQUFDLEVBQUVDLE1BQU0sRUFBRUMsbUJBQW1CQyxLQUFLLEVBQUVDLGFBQWE7SUFDcEUsMkVBQTJFO0lBRTNFLDBFQUEwRTtJQUMxRSxzQ0FBc0M7SUFDdEMsNkNBQTZDO0lBQzdDLE1BQU1DLFFBQVEsSUFBSUgsaUJBQWlCRixHQUFHSSxlQUFlLDhCQUE4Qjs7SUFFbkYsc0VBQXNFO0lBQ3RFLG1DQUFtQztJQUVuQywwRUFBMEU7SUFDMUUsK0JBQStCO0lBQy9CSCxPQUFPSyxh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OUM7SUFDQUc7SUFDQUU7SUFDQUU7SUFDQXNCO0lBQ0FNO0lBQ0FaO0lBQ0FSO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvdXRpbC5qcz83MjZkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGtSZWFkeVN0YXRlLCBrQ29udHJvbGxlciwga1Jlc3BvbnNlLCBrQmluYXJ5VHlwZSwga1dlYlNvY2tldFVSTCB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgc3RhdGVzLCBvcGNvZGVzIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IE1lc3NhZ2VFdmVudCwgRXJyb3JFdmVudCB9ID0gcmVxdWlyZSgnLi9ldmVudHMnKVxuXG4vKiBnbG9iYWxzIEJsb2IgKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi93ZWJzb2NrZXQnKS5XZWJTb2NrZXR9IHdzXG4gKi9cbmZ1bmN0aW9uIGlzRXN0YWJsaXNoZWQgKHdzKSB7XG4gIC8vIElmIHRoZSBzZXJ2ZXIncyByZXNwb25zZSBpcyB2YWxpZGF0ZWQgYXMgcHJvdmlkZWQgZm9yIGFib3ZlLCBpdCBpc1xuICAvLyBzYWlkIHRoYXQgX1RoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbiBpcyBFc3RhYmxpc2hlZF8gYW5kIHRoYXQgdGhlXG4gIC8vIFdlYlNvY2tldCBDb25uZWN0aW9uIGlzIGluIHRoZSBPUEVOIHN0YXRlLlxuICByZXR1cm4gd3Nba1JlYWR5U3RhdGVdID09PSBzdGF0ZXMuT1BFTlxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3dlYnNvY2tldCcpLldlYlNvY2tldH0gd3NcbiAqL1xuZnVuY3Rpb24gaXNDbG9zaW5nICh3cykge1xuICAvLyBVcG9uIGVpdGhlciBzZW5kaW5nIG9yIHJlY2VpdmluZyBhIENsb3NlIGNvbnRyb2wgZnJhbWUsIGl0IGlzIHNhaWRcbiAgLy8gdGhhdCBfVGhlIFdlYlNvY2tldCBDbG9zaW5nIEhhbmRzaGFrZSBpcyBTdGFydGVkXyBhbmQgdGhhdCB0aGVcbiAgLy8gV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgaW4gdGhlIENMT1NJTkcgc3RhdGUuXG4gIHJldHVybiB3c1trUmVhZHlTdGF0ZV0gPT09IHN0YXRlcy5DTE9TSU5HXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vd2Vic29ja2V0JykuV2ViU29ja2V0fSB3c1xuICovXG5mdW5jdGlvbiBpc0Nsb3NlZCAod3MpIHtcbiAgcmV0dXJuIHdzW2tSZWFkeVN0YXRlXSA9PT0gc3RhdGVzLkNMT1NFRFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWV2ZW50LWZpcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7RXZlbnRJbml0IHwgdW5kZWZpbmVkfSBldmVudEluaXREaWN0XG4gKi9cbmZ1bmN0aW9uIGZpcmVFdmVudCAoZSwgdGFyZ2V0LCBldmVudENvbnN0cnVjdG9yID0gRXZlbnQsIGV2ZW50SW5pdERpY3QpIHtcbiAgLy8gMS4gSWYgZXZlbnRDb25zdHJ1Y3RvciBpcyBub3QgZ2l2ZW4sIHRoZW4gbGV0IGV2ZW50Q29uc3RydWN0b3IgYmUgRXZlbnQuXG5cbiAgLy8gMi4gTGV0IGV2ZW50IGJlIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYW4gZXZlbnQgZ2l2ZW4gZXZlbnRDb25zdHJ1Y3RvcixcbiAgLy8gICAgaW4gdGhlIHJlbGV2YW50IHJlYWxtIG9mIHRhcmdldC5cbiAgLy8gMy4gSW5pdGlhbGl6ZSBldmVudOKAmXMgdHlwZSBhdHRyaWJ1dGUgdG8gZS5cbiAgY29uc3QgZXZlbnQgPSBuZXcgZXZlbnRDb25zdHJ1Y3RvcihlLCBldmVudEluaXREaWN0KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcblxuICAvLyA0LiBJbml0aWFsaXplIGFueSBvdGhlciBJREwgYXR0cmlidXRlcyBvZiBldmVudCBhcyBkZXNjcmliZWQgaW4gdGhlXG4gIC8vICAgIGludm9jYXRpb24gb2YgdGhpcyBhbGdvcml0aG0uXG5cbiAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgZGlzcGF0Y2hpbmcgZXZlbnQgYXQgdGFyZ2V0LCB3aXRoIGxlZ2FjeSB0YXJnZXRcbiAgLy8gICAgb3ZlcnJpZGUgZmxhZyBzZXQgaWYgc2V0LlxuICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudClcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2ZlZWRiYWNrLWZyb20tdGhlLXByb3RvY29sXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi93ZWJzb2NrZXQnKS5XZWJTb2NrZXR9IHdzXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZSBPcGNvZGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIGFwcGxpY2F0aW9uIGRhdGFcbiAqL1xuZnVuY3Rpb24gd2Vic29ja2V0TWVzc2FnZVJlY2VpdmVkICh3cywgdHlwZSwgZGF0YSkge1xuICAvLyAxLiBJZiByZWFkeSBzdGF0ZSBpcyBub3QgT1BFTiAoMSksIHRoZW4gcmV0dXJuLlxuICBpZiAod3Nba1JlYWR5U3RhdGVdICE9PSBzdGF0ZXMuT1BFTikge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gMi4gTGV0IGRhdGFGb3JFdmVudCBiZSBkZXRlcm1pbmVkIGJ5IHN3aXRjaGluZyBvbiB0eXBlIGFuZCBiaW5hcnkgdHlwZTpcbiAgbGV0IGRhdGFGb3JFdmVudFxuXG4gIGlmICh0eXBlID09PSBvcGNvZGVzLlRFWFQpIHtcbiAgICAvLyAtPiB0eXBlIGluZGljYXRlcyB0aGF0IHRoZSBkYXRhIGlzIFRleHRcbiAgICAvLyAgICAgIGEgbmV3IERPTVN0cmluZyBjb250YWluaW5nIGRhdGFcbiAgICB0cnkge1xuICAgICAgZGF0YUZvckV2ZW50ID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcsIHsgZmF0YWw6IHRydWUgfSkuZGVjb2RlKGRhdGEpXG4gICAgfSBjYXRjaCB7XG4gICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih3cywgJ1JlY2VpdmVkIGludmFsaWQgVVRGLTggaW4gdGV4dCBmcmFtZS4nKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09IG9wY29kZXMuQklOQVJZKSB7XG4gICAgaWYgKHdzW2tCaW5hcnlUeXBlXSA9PT0gJ2Jsb2InKSB7XG4gICAgICAvLyAtPiB0eXBlIGluZGljYXRlcyB0aGF0IHRoZSBkYXRhIGlzIEJpbmFyeSBhbmQgYmluYXJ5IHR5cGUgaXMgXCJibG9iXCJcbiAgICAgIC8vICAgICAgYSBuZXcgQmxvYiBvYmplY3QsIGNyZWF0ZWQgaW4gdGhlIHJlbGV2YW50IFJlYWxtIG9mIHRoZSBXZWJTb2NrZXRcbiAgICAgIC8vICAgICAgb2JqZWN0LCB0aGF0IHJlcHJlc2VudHMgZGF0YSBhcyBpdHMgcmF3IGRhdGFcbiAgICAgIGRhdGFGb3JFdmVudCA9IG5ldyBCbG9iKFtkYXRhXSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gLT4gdHlwZSBpbmRpY2F0ZXMgdGhhdCB0aGUgZGF0YSBpcyBCaW5hcnkgYW5kIGJpbmFyeSB0eXBlIGlzIFwiYXJyYXlidWZmZXJcIlxuICAgICAgLy8gICAgICBhIG5ldyBBcnJheUJ1ZmZlciBvYmplY3QsIGNyZWF0ZWQgaW4gdGhlIHJlbGV2YW50IFJlYWxtIG9mIHRoZVxuICAgICAgLy8gICAgICBXZWJTb2NrZXQgb2JqZWN0LCB3aG9zZSBjb250ZW50cyBhcmUgZGF0YVxuICAgICAgZGF0YUZvckV2ZW50ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSkuYnVmZmVyXG4gICAgfVxuICB9XG5cbiAgLy8gMy4gRmlyZSBhbiBldmVudCBuYW1lZCBtZXNzYWdlIGF0IHRoZSBXZWJTb2NrZXQgb2JqZWN0LCB1c2luZyBNZXNzYWdlRXZlbnQsXG4gIC8vICAgIHdpdGggdGhlIG9yaWdpbiBhdHRyaWJ1dGUgaW5pdGlhbGl6ZWQgdG8gdGhlIHNlcmlhbGl6YXRpb24gb2YgdGhlIFdlYlNvY2tldFxuICAvLyAgICBvYmplY3TigJlzIHVybCdzIG9yaWdpbiwgYW5kIHRoZSBkYXRhIGF0dHJpYnV0ZSBpbml0aWFsaXplZCB0byBkYXRhRm9yRXZlbnQuXG4gIGZpcmVFdmVudCgnbWVzc2FnZScsIHdzLCBNZXNzYWdlRXZlbnQsIHtcbiAgICBvcmlnaW46IHdzW2tXZWJTb2NrZXRVUkxdLm9yaWdpbixcbiAgICBkYXRhOiBkYXRhRm9yRXZlbnRcbiAgfSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NVxuICogQHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzI2MTZcbiAqIEBzZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzk4NDA3XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvdG9jb2xcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFN1YnByb3RvY29sIChwcm90b2NvbCkge1xuICAvLyBJZiBwcmVzZW50LCB0aGlzIHZhbHVlIGluZGljYXRlcyBvbmVcbiAgLy8gb3IgbW9yZSBjb21tYS1zZXBhcmF0ZWQgc3VicHJvdG9jb2wgdGhlIGNsaWVudCB3aXNoZXMgdG8gc3BlYWssXG4gIC8vIG9yZGVyZWQgYnkgcHJlZmVyZW5jZS4gIFRoZSBlbGVtZW50cyB0aGF0IGNvbXByaXNlIHRoaXMgdmFsdWVcbiAgLy8gTVVTVCBiZSBub24tZW1wdHkgc3RyaW5ncyB3aXRoIGNoYXJhY3RlcnMgaW4gdGhlIHJhbmdlIFUrMDAyMSB0b1xuICAvLyBVKzAwN0Ugbm90IGluY2x1ZGluZyBzZXBhcmF0b3IgY2hhcmFjdGVycyBhcyBkZWZpbmVkIGluXG4gIC8vIFtSRkMyNjE2XSBhbmQgTVVTVCBhbGwgYmUgdW5pcXVlIHN0cmluZ3MuXG4gIGlmIChwcm90b2NvbC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZvciAoY29uc3QgY2hhciBvZiBwcm90b2NvbCkge1xuICAgIGNvbnN0IGNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMClcblxuICAgIGlmIChcbiAgICAgIGNvZGUgPCAweDIxIHx8XG4gICAgICBjb2RlID4gMHg3RSB8fFxuICAgICAgY2hhciA9PT0gJygnIHx8XG4gICAgICBjaGFyID09PSAnKScgfHxcbiAgICAgIGNoYXIgPT09ICc8JyB8fFxuICAgICAgY2hhciA9PT0gJz4nIHx8XG4gICAgICBjaGFyID09PSAnQCcgfHxcbiAgICAgIGNoYXIgPT09ICcsJyB8fFxuICAgICAgY2hhciA9PT0gJzsnIHx8XG4gICAgICBjaGFyID09PSAnOicgfHxcbiAgICAgIGNoYXIgPT09ICdcXFxcJyB8fFxuICAgICAgY2hhciA9PT0gJ1wiJyB8fFxuICAgICAgY2hhciA9PT0gJy8nIHx8XG4gICAgICBjaGFyID09PSAnWycgfHxcbiAgICAgIGNoYXIgPT09ICddJyB8fFxuICAgICAgY2hhciA9PT0gJz8nIHx8XG4gICAgICBjaGFyID09PSAnPScgfHxcbiAgICAgIGNoYXIgPT09ICd7JyB8fFxuICAgICAgY2hhciA9PT0gJ30nIHx8XG4gICAgICBjb2RlID09PSAzMiB8fCAvLyBTUFxuICAgICAgY29kZSA9PT0gOSAvLyBIVFxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTctNFxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFN0YXR1c0NvZGUgKGNvZGUpIHtcbiAgaWYgKGNvZGUgPj0gMTAwMCAmJiBjb2RlIDwgMTAxNSkge1xuICAgIHJldHVybiAoXG4gICAgICBjb2RlICE9PSAxMDA0ICYmIC8vIHJlc2VydmVkXG4gICAgICBjb2RlICE9PSAxMDA1ICYmIC8vIFwiTVVTVCBOT1QgYmUgc2V0IGFzIGEgc3RhdHVzIGNvZGVcIlxuICAgICAgY29kZSAhPT0gMTAwNiAvLyBcIk1VU1QgTk9UIGJlIHNldCBhcyBhIHN0YXR1cyBjb2RlXCJcbiAgICApXG4gIH1cblxuICByZXR1cm4gY29kZSA+PSAzMDAwICYmIGNvZGUgPD0gNDk5OVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3dlYnNvY2tldCcpLldlYlNvY2tldH0gd3NcbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gcmVhc29uXG4gKi9cbmZ1bmN0aW9uIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uICh3cywgcmVhc29uKSB7XG4gIGNvbnN0IHsgW2tDb250cm9sbGVyXTogY29udHJvbGxlciwgW2tSZXNwb25zZV06IHJlc3BvbnNlIH0gPSB3c1xuXG4gIGNvbnRyb2xsZXIuYWJvcnQoKVxuXG4gIGlmIChyZXNwb25zZT8uc29ja2V0ICYmICFyZXNwb25zZS5zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgcmVzcG9uc2Uuc29ja2V0LmRlc3Ryb3koKVxuICB9XG5cbiAgaWYgKHJlYXNvbikge1xuICAgIGZpcmVFdmVudCgnZXJyb3InLCB3cywgRXJyb3JFdmVudCwge1xuICAgICAgZXJyb3I6IG5ldyBFcnJvcihyZWFzb24pXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNFc3RhYmxpc2hlZCxcbiAgaXNDbG9zaW5nLFxuICBpc0Nsb3NlZCxcbiAgZmlyZUV2ZW50LFxuICBpc1ZhbGlkU3VicHJvdG9jb2wsXG4gIGlzVmFsaWRTdGF0dXNDb2RlLFxuICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbixcbiAgd2Vic29ja2V0TWVzc2FnZVJlY2VpdmVkXG59XG4iXSwibmFtZXMiOlsia1JlYWR5U3RhdGUiLCJrQ29udHJvbGxlciIsImtSZXNwb25zZSIsImtCaW5hcnlUeXBlIiwia1dlYlNvY2tldFVSTCIsInJlcXVpcmUiLCJzdGF0ZXMiLCJvcGNvZGVzIiwiTWVzc2FnZUV2ZW50IiwiRXJyb3JFdmVudCIsImlzRXN0YWJsaXNoZWQiLCJ3cyIsIk9QRU4iLCJpc0Nsb3NpbmciLCJDTE9TSU5HIiwiaXNDbG9zZWQiLCJDTE9TRUQiLCJmaXJlRXZlbnQiLCJlIiwidGFyZ2V0IiwiZXZlbnRDb25zdHJ1Y3RvciIsIkV2ZW50IiwiZXZlbnRJbml0RGljdCIsImV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsIndlYnNvY2tldE1lc3NhZ2VSZWNlaXZlZCIsInR5cGUiLCJkYXRhIiwiZGF0YUZvckV2ZW50IiwiVEVYVCIsIlRleHREZWNvZGVyIiwiZmF0YWwiLCJkZWNvZGUiLCJmYWlsV2Vic29ja2V0Q29ubmVjdGlvbiIsIkJJTkFSWSIsIkJsb2IiLCJVaW50OEFycmF5IiwiYnVmZmVyIiwib3JpZ2luIiwiaXNWYWxpZFN1YnByb3RvY29sIiwicHJvdG9jb2wiLCJsZW5ndGgiLCJjaGFyIiwiY29kZSIsImNoYXJDb2RlQXQiLCJpc1ZhbGlkU3RhdHVzQ29kZSIsInJlYXNvbiIsImNvbnRyb2xsZXIiLCJyZXNwb25zZSIsImFib3J0Iiwic29ja2V0IiwiZGVzdHJveWVkIiwiZGVzdHJveSIsImVycm9yIiwiRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/websocket.js":
/*!******************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/undici/lib/websocket/websocket.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/webidl.js\");\nconst { DOMException } = __webpack_require__(/*! ../fetch/constants */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/constants.js\");\nconst { URLSerializer } = __webpack_require__(/*! ../fetch/dataURL */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/dataURL.js\");\nconst { getGlobalOrigin } = __webpack_require__(/*! ../fetch/global */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/fetch/global.js\");\nconst { staticPropertyDescriptors, states, opcodes, emptyBuffer } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/constants.js\");\nconst { kWebSocketURL, kReadyState, kController, kBinaryType, kResponse, kSentClose, kByteParser } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/symbols.js\");\nconst { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/util.js\");\nconst { establishWebSocketConnection } = __webpack_require__(/*! ./connection */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/connection.js\");\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/frame.js\");\nconst { ByteParser } = __webpack_require__(/*! ./receiver */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/receiver.js\");\nconst { kEnumerableProperty, isBlobLike } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/core/util.js\");\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../global */ \"(ssr)/./node_modules/firebase/node_modules/undici/lib/global.js\");\nconst { types } = __webpack_require__(/*! util */ \"util\");\nlet experimentalWarned = false;\n// https://websockets.spec.whatwg.org/#interface-definition\nclass WebSocket extends EventTarget {\n    #events;\n    #bufferedAmount;\n    #protocol;\n    #extensions;\n    /**\n   * @param {string} url\n   * @param {string|string[]} protocols\n   */ constructor(url, protocols = []){\n        super();\n        this.#events = {\n            open: null,\n            error: null,\n            close: null,\n            message: null\n        };\n        this.#bufferedAmount = 0;\n        this.#protocol = \"\";\n        this.#extensions = \"\";\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"WebSocket constructor\"\n        });\n        if (!experimentalWarned) {\n            experimentalWarned = true;\n            process.emitWarning(\"WebSockets are experimental, expect them to change at any time.\", {\n                code: \"UNDICI-WS\"\n            });\n        }\n        const options = webidl.converters[\"DOMString or sequence<DOMString> or WebSocketInit\"](protocols);\n        url = webidl.converters.USVString(url);\n        protocols = options.protocols;\n        // 1. Let baseURL be this's relevant settings object's API base URL.\n        const baseURL = getGlobalOrigin();\n        // 1. Let urlRecord be the result of applying the URL parser to url with baseURL.\n        let urlRecord;\n        try {\n            urlRecord = new URL(url, baseURL);\n        } catch (e) {\n            // 3. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n            throw new DOMException(e, \"SyntaxError\");\n        }\n        // 4. If urlRecords scheme is \"http\", then set urlRecords scheme to \"ws\".\n        if (urlRecord.protocol === \"http:\") {\n            urlRecord.protocol = \"ws:\";\n        } else if (urlRecord.protocol === \"https:\") {\n            // 5. Otherwise, if urlRecords scheme is \"https\", set urlRecords scheme to \"wss\".\n            urlRecord.protocol = \"wss:\";\n        }\n        // 6. If urlRecords scheme is not \"ws\" or \"wss\", then throw a \"SyntaxError\" DOMException.\n        if (urlRecord.protocol !== \"ws:\" && urlRecord.protocol !== \"wss:\") {\n            throw new DOMException(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, \"SyntaxError\");\n        }\n        // 7. If urlRecords fragment is non-null, then throw a \"SyntaxError\"\n        //    DOMException.\n        if (urlRecord.hash || urlRecord.href.endsWith(\"#\")) {\n            throw new DOMException(\"Got fragment\", \"SyntaxError\");\n        }\n        // 8. If protocols is a string, set protocols to a sequence consisting\n        //    of just that string.\n        if (typeof protocols === \"string\") {\n            protocols = [\n                protocols\n            ];\n        }\n        // 9. If any of the values in protocols occur more than once or otherwise\n        //    fail to match the requirements for elements that comprise the value\n        //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket\n        //    protocol, then throw a \"SyntaxError\" DOMException.\n        if (protocols.length !== new Set(protocols.map((p)=>p.toLowerCase())).size) {\n            throw new DOMException(\"Invalid Sec-WebSocket-Protocol value\", \"SyntaxError\");\n        }\n        if (protocols.length > 0 && !protocols.every((p)=>isValidSubprotocol(p))) {\n            throw new DOMException(\"Invalid Sec-WebSocket-Protocol value\", \"SyntaxError\");\n        }\n        // 10. Set this's url to urlRecord.\n        this[kWebSocketURL] = new URL(urlRecord.href);\n        // 11. Let client be this's relevant settings object.\n        // 12. Run this step in parallel:\n        //    1. Establish a WebSocket connection given urlRecord, protocols,\n        //       and client.\n        this[kController] = establishWebSocketConnection(urlRecord, protocols, this, (response)=>this.#onConnectionEstablished(response), options);\n        // Each WebSocket object has an associated ready state, which is a\n        // number representing the state of the connection. Initially it must\n        // be CONNECTING (0).\n        this[kReadyState] = WebSocket.CONNECTING;\n        // The extensions attribute must initially return the empty string.\n        // The protocol attribute must initially return the empty string.\n        // Each WebSocket object has an associated binary type, which is a\n        // BinaryType. Initially it must be \"blob\".\n        this[kBinaryType] = \"blob\";\n    }\n    /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-close\n   * @param {number|undefined} code\n   * @param {string|undefined} reason\n   */ close(code = undefined, reason = undefined) {\n        webidl.brandCheck(this, WebSocket);\n        if (code !== undefined) {\n            code = webidl.converters[\"unsigned short\"](code, {\n                clamp: true\n            });\n        }\n        if (reason !== undefined) {\n            reason = webidl.converters.USVString(reason);\n        }\n        // 1. If code is present, but is neither an integer equal to 1000 nor an\n        //    integer in the range 3000 to 4999, inclusive, throw an\n        //    \"InvalidAccessError\" DOMException.\n        if (code !== undefined) {\n            if (code !== 1000 && (code < 3000 || code > 4999)) {\n                throw new DOMException(\"invalid code\", \"InvalidAccessError\");\n            }\n        }\n        let reasonByteLength = 0;\n        // 2. If reason is present, then run these substeps:\n        if (reason !== undefined) {\n            // 1. Let reasonBytes be the result of encoding reason.\n            // 2. If reasonBytes is longer than 123 bytes, then throw a\n            //    \"SyntaxError\" DOMException.\n            reasonByteLength = Buffer.byteLength(reason);\n            if (reasonByteLength > 123) {\n                throw new DOMException(`Reason must be less than 123 bytes; received ${reasonByteLength}`, \"SyntaxError\");\n            }\n        }\n        // 3. Run the first matching steps from the following list:\n        if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED) {\n        // If this's ready state is CLOSING (2) or CLOSED (3)\n        // Do nothing.\n        } else if (!isEstablished(this)) {\n            // If the WebSocket connection is not yet established\n            // Fail the WebSocket connection and set this's ready state\n            // to CLOSING (2).\n            failWebsocketConnection(this, \"Connection was closed before it was established.\");\n            this[kReadyState] = WebSocket.CLOSING;\n        } else if (!isClosing(this)) {\n            // If the WebSocket closing handshake has not yet been started\n            // Start the WebSocket closing handshake and set this's ready\n            // state to CLOSING (2).\n            // - If neither code nor reason is present, the WebSocket Close\n            //   message must not have a body.\n            // - If code is present, then the status code to use in the\n            //   WebSocket Close message must be the integer given by code.\n            // - If reason is also present, then reasonBytes must be\n            //   provided in the Close message after the status code.\n            const frame = new WebsocketFrameSend();\n            // If neither code nor reason is present, the WebSocket Close\n            // message must not have a body.\n            // If code is present, then the status code to use in the\n            // WebSocket Close message must be the integer given by code.\n            if (code !== undefined && reason === undefined) {\n                frame.frameData = Buffer.allocUnsafe(2);\n                frame.frameData.writeUInt16BE(code, 0);\n            } else if (code !== undefined && reason !== undefined) {\n                // If reason is also present, then reasonBytes must be\n                // provided in the Close message after the status code.\n                frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);\n                frame.frameData.writeUInt16BE(code, 0);\n                // the body MAY contain UTF-8-encoded data with value /reason/\n                frame.frameData.write(reason, 2, \"utf-8\");\n            } else {\n                frame.frameData = emptyBuffer;\n            }\n            /** @type {import('stream').Duplex} */ const socket = this[kResponse].socket;\n            socket.write(frame.createFrame(opcodes.CLOSE), (err)=>{\n                if (!err) {\n                    this[kSentClose] = true;\n                }\n            });\n            // Upon either sending or receiving a Close control frame, it is said\n            // that _The WebSocket Closing Handshake is Started_ and that the\n            // WebSocket connection is in the CLOSING state.\n            this[kReadyState] = states.CLOSING;\n        } else {\n            // Otherwise\n            // Set this's ready state to CLOSING (2).\n            this[kReadyState] = WebSocket.CLOSING;\n        }\n    }\n    /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-send\n   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data\n   */ send(data) {\n        webidl.brandCheck(this, WebSocket);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"WebSocket.send\"\n        });\n        data = webidl.converters.WebSocketSendData(data);\n        // 1. If this's ready state is CONNECTING, then throw an\n        //    \"InvalidStateError\" DOMException.\n        if (this[kReadyState] === WebSocket.CONNECTING) {\n            throw new DOMException(\"Sent before connected.\", \"InvalidStateError\");\n        }\n        // 2. Run the appropriate set of steps from the following list:\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n        if (!isEstablished(this) || isClosing(this)) {\n            return;\n        }\n        /** @type {import('stream').Duplex} */ const socket = this[kResponse].socket;\n        // If data is a string\n        if (typeof data === \"string\") {\n            // If the WebSocket connection is established and the WebSocket\n            // closing handshake has not yet started, then the user agent\n            // must send a WebSocket Message comprised of the data argument\n            // using a text frame opcode; if the data cannot be sent, e.g.\n            // because it would need to be buffered but the buffer is full,\n            // the user agent must flag the WebSocket as full and then close\n            // the WebSocket connection. Any invocation of this method with a\n            // string argument that does not throw an exception must increase\n            // the bufferedAmount attribute by the number of bytes needed to\n            // express the argument as UTF-8.\n            const value = Buffer.from(data);\n            const frame = new WebsocketFrameSend(value);\n            const buffer = frame.createFrame(opcodes.TEXT);\n            this.#bufferedAmount += value.byteLength;\n            socket.write(buffer, ()=>{\n                this.#bufferedAmount -= value.byteLength;\n            });\n        } else if (types.isArrayBuffer(data)) {\n            // If the WebSocket connection is established, and the WebSocket\n            // closing handshake has not yet started, then the user agent must\n            // send a WebSocket Message comprised of data using a binary frame\n            // opcode; if the data cannot be sent, e.g. because it would need\n            // to be buffered but the buffer is full, the user agent must flag\n            // the WebSocket as full and then close the WebSocket connection.\n            // The data to be sent is the data stored in the buffer described\n            // by the ArrayBuffer object. Any invocation of this method with an\n            // ArrayBuffer argument that does not throw an exception must\n            // increase the bufferedAmount attribute by the length of the\n            // ArrayBuffer in bytes.\n            const value = Buffer.from(data);\n            const frame = new WebsocketFrameSend(value);\n            const buffer = frame.createFrame(opcodes.BINARY);\n            this.#bufferedAmount += value.byteLength;\n            socket.write(buffer, ()=>{\n                this.#bufferedAmount -= value.byteLength;\n            });\n        } else if (ArrayBuffer.isView(data)) {\n            // If the WebSocket connection is established, and the WebSocket\n            // closing handshake has not yet started, then the user agent must\n            // send a WebSocket Message comprised of data using a binary frame\n            // opcode; if the data cannot be sent, e.g. because it would need to\n            // be buffered but the buffer is full, the user agent must flag the\n            // WebSocket as full and then close the WebSocket connection. The\n            // data to be sent is the data stored in the section of the buffer\n            // described by the ArrayBuffer object that data references. Any\n            // invocation of this method with this kind of argument that does\n            // not throw an exception must increase the bufferedAmount attribute\n            // by the length of datas buffer in bytes.\n            const ab = Buffer.from(data, data.byteOffset, data.byteLength);\n            const frame = new WebsocketFrameSend(ab);\n            const buffer = frame.createFrame(opcodes.BINARY);\n            this.#bufferedAmount += ab.byteLength;\n            socket.write(buffer, ()=>{\n                this.#bufferedAmount -= ab.byteLength;\n            });\n        } else if (isBlobLike(data)) {\n            // If the WebSocket connection is established, and the WebSocket\n            // closing handshake has not yet started, then the user agent must\n            // send a WebSocket Message comprised of data using a binary frame\n            // opcode; if the data cannot be sent, e.g. because it would need to\n            // be buffered but the buffer is full, the user agent must flag the\n            // WebSocket as full and then close the WebSocket connection. The data\n            // to be sent is the raw data represented by the Blob object. Any\n            // invocation of this method with a Blob argument that does not throw\n            // an exception must increase the bufferedAmount attribute by the size\n            // of the Blob objects raw data, in bytes.\n            const frame = new WebsocketFrameSend();\n            data.arrayBuffer().then((ab)=>{\n                const value = Buffer.from(ab);\n                frame.frameData = value;\n                const buffer = frame.createFrame(opcodes.BINARY);\n                this.#bufferedAmount += value.byteLength;\n                socket.write(buffer, ()=>{\n                    this.#bufferedAmount -= value.byteLength;\n                });\n            });\n        }\n    }\n    get readyState() {\n        webidl.brandCheck(this, WebSocket);\n        // The readyState getter steps are to return this's ready state.\n        return this[kReadyState];\n    }\n    get bufferedAmount() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#bufferedAmount;\n    }\n    get url() {\n        webidl.brandCheck(this, WebSocket);\n        // The url getter steps are to return this's url, serialized.\n        return URLSerializer(this[kWebSocketURL]);\n    }\n    get extensions() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#extensions;\n    }\n    get protocol() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#protocol;\n    }\n    get onopen() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#events.open;\n    }\n    set onopen(fn) {\n        webidl.brandCheck(this, WebSocket);\n        if (this.#events.open) {\n            this.removeEventListener(\"open\", this.#events.open);\n        }\n        if (typeof fn === \"function\") {\n            this.#events.open = fn;\n            this.addEventListener(\"open\", fn);\n        } else {\n            this.#events.open = null;\n        }\n    }\n    get onerror() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#events.error;\n    }\n    set onerror(fn) {\n        webidl.brandCheck(this, WebSocket);\n        if (this.#events.error) {\n            this.removeEventListener(\"error\", this.#events.error);\n        }\n        if (typeof fn === \"function\") {\n            this.#events.error = fn;\n            this.addEventListener(\"error\", fn);\n        } else {\n            this.#events.error = null;\n        }\n    }\n    get onclose() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#events.close;\n    }\n    set onclose(fn) {\n        webidl.brandCheck(this, WebSocket);\n        if (this.#events.close) {\n            this.removeEventListener(\"close\", this.#events.close);\n        }\n        if (typeof fn === \"function\") {\n            this.#events.close = fn;\n            this.addEventListener(\"close\", fn);\n        } else {\n            this.#events.close = null;\n        }\n    }\n    get onmessage() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#events.message;\n    }\n    set onmessage(fn) {\n        webidl.brandCheck(this, WebSocket);\n        if (this.#events.message) {\n            this.removeEventListener(\"message\", this.#events.message);\n        }\n        if (typeof fn === \"function\") {\n            this.#events.message = fn;\n            this.addEventListener(\"message\", fn);\n        } else {\n            this.#events.message = null;\n        }\n    }\n    get binaryType() {\n        webidl.brandCheck(this, WebSocket);\n        return this[kBinaryType];\n    }\n    set binaryType(type) {\n        webidl.brandCheck(this, WebSocket);\n        if (type !== \"blob\" && type !== \"arraybuffer\") {\n            this[kBinaryType] = \"blob\";\n        } else {\n            this[kBinaryType] = type;\n        }\n    }\n    /**\n   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n   */ #onConnectionEstablished(response) {\n        // processResponse is called when the \"responses header list has been received and initialized.\"\n        // once this happens, the connection is open\n        this[kResponse] = response;\n        const parser = new ByteParser(this);\n        parser.on(\"drain\", function onParserDrain() {\n            this.ws[kResponse].socket.resume();\n        });\n        response.socket.ws = this;\n        this[kByteParser] = parser;\n        // 1. Change the ready state to OPEN (1).\n        this[kReadyState] = states.OPEN;\n        // 2. Change the extensions attributes value to the extensions in use, if\n        //    it is not the null value.\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\n        const extensions = response.headersList.get(\"sec-websocket-extensions\");\n        if (extensions !== null) {\n            this.#extensions = extensions;\n        }\n        // 3. Change the protocol attributes value to the subprotocol in use, if\n        //    it is not the null value.\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9\n        const protocol = response.headersList.get(\"sec-websocket-protocol\");\n        if (protocol !== null) {\n            this.#protocol = protocol;\n        }\n        // 4. Fire an event named open at the WebSocket object.\n        fireEvent(\"open\", this);\n    }\n}\n// https://websockets.spec.whatwg.org/#dom-websocket-connecting\nWebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;\n// https://websockets.spec.whatwg.org/#dom-websocket-open\nWebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;\n// https://websockets.spec.whatwg.org/#dom-websocket-closing\nWebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;\n// https://websockets.spec.whatwg.org/#dom-websocket-closed\nWebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;\nObject.defineProperties(WebSocket.prototype, {\n    CONNECTING: staticPropertyDescriptors,\n    OPEN: staticPropertyDescriptors,\n    CLOSING: staticPropertyDescriptors,\n    CLOSED: staticPropertyDescriptors,\n    url: kEnumerableProperty,\n    readyState: kEnumerableProperty,\n    bufferedAmount: kEnumerableProperty,\n    onopen: kEnumerableProperty,\n    onerror: kEnumerableProperty,\n    onclose: kEnumerableProperty,\n    close: kEnumerableProperty,\n    onmessage: kEnumerableProperty,\n    binaryType: kEnumerableProperty,\n    send: kEnumerableProperty,\n    extensions: kEnumerableProperty,\n    protocol: kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: \"WebSocket\",\n        writable: false,\n        enumerable: false,\n        configurable: true\n    }\n});\nObject.defineProperties(WebSocket, {\n    CONNECTING: staticPropertyDescriptors,\n    OPEN: staticPropertyDescriptors,\n    CLOSING: staticPropertyDescriptors,\n    CLOSED: staticPropertyDescriptors\n});\nwebidl.converters[\"sequence<DOMString>\"] = webidl.sequenceConverter(webidl.converters.DOMString);\nwebidl.converters[\"DOMString or sequence<DOMString>\"] = function(V) {\n    if (webidl.util.Type(V) === \"Object\" && Symbol.iterator in V) {\n        return webidl.converters[\"sequence<DOMString>\"](V);\n    }\n    return webidl.converters.DOMString(V);\n};\n// This implements the propsal made in https://github.com/whatwg/websockets/issues/42\nwebidl.converters.WebSocketInit = webidl.dictionaryConverter([\n    {\n        key: \"protocols\",\n        converter: webidl.converters[\"DOMString or sequence<DOMString>\"],\n        get defaultValue () {\n            return [];\n        }\n    },\n    {\n        key: \"dispatcher\",\n        converter: (V)=>V,\n        get defaultValue () {\n            return getGlobalDispatcher();\n        }\n    },\n    {\n        key: \"headers\",\n        converter: webidl.nullableConverter(webidl.converters.HeadersInit)\n    }\n]);\nwebidl.converters[\"DOMString or sequence<DOMString> or WebSocketInit\"] = function(V) {\n    if (webidl.util.Type(V) === \"Object\" && !(Symbol.iterator in V)) {\n        return webidl.converters.WebSocketInit(V);\n    }\n    return {\n        protocols: webidl.converters[\"DOMString or sequence<DOMString>\"](V)\n    };\n};\nwebidl.converters.WebSocketSendData = function(V) {\n    if (webidl.util.Type(V) === \"Object\") {\n        if (isBlobLike(V)) {\n            return webidl.converters.Blob(V, {\n                strict: false\n            });\n        }\n        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {\n            return webidl.converters.BufferSource(V);\n        }\n    }\n    return webidl.converters.USVString(V);\n};\nmodule.exports = {\n    WebSocket\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L3dlYnNvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsTUFBTSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRUMsWUFBWSxFQUFFLEdBQUdELG1CQUFPQSxDQUFDO0FBQ2pDLE1BQU0sRUFBRUUsYUFBYSxFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU0sRUFBRUcsZUFBZSxFQUFFLEdBQUdILG1CQUFPQSxDQUFDO0FBQ3BDLE1BQU0sRUFBRUkseUJBQXlCLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxXQUFXLEVBQUUsR0FBR1AsbUJBQU9BLENBQUM7QUFDNUUsTUFBTSxFQUNKUSxhQUFhLEVBQ2JDLFdBQVcsRUFDWEMsV0FBVyxFQUNYQyxXQUFXLEVBQ1hDLFNBQVMsRUFDVEMsVUFBVSxFQUNWQyxXQUFXLEVBQ1osR0FBR2QsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQUVlLGFBQWEsRUFBRUMsU0FBUyxFQUFFQyxrQkFBa0IsRUFBRUMsdUJBQXVCLEVBQUVDLFNBQVMsRUFBRSxHQUFHbkIsbUJBQU9BLENBQUM7QUFDckcsTUFBTSxFQUFFb0IsNEJBQTRCLEVBQUUsR0FBR3BCLG1CQUFPQSxDQUFDO0FBQ2pELE1BQU0sRUFBRXFCLGtCQUFrQixFQUFFLEdBQUdyQixtQkFBT0EsQ0FBQztBQUN2QyxNQUFNLEVBQUVzQixVQUFVLEVBQUUsR0FBR3RCLG1CQUFPQSxDQUFDO0FBQy9CLE1BQU0sRUFBRXVCLG1CQUFtQixFQUFFQyxVQUFVLEVBQUUsR0FBR3hCLG1CQUFPQSxDQUFDO0FBQ3BELE1BQU0sRUFBRXlCLG1CQUFtQixFQUFFLEdBQUd6QixtQkFBT0EsQ0FBQztBQUN4QyxNQUFNLEVBQUUwQixLQUFLLEVBQUUsR0FBRzFCLG1CQUFPQSxDQUFDO0FBRTFCLElBQUkyQixxQkFBcUI7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QUMsb0RBQW9ELEdBQUcsU0FBVWdGLENBQUM7SUFDbEYsSUFBSWpJLE9BQU9rSSxJQUFJLENBQUNDLElBQUksQ0FBQ0YsT0FBTyxZQUFZLENBQUVQLENBQUFBLE9BQU9VLFFBQVEsSUFBSUgsQ0FBQUEsR0FBSTtRQUMvRCxPQUFPakksT0FBT2lELFVBQVUsQ0FBQ29GLGFBQWEsQ0FBQ0o7SUFDekM7SUFFQSxPQUFPO1FBQUU1RixXQUFXckMsT0FBT2lELFVBQVUsQ0FBQyxtQ0FBbUMsQ0FBQ2dGO0lBQUc7QUFDL0U7QUFFQWpJLE9BQU9pRCxVQUFVLENBQUN1QyxpQkFBaUIsR0FBRyxTQUFVeUMsQ0FBQztJQUMvQyxJQUFJakksT0FBT2tJLElBQUksQ0FBQ0MsSUFBSSxDQUFDRixPQUFPLFVBQVU7UUFDcEMsSUFBSXhHLFdBQVd3RyxJQUFJO1lBQ2pCLE9BQU9qSSxPQUFPaUQsVUFBVSxDQUFDMkYsSUFBSSxDQUFDWCxHQUFHO2dCQUFFWSxRQUFRO1lBQU07UUFDbkQ7UUFFQSxJQUFJOUMsWUFBWUMsTUFBTSxDQUFDaUMsTUFBTXRHLE1BQU1tSCxnQkFBZ0IsQ0FBQ2IsSUFBSTtZQUN0RCxPQUFPakksT0FBT2lELFVBQVUsQ0FBQzhGLFlBQVksQ0FBQ2Q7UUFDeEM7SUFDRjtJQUVBLE9BQU9qSSxPQUFPaUQsVUFBVSxDQUFDQyxTQUFTLENBQUMrRTtBQUNyQztBQUVBZSxPQUFPQyxPQUFPLEdBQUc7SUFDZnBIO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvd2Vic29ja2V0LmpzPzRjZGIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi9mZXRjaC93ZWJpZGwnKVxuY29uc3QgeyBET01FeGNlcHRpb24gfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2NvbnN0YW50cycpXG5jb25zdCB7IFVSTFNlcmlhbGl6ZXIgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2RhdGFVUkwnKVxuY29uc3QgeyBnZXRHbG9iYWxPcmlnaW4gfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2dsb2JhbCcpXG5jb25zdCB7IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsIHN0YXRlcywgb3Bjb2RlcywgZW1wdHlCdWZmZXIgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHtcbiAga1dlYlNvY2tldFVSTCxcbiAga1JlYWR5U3RhdGUsXG4gIGtDb250cm9sbGVyLFxuICBrQmluYXJ5VHlwZSxcbiAga1Jlc3BvbnNlLFxuICBrU2VudENsb3NlLFxuICBrQnl0ZVBhcnNlclxufSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IGlzRXN0YWJsaXNoZWQsIGlzQ2xvc2luZywgaXNWYWxpZFN1YnByb3RvY29sLCBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbiwgZmlyZUV2ZW50IH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBlc3RhYmxpc2hXZWJTb2NrZXRDb25uZWN0aW9uIH0gPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24nKVxuY29uc3QgeyBXZWJzb2NrZXRGcmFtZVNlbmQgfSA9IHJlcXVpcmUoJy4vZnJhbWUnKVxuY29uc3QgeyBCeXRlUGFyc2VyIH0gPSByZXF1aXJlKCcuL3JlY2VpdmVyJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSwgaXNCbG9iTGlrZSB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgZ2V0R2xvYmFsRGlzcGF0Y2hlciB9ID0gcmVxdWlyZSgnLi4vZ2xvYmFsJylcbmNvbnN0IHsgdHlwZXMgfSA9IHJlcXVpcmUoJ3V0aWwnKVxuXG5sZXQgZXhwZXJpbWVudGFsV2FybmVkID0gZmFsc2VcblxuLy8gaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jaW50ZXJmYWNlLWRlZmluaXRpb25cbmNsYXNzIFdlYlNvY2tldCBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgI2V2ZW50cyA9IHtcbiAgICBvcGVuOiBudWxsLFxuICAgIGVycm9yOiBudWxsLFxuICAgIGNsb3NlOiBudWxsLFxuICAgIG1lc3NhZ2U6IG51bGxcbiAgfVxuXG4gICNidWZmZXJlZEFtb3VudCA9IDBcbiAgI3Byb3RvY29sID0gJydcbiAgI2V4dGVuc2lvbnMgPSAnJ1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwcm90b2NvbHNcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1cmwsIHByb3RvY29scyA9IFtdKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ1dlYlNvY2tldCBjb25zdHJ1Y3RvcicgfSlcblxuICAgIGlmICghZXhwZXJpbWVudGFsV2FybmVkKSB7XG4gICAgICBleHBlcmltZW50YWxXYXJuZWQgPSB0cnVlXG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKCdXZWJTb2NrZXRzIGFyZSBleHBlcmltZW50YWwsIGV4cGVjdCB0aGVtIHRvIGNoYW5nZSBhdCBhbnkgdGltZS4nLCB7XG4gICAgICAgIGNvZGU6ICdVTkRJQ0ktV1MnXG4gICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVyc1snRE9NU3RyaW5nIG9yIHNlcXVlbmNlPERPTVN0cmluZz4gb3IgV2ViU29ja2V0SW5pdCddKHByb3RvY29scylcblxuICAgIHVybCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyh1cmwpXG4gICAgcHJvdG9jb2xzID0gb3B0aW9ucy5wcm90b2NvbHNcblxuICAgIC8vIDEuIExldCBiYXNlVVJMIGJlIHRoaXMncyByZWxldmFudCBzZXR0aW5ncyBvYmplY3QncyBBUEkgYmFzZSBVUkwuXG4gICAgY29uc3QgYmFzZVVSTCA9IGdldEdsb2JhbE9yaWdpbigpXG5cbiAgICAvLyAxLiBMZXQgdXJsUmVjb3JkIGJlIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIFVSTCBwYXJzZXIgdG8gdXJsIHdpdGggYmFzZVVSTC5cbiAgICBsZXQgdXJsUmVjb3JkXG5cbiAgICB0cnkge1xuICAgICAgdXJsUmVjb3JkID0gbmV3IFVSTCh1cmwsIGJhc2VVUkwpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gMy4gSWYgdXJsUmVjb3JkIGlzIGZhaWx1cmUsIHRoZW4gdGhyb3cgYSBcIlN5bnRheEVycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihlLCAnU3ludGF4RXJyb3InKVxuICAgIH1cblxuICAgIC8vIDQuIElmIHVybFJlY29yZOKAmXMgc2NoZW1lIGlzIFwiaHR0cFwiLCB0aGVuIHNldCB1cmxSZWNvcmTigJlzIHNjaGVtZSB0byBcIndzXCIuXG4gICAgaWYgKHVybFJlY29yZC5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuICAgICAgdXJsUmVjb3JkLnByb3RvY29sID0gJ3dzOidcbiAgICB9IGVsc2UgaWYgKHVybFJlY29yZC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICAgIC8vIDUuIE90aGVyd2lzZSwgaWYgdXJsUmVjb3Jk4oCZcyBzY2hlbWUgaXMgXCJodHRwc1wiLCBzZXQgdXJsUmVjb3Jk4oCZcyBzY2hlbWUgdG8gXCJ3c3NcIi5cbiAgICAgIHVybFJlY29yZC5wcm90b2NvbCA9ICd3c3M6J1xuICAgIH1cblxuICAgIC8vIDYuIElmIHVybFJlY29yZOKAmXMgc2NoZW1lIGlzIG5vdCBcIndzXCIgb3IgXCJ3c3NcIiwgdGhlbiB0aHJvdyBhIFwiU3ludGF4RXJyb3JcIiBET01FeGNlcHRpb24uXG4gICAgaWYgKHVybFJlY29yZC5wcm90b2NvbCAhPT0gJ3dzOicgJiYgdXJsUmVjb3JkLnByb3RvY29sICE9PSAnd3NzOicpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXG4gICAgICAgIGBFeHBlY3RlZCBhIHdzOiBvciB3c3M6IHByb3RvY29sLCBnb3QgJHt1cmxSZWNvcmQucHJvdG9jb2x9YCxcbiAgICAgICAgJ1N5bnRheEVycm9yJ1xuICAgICAgKVxuICAgIH1cblxuICAgIC8vIDcuIElmIHVybFJlY29yZOKAmXMgZnJhZ21lbnQgaXMgbm9uLW51bGwsIHRoZW4gdGhyb3cgYSBcIlN5bnRheEVycm9yXCJcbiAgICAvLyAgICBET01FeGNlcHRpb24uXG4gICAgaWYgKHVybFJlY29yZC5oYXNoIHx8IHVybFJlY29yZC5ocmVmLmVuZHNXaXRoKCcjJykpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0dvdCBmcmFnbWVudCcsICdTeW50YXhFcnJvcicpXG4gICAgfVxuXG4gICAgLy8gOC4gSWYgcHJvdG9jb2xzIGlzIGEgc3RyaW5nLCBzZXQgcHJvdG9jb2xzIHRvIGEgc2VxdWVuY2UgY29uc2lzdGluZ1xuICAgIC8vICAgIG9mIGp1c3QgdGhhdCBzdHJpbmcuXG4gICAgaWYgKHR5cGVvZiBwcm90b2NvbHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwcm90b2NvbHMgPSBbcHJvdG9jb2xzXVxuICAgIH1cblxuICAgIC8vIDkuIElmIGFueSBvZiB0aGUgdmFsdWVzIGluIHByb3RvY29scyBvY2N1ciBtb3JlIHRoYW4gb25jZSBvciBvdGhlcndpc2VcbiAgICAvLyAgICBmYWlsIHRvIG1hdGNoIHRoZSByZXF1aXJlbWVudHMgZm9yIGVsZW1lbnRzIHRoYXQgY29tcHJpc2UgdGhlIHZhbHVlXG4gICAgLy8gICAgb2YgYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2xgIGZpZWxkcyBhcyBkZWZpbmVkIGJ5IFRoZSBXZWJTb2NrZXRcbiAgICAvLyAgICBwcm90b2NvbCwgdGhlbiB0aHJvdyBhIFwiU3ludGF4RXJyb3JcIiBET01FeGNlcHRpb24uXG4gICAgaWYgKHByb3RvY29scy5sZW5ndGggIT09IG5ldyBTZXQocHJvdG9jb2xzLm1hcChwID0+IHAudG9Mb3dlckNhc2UoKSkpLnNpemUpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1Qcm90b2NvbCB2YWx1ZScsICdTeW50YXhFcnJvcicpXG4gICAgfVxuXG4gICAgaWYgKHByb3RvY29scy5sZW5ndGggPiAwICYmICFwcm90b2NvbHMuZXZlcnkocCA9PiBpc1ZhbGlkU3VicHJvdG9jb2wocCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtUHJvdG9jb2wgdmFsdWUnLCAnU3ludGF4RXJyb3InKVxuICAgIH1cblxuICAgIC8vIDEwLiBTZXQgdGhpcydzIHVybCB0byB1cmxSZWNvcmQuXG4gICAgdGhpc1trV2ViU29ja2V0VVJMXSA9IG5ldyBVUkwodXJsUmVjb3JkLmhyZWYpXG5cbiAgICAvLyAxMS4gTGV0IGNsaWVudCBiZSB0aGlzJ3MgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN0LlxuXG4gICAgLy8gMTIuIFJ1biB0aGlzIHN0ZXAgaW4gcGFyYWxsZWw6XG5cbiAgICAvLyAgICAxLiBFc3RhYmxpc2ggYSBXZWJTb2NrZXQgY29ubmVjdGlvbiBnaXZlbiB1cmxSZWNvcmQsIHByb3RvY29scyxcbiAgICAvLyAgICAgICBhbmQgY2xpZW50LlxuICAgIHRoaXNba0NvbnRyb2xsZXJdID0gZXN0YWJsaXNoV2ViU29ja2V0Q29ubmVjdGlvbihcbiAgICAgIHVybFJlY29yZCxcbiAgICAgIHByb3RvY29scyxcbiAgICAgIHRoaXMsXG4gICAgICAocmVzcG9uc2UpID0+IHRoaXMuI29uQ29ubmVjdGlvbkVzdGFibGlzaGVkKHJlc3BvbnNlKSxcbiAgICAgIG9wdGlvbnNcbiAgICApXG5cbiAgICAvLyBFYWNoIFdlYlNvY2tldCBvYmplY3QgaGFzIGFuIGFzc29jaWF0ZWQgcmVhZHkgc3RhdGUsIHdoaWNoIGlzIGFcbiAgICAvLyBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGUgY29ubmVjdGlvbi4gSW5pdGlhbGx5IGl0IG11c3RcbiAgICAvLyBiZSBDT05ORUNUSU5HICgwKS5cbiAgICB0aGlzW2tSZWFkeVN0YXRlXSA9IFdlYlNvY2tldC5DT05ORUNUSU5HXG5cbiAgICAvLyBUaGUgZXh0ZW5zaW9ucyBhdHRyaWJ1dGUgbXVzdCBpbml0aWFsbHkgcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcuXG5cbiAgICAvLyBUaGUgcHJvdG9jb2wgYXR0cmlidXRlIG11c3QgaW5pdGlhbGx5IHJldHVybiB0aGUgZW1wdHkgc3RyaW5nLlxuXG4gICAgLy8gRWFjaCBXZWJTb2NrZXQgb2JqZWN0IGhhcyBhbiBhc3NvY2lhdGVkIGJpbmFyeSB0eXBlLCB3aGljaCBpcyBhXG4gICAgLy8gQmluYXJ5VHlwZS4gSW5pdGlhbGx5IGl0IG11c3QgYmUgXCJibG9iXCIuXG4gICAgdGhpc1trQmluYXJ5VHlwZV0gPSAnYmxvYidcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2RvbS13ZWJzb2NrZXQtY2xvc2VcbiAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gcmVhc29uXG4gICAqL1xuICBjbG9zZSAoY29kZSA9IHVuZGVmaW5lZCwgcmVhc29uID0gdW5kZWZpbmVkKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgaWYgKGNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29kZSA9IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBzaG9ydCddKGNvZGUsIHsgY2xhbXA6IHRydWUgfSlcbiAgICB9XG5cbiAgICBpZiAocmVhc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlYXNvbiA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhyZWFzb24pXG4gICAgfVxuXG4gICAgLy8gMS4gSWYgY29kZSBpcyBwcmVzZW50LCBidXQgaXMgbmVpdGhlciBhbiBpbnRlZ2VyIGVxdWFsIHRvIDEwMDAgbm9yIGFuXG4gICAgLy8gICAgaW50ZWdlciBpbiB0aGUgcmFuZ2UgMzAwMCB0byA0OTk5LCBpbmNsdXNpdmUsIHRocm93IGFuXG4gICAgLy8gICAgXCJJbnZhbGlkQWNjZXNzRXJyb3JcIiBET01FeGNlcHRpb24uXG4gICAgaWYgKGNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvZGUgIT09IDEwMDAgJiYgKGNvZGUgPCAzMDAwIHx8IGNvZGUgPiA0OTk5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdpbnZhbGlkIGNvZGUnLCAnSW52YWxpZEFjY2Vzc0Vycm9yJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcmVhc29uQnl0ZUxlbmd0aCA9IDBcblxuICAgIC8vIDIuIElmIHJlYXNvbiBpcyBwcmVzZW50LCB0aGVuIHJ1biB0aGVzZSBzdWJzdGVwczpcbiAgICBpZiAocmVhc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIDEuIExldCByZWFzb25CeXRlcyBiZSB0aGUgcmVzdWx0IG9mIGVuY29kaW5nIHJlYXNvbi5cbiAgICAgIC8vIDIuIElmIHJlYXNvbkJ5dGVzIGlzIGxvbmdlciB0aGFuIDEyMyBieXRlcywgdGhlbiB0aHJvdyBhXG4gICAgICAvLyAgICBcIlN5bnRheEVycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgICAgcmVhc29uQnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHJlYXNvbilcblxuICAgICAgaWYgKHJlYXNvbkJ5dGVMZW5ndGggPiAxMjMpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcbiAgICAgICAgICBgUmVhc29uIG11c3QgYmUgbGVzcyB0aGFuIDEyMyBieXRlczsgcmVjZWl2ZWQgJHtyZWFzb25CeXRlTGVuZ3RofWAsXG4gICAgICAgICAgJ1N5bnRheEVycm9yJ1xuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMy4gUnVuIHRoZSBmaXJzdCBtYXRjaGluZyBzdGVwcyBmcm9tIHRoZSBmb2xsb3dpbmcgbGlzdDpcbiAgICBpZiAodGhpc1trUmVhZHlTdGF0ZV0gPT09IFdlYlNvY2tldC5DTE9TSU5HIHx8IHRoaXNba1JlYWR5U3RhdGVdID09PSBXZWJTb2NrZXQuQ0xPU0VEKSB7XG4gICAgICAvLyBJZiB0aGlzJ3MgcmVhZHkgc3RhdGUgaXMgQ0xPU0lORyAoMikgb3IgQ0xPU0VEICgzKVxuICAgICAgLy8gRG8gbm90aGluZy5cbiAgICB9IGVsc2UgaWYgKCFpc0VzdGFibGlzaGVkKHRoaXMpKSB7XG4gICAgICAvLyBJZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgbm90IHlldCBlc3RhYmxpc2hlZFxuICAgICAgLy8gRmFpbCB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gYW5kIHNldCB0aGlzJ3MgcmVhZHkgc3RhdGVcbiAgICAgIC8vIHRvIENMT1NJTkcgKDIpLlxuICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcywgJ0Nvbm5lY3Rpb24gd2FzIGNsb3NlZCBiZWZvcmUgaXQgd2FzIGVzdGFibGlzaGVkLicpXG4gICAgICB0aGlzW2tSZWFkeVN0YXRlXSA9IFdlYlNvY2tldC5DTE9TSU5HXG4gICAgfSBlbHNlIGlmICghaXNDbG9zaW5nKHRoaXMpKSB7XG4gICAgICAvLyBJZiB0aGUgV2ViU29ja2V0IGNsb3NpbmcgaGFuZHNoYWtlIGhhcyBub3QgeWV0IGJlZW4gc3RhcnRlZFxuICAgICAgLy8gU3RhcnQgdGhlIFdlYlNvY2tldCBjbG9zaW5nIGhhbmRzaGFrZSBhbmQgc2V0IHRoaXMncyByZWFkeVxuICAgICAgLy8gc3RhdGUgdG8gQ0xPU0lORyAoMikuXG4gICAgICAvLyAtIElmIG5laXRoZXIgY29kZSBub3IgcmVhc29uIGlzIHByZXNlbnQsIHRoZSBXZWJTb2NrZXQgQ2xvc2VcbiAgICAgIC8vICAgbWVzc2FnZSBtdXN0IG5vdCBoYXZlIGEgYm9keS5cbiAgICAgIC8vIC0gSWYgY29kZSBpcyBwcmVzZW50LCB0aGVuIHRoZSBzdGF0dXMgY29kZSB0byB1c2UgaW4gdGhlXG4gICAgICAvLyAgIFdlYlNvY2tldCBDbG9zZSBtZXNzYWdlIG11c3QgYmUgdGhlIGludGVnZXIgZ2l2ZW4gYnkgY29kZS5cbiAgICAgIC8vIC0gSWYgcmVhc29uIGlzIGFsc28gcHJlc2VudCwgdGhlbiByZWFzb25CeXRlcyBtdXN0IGJlXG4gICAgICAvLyAgIHByb3ZpZGVkIGluIHRoZSBDbG9zZSBtZXNzYWdlIGFmdGVyIHRoZSBzdGF0dXMgY29kZS5cblxuICAgICAgY29uc3QgZnJhbWUgPSBuZXcgV2Vic29ja2V0RnJhbWVTZW5kKClcblxuICAgICAgLy8gSWYgbmVpdGhlciBjb2RlIG5vciByZWFzb24gaXMgcHJlc2VudCwgdGhlIFdlYlNvY2tldCBDbG9zZVxuICAgICAgLy8gbWVzc2FnZSBtdXN0IG5vdCBoYXZlIGEgYm9keS5cblxuICAgICAgLy8gSWYgY29kZSBpcyBwcmVzZW50LCB0aGVuIHRoZSBzdGF0dXMgY29kZSB0byB1c2UgaW4gdGhlXG4gICAgICAvLyBXZWJTb2NrZXQgQ2xvc2UgbWVzc2FnZSBtdXN0IGJlIHRoZSBpbnRlZ2VyIGdpdmVuIGJ5IGNvZGUuXG4gICAgICBpZiAoY29kZSAhPT0gdW5kZWZpbmVkICYmIHJlYXNvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZyYW1lLmZyYW1lRGF0YSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyKVxuICAgICAgICBmcmFtZS5mcmFtZURhdGEud3JpdGVVSW50MTZCRShjb2RlLCAwKVxuICAgICAgfSBlbHNlIGlmIChjb2RlICE9PSB1bmRlZmluZWQgJiYgcmVhc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gSWYgcmVhc29uIGlzIGFsc28gcHJlc2VudCwgdGhlbiByZWFzb25CeXRlcyBtdXN0IGJlXG4gICAgICAgIC8vIHByb3ZpZGVkIGluIHRoZSBDbG9zZSBtZXNzYWdlIGFmdGVyIHRoZSBzdGF0dXMgY29kZS5cbiAgICAgICAgZnJhbWUuZnJhbWVEYXRhID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIgKyByZWFzb25CeXRlTGVuZ3RoKVxuICAgICAgICBmcmFtZS5mcmFtZURhdGEud3JpdGVVSW50MTZCRShjb2RlLCAwKVxuICAgICAgICAvLyB0aGUgYm9keSBNQVkgY29udGFpbiBVVEYtOC1lbmNvZGVkIGRhdGEgd2l0aCB2YWx1ZSAvcmVhc29uL1xuICAgICAgICBmcmFtZS5mcmFtZURhdGEud3JpdGUocmVhc29uLCAyLCAndXRmLTgnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhbWUuZnJhbWVEYXRhID0gZW1wdHlCdWZmZXJcbiAgICAgIH1cblxuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoJ3N0cmVhbScpLkR1cGxleH0gKi9cbiAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXNba1Jlc3BvbnNlXS5zb2NrZXRcblxuICAgICAgc29ja2V0LndyaXRlKGZyYW1lLmNyZWF0ZUZyYW1lKG9wY29kZXMuQ0xPU0UpLCAoZXJyKSA9PiB7XG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgdGhpc1trU2VudENsb3NlXSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgLy8gVXBvbiBlaXRoZXIgc2VuZGluZyBvciByZWNlaXZpbmcgYSBDbG9zZSBjb250cm9sIGZyYW1lLCBpdCBpcyBzYWlkXG4gICAgICAvLyB0aGF0IF9UaGUgV2ViU29ja2V0IENsb3NpbmcgSGFuZHNoYWtlIGlzIFN0YXJ0ZWRfIGFuZCB0aGF0IHRoZVxuICAgICAgLy8gV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgaW4gdGhlIENMT1NJTkcgc3RhdGUuXG4gICAgICB0aGlzW2tSZWFkeVN0YXRlXSA9IHN0YXRlcy5DTE9TSU5HXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZVxuICAgICAgLy8gU2V0IHRoaXMncyByZWFkeSBzdGF0ZSB0byBDTE9TSU5HICgyKS5cbiAgICAgIHRoaXNba1JlYWR5U3RhdGVdID0gV2ViU29ja2V0LkNMT1NJTkdcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNkb20td2Vic29ja2V0LXNlbmRcbiAgICogQHBhcmFtIHtOb2RlSlMuVHlwZWRBcnJheXxBcnJheUJ1ZmZlcnxCbG9ifHN0cmluZ30gZGF0YVxuICAgKi9cbiAgc2VuZCAoZGF0YSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdXZWJTb2NrZXQuc2VuZCcgfSlcblxuICAgIGRhdGEgPSB3ZWJpZGwuY29udmVydGVycy5XZWJTb2NrZXRTZW5kRGF0YShkYXRhKVxuXG4gICAgLy8gMS4gSWYgdGhpcydzIHJlYWR5IHN0YXRlIGlzIENPTk5FQ1RJTkcsIHRoZW4gdGhyb3cgYW5cbiAgICAvLyAgICBcIkludmFsaWRTdGF0ZUVycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgIGlmICh0aGlzW2tSZWFkeVN0YXRlXSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1NlbnQgYmVmb3JlIGNvbm5lY3RlZC4nLCAnSW52YWxpZFN0YXRlRXJyb3InKVxuICAgIH1cblxuICAgIC8vIDIuIFJ1biB0aGUgYXBwcm9wcmlhdGUgc2V0IG9mIHN0ZXBzIGZyb20gdGhlIGZvbGxvd2luZyBsaXN0OlxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTYuMVxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTUuMlxuXG4gICAgaWYgKCFpc0VzdGFibGlzaGVkKHRoaXMpIHx8IGlzQ2xvc2luZyh0aGlzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJ3N0cmVhbScpLkR1cGxleH0gKi9cbiAgICBjb25zdCBzb2NrZXQgPSB0aGlzW2tSZXNwb25zZV0uc29ja2V0XG5cbiAgICAvLyBJZiBkYXRhIGlzIGEgc3RyaW5nXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkIGFuZCB0aGUgV2ViU29ja2V0XG4gICAgICAvLyBjbG9zaW5nIGhhbmRzaGFrZSBoYXMgbm90IHlldCBzdGFydGVkLCB0aGVuIHRoZSB1c2VyIGFnZW50XG4gICAgICAvLyBtdXN0IHNlbmQgYSBXZWJTb2NrZXQgTWVzc2FnZSBjb21wcmlzZWQgb2YgdGhlIGRhdGEgYXJndW1lbnRcbiAgICAgIC8vIHVzaW5nIGEgdGV4dCBmcmFtZSBvcGNvZGU7IGlmIHRoZSBkYXRhIGNhbm5vdCBiZSBzZW50LCBlLmcuXG4gICAgICAvLyBiZWNhdXNlIGl0IHdvdWxkIG5lZWQgdG8gYmUgYnVmZmVyZWQgYnV0IHRoZSBidWZmZXIgaXMgZnVsbCxcbiAgICAgIC8vIHRoZSB1c2VyIGFnZW50IG11c3QgZmxhZyB0aGUgV2ViU29ja2V0IGFzIGZ1bGwgYW5kIHRoZW4gY2xvc2VcbiAgICAgIC8vIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi4gQW55IGludm9jYXRpb24gb2YgdGhpcyBtZXRob2Qgd2l0aCBhXG4gICAgICAvLyBzdHJpbmcgYXJndW1lbnQgdGhhdCBkb2VzIG5vdCB0aHJvdyBhbiBleGNlcHRpb24gbXVzdCBpbmNyZWFzZVxuICAgICAgLy8gdGhlIGJ1ZmZlcmVkQW1vdW50IGF0dHJpYnV0ZSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzIG5lZWRlZCB0b1xuICAgICAgLy8gZXhwcmVzcyB0aGUgYXJndW1lbnQgYXMgVVRGLTguXG5cbiAgICAgIGNvbnN0IHZhbHVlID0gQnVmZmVyLmZyb20oZGF0YSlcbiAgICAgIGNvbnN0IGZyYW1lID0gbmV3IFdlYnNvY2tldEZyYW1lU2VuZCh2YWx1ZSlcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGZyYW1lLmNyZWF0ZUZyYW1lKG9wY29kZXMuVEVYVClcblxuICAgICAgdGhpcy4jYnVmZmVyZWRBbW91bnQgKz0gdmFsdWUuYnl0ZUxlbmd0aFxuICAgICAgc29ja2V0LndyaXRlKGJ1ZmZlciwgKCkgPT4ge1xuICAgICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCAtPSB2YWx1ZS5ieXRlTGVuZ3RoXG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAodHlwZXMuaXNBcnJheUJ1ZmZlcihkYXRhKSkge1xuICAgICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLCBhbmQgdGhlIFdlYlNvY2tldFxuICAgICAgLy8gY2xvc2luZyBoYW5kc2hha2UgaGFzIG5vdCB5ZXQgc3RhcnRlZCwgdGhlbiB0aGUgdXNlciBhZ2VudCBtdXN0XG4gICAgICAvLyBzZW5kIGEgV2ViU29ja2V0IE1lc3NhZ2UgY29tcHJpc2VkIG9mIGRhdGEgdXNpbmcgYSBiaW5hcnkgZnJhbWVcbiAgICAgIC8vIG9wY29kZTsgaWYgdGhlIGRhdGEgY2Fubm90IGJlIHNlbnQsIGUuZy4gYmVjYXVzZSBpdCB3b3VsZCBuZWVkXG4gICAgICAvLyB0byBiZSBidWZmZXJlZCBidXQgdGhlIGJ1ZmZlciBpcyBmdWxsLCB0aGUgdXNlciBhZ2VudCBtdXN0IGZsYWdcbiAgICAgIC8vIHRoZSBXZWJTb2NrZXQgYXMgZnVsbCBhbmQgdGhlbiBjbG9zZSB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAgICAvLyBUaGUgZGF0YSB0byBiZSBzZW50IGlzIHRoZSBkYXRhIHN0b3JlZCBpbiB0aGUgYnVmZmVyIGRlc2NyaWJlZFxuICAgICAgLy8gYnkgdGhlIEFycmF5QnVmZmVyIG9iamVjdC4gQW55IGludm9jYXRpb24gb2YgdGhpcyBtZXRob2Qgd2l0aCBhblxuICAgICAgLy8gQXJyYXlCdWZmZXIgYXJndW1lbnQgdGhhdCBkb2VzIG5vdCB0aHJvdyBhbiBleGNlcHRpb24gbXVzdFxuICAgICAgLy8gaW5jcmVhc2UgdGhlIGJ1ZmZlcmVkQW1vdW50IGF0dHJpYnV0ZSBieSB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgICAgLy8gQXJyYXlCdWZmZXIgaW4gYnl0ZXMuXG5cbiAgICAgIGNvbnN0IHZhbHVlID0gQnVmZmVyLmZyb20oZGF0YSlcbiAgICAgIGNvbnN0IGZyYW1lID0gbmV3IFdlYnNvY2tldEZyYW1lU2VuZCh2YWx1ZSlcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGZyYW1lLmNyZWF0ZUZyYW1lKG9wY29kZXMuQklOQVJZKVxuXG4gICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCArPSB2YWx1ZS5ieXRlTGVuZ3RoXG4gICAgICBzb2NrZXQud3JpdGUoYnVmZmVyLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50IC09IHZhbHVlLmJ5dGVMZW5ndGhcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCwgYW5kIHRoZSBXZWJTb2NrZXRcbiAgICAgIC8vIGNsb3NpbmcgaGFuZHNoYWtlIGhhcyBub3QgeWV0IHN0YXJ0ZWQsIHRoZW4gdGhlIHVzZXIgYWdlbnQgbXVzdFxuICAgICAgLy8gc2VuZCBhIFdlYlNvY2tldCBNZXNzYWdlIGNvbXByaXNlZCBvZiBkYXRhIHVzaW5nIGEgYmluYXJ5IGZyYW1lXG4gICAgICAvLyBvcGNvZGU7IGlmIHRoZSBkYXRhIGNhbm5vdCBiZSBzZW50LCBlLmcuIGJlY2F1c2UgaXQgd291bGQgbmVlZCB0b1xuICAgICAgLy8gYmUgYnVmZmVyZWQgYnV0IHRoZSBidWZmZXIgaXMgZnVsbCwgdGhlIHVzZXIgYWdlbnQgbXVzdCBmbGFnIHRoZVxuICAgICAgLy8gV2ViU29ja2V0IGFzIGZ1bGwgYW5kIHRoZW4gY2xvc2UgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLiBUaGVcbiAgICAgIC8vIGRhdGEgdG8gYmUgc2VudCBpcyB0aGUgZGF0YSBzdG9yZWQgaW4gdGhlIHNlY3Rpb24gb2YgdGhlIGJ1ZmZlclxuICAgICAgLy8gZGVzY3JpYmVkIGJ5IHRoZSBBcnJheUJ1ZmZlciBvYmplY3QgdGhhdCBkYXRhIHJlZmVyZW5jZXMuIEFueVxuICAgICAgLy8gaW52b2NhdGlvbiBvZiB0aGlzIG1ldGhvZCB3aXRoIHRoaXMga2luZCBvZiBhcmd1bWVudCB0aGF0IGRvZXNcbiAgICAgIC8vIG5vdCB0aHJvdyBhbiBleGNlcHRpb24gbXVzdCBpbmNyZWFzZSB0aGUgYnVmZmVyZWRBbW91bnQgYXR0cmlidXRlXG4gICAgICAvLyBieSB0aGUgbGVuZ3RoIG9mIGRhdGHigJlzIGJ1ZmZlciBpbiBieXRlcy5cblxuICAgICAgY29uc3QgYWIgPSBCdWZmZXIuZnJvbShkYXRhLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aClcblxuICAgICAgY29uc3QgZnJhbWUgPSBuZXcgV2Vic29ja2V0RnJhbWVTZW5kKGFiKVxuICAgICAgY29uc3QgYnVmZmVyID0gZnJhbWUuY3JlYXRlRnJhbWUob3Bjb2Rlcy5CSU5BUlkpXG5cbiAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50ICs9IGFiLmJ5dGVMZW5ndGhcbiAgICAgIHNvY2tldC53cml0ZShidWZmZXIsICgpID0+IHtcbiAgICAgICAgdGhpcy4jYnVmZmVyZWRBbW91bnQgLT0gYWIuYnl0ZUxlbmd0aFxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKGlzQmxvYkxpa2UoZGF0YSkpIHtcbiAgICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCwgYW5kIHRoZSBXZWJTb2NrZXRcbiAgICAgIC8vIGNsb3NpbmcgaGFuZHNoYWtlIGhhcyBub3QgeWV0IHN0YXJ0ZWQsIHRoZW4gdGhlIHVzZXIgYWdlbnQgbXVzdFxuICAgICAgLy8gc2VuZCBhIFdlYlNvY2tldCBNZXNzYWdlIGNvbXByaXNlZCBvZiBkYXRhIHVzaW5nIGEgYmluYXJ5IGZyYW1lXG4gICAgICAvLyBvcGNvZGU7IGlmIHRoZSBkYXRhIGNhbm5vdCBiZSBzZW50LCBlLmcuIGJlY2F1c2UgaXQgd291bGQgbmVlZCB0b1xuICAgICAgLy8gYmUgYnVmZmVyZWQgYnV0IHRoZSBidWZmZXIgaXMgZnVsbCwgdGhlIHVzZXIgYWdlbnQgbXVzdCBmbGFnIHRoZVxuICAgICAgLy8gV2ViU29ja2V0IGFzIGZ1bGwgYW5kIHRoZW4gY2xvc2UgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLiBUaGUgZGF0YVxuICAgICAgLy8gdG8gYmUgc2VudCBpcyB0aGUgcmF3IGRhdGEgcmVwcmVzZW50ZWQgYnkgdGhlIEJsb2Igb2JqZWN0LiBBbnlcbiAgICAgIC8vIGludm9jYXRpb24gb2YgdGhpcyBtZXRob2Qgd2l0aCBhIEJsb2IgYXJndW1lbnQgdGhhdCBkb2VzIG5vdCB0aHJvd1xuICAgICAgLy8gYW4gZXhjZXB0aW9uIG11c3QgaW5jcmVhc2UgdGhlIGJ1ZmZlcmVkQW1vdW50IGF0dHJpYnV0ZSBieSB0aGUgc2l6ZVxuICAgICAgLy8gb2YgdGhlIEJsb2Igb2JqZWN04oCZcyByYXcgZGF0YSwgaW4gYnl0ZXMuXG5cbiAgICAgIGNvbnN0IGZyYW1lID0gbmV3IFdlYnNvY2tldEZyYW1lU2VuZCgpXG5cbiAgICAgIGRhdGEuYXJyYXlCdWZmZXIoKS50aGVuKChhYikgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEJ1ZmZlci5mcm9tKGFiKVxuICAgICAgICBmcmFtZS5mcmFtZURhdGEgPSB2YWx1ZVxuICAgICAgICBjb25zdCBidWZmZXIgPSBmcmFtZS5jcmVhdGVGcmFtZShvcGNvZGVzLkJJTkFSWSlcblxuICAgICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCArPSB2YWx1ZS5ieXRlTGVuZ3RoXG4gICAgICAgIHNvY2tldC53cml0ZShidWZmZXIsICgpID0+IHtcbiAgICAgICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCAtPSB2YWx1ZS5ieXRlTGVuZ3RoXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGdldCByZWFkeVN0YXRlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICAvLyBUaGUgcmVhZHlTdGF0ZSBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlzJ3MgcmVhZHkgc3RhdGUuXG4gICAgcmV0dXJuIHRoaXNba1JlYWR5U3RhdGVdXG4gIH1cblxuICBnZXQgYnVmZmVyZWRBbW91bnQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNidWZmZXJlZEFtb3VudFxuICB9XG5cbiAgZ2V0IHVybCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgLy8gVGhlIHVybCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlzJ3MgdXJsLCBzZXJpYWxpemVkLlxuICAgIHJldHVybiBVUkxTZXJpYWxpemVyKHRoaXNba1dlYlNvY2tldFVSTF0pXG4gIH1cblxuICBnZXQgZXh0ZW5zaW9ucyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V4dGVuc2lvbnNcbiAgfVxuXG4gIGdldCBwcm90b2NvbCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgcmV0dXJuIHRoaXMuI3Byb3RvY29sXG4gIH1cblxuICBnZXQgb25vcGVuICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRzLm9wZW5cbiAgfVxuXG4gIHNldCBvbm9wZW4gKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgaWYgKHRoaXMuI2V2ZW50cy5vcGVuKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29wZW4nLCB0aGlzLiNldmVudHMub3BlbilcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLiNldmVudHMub3BlbiA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZXZlbnRzLm9wZW4gPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IG9uZXJyb3IgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNldmVudHMuZXJyb3JcbiAgfVxuXG4gIHNldCBvbmVycm9yIChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIGlmICh0aGlzLiNldmVudHMuZXJyb3IpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLiNldmVudHMuZXJyb3IpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy4jZXZlbnRzLmVycm9yID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZXZlbnRzLmVycm9yID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbmNsb3NlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRzLmNsb3NlXG4gIH1cblxuICBzZXQgb25jbG9zZSAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBpZiAodGhpcy4jZXZlbnRzLmNsb3NlKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgdGhpcy4jZXZlbnRzLmNsb3NlKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5jbG9zZSA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5jbG9zZSA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25tZXNzYWdlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRzLm1lc3NhZ2VcbiAgfVxuXG4gIHNldCBvbm1lc3NhZ2UgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgaWYgKHRoaXMuI2V2ZW50cy5tZXNzYWdlKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLiNldmVudHMubWVzc2FnZSlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLiNldmVudHMubWVzc2FnZSA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZXZlbnRzLm1lc3NhZ2UgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IGJpbmFyeVR5cGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzW2tCaW5hcnlUeXBlXVxuICB9XG5cbiAgc2V0IGJpbmFyeVR5cGUgKHR5cGUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBpZiAodHlwZSAhPT0gJ2Jsb2InICYmIHR5cGUgIT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgIHRoaXNba0JpbmFyeVR5cGVdID0gJ2Jsb2InXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0JpbmFyeVR5cGVdID0gdHlwZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2ZlZWRiYWNrLWZyb20tdGhlLXByb3RvY29sXG4gICAqL1xuICAjb25Db25uZWN0aW9uRXN0YWJsaXNoZWQgKHJlc3BvbnNlKSB7XG4gICAgLy8gcHJvY2Vzc1Jlc3BvbnNlIGlzIGNhbGxlZCB3aGVuIHRoZSBcInJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdCBoYXMgYmVlbiByZWNlaXZlZCBhbmQgaW5pdGlhbGl6ZWQuXCJcbiAgICAvLyBvbmNlIHRoaXMgaGFwcGVucywgdGhlIGNvbm5lY3Rpb24gaXMgb3BlblxuICAgIHRoaXNba1Jlc3BvbnNlXSA9IHJlc3BvbnNlXG5cbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgQnl0ZVBhcnNlcih0aGlzKVxuICAgIHBhcnNlci5vbignZHJhaW4nLCBmdW5jdGlvbiBvblBhcnNlckRyYWluICgpIHtcbiAgICAgIHRoaXMud3Nba1Jlc3BvbnNlXS5zb2NrZXQucmVzdW1lKClcbiAgICB9KVxuXG4gICAgcmVzcG9uc2Uuc29ja2V0LndzID0gdGhpc1xuICAgIHRoaXNba0J5dGVQYXJzZXJdID0gcGFyc2VyXG5cbiAgICAvLyAxLiBDaGFuZ2UgdGhlIHJlYWR5IHN0YXRlIHRvIE9QRU4gKDEpLlxuICAgIHRoaXNba1JlYWR5U3RhdGVdID0gc3RhdGVzLk9QRU5cblxuICAgIC8vIDIuIENoYW5nZSB0aGUgZXh0ZW5zaW9ucyBhdHRyaWJ1dGXigJlzIHZhbHVlIHRvIHRoZSBleHRlbnNpb25zIGluIHVzZSwgaWZcbiAgICAvLyAgICBpdCBpcyBub3QgdGhlIG51bGwgdmFsdWUuXG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tOS4xXG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJylcblxuICAgIGlmIChleHRlbnNpb25zICE9PSBudWxsKSB7XG4gICAgICB0aGlzLiNleHRlbnNpb25zID0gZXh0ZW5zaW9uc1xuICAgIH1cblxuICAgIC8vIDMuIENoYW5nZSB0aGUgcHJvdG9jb2wgYXR0cmlidXRl4oCZcyB2YWx1ZSB0byB0aGUgc3VicHJvdG9jb2wgaW4gdXNlLCBpZlxuICAgIC8vICAgIGl0IGlzIG5vdCB0aGUgbnVsbCB2YWx1ZS5cbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi0xLjlcbiAgICBjb25zdCBwcm90b2NvbCA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnc2VjLXdlYnNvY2tldC1wcm90b2NvbCcpXG5cbiAgICBpZiAocHJvdG9jb2wgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuI3Byb3RvY29sID0gcHJvdG9jb2xcbiAgICB9XG5cbiAgICAvLyA0LiBGaXJlIGFuIGV2ZW50IG5hbWVkIG9wZW4gYXQgdGhlIFdlYlNvY2tldCBvYmplY3QuXG4gICAgZmlyZUV2ZW50KCdvcGVuJywgdGhpcylcbiAgfVxufVxuXG4vLyBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNkb20td2Vic29ja2V0LWNvbm5lY3RpbmdcbldlYlNvY2tldC5DT05ORUNUSU5HID0gV2ViU29ja2V0LnByb3RvdHlwZS5DT05ORUNUSU5HID0gc3RhdGVzLkNPTk5FQ1RJTkdcbi8vIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2RvbS13ZWJzb2NrZXQtb3BlblxuV2ViU29ja2V0Lk9QRU4gPSBXZWJTb2NrZXQucHJvdG90eXBlLk9QRU4gPSBzdGF0ZXMuT1BFTlxuLy8gaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZG9tLXdlYnNvY2tldC1jbG9zaW5nXG5XZWJTb2NrZXQuQ0xPU0lORyA9IFdlYlNvY2tldC5wcm90b3R5cGUuQ0xPU0lORyA9IHN0YXRlcy5DTE9TSU5HXG4vLyBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNkb20td2Vic29ja2V0LWNsb3NlZFxuV2ViU29ja2V0LkNMT1NFRCA9IFdlYlNvY2tldC5wcm90b3R5cGUuQ0xPU0VEID0gc3RhdGVzLkNMT1NFRFxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhXZWJTb2NrZXQucHJvdG90eXBlLCB7XG4gIENPTk5FQ1RJTkc6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIE9QRU46IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIENMT1NJTkc6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIENMT1NFRDogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgdXJsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWFkeVN0YXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBidWZmZXJlZEFtb3VudDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25vcGVuOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmVycm9yOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmNsb3NlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjbG9zZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25tZXNzYWdlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBiaW5hcnlUeXBlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBzZW5kOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBleHRlbnNpb25zOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBwcm90b2NvbDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ1dlYlNvY2tldCcsXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhXZWJTb2NrZXQsIHtcbiAgQ09OTkVDVElORzogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgT1BFTjogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgQ0xPU0lORzogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgQ0xPU0VEOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzXG59KVxuXG53ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8RE9NU3RyaW5nPiddID0gd2ViaWRsLnNlcXVlbmNlQ29udmVydGVyKFxuICB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmdcbilcblxud2ViaWRsLmNvbnZlcnRlcnNbJ0RPTVN0cmluZyBvciBzZXF1ZW5jZTxET01TdHJpbmc+J10gPSBmdW5jdGlvbiAoVikge1xuICBpZiAod2ViaWRsLnV0aWwuVHlwZShWKSA9PT0gJ09iamVjdCcgJiYgU3ltYm9sLml0ZXJhdG9yIGluIFYpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPERPTVN0cmluZz4nXShWKVxuICB9XG5cbiAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhWKVxufVxuXG4vLyBUaGlzIGltcGxlbWVudHMgdGhlIHByb3BzYWwgbWFkZSBpbiBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL3dlYnNvY2tldHMvaXNzdWVzLzQyXG53ZWJpZGwuY29udmVydGVycy5XZWJTb2NrZXRJbml0ID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICB7XG4gICAga2V5OiAncHJvdG9jb2xzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWydET01TdHJpbmcgb3Igc2VxdWVuY2U8RE9NU3RyaW5nPiddLFxuICAgIGdldCBkZWZhdWx0VmFsdWUgKCkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuICB9LFxuICB7XG4gICAga2V5OiAnZGlzcGF0Y2hlcicsXG4gICAgY29udmVydGVyOiAoVikgPT4gVixcbiAgICBnZXQgZGVmYXVsdFZhbHVlICgpIHtcbiAgICAgIHJldHVybiBnZXRHbG9iYWxEaXNwYXRjaGVyKClcbiAgICB9XG4gIH0sXG4gIHtcbiAgICBrZXk6ICdoZWFkZXJzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5IZWFkZXJzSW5pdClcbiAgfVxuXSlcblxud2ViaWRsLmNvbnZlcnRlcnNbJ0RPTVN0cmluZyBvciBzZXF1ZW5jZTxET01TdHJpbmc+IG9yIFdlYlNvY2tldEluaXQnXSA9IGZ1bmN0aW9uIChWKSB7XG4gIGlmICh3ZWJpZGwudXRpbC5UeXBlKFYpID09PSAnT2JqZWN0JyAmJiAhKFN5bWJvbC5pdGVyYXRvciBpbiBWKSkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5XZWJTb2NrZXRJbml0KFYpXG4gIH1cblxuICByZXR1cm4geyBwcm90b2NvbHM6IHdlYmlkbC5jb252ZXJ0ZXJzWydET01TdHJpbmcgb3Igc2VxdWVuY2U8RE9NU3RyaW5nPiddKFYpIH1cbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuV2ViU29ja2V0U2VuZERhdGEgPSBmdW5jdGlvbiAoVikge1xuICBpZiAod2ViaWRsLnV0aWwuVHlwZShWKSA9PT0gJ09iamVjdCcpIHtcbiAgICBpZiAoaXNCbG9iTGlrZShWKSkge1xuICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IoViwgeyBzdHJpY3Q6IGZhbHNlIH0pXG4gICAgfVxuXG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhWKSB8fCB0eXBlcy5pc0FueUFycmF5QnVmZmVyKFYpKSB7XG4gICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuQnVmZmVyU291cmNlKFYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhWKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViU29ja2V0XG59XG4iXSwibmFtZXMiOlsid2ViaWRsIiwicmVxdWlyZSIsIkRPTUV4Y2VwdGlvbiIsIlVSTFNlcmlhbGl6ZXIiLCJnZXRHbG9iYWxPcmlnaW4iLCJzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzIiwic3RhdGVzIiwib3Bjb2RlcyIsImVtcHR5QnVmZmVyIiwia1dlYlNvY2tldFVSTCIsImtSZWFkeVN0YXRlIiwia0NvbnRyb2xsZXIiLCJrQmluYXJ5VHlwZSIsImtSZXNwb25zZSIsImtTZW50Q2xvc2UiLCJrQnl0ZVBhcnNlciIsImlzRXN0YWJsaXNoZWQiLCJpc0Nsb3NpbmciLCJpc1ZhbGlkU3VicHJvdG9jb2wiLCJmYWlsV2Vic29ja2V0Q29ubmVjdGlvbiIsImZpcmVFdmVudCIsImVzdGFibGlzaFdlYlNvY2tldENvbm5lY3Rpb24iLCJXZWJzb2NrZXRGcmFtZVNlbmQiLCJCeXRlUGFyc2VyIiwia0VudW1lcmFibGVQcm9wZXJ0eSIsImlzQmxvYkxpa2UiLCJnZXRHbG9iYWxEaXNwYXRjaGVyIiwidHlwZXMiLCJleHBlcmltZW50YWxXYXJuZWQiLCJXZWJTb2NrZXQiLCJFdmVudFRhcmdldCIsImV2ZW50cyIsImJ1ZmZlcmVkQW1vdW50IiwicHJvdG9jb2wiLCJleHRlbnNpb25zIiwiY29uc3RydWN0b3IiLCJ1cmwiLCJwcm90b2NvbHMiLCJvcGVuIiwiZXJyb3IiLCJjbG9zZSIsIm1lc3NhZ2UiLCJhcmd1bWVudExlbmd0aENoZWNrIiwiYXJndW1lbnRzIiwiaGVhZGVyIiwicHJvY2VzcyIsImVtaXRXYXJuaW5nIiwiY29kZSIsIm9wdGlvbnMiLCJjb252ZXJ0ZXJzIiwiVVNWU3RyaW5nIiwiYmFzZVVSTCIsInVybFJlY29yZCIsIlVSTCIsImUiLCJoYXNoIiwiaHJlZiIsImVuZHNXaXRoIiwibGVuZ3RoIiwiU2V0IiwibWFwIiwicCIsInRvTG93ZXJDYXNlIiwic2l6ZSIsImV2ZXJ5IiwicmVzcG9uc2UiLCJvbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZCIsIkNPTk5FQ1RJTkciLCJ1bmRlZmluZWQiLCJyZWFzb24iLCJicmFuZENoZWNrIiwiY2xhbXAiLCJyZWFzb25CeXRlTGVuZ3RoIiwiQnVmZmVyIiwiYnl0ZUxlbmd0aCIsIkNMT1NJTkciLCJDTE9TRUQiLCJmcmFtZSIsImZyYW1lRGF0YSIsImFsbG9jVW5zYWZlIiwid3JpdGVVSW50MTZCRSIsIndyaXRlIiwic29ja2V0IiwiY3JlYXRlRnJhbWUiLCJDTE9TRSIsImVyciIsInNlbmQiLCJkYXRhIiwiV2ViU29ja2V0U2VuZERhdGEiLCJ2YWx1ZSIsImZyb20iLCJidWZmZXIiLCJURVhUIiwiaXNBcnJheUJ1ZmZlciIsIkJJTkFSWSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYWIiLCJieXRlT2Zmc2V0IiwiYXJyYXlCdWZmZXIiLCJ0aGVuIiwicmVhZHlTdGF0ZSIsIm9ub3BlbiIsImZuIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbmVycm9yIiwib25jbG9zZSIsIm9ubWVzc2FnZSIsImJpbmFyeVR5cGUiLCJ0eXBlIiwicGFyc2VyIiwib24iLCJvblBhcnNlckRyYWluIiwid3MiLCJyZXN1bWUiLCJPUEVOIiwiaGVhZGVyc0xpc3QiLCJnZXQiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJzZXF1ZW5jZUNvbnZlcnRlciIsIkRPTVN0cmluZyIsIlYiLCJ1dGlsIiwiVHlwZSIsIml0ZXJhdG9yIiwiV2ViU29ja2V0SW5pdCIsImRpY3Rpb25hcnlDb252ZXJ0ZXIiLCJrZXkiLCJjb252ZXJ0ZXIiLCJkZWZhdWx0VmFsdWUiLCJudWxsYWJsZUNvbnZlcnRlciIsIkhlYWRlcnNJbml0IiwiQmxvYiIsInN0cmljdCIsImlzQW55QXJyYXlCdWZmZXIiLCJCdWZmZXJTb3VyY2UiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/undici/lib/websocket/websocket.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/app/dist/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/firebase/app/dist/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirebaseError: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.FirebaseError),\n/* harmony export */   SDK_VERSION: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION),\n/* harmony export */   _DEFAULT_ENTRY_NAME: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._DEFAULT_ENTRY_NAME),\n/* harmony export */   _addComponent: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._addComponent),\n/* harmony export */   _addOrOverwriteComponent: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._addOrOverwriteComponent),\n/* harmony export */   _apps: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._apps),\n/* harmony export */   _clearComponents: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._clearComponents),\n/* harmony export */   _components: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._components),\n/* harmony export */   _getProvider: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider),\n/* harmony export */   _isFirebaseApp: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseApp),\n/* harmony export */   _isFirebaseServerApp: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp),\n/* harmony export */   _registerComponent: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent),\n/* harmony export */   _removeServiceInstance: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._removeServiceInstance),\n/* harmony export */   _serverApps: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._serverApps),\n/* harmony export */   deleteApp: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.deleteApp),\n/* harmony export */   getApp: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp),\n/* harmony export */   getApps: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApps),\n/* harmony export */   initializeApp: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.initializeApp),\n/* harmony export */   initializeServerApp: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.initializeServerApp),\n/* harmony export */   onLog: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.onLog),\n/* harmony export */   registerVersion: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion),\n/* harmony export */   setLogLevel: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n\n\nvar name = \"firebase\";\nvar version = \"10.14.1\";\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, \"app\"); //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2UvYXBwL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdEO0FBQ2xCO0FBRTlCLElBQUlDLE9BQU87QUFDWCxJQUFJQyxVQUFVO0FBRWQ7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RGLDhEQUFlQSxDQUFDQyxNQUFNQyxTQUFTLFFBQy9CLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL2FwcC9kaXN0L2luZGV4Lm1qcz83MWVhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlZ2lzdGVyVmVyc2lvbiB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuZXhwb3J0ICogZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5cbnZhciBuYW1lID0gXCJmaXJlYmFzZVwiO1xudmFyIHZlcnNpb24gPSBcIjEwLjE0LjFcIjtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxucmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sICdhcHAnKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJyZWdpc3RlclZlcnNpb24iLCJuYW1lIiwidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/app/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/auth/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/firebase/auth/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActionCodeOperation: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.ActionCodeOperation),\n/* harmony export */   ActionCodeURL: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.ActionCodeURL),\n/* harmony export */   AuthCredential: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.AuthCredential),\n/* harmony export */   AuthErrorCodes: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.AuthErrorCodes),\n/* harmony export */   EmailAuthCredential: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.EmailAuthCredential),\n/* harmony export */   EmailAuthProvider: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.EmailAuthProvider),\n/* harmony export */   FacebookAuthProvider: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.FacebookAuthProvider),\n/* harmony export */   FactorId: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.FactorId),\n/* harmony export */   GithubAuthProvider: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.GithubAuthProvider),\n/* harmony export */   GoogleAuthProvider: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.GoogleAuthProvider),\n/* harmony export */   OAuthCredential: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.OAuthCredential),\n/* harmony export */   OAuthProvider: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.OAuthProvider),\n/* harmony export */   OperationType: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.OperationType),\n/* harmony export */   PhoneAuthCredential: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.PhoneAuthCredential),\n/* harmony export */   PhoneAuthProvider: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.PhoneAuthProvider),\n/* harmony export */   PhoneMultiFactorGenerator: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.PhoneMultiFactorGenerator),\n/* harmony export */   ProviderId: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.ProviderId),\n/* harmony export */   RecaptchaVerifier: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.RecaptchaVerifier),\n/* harmony export */   SAMLAuthProvider: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.SAMLAuthProvider),\n/* harmony export */   SignInMethod: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.SignInMethod),\n/* harmony export */   TotpMultiFactorGenerator: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.TotpMultiFactorGenerator),\n/* harmony export */   TotpSecret: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.TotpSecret),\n/* harmony export */   TwitterAuthProvider: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.TwitterAuthProvider),\n/* harmony export */   applyActionCode: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.applyActionCode),\n/* harmony export */   beforeAuthStateChanged: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.beforeAuthStateChanged),\n/* harmony export */   browserLocalPersistence: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.browserLocalPersistence),\n/* harmony export */   browserPopupRedirectResolver: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.browserPopupRedirectResolver),\n/* harmony export */   browserSessionPersistence: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.browserSessionPersistence),\n/* harmony export */   checkActionCode: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.checkActionCode),\n/* harmony export */   confirmPasswordReset: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.confirmPasswordReset),\n/* harmony export */   connectAuthEmulator: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.connectAuthEmulator),\n/* harmony export */   createUserWithEmailAndPassword: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.createUserWithEmailAndPassword),\n/* harmony export */   debugErrorMap: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.debugErrorMap),\n/* harmony export */   deleteUser: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.deleteUser),\n/* harmony export */   fetchSignInMethodsForEmail: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.fetchSignInMethodsForEmail),\n/* harmony export */   getAdditionalUserInfo: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.getAdditionalUserInfo),\n/* harmony export */   getAuth: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.getAuth),\n/* harmony export */   getIdToken: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.getIdToken),\n/* harmony export */   getIdTokenResult: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.getIdTokenResult),\n/* harmony export */   getMultiFactorResolver: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.getMultiFactorResolver),\n/* harmony export */   getRedirectResult: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.getRedirectResult),\n/* harmony export */   inMemoryPersistence: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.inMemoryPersistence),\n/* harmony export */   indexedDBLocalPersistence: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.indexedDBLocalPersistence),\n/* harmony export */   initializeAuth: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.initializeAuth),\n/* harmony export */   initializeRecaptchaConfig: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.initializeRecaptchaConfig),\n/* harmony export */   isSignInWithEmailLink: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.isSignInWithEmailLink),\n/* harmony export */   linkWithCredential: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.linkWithCredential),\n/* harmony export */   linkWithPhoneNumber: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.linkWithPhoneNumber),\n/* harmony export */   linkWithPopup: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.linkWithPopup),\n/* harmony export */   linkWithRedirect: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.linkWithRedirect),\n/* harmony export */   multiFactor: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.multiFactor),\n/* harmony export */   onAuthStateChanged: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.onAuthStateChanged),\n/* harmony export */   onIdTokenChanged: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.onIdTokenChanged),\n/* harmony export */   parseActionCodeURL: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.parseActionCodeURL),\n/* harmony export */   prodErrorMap: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.prodErrorMap),\n/* harmony export */   reauthenticateWithCredential: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.reauthenticateWithCredential),\n/* harmony export */   reauthenticateWithPhoneNumber: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.reauthenticateWithPhoneNumber),\n/* harmony export */   reauthenticateWithPopup: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.reauthenticateWithPopup),\n/* harmony export */   reauthenticateWithRedirect: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.reauthenticateWithRedirect),\n/* harmony export */   reload: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.reload),\n/* harmony export */   revokeAccessToken: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.revokeAccessToken),\n/* harmony export */   sendEmailVerification: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.sendEmailVerification),\n/* harmony export */   sendPasswordResetEmail: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.sendPasswordResetEmail),\n/* harmony export */   sendSignInLinkToEmail: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.sendSignInLinkToEmail),\n/* harmony export */   setPersistence: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.setPersistence),\n/* harmony export */   signInAnonymously: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.signInAnonymously),\n/* harmony export */   signInWithCredential: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.signInWithCredential),\n/* harmony export */   signInWithCustomToken: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.signInWithCustomToken),\n/* harmony export */   signInWithEmailAndPassword: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.signInWithEmailAndPassword),\n/* harmony export */   signInWithEmailLink: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.signInWithEmailLink),\n/* harmony export */   signInWithPhoneNumber: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.signInWithPhoneNumber),\n/* harmony export */   signInWithPopup: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.signInWithPopup),\n/* harmony export */   signInWithRedirect: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.signInWithRedirect),\n/* harmony export */   signOut: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.signOut),\n/* harmony export */   unlink: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.unlink),\n/* harmony export */   updateCurrentUser: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.updateCurrentUser),\n/* harmony export */   updateEmail: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.updateEmail),\n/* harmony export */   updatePassword: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.updatePassword),\n/* harmony export */   updatePhoneNumber: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.updatePhoneNumber),\n/* harmony export */   updateProfile: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.updateProfile),\n/* harmony export */   useDeviceLanguage: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.useDeviceLanguage),\n/* harmony export */   validatePassword: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.validatePassword),\n/* harmony export */   verifyBeforeUpdateEmail: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.verifyBeforeUpdateEmail),\n/* harmony export */   verifyPasswordResetCode: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.verifyPasswordResetCode)\n/* harmony export */ });\n/* harmony import */ var _firebase_auth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/auth */ \"(ssr)/./node_modules/firebase/node_modules/@firebase/auth/dist/node-esm/index.js\");\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2UvYXV0aC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCLENBQy9CLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL2F1dGgvZGlzdC9pbmRleC5tanM/MGY4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICdAZmlyZWJhc2UvYXV0aCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/auth/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/firestore/dist/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/firebase/firestore/dist/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractUserDataWriter: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.AbstractUserDataWriter),\n/* harmony export */   AggregateField: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.AggregateField),\n/* harmony export */   AggregateQuerySnapshot: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.AggregateQuerySnapshot),\n/* harmony export */   Bytes: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.Bytes),\n/* harmony export */   CACHE_SIZE_UNLIMITED: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.CACHE_SIZE_UNLIMITED),\n/* harmony export */   CollectionReference: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.CollectionReference),\n/* harmony export */   DocumentReference: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.DocumentReference),\n/* harmony export */   DocumentSnapshot: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.DocumentSnapshot),\n/* harmony export */   FieldPath: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.FieldPath),\n/* harmony export */   FieldValue: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.FieldValue),\n/* harmony export */   Firestore: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.Firestore),\n/* harmony export */   FirestoreError: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.FirestoreError),\n/* harmony export */   GeoPoint: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.GeoPoint),\n/* harmony export */   LoadBundleTask: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.LoadBundleTask),\n/* harmony export */   PersistentCacheIndexManager: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.PersistentCacheIndexManager),\n/* harmony export */   Query: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.Query),\n/* harmony export */   QueryCompositeFilterConstraint: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.QueryCompositeFilterConstraint),\n/* harmony export */   QueryConstraint: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.QueryConstraint),\n/* harmony export */   QueryDocumentSnapshot: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.QueryDocumentSnapshot),\n/* harmony export */   QueryEndAtConstraint: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.QueryEndAtConstraint),\n/* harmony export */   QueryFieldFilterConstraint: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.QueryFieldFilterConstraint),\n/* harmony export */   QueryLimitConstraint: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.QueryLimitConstraint),\n/* harmony export */   QueryOrderByConstraint: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.QueryOrderByConstraint),\n/* harmony export */   QuerySnapshot: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.QuerySnapshot),\n/* harmony export */   QueryStartAtConstraint: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.QueryStartAtConstraint),\n/* harmony export */   SnapshotMetadata: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.SnapshotMetadata),\n/* harmony export */   Timestamp: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.Timestamp),\n/* harmony export */   Transaction: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.Transaction),\n/* harmony export */   VectorValue: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.VectorValue),\n/* harmony export */   WriteBatch: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.WriteBatch),\n/* harmony export */   _AutoId: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._AutoId),\n/* harmony export */   _ByteString: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._ByteString),\n/* harmony export */   _DatabaseId: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._DatabaseId),\n/* harmony export */   _DocumentKey: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._DocumentKey),\n/* harmony export */   _EmptyAppCheckTokenProvider: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._EmptyAppCheckTokenProvider),\n/* harmony export */   _EmptyAuthCredentialsProvider: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._EmptyAuthCredentialsProvider),\n/* harmony export */   _FieldPath: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._FieldPath),\n/* harmony export */   _TestingHooks: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._TestingHooks),\n/* harmony export */   _cast: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._cast),\n/* harmony export */   _debugAssert: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._debugAssert),\n/* harmony export */   _internalAggregationQueryToProtoRunAggregationQueryRequest: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._internalAggregationQueryToProtoRunAggregationQueryRequest),\n/* harmony export */   _internalQueryToProtoQueryTarget: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._internalQueryToProtoQueryTarget),\n/* harmony export */   _isBase64Available: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._isBase64Available),\n/* harmony export */   _logWarn: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._logWarn),\n/* harmony export */   _validateIsNotUsedTogether: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._validateIsNotUsedTogether),\n/* harmony export */   addDoc: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc),\n/* harmony export */   aggregateFieldEqual: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.aggregateFieldEqual),\n/* harmony export */   aggregateQuerySnapshotEqual: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.aggregateQuerySnapshotEqual),\n/* harmony export */   and: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.and),\n/* harmony export */   arrayRemove: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.arrayRemove),\n/* harmony export */   arrayUnion: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.arrayUnion),\n/* harmony export */   average: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.average),\n/* harmony export */   clearIndexedDbPersistence: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.clearIndexedDbPersistence),\n/* harmony export */   collection: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection),\n/* harmony export */   collectionGroup: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collectionGroup),\n/* harmony export */   connectFirestoreEmulator: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.connectFirestoreEmulator),\n/* harmony export */   count: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.count),\n/* harmony export */   deleteAllPersistentCacheIndexes: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.deleteAllPersistentCacheIndexes),\n/* harmony export */   deleteDoc: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.deleteDoc),\n/* harmony export */   deleteField: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.deleteField),\n/* harmony export */   disableNetwork: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.disableNetwork),\n/* harmony export */   disablePersistentCacheIndexAutoCreation: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.disablePersistentCacheIndexAutoCreation),\n/* harmony export */   doc: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc),\n/* harmony export */   documentId: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.documentId),\n/* harmony export */   enableIndexedDbPersistence: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.enableIndexedDbPersistence),\n/* harmony export */   enableMultiTabIndexedDbPersistence: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.enableMultiTabIndexedDbPersistence),\n/* harmony export */   enableNetwork: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.enableNetwork),\n/* harmony export */   enablePersistentCacheIndexAutoCreation: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.enablePersistentCacheIndexAutoCreation),\n/* harmony export */   endAt: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.endAt),\n/* harmony export */   endBefore: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.endBefore),\n/* harmony export */   ensureFirestoreConfigured: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.ensureFirestoreConfigured),\n/* harmony export */   executeWrite: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.executeWrite),\n/* harmony export */   getAggregateFromServer: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getAggregateFromServer),\n/* harmony export */   getCountFromServer: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getCountFromServer),\n/* harmony export */   getDoc: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc),\n/* harmony export */   getDocFromCache: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocFromCache),\n/* harmony export */   getDocFromServer: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocFromServer),\n/* harmony export */   getDocs: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs),\n/* harmony export */   getDocsFromCache: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocsFromCache),\n/* harmony export */   getDocsFromServer: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocsFromServer),\n/* harmony export */   getFirestore: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getFirestore),\n/* harmony export */   getPersistentCacheIndexManager: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getPersistentCacheIndexManager),\n/* harmony export */   increment: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.increment),\n/* harmony export */   initializeFirestore: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.initializeFirestore),\n/* harmony export */   limit: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit),\n/* harmony export */   limitToLast: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limitToLast),\n/* harmony export */   loadBundle: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.loadBundle),\n/* harmony export */   memoryEagerGarbageCollector: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.memoryEagerGarbageCollector),\n/* harmony export */   memoryLocalCache: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.memoryLocalCache),\n/* harmony export */   memoryLruGarbageCollector: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.memoryLruGarbageCollector),\n/* harmony export */   namedQuery: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.namedQuery),\n/* harmony export */   onSnapshot: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.onSnapshot),\n/* harmony export */   onSnapshotsInSync: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.onSnapshotsInSync),\n/* harmony export */   or: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.or),\n/* harmony export */   orderBy: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy),\n/* harmony export */   persistentLocalCache: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.persistentLocalCache),\n/* harmony export */   persistentMultipleTabManager: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.persistentMultipleTabManager),\n/* harmony export */   persistentSingleTabManager: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.persistentSingleTabManager),\n/* harmony export */   query: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query),\n/* harmony export */   queryEqual: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.queryEqual),\n/* harmony export */   refEqual: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.refEqual),\n/* harmony export */   runTransaction: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.runTransaction),\n/* harmony export */   serverTimestamp: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp),\n/* harmony export */   setDoc: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc),\n/* harmony export */   setIndexConfiguration: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setIndexConfiguration),\n/* harmony export */   setLogLevel: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setLogLevel),\n/* harmony export */   snapshotEqual: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.snapshotEqual),\n/* harmony export */   startAfter: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.startAfter),\n/* harmony export */   startAt: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.startAt),\n/* harmony export */   sum: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.sum),\n/* harmony export */   terminate: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.terminate),\n/* harmony export */   updateDoc: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc),\n/* harmony export */   vector: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.vector),\n/* harmony export */   waitForPendingWrites: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.waitForPendingWrites),\n/* harmony export */   where: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where),\n/* harmony export */   writeBatch: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.writeBatch)\n/* harmony export */ });\n/* harmony import */ var _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/firestore */ \"(ssr)/./node_modules/@firebase/firestore/dist/index.node.mjs\");\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2UvZmlyZXN0b3JlL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvQyxDQUNwQyxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waHlzaWNzLWZpZ2h0ZXItYWNhZGVteS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9maXJlc3RvcmUvZGlzdC9pbmRleC5tanM/NTVmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICdAZmlyZWJhc2UvZmlyZXN0b3JlJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/firestore/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/@firebase/auth/dist/node-esm/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/@firebase/auth/dist/node-esm/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActionCodeOperation: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.A),\n/* harmony export */   ActionCodeURL: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.ai),\n/* harmony export */   AuthCredential: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.L),\n/* harmony export */   AuthErrorCodes: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.I),\n/* harmony export */   EmailAuthCredential: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.M),\n/* harmony export */   EmailAuthProvider: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.V),\n/* harmony export */   FacebookAuthProvider: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.W),\n/* harmony export */   FactorId: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   GithubAuthProvider: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.Y),\n/* harmony export */   GoogleAuthProvider: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.X),\n/* harmony export */   OAuthCredential: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.N),\n/* harmony export */   OAuthProvider: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.Z),\n/* harmony export */   OperationType: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.O),\n/* harmony export */   PhoneAuthCredential: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.Q),\n/* harmony export */   PhoneAuthProvider: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.P),\n/* harmony export */   PhoneMultiFactorGenerator: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   ProviderId: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   RecaptchaVerifier: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.R),\n/* harmony export */   SAMLAuthProvider: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__._),\n/* harmony export */   SignInMethod: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.S),\n/* harmony export */   TotpMultiFactorGenerator: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.T),\n/* harmony export */   TotpSecret: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   TwitterAuthProvider: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.$),\n/* harmony export */   applyActionCode: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.a7),\n/* harmony export */   beforeAuthStateChanged: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   browserLocalPersistence: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   browserPopupRedirectResolver: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   browserSessionPersistence: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.a),\n/* harmony export */   checkActionCode: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.a8),\n/* harmony export */   confirmPasswordReset: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.a6),\n/* harmony export */   connectAuthEmulator: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.K),\n/* harmony export */   createUserWithEmailAndPassword: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.aa),\n/* harmony export */   debugErrorMap: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.G),\n/* harmony export */   deleteUser: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.E),\n/* harmony export */   fetchSignInMethodsForEmail: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.af),\n/* harmony export */   getAdditionalUserInfo: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.aq),\n/* harmony export */   getAuth: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   getIdToken: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.an),\n/* harmony export */   getIdTokenResult: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.ao),\n/* harmony export */   getMultiFactorResolver: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.as),\n/* harmony export */   getRedirectResult: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   inMemoryPersistence: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.U),\n/* harmony export */   indexedDBLocalPersistence: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.i),\n/* harmony export */   initializeAuth: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.J),\n/* harmony export */   initializeRecaptchaConfig: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   isSignInWithEmailLink: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.ad),\n/* harmony export */   linkWithCredential: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.a2),\n/* harmony export */   linkWithPhoneNumber: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   linkWithPopup: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   linkWithRedirect: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   multiFactor: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.at),\n/* harmony export */   onAuthStateChanged: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   onIdTokenChanged: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   parseActionCodeURL: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.aj),\n/* harmony export */   prodErrorMap: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.H),\n/* harmony export */   reauthenticateWithCredential: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.a3),\n/* harmony export */   reauthenticateWithPhoneNumber: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   reauthenticateWithPopup: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   reauthenticateWithRedirect: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   reload: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.ar),\n/* harmony export */   revokeAccessToken: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.D),\n/* harmony export */   sendEmailVerification: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.ag),\n/* harmony export */   sendPasswordResetEmail: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.a5),\n/* harmony export */   sendSignInLinkToEmail: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.ac),\n/* harmony export */   setPersistence: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   signInAnonymously: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.a0),\n/* harmony export */   signInWithCredential: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.a1),\n/* harmony export */   signInWithCustomToken: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.a4),\n/* harmony export */   signInWithEmailAndPassword: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.ab),\n/* harmony export */   signInWithEmailLink: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.ae),\n/* harmony export */   signInWithPhoneNumber: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   signInWithPopup: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   signInWithRedirect: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   signOut: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   unlink: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.ap),\n/* harmony export */   updateCurrentUser: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.B),\n/* harmony export */   updateEmail: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.al),\n/* harmony export */   updatePassword: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.am),\n/* harmony export */   updatePhoneNumber: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.u),\n/* harmony export */   updateProfile: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.ak),\n/* harmony export */   useDeviceLanguage: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.z),\n/* harmony export */   validatePassword: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.v),\n/* harmony export */   verifyBeforeUpdateEmail: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.ah),\n/* harmony export */   verifyPasswordResetCode: () => (/* reexport safe */ _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__.a9)\n/* harmony export */ });\n/* harmony import */ var _totp_219bb96f_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./totp-219bb96f.js */ \"(ssr)/./node_modules/firebase/node_modules/@firebase/auth/dist/node-esm/totp-219bb96f.js\");\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! undici */ \"(ssr)/./node_modules/firebase/node_modules/undici/index.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n\n\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL2Rpc3Qvbm9kZS1lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdsRTtBQUNqa0U7QUFDQztBQUNUO0FBQ2M7QUFDYjtBQUNVLENBQzFCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9kaXN0L25vZGUtZXNtL2luZGV4LmpzPzUzMGYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgQSBhcyBBY3Rpb25Db2RlT3BlcmF0aW9uLCBhaSBhcyBBY3Rpb25Db2RlVVJMLCBMIGFzIEF1dGhDcmVkZW50aWFsLCBJIGFzIEF1dGhFcnJvckNvZGVzLCBNIGFzIEVtYWlsQXV0aENyZWRlbnRpYWwsIFYgYXMgRW1haWxBdXRoUHJvdmlkZXIsIFcgYXMgRmFjZWJvb2tBdXRoUHJvdmlkZXIsIEYgYXMgRmFjdG9ySWQsIFkgYXMgR2l0aHViQXV0aFByb3ZpZGVyLCBYIGFzIEdvb2dsZUF1dGhQcm92aWRlciwgTiBhcyBPQXV0aENyZWRlbnRpYWwsIFogYXMgT0F1dGhQcm92aWRlciwgTyBhcyBPcGVyYXRpb25UeXBlLCBRIGFzIFBob25lQXV0aENyZWRlbnRpYWwsIFAgYXMgUGhvbmVBdXRoUHJvdmlkZXIsIG0gYXMgUGhvbmVNdWx0aUZhY3RvckdlbmVyYXRvciwgcCBhcyBQcm92aWRlcklkLCBSIGFzIFJlY2FwdGNoYVZlcmlmaWVyLCBfIGFzIFNBTUxBdXRoUHJvdmlkZXIsIFMgYXMgU2lnbkluTWV0aG9kLCBUIGFzIFRvdHBNdWx0aUZhY3RvckdlbmVyYXRvciwgbiBhcyBUb3RwU2VjcmV0LCAkIGFzIFR3aXR0ZXJBdXRoUHJvdmlkZXIsIGE3IGFzIGFwcGx5QWN0aW9uQ29kZSwgeCBhcyBiZWZvcmVBdXRoU3RhdGVDaGFuZ2VkLCBiIGFzIGJyb3dzZXJMb2NhbFBlcnNpc3RlbmNlLCBrIGFzIGJyb3dzZXJQb3B1cFJlZGlyZWN0UmVzb2x2ZXIsIGEgYXMgYnJvd3NlclNlc3Npb25QZXJzaXN0ZW5jZSwgYTggYXMgY2hlY2tBY3Rpb25Db2RlLCBhNiBhcyBjb25maXJtUGFzc3dvcmRSZXNldCwgSyBhcyBjb25uZWN0QXV0aEVtdWxhdG9yLCBhYSBhcyBjcmVhdGVVc2VyV2l0aEVtYWlsQW5kUGFzc3dvcmQsIEcgYXMgZGVidWdFcnJvck1hcCwgRSBhcyBkZWxldGVVc2VyLCBhZiBhcyBmZXRjaFNpZ25Jbk1ldGhvZHNGb3JFbWFpbCwgYXEgYXMgZ2V0QWRkaXRpb25hbFVzZXJJbmZvLCBvIGFzIGdldEF1dGgsIGFuIGFzIGdldElkVG9rZW4sIGFvIGFzIGdldElkVG9rZW5SZXN1bHQsIGFzIGFzIGdldE11bHRpRmFjdG9yUmVzb2x2ZXIsIGogYXMgZ2V0UmVkaXJlY3RSZXN1bHQsIFUgYXMgaW5NZW1vcnlQZXJzaXN0ZW5jZSwgaSBhcyBpbmRleGVkREJMb2NhbFBlcnNpc3RlbmNlLCBKIGFzIGluaXRpYWxpemVBdXRoLCB0IGFzIGluaXRpYWxpemVSZWNhcHRjaGFDb25maWcsIGFkIGFzIGlzU2lnbkluV2l0aEVtYWlsTGluaywgYTIgYXMgbGlua1dpdGhDcmVkZW50aWFsLCBsIGFzIGxpbmtXaXRoUGhvbmVOdW1iZXIsIGQgYXMgbGlua1dpdGhQb3B1cCwgZyBhcyBsaW5rV2l0aFJlZGlyZWN0LCBhdCBhcyBtdWx0aUZhY3RvciwgeSBhcyBvbkF1dGhTdGF0ZUNoYW5nZWQsIHcgYXMgb25JZFRva2VuQ2hhbmdlZCwgYWogYXMgcGFyc2VBY3Rpb25Db2RlVVJMLCBIIGFzIHByb2RFcnJvck1hcCwgYTMgYXMgcmVhdXRoZW50aWNhdGVXaXRoQ3JlZGVudGlhbCwgciBhcyByZWF1dGhlbnRpY2F0ZVdpdGhQaG9uZU51bWJlciwgZSBhcyByZWF1dGhlbnRpY2F0ZVdpdGhQb3B1cCwgaCBhcyByZWF1dGhlbnRpY2F0ZVdpdGhSZWRpcmVjdCwgYXIgYXMgcmVsb2FkLCBEIGFzIHJldm9rZUFjY2Vzc1Rva2VuLCBhZyBhcyBzZW5kRW1haWxWZXJpZmljYXRpb24sIGE1IGFzIHNlbmRQYXNzd29yZFJlc2V0RW1haWwsIGFjIGFzIHNlbmRTaWduSW5MaW5rVG9FbWFpbCwgcSBhcyBzZXRQZXJzaXN0ZW5jZSwgYTAgYXMgc2lnbkluQW5vbnltb3VzbHksIGExIGFzIHNpZ25JbldpdGhDcmVkZW50aWFsLCBhNCBhcyBzaWduSW5XaXRoQ3VzdG9tVG9rZW4sIGFiIGFzIHNpZ25JbldpdGhFbWFpbEFuZFBhc3N3b3JkLCBhZSBhcyBzaWduSW5XaXRoRW1haWxMaW5rLCBzIGFzIHNpZ25JbldpdGhQaG9uZU51bWJlciwgYyBhcyBzaWduSW5XaXRoUG9wdXAsIGYgYXMgc2lnbkluV2l0aFJlZGlyZWN0LCBDIGFzIHNpZ25PdXQsIGFwIGFzIHVubGluaywgQiBhcyB1cGRhdGVDdXJyZW50VXNlciwgYWwgYXMgdXBkYXRlRW1haWwsIGFtIGFzIHVwZGF0ZVBhc3N3b3JkLCB1IGFzIHVwZGF0ZVBob25lTnVtYmVyLCBhayBhcyB1cGRhdGVQcm9maWxlLCB6IGFzIHVzZURldmljZUxhbmd1YWdlLCB2IGFzIHZhbGlkYXRlUGFzc3dvcmQsIGFoIGFzIHZlcmlmeUJlZm9yZVVwZGF0ZUVtYWlsLCBhOSBhcyB2ZXJpZnlQYXNzd29yZFJlc2V0Q29kZSB9IGZyb20gJy4vdG90cC0yMTliYjk2Zi5qcyc7XG5pbXBvcnQgJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0ICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgJ3RzbGliJztcbmltcG9ydCAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgJ3VuZGljaSc7XG5pbXBvcnQgJ0BmaXJlYmFzZS9sb2dnZXInO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiQSIsIkFjdGlvbkNvZGVPcGVyYXRpb24iLCJhaSIsIkFjdGlvbkNvZGVVUkwiLCJMIiwiQXV0aENyZWRlbnRpYWwiLCJJIiwiQXV0aEVycm9yQ29kZXMiLCJNIiwiRW1haWxBdXRoQ3JlZGVudGlhbCIsIlYiLCJFbWFpbEF1dGhQcm92aWRlciIsIlciLCJGYWNlYm9va0F1dGhQcm92aWRlciIsIkYiLCJGYWN0b3JJZCIsIlkiLCJHaXRodWJBdXRoUHJvdmlkZXIiLCJYIiwiR29vZ2xlQXV0aFByb3ZpZGVyIiwiTiIsIk9BdXRoQ3JlZGVudGlhbCIsIloiLCJPQXV0aFByb3ZpZGVyIiwiTyIsIk9wZXJhdGlvblR5cGUiLCJRIiwiUGhvbmVBdXRoQ3JlZGVudGlhbCIsIlAiLCJQaG9uZUF1dGhQcm92aWRlciIsIm0iLCJQaG9uZU11bHRpRmFjdG9yR2VuZXJhdG9yIiwicCIsIlByb3ZpZGVySWQiLCJSIiwiUmVjYXB0Y2hhVmVyaWZpZXIiLCJfIiwiU0FNTEF1dGhQcm92aWRlciIsIlMiLCJTaWduSW5NZXRob2QiLCJUIiwiVG90cE11bHRpRmFjdG9yR2VuZXJhdG9yIiwibiIsIlRvdHBTZWNyZXQiLCIkIiwiVHdpdHRlckF1dGhQcm92aWRlciIsImE3IiwiYXBwbHlBY3Rpb25Db2RlIiwieCIsImJlZm9yZUF1dGhTdGF0ZUNoYW5nZWQiLCJiIiwiYnJvd3NlckxvY2FsUGVyc2lzdGVuY2UiLCJrIiwiYnJvd3NlclBvcHVwUmVkaXJlY3RSZXNvbHZlciIsImEiLCJicm93c2VyU2Vzc2lvblBlcnNpc3RlbmNlIiwiYTgiLCJjaGVja0FjdGlvbkNvZGUiLCJhNiIsImNvbmZpcm1QYXNzd29yZFJlc2V0IiwiSyIsImNvbm5lY3RBdXRoRW11bGF0b3IiLCJhYSIsImNyZWF0ZVVzZXJXaXRoRW1haWxBbmRQYXNzd29yZCIsIkciLCJkZWJ1Z0Vycm9yTWFwIiwiRSIsImRlbGV0ZVVzZXIiLCJhZiIsImZldGNoU2lnbkluTWV0aG9kc0ZvckVtYWlsIiwiYXEiLCJnZXRBZGRpdGlvbmFsVXNlckluZm8iLCJvIiwiZ2V0QXV0aCIsImFuIiwiZ2V0SWRUb2tlbiIsImFvIiwiZ2V0SWRUb2tlblJlc3VsdCIsImFzIiwiZ2V0TXVsdGlGYWN0b3JSZXNvbHZlciIsImoiLCJnZXRSZWRpcmVjdFJlc3VsdCIsIlUiLCJpbk1lbW9yeVBlcnNpc3RlbmNlIiwiaSIsImluZGV4ZWREQkxvY2FsUGVyc2lzdGVuY2UiLCJKIiwiaW5pdGlhbGl6ZUF1dGgiLCJ0IiwiaW5pdGlhbGl6ZVJlY2FwdGNoYUNvbmZpZyIsImFkIiwiaXNTaWduSW5XaXRoRW1haWxMaW5rIiwiYTIiLCJsaW5rV2l0aENyZWRlbnRpYWwiLCJsIiwibGlua1dpdGhQaG9uZU51bWJlciIsImQiLCJsaW5rV2l0aFBvcHVwIiwiZyIsImxpbmtXaXRoUmVkaXJlY3QiLCJhdCIsIm11bHRpRmFjdG9yIiwieSIsIm9uQXV0aFN0YXRlQ2hhbmdlZCIsInciLCJvbklkVG9rZW5DaGFuZ2VkIiwiYWoiLCJwYXJzZUFjdGlvbkNvZGVVUkwiLCJIIiwicHJvZEVycm9yTWFwIiwiYTMiLCJyZWF1dGhlbnRpY2F0ZVdpdGhDcmVkZW50aWFsIiwiciIsInJlYXV0aGVudGljYXRlV2l0aFBob25lTnVtYmVyIiwiZSIsInJlYXV0aGVudGljYXRlV2l0aFBvcHVwIiwiaCIsInJlYXV0aGVudGljYXRlV2l0aFJlZGlyZWN0IiwiYXIiLCJyZWxvYWQiLCJEIiwicmV2b2tlQWNjZXNzVG9rZW4iLCJhZyIsInNlbmRFbWFpbFZlcmlmaWNhdGlvbiIsImE1Iiwic2VuZFBhc3N3b3JkUmVzZXRFbWFpbCIsImFjIiwic2VuZFNpZ25JbkxpbmtUb0VtYWlsIiwicSIsInNldFBlcnNpc3RlbmNlIiwiYTAiLCJzaWduSW5Bbm9ueW1vdXNseSIsImExIiwic2lnbkluV2l0aENyZWRlbnRpYWwiLCJhNCIsInNpZ25JbldpdGhDdXN0b21Ub2tlbiIsImFiIiwic2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmQiLCJhZSIsInNpZ25JbldpdGhFbWFpbExpbmsiLCJzIiwic2lnbkluV2l0aFBob25lTnVtYmVyIiwiYyIsInNpZ25JbldpdGhQb3B1cCIsImYiLCJzaWduSW5XaXRoUmVkaXJlY3QiLCJDIiwic2lnbk91dCIsImFwIiwidW5saW5rIiwiQiIsInVwZGF0ZUN1cnJlbnRVc2VyIiwiYWwiLCJ1cGRhdGVFbWFpbCIsImFtIiwidXBkYXRlUGFzc3dvcmQiLCJ1IiwidXBkYXRlUGhvbmVOdW1iZXIiLCJhayIsInVwZGF0ZVByb2ZpbGUiLCJ6IiwidXNlRGV2aWNlTGFuZ3VhZ2UiLCJ2IiwidmFsaWRhdGVQYXNzd29yZCIsImFoIiwidmVyaWZ5QmVmb3JlVXBkYXRlRW1haWwiLCJhOSIsInZlcmlmeVBhc3N3b3JkUmVzZXRDb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/@firebase/auth/dist/node-esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/@firebase/auth/dist/node-esm/totp-219bb96f.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/@firebase/auth/dist/node-esm/totp-219bb96f.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ TwitterAuthProvider),\n/* harmony export */   A: () => (/* binding */ ActionCodeOperation),\n/* harmony export */   B: () => (/* binding */ updateCurrentUser),\n/* harmony export */   C: () => (/* binding */ signOut),\n/* harmony export */   D: () => (/* binding */ revokeAccessToken),\n/* harmony export */   E: () => (/* binding */ deleteUser),\n/* harmony export */   F: () => (/* binding */ FactorId),\n/* harmony export */   G: () => (/* binding */ debugErrorMap),\n/* harmony export */   H: () => (/* binding */ prodErrorMap),\n/* harmony export */   I: () => (/* binding */ AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY),\n/* harmony export */   J: () => (/* binding */ initializeAuth),\n/* harmony export */   K: () => (/* binding */ connectAuthEmulator),\n/* harmony export */   L: () => (/* binding */ AuthCredential),\n/* harmony export */   M: () => (/* binding */ EmailAuthCredential),\n/* harmony export */   N: () => (/* binding */ OAuthCredential),\n/* harmony export */   O: () => (/* binding */ OperationType),\n/* harmony export */   P: () => (/* binding */ PhoneAuthProvider),\n/* harmony export */   Q: () => (/* binding */ PhoneAuthCredential),\n/* harmony export */   R: () => (/* binding */ RecaptchaVerifier),\n/* harmony export */   S: () => (/* binding */ SignInMethod),\n/* harmony export */   T: () => (/* binding */ TotpMultiFactorGenerator),\n/* harmony export */   U: () => (/* binding */ inMemoryPersistence),\n/* harmony export */   V: () => (/* binding */ EmailAuthProvider),\n/* harmony export */   W: () => (/* binding */ FacebookAuthProvider),\n/* harmony export */   X: () => (/* binding */ GoogleAuthProvider),\n/* harmony export */   Y: () => (/* binding */ GithubAuthProvider),\n/* harmony export */   Z: () => (/* binding */ OAuthProvider),\n/* harmony export */   _: () => (/* binding */ SAMLAuthProvider),\n/* harmony export */   a: () => (/* binding */ browserSessionPersistence),\n/* harmony export */   a0: () => (/* binding */ signInAnonymously),\n/* harmony export */   a1: () => (/* binding */ signInWithCredential),\n/* harmony export */   a2: () => (/* binding */ linkWithCredential),\n/* harmony export */   a3: () => (/* binding */ reauthenticateWithCredential),\n/* harmony export */   a4: () => (/* binding */ signInWithCustomToken),\n/* harmony export */   a5: () => (/* binding */ sendPasswordResetEmail),\n/* harmony export */   a6: () => (/* binding */ confirmPasswordReset),\n/* harmony export */   a7: () => (/* binding */ applyActionCode),\n/* harmony export */   a8: () => (/* binding */ checkActionCode),\n/* harmony export */   a9: () => (/* binding */ verifyPasswordResetCode),\n/* harmony export */   aA: () => (/* binding */ _fail),\n/* harmony export */   aB: () => (/* binding */ debugAssert),\n/* harmony export */   aC: () => (/* binding */ _persistenceKeyName),\n/* harmony export */   aD: () => (/* binding */ _serverAppCurrentUserOperationNotSupportedError),\n/* harmony export */   aE: () => (/* binding */ _castAuth),\n/* harmony export */   aF: () => (/* binding */ FederatedAuthProvider),\n/* harmony export */   aG: () => (/* binding */ BaseOAuthProvider),\n/* harmony export */   aH: () => (/* binding */ _emulatorUrl),\n/* harmony export */   aI: () => (/* binding */ _performApiRequest),\n/* harmony export */   aJ: () => (/* binding */ _isIOS),\n/* harmony export */   aK: () => (/* binding */ _isAndroid),\n/* harmony export */   aL: () => (/* binding */ _isIOS7Or8),\n/* harmony export */   aM: () => (/* binding */ _createError),\n/* harmony export */   aN: () => (/* binding */ _isMobileBrowser),\n/* harmony export */   aO: () => (/* binding */ _isIE10),\n/* harmony export */   aP: () => (/* binding */ UserImpl),\n/* harmony export */   aQ: () => (/* binding */ AuthImpl),\n/* harmony export */   aR: () => (/* binding */ _getClientVersion),\n/* harmony export */   aS: () => (/* binding */ FetchProvider),\n/* harmony export */   aT: () => (/* binding */ SAMLAuthCredential),\n/* harmony export */   aa: () => (/* binding */ createUserWithEmailAndPassword),\n/* harmony export */   ab: () => (/* binding */ signInWithEmailAndPassword),\n/* harmony export */   ac: () => (/* binding */ sendSignInLinkToEmail),\n/* harmony export */   ad: () => (/* binding */ isSignInWithEmailLink),\n/* harmony export */   ae: () => (/* binding */ signInWithEmailLink),\n/* harmony export */   af: () => (/* binding */ fetchSignInMethodsForEmail),\n/* harmony export */   ag: () => (/* binding */ sendEmailVerification),\n/* harmony export */   ah: () => (/* binding */ verifyBeforeUpdateEmail),\n/* harmony export */   ai: () => (/* binding */ ActionCodeURL),\n/* harmony export */   aj: () => (/* binding */ parseActionCodeURL),\n/* harmony export */   ak: () => (/* binding */ updateProfile),\n/* harmony export */   al: () => (/* binding */ updateEmail),\n/* harmony export */   am: () => (/* binding */ updatePassword),\n/* harmony export */   an: () => (/* binding */ getIdToken),\n/* harmony export */   ao: () => (/* binding */ getIdTokenResult),\n/* harmony export */   ap: () => (/* binding */ unlink),\n/* harmony export */   aq: () => (/* binding */ getAdditionalUserInfo),\n/* harmony export */   ar: () => (/* binding */ reload),\n/* harmony export */   as: () => (/* binding */ getMultiFactorResolver),\n/* harmony export */   at: () => (/* binding */ multiFactor),\n/* harmony export */   au: () => (/* binding */ _getInstance),\n/* harmony export */   av: () => (/* binding */ _assert),\n/* harmony export */   aw: () => (/* binding */ _signInWithCredential),\n/* harmony export */   ax: () => (/* binding */ _reauthenticate),\n/* harmony export */   ay: () => (/* binding */ _link),\n/* harmony export */   az: () => (/* binding */ signInWithIdp),\n/* harmony export */   b: () => (/* binding */ browserLocalPersistence),\n/* harmony export */   c: () => (/* binding */ signInWithPopup),\n/* harmony export */   d: () => (/* binding */ linkWithPopup),\n/* harmony export */   e: () => (/* binding */ reauthenticateWithPopup),\n/* harmony export */   f: () => (/* binding */ signInWithRedirect),\n/* harmony export */   g: () => (/* binding */ linkWithRedirect),\n/* harmony export */   h: () => (/* binding */ reauthenticateWithRedirect),\n/* harmony export */   i: () => (/* binding */ indexedDBLocalPersistence),\n/* harmony export */   j: () => (/* binding */ getRedirectResult),\n/* harmony export */   k: () => (/* binding */ browserPopupRedirectResolver),\n/* harmony export */   l: () => (/* binding */ linkWithPhoneNumber),\n/* harmony export */   m: () => (/* binding */ PhoneMultiFactorGenerator),\n/* harmony export */   n: () => (/* binding */ TotpSecret),\n/* harmony export */   o: () => (/* binding */ getAuth),\n/* harmony export */   p: () => (/* binding */ ProviderId),\n/* harmony export */   q: () => (/* binding */ setPersistence),\n/* harmony export */   r: () => (/* binding */ reauthenticateWithPhoneNumber),\n/* harmony export */   s: () => (/* binding */ signInWithPhoneNumber),\n/* harmony export */   t: () => (/* binding */ initializeRecaptchaConfig),\n/* harmony export */   u: () => (/* binding */ updatePhoneNumber),\n/* harmony export */   v: () => (/* binding */ validatePassword),\n/* harmony export */   w: () => (/* binding */ onIdTokenChanged),\n/* harmony export */   x: () => (/* binding */ beforeAuthStateChanged),\n/* harmony export */   y: () => (/* binding */ onAuthStateChanged),\n/* harmony export */   z: () => (/* binding */ useDeviceLanguage)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! undici */ \"(ssr)/./node_modules/firebase/node_modules/undici/index.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n\n\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An enum of factors that may be used for multifactor authentication.\r\n *\r\n * @public\r\n */ const FactorId = {\n    /** Phone as second factor */ PHONE: \"phone\",\n    TOTP: \"totp\"\n};\n/**\r\n * Enumeration of supported providers.\r\n *\r\n * @public\r\n */ const ProviderId = {\n    /** Facebook provider ID */ FACEBOOK: \"facebook.com\",\n    /** GitHub provider ID */ GITHUB: \"github.com\",\n    /** Google provider ID */ GOOGLE: \"google.com\",\n    /** Password provider */ PASSWORD: \"password\",\n    /** Phone provider */ PHONE: \"phone\",\n    /** Twitter provider ID */ TWITTER: \"twitter.com\"\n};\n/**\r\n * Enumeration of supported sign-in methods.\r\n *\r\n * @public\r\n */ const SignInMethod = {\n    /** Email link sign in method */ EMAIL_LINK: \"emailLink\",\n    /** Email/password sign in method */ EMAIL_PASSWORD: \"password\",\n    /** Facebook sign in method */ FACEBOOK: \"facebook.com\",\n    /** GitHub sign in method */ GITHUB: \"github.com\",\n    /** Google sign in method */ GOOGLE: \"google.com\",\n    /** Phone sign in method */ PHONE: \"phone\",\n    /** Twitter sign in method */ TWITTER: \"twitter.com\"\n};\n/**\r\n * Enumeration of supported operation types.\r\n *\r\n * @public\r\n */ const OperationType = {\n    /** Operation involving linking an additional provider to an already signed-in user. */ LINK: \"link\",\n    /** Operation involving using a provider to reauthenticate an already signed-in user. */ REAUTHENTICATE: \"reauthenticate\",\n    /** Operation involving signing in a user. */ SIGN_IN: \"signIn\"\n};\n/**\r\n * An enumeration of the possible email action types.\r\n *\r\n * @public\r\n */ const ActionCodeOperation = {\n    /** The email link sign-in action. */ EMAIL_SIGNIN: \"EMAIL_SIGNIN\",\n    /** The password reset action. */ PASSWORD_RESET: \"PASSWORD_RESET\",\n    /** The email revocation action. */ RECOVER_EMAIL: \"RECOVER_EMAIL\",\n    /** The revert second factor addition email action. */ REVERT_SECOND_FACTOR_ADDITION: \"REVERT_SECOND_FACTOR_ADDITION\",\n    /** The revert second factor addition email action. */ VERIFY_AND_CHANGE_EMAIL: \"VERIFY_AND_CHANGE_EMAIL\",\n    /** The email verification action. */ VERIFY_EMAIL: \"VERIFY_EMAIL\"\n};\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function _debugErrorMap() {\n    return {\n        [\"admin-restricted-operation\" /* AuthErrorCode.ADMIN_ONLY_OPERATION */ ]: \"This operation is restricted to administrators only.\",\n        [\"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ ]: \"\",\n        [\"app-not-authorized\" /* AuthErrorCode.APP_NOT_AUTHORIZED */ ]: \"This app, identified by the domain where it's hosted, is not \" + \"authorized to use Firebase Authentication with the provided API key. \" + \"Review your key configuration in the Google API console.\",\n        [\"app-not-installed\" /* AuthErrorCode.APP_NOT_INSTALLED */ ]: \"The requested mobile application corresponding to the identifier (\" + \"Android package name or iOS bundle ID) provided is not installed on \" + \"this device.\",\n        [\"captcha-check-failed\" /* AuthErrorCode.CAPTCHA_CHECK_FAILED */ ]: \"The reCAPTCHA response token provided is either invalid, expired, \" + \"already used or the domain associated with it does not match the list \" + \"of whitelisted domains.\",\n        [\"code-expired\" /* AuthErrorCode.CODE_EXPIRED */ ]: \"The SMS code has expired. Please re-send the verification code to try \" + \"again.\",\n        [\"cordova-not-ready\" /* AuthErrorCode.CORDOVA_NOT_READY */ ]: \"Cordova framework is not ready.\",\n        [\"cors-unsupported\" /* AuthErrorCode.CORS_UNSUPPORTED */ ]: \"This browser is not supported.\",\n        [\"credential-already-in-use\" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */ ]: \"This credential is already associated with a different user account.\",\n        [\"custom-token-mismatch\" /* AuthErrorCode.CREDENTIAL_MISMATCH */ ]: \"The custom token corresponds to a different audience.\",\n        [\"requires-recent-login\" /* AuthErrorCode.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */ ]: \"This operation is sensitive and requires recent authentication. Log in \" + \"again before retrying this request.\",\n        [\"dependent-sdk-initialized-before-auth\" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */ ]: \"Another Firebase SDK was initialized and is trying to use Auth before Auth is \" + \"initialized. Please be sure to call `initializeAuth` or `getAuth` before \" + \"starting any other Firebase SDK.\",\n        [\"dynamic-link-not-activated\" /* AuthErrorCode.DYNAMIC_LINK_NOT_ACTIVATED */ ]: \"Please activate Dynamic Links in the Firebase Console and agree to the terms and \" + \"conditions.\",\n        [\"email-change-needs-verification\" /* AuthErrorCode.EMAIL_CHANGE_NEEDS_VERIFICATION */ ]: \"Multi-factor users must always have a verified email.\",\n        [\"email-already-in-use\" /* AuthErrorCode.EMAIL_EXISTS */ ]: \"The email address is already in use by another account.\",\n        [\"emulator-config-failed\" /* AuthErrorCode.EMULATOR_CONFIG_FAILED */ ]: \"Auth instance has already been used to make a network call. Auth can \" + \"no longer be configured to use the emulator. Try calling \" + '\"connectAuthEmulator()\" sooner.',\n        [\"expired-action-code\" /* AuthErrorCode.EXPIRED_OOB_CODE */ ]: \"The action code has expired.\",\n        [\"cancelled-popup-request\" /* AuthErrorCode.EXPIRED_POPUP_REQUEST */ ]: \"This operation has been cancelled due to another conflicting popup being opened.\",\n        [\"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ ]: \"An internal AuthError has occurred.\",\n        [\"invalid-app-credential\" /* AuthErrorCode.INVALID_APP_CREDENTIAL */ ]: \"The phone verification request contains an invalid application verifier.\" + \" The reCAPTCHA token response is either invalid or expired.\",\n        [\"invalid-app-id\" /* AuthErrorCode.INVALID_APP_ID */ ]: \"The mobile app identifier is not registered for the current project.\",\n        [\"invalid-user-token\" /* AuthErrorCode.INVALID_AUTH */ ]: \"This user's credential isn't valid for this project. This can happen \" + \"if the user's token has been tampered with, or if the user isn't for \" + \"the project associated with this API key.\",\n        [\"invalid-auth-event\" /* AuthErrorCode.INVALID_AUTH_EVENT */ ]: \"An internal AuthError has occurred.\",\n        [\"invalid-verification-code\" /* AuthErrorCode.INVALID_CODE */ ]: \"The SMS verification code used to create the phone auth credential is \" + \"invalid. Please resend the verification code sms and be sure to use the \" + \"verification code provided by the user.\",\n        [\"invalid-continue-uri\" /* AuthErrorCode.INVALID_CONTINUE_URI */ ]: \"The continue URL provided in the request is invalid.\",\n        [\"invalid-cordova-configuration\" /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */ ]: \"The following Cordova plugins must be installed to enable OAuth sign-in: \" + \"cordova-plugin-buildinfo, cordova-universal-links-plugin, \" + \"cordova-plugin-browsertab, cordova-plugin-inappbrowser and \" + \"cordova-plugin-customurlscheme.\",\n        [\"invalid-custom-token\" /* AuthErrorCode.INVALID_CUSTOM_TOKEN */ ]: \"The custom token format is incorrect. Please check the documentation.\",\n        [\"invalid-dynamic-link-domain\" /* AuthErrorCode.INVALID_DYNAMIC_LINK_DOMAIN */ ]: \"The provided dynamic link domain is not configured or authorized for the current project.\",\n        [\"invalid-email\" /* AuthErrorCode.INVALID_EMAIL */ ]: \"The email address is badly formatted.\",\n        [\"invalid-emulator-scheme\" /* AuthErrorCode.INVALID_EMULATOR_SCHEME */ ]: \"Emulator URL must start with a valid scheme (http:// or https://).\",\n        [\"invalid-api-key\" /* AuthErrorCode.INVALID_API_KEY */ ]: \"Your API key is invalid, please check you have copied it correctly.\",\n        [\"invalid-cert-hash\" /* AuthErrorCode.INVALID_CERT_HASH */ ]: \"The SHA-1 certificate hash provided is invalid.\",\n        [\"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */ ]: \"The supplied auth credential is incorrect, malformed or has expired.\",\n        [\"invalid-message-payload\" /* AuthErrorCode.INVALID_MESSAGE_PAYLOAD */ ]: \"The email template corresponding to this action contains invalid characters in its message. \" + \"Please fix by going to the Auth email templates section in the Firebase Console.\",\n        [\"invalid-multi-factor-session\" /* AuthErrorCode.INVALID_MFA_SESSION */ ]: \"The request does not contain a valid proof of first factor successful sign-in.\",\n        [\"invalid-oauth-provider\" /* AuthErrorCode.INVALID_OAUTH_PROVIDER */ ]: \"EmailAuthProvider is not supported for this operation. This operation \" + \"only supports OAuth providers.\",\n        [\"invalid-oauth-client-id\" /* AuthErrorCode.INVALID_OAUTH_CLIENT_ID */ ]: \"The OAuth client ID provided is either invalid or does not match the \" + \"specified API key.\",\n        [\"unauthorized-domain\" /* AuthErrorCode.INVALID_ORIGIN */ ]: \"This domain is not authorized for OAuth operations for your Firebase \" + \"project. Edit the list of authorized domains from the Firebase console.\",\n        [\"invalid-action-code\" /* AuthErrorCode.INVALID_OOB_CODE */ ]: \"The action code is invalid. This can happen if the code is malformed, \" + \"expired, or has already been used.\",\n        [\"wrong-password\" /* AuthErrorCode.INVALID_PASSWORD */ ]: \"The password is invalid or the user does not have a password.\",\n        [\"invalid-persistence-type\" /* AuthErrorCode.INVALID_PERSISTENCE */ ]: \"The specified persistence type is invalid. It can only be local, session or none.\",\n        [\"invalid-phone-number\" /* AuthErrorCode.INVALID_PHONE_NUMBER */ ]: \"The format of the phone number provided is incorrect. Please enter the \" + \"phone number in a format that can be parsed into E.164 format. E.164 \" + \"phone numbers are written in the format [+][country code][subscriber \" + \"number including area code].\",\n        [\"invalid-provider-id\" /* AuthErrorCode.INVALID_PROVIDER_ID */ ]: \"The specified provider ID is invalid.\",\n        [\"invalid-recipient-email\" /* AuthErrorCode.INVALID_RECIPIENT_EMAIL */ ]: \"The email corresponding to this action failed to send as the provided \" + \"recipient email address is invalid.\",\n        [\"invalid-sender\" /* AuthErrorCode.INVALID_SENDER */ ]: \"The email template corresponding to this action contains an invalid sender email or name. \" + \"Please fix by going to the Auth email templates section in the Firebase Console.\",\n        [\"invalid-verification-id\" /* AuthErrorCode.INVALID_SESSION_INFO */ ]: \"The verification ID used to create the phone auth credential is invalid.\",\n        [\"invalid-tenant-id\" /* AuthErrorCode.INVALID_TENANT_ID */ ]: \"The Auth instance's tenant ID is invalid.\",\n        [\"login-blocked\" /* AuthErrorCode.LOGIN_BLOCKED */ ]: \"Login blocked by user-provided method: {$originalMessage}\",\n        [\"missing-android-pkg-name\" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */ ]: \"An Android Package Name must be provided if the Android App is required to be installed.\",\n        [\"auth-domain-config-required\" /* AuthErrorCode.MISSING_AUTH_DOMAIN */ ]: \"Be sure to include authDomain when calling firebase.initializeApp(), \" + \"by following the instructions in the Firebase console.\",\n        [\"missing-app-credential\" /* AuthErrorCode.MISSING_APP_CREDENTIAL */ ]: \"The phone verification request is missing an application verifier \" + \"assertion. A reCAPTCHA response token needs to be provided.\",\n        [\"missing-verification-code\" /* AuthErrorCode.MISSING_CODE */ ]: \"The phone auth credential was created with an empty SMS verification code.\",\n        [\"missing-continue-uri\" /* AuthErrorCode.MISSING_CONTINUE_URI */ ]: \"A continue URL must be provided in the request.\",\n        [\"missing-iframe-start\" /* AuthErrorCode.MISSING_IFRAME_START */ ]: \"An internal AuthError has occurred.\",\n        [\"missing-ios-bundle-id\" /* AuthErrorCode.MISSING_IOS_BUNDLE_ID */ ]: \"An iOS Bundle ID must be provided if an App Store ID is provided.\",\n        [\"missing-or-invalid-nonce\" /* AuthErrorCode.MISSING_OR_INVALID_NONCE */ ]: \"The request does not contain a valid nonce. This can occur if the \" + \"SHA-256 hash of the provided raw nonce does not match the hashed nonce \" + \"in the ID token payload.\",\n        [\"missing-password\" /* AuthErrorCode.MISSING_PASSWORD */ ]: \"A non-empty password must be provided\",\n        [\"missing-multi-factor-info\" /* AuthErrorCode.MISSING_MFA_INFO */ ]: \"No second factor identifier is provided.\",\n        [\"missing-multi-factor-session\" /* AuthErrorCode.MISSING_MFA_SESSION */ ]: \"The request is missing proof of first factor successful sign-in.\",\n        [\"missing-phone-number\" /* AuthErrorCode.MISSING_PHONE_NUMBER */ ]: \"To send verification codes, provide a phone number for the recipient.\",\n        [\"missing-verification-id\" /* AuthErrorCode.MISSING_SESSION_INFO */ ]: \"The phone auth credential was created with an empty verification ID.\",\n        [\"app-deleted\" /* AuthErrorCode.MODULE_DESTROYED */ ]: \"This instance of FirebaseApp has been deleted.\",\n        [\"multi-factor-info-not-found\" /* AuthErrorCode.MFA_INFO_NOT_FOUND */ ]: \"The user does not have a second factor matching the identifier provided.\",\n        [\"multi-factor-auth-required\" /* AuthErrorCode.MFA_REQUIRED */ ]: \"Proof of ownership of a second factor is required to complete sign-in.\",\n        [\"account-exists-with-different-credential\" /* AuthErrorCode.NEED_CONFIRMATION */ ]: \"An account already exists with the same email address but different \" + \"sign-in credentials. Sign in using a provider associated with this \" + \"email address.\",\n        [\"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */ ]: \"A network AuthError (such as timeout, interrupted connection or unreachable host) has occurred.\",\n        [\"no-auth-event\" /* AuthErrorCode.NO_AUTH_EVENT */ ]: \"An internal AuthError has occurred.\",\n        [\"no-such-provider\" /* AuthErrorCode.NO_SUCH_PROVIDER */ ]: \"User was not linked to an account with the given provider.\",\n        [\"null-user\" /* AuthErrorCode.NULL_USER */ ]: \"A null user object was provided as the argument for an operation which \" + \"requires a non-null user object.\",\n        [\"operation-not-allowed\" /* AuthErrorCode.OPERATION_NOT_ALLOWED */ ]: \"The given sign-in provider is disabled for this Firebase project. \" + \"Enable it in the Firebase console, under the sign-in method tab of the \" + \"Auth section.\",\n        [\"operation-not-supported-in-this-environment\" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */ ]: \"This operation is not supported in the environment this application is \" + 'running on. \"location.protocol\" must be http, https or chrome-extension' + \" and web storage must be enabled.\",\n        [\"popup-blocked\" /* AuthErrorCode.POPUP_BLOCKED */ ]: \"Unable to establish a connection with the popup. It may have been blocked by the browser.\",\n        [\"popup-closed-by-user\" /* AuthErrorCode.POPUP_CLOSED_BY_USER */ ]: \"The popup has been closed by the user before finalizing the operation.\",\n        [\"provider-already-linked\" /* AuthErrorCode.PROVIDER_ALREADY_LINKED */ ]: \"User can only be linked to one identity for the given provider.\",\n        [\"quota-exceeded\" /* AuthErrorCode.QUOTA_EXCEEDED */ ]: \"The project's quota for this operation has been exceeded.\",\n        [\"redirect-cancelled-by-user\" /* AuthErrorCode.REDIRECT_CANCELLED_BY_USER */ ]: \"The redirect operation has been cancelled by the user before finalizing.\",\n        [\"redirect-operation-pending\" /* AuthErrorCode.REDIRECT_OPERATION_PENDING */ ]: \"A redirect sign-in operation is already pending.\",\n        [\"rejected-credential\" /* AuthErrorCode.REJECTED_CREDENTIAL */ ]: \"The request contains malformed or mismatching credentials.\",\n        [\"second-factor-already-in-use\" /* AuthErrorCode.SECOND_FACTOR_ALREADY_ENROLLED */ ]: \"The second factor is already enrolled on this account.\",\n        [\"maximum-second-factor-count-exceeded\" /* AuthErrorCode.SECOND_FACTOR_LIMIT_EXCEEDED */ ]: \"The maximum allowed number of second factors on a user has been exceeded.\",\n        [\"tenant-id-mismatch\" /* AuthErrorCode.TENANT_ID_MISMATCH */ ]: \"The provided tenant ID does not match the Auth instance's tenant ID\",\n        [\"timeout\" /* AuthErrorCode.TIMEOUT */ ]: \"The operation has timed out.\",\n        [\"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */ ]: \"The user's credential is no longer valid. The user must sign in again.\",\n        [\"too-many-requests\" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */ ]: \"We have blocked all requests from this device due to unusual activity. \" + \"Try again later.\",\n        [\"unauthorized-continue-uri\" /* AuthErrorCode.UNAUTHORIZED_DOMAIN */ ]: \"The domain of the continue URL is not whitelisted.  Please whitelist \" + \"the domain in the Firebase console.\",\n        [\"unsupported-first-factor\" /* AuthErrorCode.UNSUPPORTED_FIRST_FACTOR */ ]: \"Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.\",\n        [\"unsupported-persistence-type\" /* AuthErrorCode.UNSUPPORTED_PERSISTENCE */ ]: \"The current environment does not support the specified persistence type.\",\n        [\"unsupported-tenant-operation\" /* AuthErrorCode.UNSUPPORTED_TENANT_OPERATION */ ]: \"This operation is not supported in a multi-tenant context.\",\n        [\"unverified-email\" /* AuthErrorCode.UNVERIFIED_EMAIL */ ]: \"The operation requires a verified email.\",\n        [\"user-cancelled\" /* AuthErrorCode.USER_CANCELLED */ ]: \"The user did not grant your application the permissions it requested.\",\n        [\"user-not-found\" /* AuthErrorCode.USER_DELETED */ ]: \"There is no user record corresponding to this identifier. The user may \" + \"have been deleted.\",\n        [\"user-disabled\" /* AuthErrorCode.USER_DISABLED */ ]: \"The user account has been disabled by an administrator.\",\n        [\"user-mismatch\" /* AuthErrorCode.USER_MISMATCH */ ]: \"The supplied credentials do not correspond to the previously signed in user.\",\n        [\"user-signed-out\" /* AuthErrorCode.USER_SIGNED_OUT */ ]: \"\",\n        [\"weak-password\" /* AuthErrorCode.WEAK_PASSWORD */ ]: \"The password must be 6 characters long or more.\",\n        [\"web-storage-unsupported\" /* AuthErrorCode.WEB_STORAGE_UNSUPPORTED */ ]: \"This browser is not supported or 3rd party cookies and data may be disabled.\",\n        [\"already-initialized\" /* AuthErrorCode.ALREADY_INITIALIZED */ ]: \"initializeAuth() has already been called with \" + \"different options. To avoid this error, call initializeAuth() with the \" + \"same options as when it was originally called, or call getAuth() to return the\" + \" already initialized instance.\",\n        [\"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */ ]: \"The reCAPTCHA token is missing when sending request to the backend.\",\n        [\"invalid-recaptcha-token\" /* AuthErrorCode.INVALID_RECAPTCHA_TOKEN */ ]: \"The reCAPTCHA token is invalid when sending request to the backend.\",\n        [\"invalid-recaptcha-action\" /* AuthErrorCode.INVALID_RECAPTCHA_ACTION */ ]: \"The reCAPTCHA action is invalid when sending request to the backend.\",\n        [\"recaptcha-not-enabled\" /* AuthErrorCode.RECAPTCHA_NOT_ENABLED */ ]: \"reCAPTCHA Enterprise integration is not enabled for this project.\",\n        [\"missing-client-type\" /* AuthErrorCode.MISSING_CLIENT_TYPE */ ]: \"The reCAPTCHA client type is missing when sending request to the backend.\",\n        [\"missing-recaptcha-version\" /* AuthErrorCode.MISSING_RECAPTCHA_VERSION */ ]: \"The reCAPTCHA version is missing when sending request to the backend.\",\n        [\"invalid-req-type\" /* AuthErrorCode.INVALID_REQ_TYPE */ ]: \"Invalid request parameters.\",\n        [\"invalid-recaptcha-version\" /* AuthErrorCode.INVALID_RECAPTCHA_VERSION */ ]: \"The reCAPTCHA version is invalid when sending request to the backend.\",\n        [\"unsupported-password-policy-schema-version\" /* AuthErrorCode.UNSUPPORTED_PASSWORD_POLICY_SCHEMA_VERSION */ ]: \"The password policy received from the backend uses a schema version that is not supported by this version of the Firebase SDK.\",\n        [\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */ ]: \"The password does not meet the requirements.\"\n    };\n}\nfunction _prodErrorMap() {\n    // We will include this one message in the prod error map since by the very\n    // nature of this error, developers will never be able to see the message\n    // using the debugErrorMap (which is installed during auth initialization).\n    return {\n        [\"dependent-sdk-initialized-before-auth\" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */ ]: \"Another Firebase SDK was initialized and is trying to use Auth before Auth is \" + \"initialized. Please be sure to call `initializeAuth` or `getAuth` before \" + \"starting any other Firebase SDK.\"\n    };\n}\n/**\r\n * A verbose error map with detailed descriptions for most error codes.\r\n *\r\n * See discussion at {@link AuthErrorMap}\r\n *\r\n * @public\r\n */ const debugErrorMap = _debugErrorMap;\n/**\r\n * A minimal error map with all verbose error messages stripped.\r\n *\r\n * See discussion at {@link AuthErrorMap}\r\n *\r\n * @public\r\n */ const prodErrorMap = _prodErrorMap;\nconst _DEFAULT_AUTH_ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.ErrorFactory(\"auth\", \"Firebase\", _prodErrorMap());\n/**\r\n * A map of potential `Auth` error codes, for easier comparison with errors\r\n * thrown by the SDK.\r\n *\r\n * @remarks\r\n * Note that you can't tree-shake individual keys\r\n * in the map, so by using the map you might substantially increase your\r\n * bundle size.\r\n *\r\n * @public\r\n */ const AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY = {\n    ADMIN_ONLY_OPERATION: \"auth/admin-restricted-operation\",\n    ARGUMENT_ERROR: \"auth/argument-error\",\n    APP_NOT_AUTHORIZED: \"auth/app-not-authorized\",\n    APP_NOT_INSTALLED: \"auth/app-not-installed\",\n    CAPTCHA_CHECK_FAILED: \"auth/captcha-check-failed\",\n    CODE_EXPIRED: \"auth/code-expired\",\n    CORDOVA_NOT_READY: \"auth/cordova-not-ready\",\n    CORS_UNSUPPORTED: \"auth/cors-unsupported\",\n    CREDENTIAL_ALREADY_IN_USE: \"auth/credential-already-in-use\",\n    CREDENTIAL_MISMATCH: \"auth/custom-token-mismatch\",\n    CREDENTIAL_TOO_OLD_LOGIN_AGAIN: \"auth/requires-recent-login\",\n    DEPENDENT_SDK_INIT_BEFORE_AUTH: \"auth/dependent-sdk-initialized-before-auth\",\n    DYNAMIC_LINK_NOT_ACTIVATED: \"auth/dynamic-link-not-activated\",\n    EMAIL_CHANGE_NEEDS_VERIFICATION: \"auth/email-change-needs-verification\",\n    EMAIL_EXISTS: \"auth/email-already-in-use\",\n    EMULATOR_CONFIG_FAILED: \"auth/emulator-config-failed\",\n    EXPIRED_OOB_CODE: \"auth/expired-action-code\",\n    EXPIRED_POPUP_REQUEST: \"auth/cancelled-popup-request\",\n    INTERNAL_ERROR: \"auth/internal-error\",\n    INVALID_API_KEY: \"auth/invalid-api-key\",\n    INVALID_APP_CREDENTIAL: \"auth/invalid-app-credential\",\n    INVALID_APP_ID: \"auth/invalid-app-id\",\n    INVALID_AUTH: \"auth/invalid-user-token\",\n    INVALID_AUTH_EVENT: \"auth/invalid-auth-event\",\n    INVALID_CERT_HASH: \"auth/invalid-cert-hash\",\n    INVALID_CODE: \"auth/invalid-verification-code\",\n    INVALID_CONTINUE_URI: \"auth/invalid-continue-uri\",\n    INVALID_CORDOVA_CONFIGURATION: \"auth/invalid-cordova-configuration\",\n    INVALID_CUSTOM_TOKEN: \"auth/invalid-custom-token\",\n    INVALID_DYNAMIC_LINK_DOMAIN: \"auth/invalid-dynamic-link-domain\",\n    INVALID_EMAIL: \"auth/invalid-email\",\n    INVALID_EMULATOR_SCHEME: \"auth/invalid-emulator-scheme\",\n    INVALID_IDP_RESPONSE: \"auth/invalid-credential\",\n    INVALID_LOGIN_CREDENTIALS: \"auth/invalid-credential\",\n    INVALID_MESSAGE_PAYLOAD: \"auth/invalid-message-payload\",\n    INVALID_MFA_SESSION: \"auth/invalid-multi-factor-session\",\n    INVALID_OAUTH_CLIENT_ID: \"auth/invalid-oauth-client-id\",\n    INVALID_OAUTH_PROVIDER: \"auth/invalid-oauth-provider\",\n    INVALID_OOB_CODE: \"auth/invalid-action-code\",\n    INVALID_ORIGIN: \"auth/unauthorized-domain\",\n    INVALID_PASSWORD: \"auth/wrong-password\",\n    INVALID_PERSISTENCE: \"auth/invalid-persistence-type\",\n    INVALID_PHONE_NUMBER: \"auth/invalid-phone-number\",\n    INVALID_PROVIDER_ID: \"auth/invalid-provider-id\",\n    INVALID_RECIPIENT_EMAIL: \"auth/invalid-recipient-email\",\n    INVALID_SENDER: \"auth/invalid-sender\",\n    INVALID_SESSION_INFO: \"auth/invalid-verification-id\",\n    INVALID_TENANT_ID: \"auth/invalid-tenant-id\",\n    MFA_INFO_NOT_FOUND: \"auth/multi-factor-info-not-found\",\n    MFA_REQUIRED: \"auth/multi-factor-auth-required\",\n    MISSING_ANDROID_PACKAGE_NAME: \"auth/missing-android-pkg-name\",\n    MISSING_APP_CREDENTIAL: \"auth/missing-app-credential\",\n    MISSING_AUTH_DOMAIN: \"auth/auth-domain-config-required\",\n    MISSING_CODE: \"auth/missing-verification-code\",\n    MISSING_CONTINUE_URI: \"auth/missing-continue-uri\",\n    MISSING_IFRAME_START: \"auth/missing-iframe-start\",\n    MISSING_IOS_BUNDLE_ID: \"auth/missing-ios-bundle-id\",\n    MISSING_OR_INVALID_NONCE: \"auth/missing-or-invalid-nonce\",\n    MISSING_MFA_INFO: \"auth/missing-multi-factor-info\",\n    MISSING_MFA_SESSION: \"auth/missing-multi-factor-session\",\n    MISSING_PHONE_NUMBER: \"auth/missing-phone-number\",\n    MISSING_SESSION_INFO: \"auth/missing-verification-id\",\n    MODULE_DESTROYED: \"auth/app-deleted\",\n    NEED_CONFIRMATION: \"auth/account-exists-with-different-credential\",\n    NETWORK_REQUEST_FAILED: \"auth/network-request-failed\",\n    NULL_USER: \"auth/null-user\",\n    NO_AUTH_EVENT: \"auth/no-auth-event\",\n    NO_SUCH_PROVIDER: \"auth/no-such-provider\",\n    OPERATION_NOT_ALLOWED: \"auth/operation-not-allowed\",\n    OPERATION_NOT_SUPPORTED: \"auth/operation-not-supported-in-this-environment\",\n    POPUP_BLOCKED: \"auth/popup-blocked\",\n    POPUP_CLOSED_BY_USER: \"auth/popup-closed-by-user\",\n    PROVIDER_ALREADY_LINKED: \"auth/provider-already-linked\",\n    QUOTA_EXCEEDED: \"auth/quota-exceeded\",\n    REDIRECT_CANCELLED_BY_USER: \"auth/redirect-cancelled-by-user\",\n    REDIRECT_OPERATION_PENDING: \"auth/redirect-operation-pending\",\n    REJECTED_CREDENTIAL: \"auth/rejected-credential\",\n    SECOND_FACTOR_ALREADY_ENROLLED: \"auth/second-factor-already-in-use\",\n    SECOND_FACTOR_LIMIT_EXCEEDED: \"auth/maximum-second-factor-count-exceeded\",\n    TENANT_ID_MISMATCH: \"auth/tenant-id-mismatch\",\n    TIMEOUT: \"auth/timeout\",\n    TOKEN_EXPIRED: \"auth/user-token-expired\",\n    TOO_MANY_ATTEMPTS_TRY_LATER: \"auth/too-many-requests\",\n    UNAUTHORIZED_DOMAIN: \"auth/unauthorized-continue-uri\",\n    UNSUPPORTED_FIRST_FACTOR: \"auth/unsupported-first-factor\",\n    UNSUPPORTED_PERSISTENCE: \"auth/unsupported-persistence-type\",\n    UNSUPPORTED_TENANT_OPERATION: \"auth/unsupported-tenant-operation\",\n    UNVERIFIED_EMAIL: \"auth/unverified-email\",\n    USER_CANCELLED: \"auth/user-cancelled\",\n    USER_DELETED: \"auth/user-not-found\",\n    USER_DISABLED: \"auth/user-disabled\",\n    USER_MISMATCH: \"auth/user-mismatch\",\n    USER_SIGNED_OUT: \"auth/user-signed-out\",\n    WEAK_PASSWORD: \"auth/weak-password\",\n    WEB_STORAGE_UNSUPPORTED: \"auth/web-storage-unsupported\",\n    ALREADY_INITIALIZED: \"auth/already-initialized\",\n    RECAPTCHA_NOT_ENABLED: \"auth/recaptcha-not-enabled\",\n    MISSING_RECAPTCHA_TOKEN: \"auth/missing-recaptcha-token\",\n    INVALID_RECAPTCHA_TOKEN: \"auth/invalid-recaptcha-token\",\n    INVALID_RECAPTCHA_ACTION: \"auth/invalid-recaptcha-action\",\n    MISSING_CLIENT_TYPE: \"auth/missing-client-type\",\n    MISSING_RECAPTCHA_VERSION: \"auth/missing-recaptcha-version\",\n    INVALID_RECAPTCHA_VERSION: \"auth/invalid-recaptcha-version\",\n    INVALID_REQ_TYPE: \"auth/invalid-req-type\"\n};\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const logClient = new _firebase_logger__WEBPACK_IMPORTED_MODULE_4__.Logger(\"@firebase/auth\");\nfunction _logWarn(msg, ...args) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.WARN) {\n        logClient.warn(`Auth (${_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION}): ${msg}`, ...args);\n    }\n}\nfunction _logError(msg, ...args) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.ERROR) {\n        logClient.error(`Auth (${_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION}): ${msg}`, ...args);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function _fail(authOrCode, ...rest) {\n    throw createErrorInternal(authOrCode, ...rest);\n}\nfunction _createError(authOrCode, ...rest) {\n    return createErrorInternal(authOrCode, ...rest);\n}\nfunction _errorWithCustomMessage(auth, code, message) {\n    const errorMap = Object.assign(Object.assign({}, prodErrorMap()), {\n        [code]: message\n    });\n    const factory = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.ErrorFactory(\"auth\", \"Firebase\", errorMap);\n    return factory.create(code, {\n        appName: auth.name\n    });\n}\nfunction _serverAppCurrentUserOperationNotSupportedError(auth) {\n    return _errorWithCustomMessage(auth, \"operation-not-supported-in-this-environment\" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */ , \"Operations that alter the current user are not supported in conjunction with FirebaseServerApp\");\n}\nfunction createErrorInternal(authOrCode, ...rest) {\n    if (typeof authOrCode !== \"string\") {\n        const code = rest[0];\n        const fullParams = [\n            ...rest.slice(1)\n        ];\n        if (fullParams[0]) {\n            fullParams[0].appName = authOrCode.name;\n        }\n        return authOrCode._errorFactory.create(code, ...fullParams);\n    }\n    return _DEFAULT_AUTH_ERROR_FACTORY.create(authOrCode, ...rest);\n}\nfunction _assert(assertion, authOrCode, ...rest) {\n    if (!assertion) {\n        throw createErrorInternal(authOrCode, ...rest);\n    }\n}\n/**\r\n * Unconditionally fails, throwing an internal error with the given message.\r\n *\r\n * @param failure type of failure encountered\r\n * @throws Error\r\n */ function debugFail(failure) {\n    // Log the failure in addition to throw an exception, just in case the\n    // exception is swallowed.\n    const message = `INTERNAL ASSERTION FAILED: ` + failure;\n    _logError(message);\n    // NOTE: We don't use FirebaseError here because these are internal failures\n    // that cannot be handled by the user. (Also it would create a circular\n    // dependency between the error and assert modules which doesn't work.)\n    throw new Error(message);\n}\n/**\r\n * Fails if the given assertion condition is false, throwing an Error with the\r\n * given message if it did.\r\n *\r\n * @param assertion\r\n * @param message\r\n */ function debugAssert(assertion, message) {\n    if (!assertion) {\n        debugFail(message);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function _getCurrentUrl() {\n    var _a;\n    return typeof self !== \"undefined\" && ((_a = self.location) === null || _a === void 0 ? void 0 : _a.href) || \"\";\n}\nfunction _isHttpOrHttps() {\n    return _getCurrentScheme() === \"http:\" || _getCurrentScheme() === \"https:\";\n}\nfunction _getCurrentScheme() {\n    var _a;\n    return typeof self !== \"undefined\" && ((_a = self.location) === null || _a === void 0 ? void 0 : _a.protocol) || null;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Determine whether the browser is working online\r\n */ function _isOnline() {\n    if (typeof navigator !== \"undefined\" && navigator && \"onLine\" in navigator && typeof navigator.onLine === \"boolean\" && // Apply only for traditional web apps and Chrome extensions.\n    // This is especially true for Cordova apps which have unreliable\n    // navigator.onLine behavior unless cordova-plugin-network-information is\n    // installed which overwrites the native navigator.onLine value and\n    // defines navigator.connection.\n    (_isHttpOrHttps() || (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isBrowserExtension)() || \"connection\" in navigator)) {\n        return navigator.onLine;\n    }\n    // If we can't determine the state, assume it is online.\n    return true;\n}\nfunction _getUserLanguage() {\n    if (typeof navigator === \"undefined\") {\n        return null;\n    }\n    const navigatorLanguage = navigator;\n    return(// Most reliable, but only supported in Chrome/Firefox.\n    navigatorLanguage.languages && navigatorLanguage.languages[0] || // Supported in most browsers, but returns the language of the browser\n    // UI, not the language set in browser settings.\n    navigatorLanguage.language || // Couldn't determine language.\n    null);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A structure to help pick between a range of long and short delay durations\r\n * depending on the current environment. In general, the long delay is used for\r\n * mobile environments whereas short delays are used for desktop environments.\r\n */ class Delay {\n    constructor(shortDelay, longDelay){\n        this.shortDelay = shortDelay;\n        this.longDelay = longDelay;\n        // Internal error when improperly initialized.\n        debugAssert(longDelay > shortDelay, \"Short delay should be less than long delay!\");\n        this.isMobile = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isMobileCordova)() || (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isReactNative)();\n    }\n    get() {\n        if (!_isOnline()) {\n            // Pick the shorter timeout.\n            return Math.min(5000 /* DelayMin.OFFLINE */ , this.shortDelay);\n        }\n        // If running in a mobile environment, return the long delay, otherwise\n        // return the short delay.\n        // This could be improved in the future to dynamically change based on other\n        // variables instead of just reading the current environment.\n        return this.isMobile ? this.longDelay : this.shortDelay;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function _emulatorUrl(config, path) {\n    debugAssert(config.emulator, \"Emulator should always be set here\");\n    const { url } = config.emulator;\n    if (!path) {\n        return url;\n    }\n    return `${url}${path.startsWith(\"/\") ? path.slice(1) : path}`;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class FetchProvider {\n    static initialize(fetchImpl, headersImpl, responseImpl) {\n        this.fetchImpl = fetchImpl;\n        if (headersImpl) {\n            this.headersImpl = headersImpl;\n        }\n        if (responseImpl) {\n            this.responseImpl = responseImpl;\n        }\n    }\n    static fetch() {\n        if (this.fetchImpl) {\n            return this.fetchImpl;\n        }\n        if (typeof self !== \"undefined\" && \"fetch\" in self) {\n            return self.fetch;\n        }\n        if (typeof globalThis !== \"undefined\" && globalThis.fetch) {\n            return globalThis.fetch;\n        }\n        if (typeof fetch !== \"undefined\") {\n            return fetch;\n        }\n        debugFail(\"Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill\");\n    }\n    static headers() {\n        if (this.headersImpl) {\n            return this.headersImpl;\n        }\n        if (typeof self !== \"undefined\" && \"Headers\" in self) {\n            return self.Headers;\n        }\n        if (typeof globalThis !== \"undefined\" && globalThis.Headers) {\n            return globalThis.Headers;\n        }\n        if (typeof Headers !== \"undefined\") {\n            return Headers;\n        }\n        debugFail(\"Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill\");\n    }\n    static response() {\n        if (this.responseImpl) {\n            return this.responseImpl;\n        }\n        if (typeof self !== \"undefined\" && \"Response\" in self) {\n            return self.Response;\n        }\n        if (typeof globalThis !== \"undefined\" && globalThis.Response) {\n            return globalThis.Response;\n        }\n        if (typeof Response !== \"undefined\") {\n            return Response;\n        }\n        debugFail(\"Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill\");\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Map from errors returned by the server to errors to developer visible errors\r\n */ const SERVER_ERROR_MAP = {\n    // Custom token errors.\n    [\"CREDENTIAL_MISMATCH\" /* ServerError.CREDENTIAL_MISMATCH */ ]: \"custom-token-mismatch\" /* AuthErrorCode.CREDENTIAL_MISMATCH */ ,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_CUSTOM_TOKEN\" /* ServerError.MISSING_CUSTOM_TOKEN */ ]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ ,\n    // Create Auth URI errors.\n    [\"INVALID_IDENTIFIER\" /* ServerError.INVALID_IDENTIFIER */ ]: \"invalid-email\" /* AuthErrorCode.INVALID_EMAIL */ ,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_CONTINUE_URI\" /* ServerError.MISSING_CONTINUE_URI */ ]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ ,\n    // Sign in with email and password errors (some apply to sign up too).\n    [\"INVALID_PASSWORD\" /* ServerError.INVALID_PASSWORD */ ]: \"wrong-password\" /* AuthErrorCode.INVALID_PASSWORD */ ,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_PASSWORD\" /* ServerError.MISSING_PASSWORD */ ]: \"missing-password\" /* AuthErrorCode.MISSING_PASSWORD */ ,\n    // Thrown if Email Enumeration Protection is enabled in the project and the email or password is\n    // invalid.\n    [\"INVALID_LOGIN_CREDENTIALS\" /* ServerError.INVALID_LOGIN_CREDENTIALS */ ]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */ ,\n    // Sign up with email and password errors.\n    [\"EMAIL_EXISTS\" /* ServerError.EMAIL_EXISTS */ ]: \"email-already-in-use\" /* AuthErrorCode.EMAIL_EXISTS */ ,\n    [\"PASSWORD_LOGIN_DISABLED\" /* ServerError.PASSWORD_LOGIN_DISABLED */ ]: \"operation-not-allowed\" /* AuthErrorCode.OPERATION_NOT_ALLOWED */ ,\n    // Verify assertion for sign in with credential errors:\n    [\"INVALID_IDP_RESPONSE\" /* ServerError.INVALID_IDP_RESPONSE */ ]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */ ,\n    [\"INVALID_PENDING_TOKEN\" /* ServerError.INVALID_PENDING_TOKEN */ ]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */ ,\n    [\"FEDERATED_USER_ID_ALREADY_LINKED\" /* ServerError.FEDERATED_USER_ID_ALREADY_LINKED */ ]: \"credential-already-in-use\" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */ ,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_REQ_TYPE\" /* ServerError.MISSING_REQ_TYPE */ ]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ ,\n    // Send Password reset email errors:\n    [\"EMAIL_NOT_FOUND\" /* ServerError.EMAIL_NOT_FOUND */ ]: \"user-not-found\" /* AuthErrorCode.USER_DELETED */ ,\n    [\"RESET_PASSWORD_EXCEED_LIMIT\" /* ServerError.RESET_PASSWORD_EXCEED_LIMIT */ ]: \"too-many-requests\" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */ ,\n    [\"EXPIRED_OOB_CODE\" /* ServerError.EXPIRED_OOB_CODE */ ]: \"expired-action-code\" /* AuthErrorCode.EXPIRED_OOB_CODE */ ,\n    [\"INVALID_OOB_CODE\" /* ServerError.INVALID_OOB_CODE */ ]: \"invalid-action-code\" /* AuthErrorCode.INVALID_OOB_CODE */ ,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_OOB_CODE\" /* ServerError.MISSING_OOB_CODE */ ]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ ,\n    // Operations that require ID token in request:\n    [\"CREDENTIAL_TOO_OLD_LOGIN_AGAIN\" /* ServerError.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */ ]: \"requires-recent-login\" /* AuthErrorCode.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */ ,\n    [\"INVALID_ID_TOKEN\" /* ServerError.INVALID_ID_TOKEN */ ]: \"invalid-user-token\" /* AuthErrorCode.INVALID_AUTH */ ,\n    [\"TOKEN_EXPIRED\" /* ServerError.TOKEN_EXPIRED */ ]: \"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */ ,\n    [\"USER_NOT_FOUND\" /* ServerError.USER_NOT_FOUND */ ]: \"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */ ,\n    // Other errors.\n    [\"TOO_MANY_ATTEMPTS_TRY_LATER\" /* ServerError.TOO_MANY_ATTEMPTS_TRY_LATER */ ]: \"too-many-requests\" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */ ,\n    [\"PASSWORD_DOES_NOT_MEET_REQUIREMENTS\" /* ServerError.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */ ]: \"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */ ,\n    // Phone Auth related errors.\n    [\"INVALID_CODE\" /* ServerError.INVALID_CODE */ ]: \"invalid-verification-code\" /* AuthErrorCode.INVALID_CODE */ ,\n    [\"INVALID_SESSION_INFO\" /* ServerError.INVALID_SESSION_INFO */ ]: \"invalid-verification-id\" /* AuthErrorCode.INVALID_SESSION_INFO */ ,\n    [\"INVALID_TEMPORARY_PROOF\" /* ServerError.INVALID_TEMPORARY_PROOF */ ]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */ ,\n    [\"MISSING_SESSION_INFO\" /* ServerError.MISSING_SESSION_INFO */ ]: \"missing-verification-id\" /* AuthErrorCode.MISSING_SESSION_INFO */ ,\n    [\"SESSION_EXPIRED\" /* ServerError.SESSION_EXPIRED */ ]: \"code-expired\" /* AuthErrorCode.CODE_EXPIRED */ ,\n    // Other action code errors when additional settings passed.\n    // MISSING_CONTINUE_URI is getting mapped to INTERNAL_ERROR above.\n    // This is OK as this error will be caught by client side validation.\n    [\"MISSING_ANDROID_PACKAGE_NAME\" /* ServerError.MISSING_ANDROID_PACKAGE_NAME */ ]: \"missing-android-pkg-name\" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */ ,\n    [\"UNAUTHORIZED_DOMAIN\" /* ServerError.UNAUTHORIZED_DOMAIN */ ]: \"unauthorized-continue-uri\" /* AuthErrorCode.UNAUTHORIZED_DOMAIN */ ,\n    // getProjectConfig errors when clientId is passed.\n    [\"INVALID_OAUTH_CLIENT_ID\" /* ServerError.INVALID_OAUTH_CLIENT_ID */ ]: \"invalid-oauth-client-id\" /* AuthErrorCode.INVALID_OAUTH_CLIENT_ID */ ,\n    // User actions (sign-up or deletion) disabled errors.\n    [\"ADMIN_ONLY_OPERATION\" /* ServerError.ADMIN_ONLY_OPERATION */ ]: \"admin-restricted-operation\" /* AuthErrorCode.ADMIN_ONLY_OPERATION */ ,\n    // Multi factor related errors.\n    [\"INVALID_MFA_PENDING_CREDENTIAL\" /* ServerError.INVALID_MFA_PENDING_CREDENTIAL */ ]: \"invalid-multi-factor-session\" /* AuthErrorCode.INVALID_MFA_SESSION */ ,\n    [\"MFA_ENROLLMENT_NOT_FOUND\" /* ServerError.MFA_ENROLLMENT_NOT_FOUND */ ]: \"multi-factor-info-not-found\" /* AuthErrorCode.MFA_INFO_NOT_FOUND */ ,\n    [\"MISSING_MFA_ENROLLMENT_ID\" /* ServerError.MISSING_MFA_ENROLLMENT_ID */ ]: \"missing-multi-factor-info\" /* AuthErrorCode.MISSING_MFA_INFO */ ,\n    [\"MISSING_MFA_PENDING_CREDENTIAL\" /* ServerError.MISSING_MFA_PENDING_CREDENTIAL */ ]: \"missing-multi-factor-session\" /* AuthErrorCode.MISSING_MFA_SESSION */ ,\n    [\"SECOND_FACTOR_EXISTS\" /* ServerError.SECOND_FACTOR_EXISTS */ ]: \"second-factor-already-in-use\" /* AuthErrorCode.SECOND_FACTOR_ALREADY_ENROLLED */ ,\n    [\"SECOND_FACTOR_LIMIT_EXCEEDED\" /* ServerError.SECOND_FACTOR_LIMIT_EXCEEDED */ ]: \"maximum-second-factor-count-exceeded\" /* AuthErrorCode.SECOND_FACTOR_LIMIT_EXCEEDED */ ,\n    // Blocking functions related errors.\n    [\"BLOCKING_FUNCTION_ERROR_RESPONSE\" /* ServerError.BLOCKING_FUNCTION_ERROR_RESPONSE */ ]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ ,\n    // Recaptcha related errors.\n    [\"RECAPTCHA_NOT_ENABLED\" /* ServerError.RECAPTCHA_NOT_ENABLED */ ]: \"recaptcha-not-enabled\" /* AuthErrorCode.RECAPTCHA_NOT_ENABLED */ ,\n    [\"MISSING_RECAPTCHA_TOKEN\" /* ServerError.MISSING_RECAPTCHA_TOKEN */ ]: \"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */ ,\n    [\"INVALID_RECAPTCHA_TOKEN\" /* ServerError.INVALID_RECAPTCHA_TOKEN */ ]: \"invalid-recaptcha-token\" /* AuthErrorCode.INVALID_RECAPTCHA_TOKEN */ ,\n    [\"INVALID_RECAPTCHA_ACTION\" /* ServerError.INVALID_RECAPTCHA_ACTION */ ]: \"invalid-recaptcha-action\" /* AuthErrorCode.INVALID_RECAPTCHA_ACTION */ ,\n    [\"MISSING_CLIENT_TYPE\" /* ServerError.MISSING_CLIENT_TYPE */ ]: \"missing-client-type\" /* AuthErrorCode.MISSING_CLIENT_TYPE */ ,\n    [\"MISSING_RECAPTCHA_VERSION\" /* ServerError.MISSING_RECAPTCHA_VERSION */ ]: \"missing-recaptcha-version\" /* AuthErrorCode.MISSING_RECAPTCHA_VERSION */ ,\n    [\"INVALID_RECAPTCHA_VERSION\" /* ServerError.INVALID_RECAPTCHA_VERSION */ ]: \"invalid-recaptcha-version\" /* AuthErrorCode.INVALID_RECAPTCHA_VERSION */ ,\n    [\"INVALID_REQ_TYPE\" /* ServerError.INVALID_REQ_TYPE */ ]: \"invalid-req-type\" /* AuthErrorCode.INVALID_REQ_TYPE */ \n};\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const DEFAULT_API_TIMEOUT_MS = new Delay(30000, 60000);\nfunction _addTidIfNecessary(auth, request) {\n    if (auth.tenantId && !request.tenantId) {\n        return Object.assign(Object.assign({}, request), {\n            tenantId: auth.tenantId\n        });\n    }\n    return request;\n}\nasync function _performApiRequest(auth, method, path, request, customErrorMap = {}) {\n    return _performFetchWithErrorHandling(auth, customErrorMap, async ()=>{\n        let body = {};\n        let params = {};\n        if (request) {\n            if (method === \"GET\" /* HttpMethod.GET */ ) {\n                params = request;\n            } else {\n                body = {\n                    body: JSON.stringify(request)\n                };\n            }\n        }\n        const query = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystring)(Object.assign({\n            key: auth.config.apiKey\n        }, params)).slice(1);\n        const headers = await auth._getAdditionalHeaders();\n        headers[\"Content-Type\" /* HttpHeader.CONTENT_TYPE */ ] = \"application/json\";\n        if (auth.languageCode) {\n            headers[\"X-Firebase-Locale\" /* HttpHeader.X_FIREBASE_LOCALE */ ] = auth.languageCode;\n        }\n        const fetchArgs = Object.assign({\n            method,\n            headers\n        }, body);\n        /* Security-conscious server-side frameworks tend to have built in mitigations for referrer\r\n           problems\". See the Cloudflare GitHub issue #487: Error: The 'referrerPolicy' field on\r\n           'RequestInitializerDict' is not implemented.\"\r\n           https://github.com/cloudflare/next-on-pages/issues/487 */ if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isCloudflareWorker)()) {\n            fetchArgs.referrerPolicy = \"no-referrer\";\n        }\n        return FetchProvider.fetch()(_getFinalTarget(auth, auth.config.apiHost, path, query), fetchArgs);\n    });\n}\nasync function _performFetchWithErrorHandling(auth, customErrorMap, fetchFn) {\n    auth._canInitEmulator = false;\n    const errorMap = Object.assign(Object.assign({}, SERVER_ERROR_MAP), customErrorMap);\n    try {\n        const networkTimeout = new NetworkTimeout(auth);\n        const response = await Promise.race([\n            fetchFn(),\n            networkTimeout.promise\n        ]);\n        // If we've reached this point, the fetch succeeded and the networkTimeout\n        // didn't throw; clear the network timeout delay so that Node won't hang\n        networkTimeout.clearNetworkTimeout();\n        const json = await response.json();\n        if (\"needConfirmation\" in json) {\n            throw _makeTaggedError(auth, \"account-exists-with-different-credential\" /* AuthErrorCode.NEED_CONFIRMATION */ , json);\n        }\n        if (response.ok && !(\"errorMessage\" in json)) {\n            return json;\n        } else {\n            const errorMessage = response.ok ? json.errorMessage : json.error.message;\n            const [serverErrorCode, serverErrorMessage] = errorMessage.split(\" : \");\n            if (serverErrorCode === \"FEDERATED_USER_ID_ALREADY_LINKED\" /* ServerError.FEDERATED_USER_ID_ALREADY_LINKED */ ) {\n                throw _makeTaggedError(auth, \"credential-already-in-use\" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */ , json);\n            } else if (serverErrorCode === \"EMAIL_EXISTS\" /* ServerError.EMAIL_EXISTS */ ) {\n                throw _makeTaggedError(auth, \"email-already-in-use\" /* AuthErrorCode.EMAIL_EXISTS */ , json);\n            } else if (serverErrorCode === \"USER_DISABLED\" /* ServerError.USER_DISABLED */ ) {\n                throw _makeTaggedError(auth, \"user-disabled\" /* AuthErrorCode.USER_DISABLED */ , json);\n            }\n            const authError = errorMap[serverErrorCode] || serverErrorCode.toLowerCase().replace(/[_\\s]+/g, \"-\");\n            if (serverErrorMessage) {\n                throw _errorWithCustomMessage(auth, authError, serverErrorMessage);\n            } else {\n                _fail(auth, authError);\n            }\n        }\n    } catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError) {\n            throw e;\n        }\n        // Changing this to a different error code will log user out when there is a network error\n        // because we treat any error other than NETWORK_REQUEST_FAILED as token is invalid.\n        // https://github.com/firebase/firebase-js-sdk/blob/4fbc73610d70be4e0852e7de63a39cb7897e8546/packages/auth/src/core/auth/auth_impl.ts#L309-L316\n        _fail(auth, \"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */ , {\n            \"message\": String(e)\n        });\n    }\n}\nasync function _performSignInRequest(auth, method, path, request, customErrorMap = {}) {\n    const serverResponse = await _performApiRequest(auth, method, path, request, customErrorMap);\n    if (\"mfaPendingCredential\" in serverResponse) {\n        _fail(auth, \"multi-factor-auth-required\" /* AuthErrorCode.MFA_REQUIRED */ , {\n            _serverResponse: serverResponse\n        });\n    }\n    return serverResponse;\n}\nfunction _getFinalTarget(auth, host, path, query) {\n    const base = `${host}${path}?${query}`;\n    if (!auth.config.emulator) {\n        return `${auth.config.apiScheme}://${base}`;\n    }\n    return _emulatorUrl(auth.config, base);\n}\nfunction _parseEnforcementState(enforcementStateStr) {\n    switch(enforcementStateStr){\n        case \"ENFORCE\":\n            return \"ENFORCE\" /* EnforcementState.ENFORCE */ ;\n        case \"AUDIT\":\n            return \"AUDIT\" /* EnforcementState.AUDIT */ ;\n        case \"OFF\":\n            return \"OFF\" /* EnforcementState.OFF */ ;\n        default:\n            return \"ENFORCEMENT_STATE_UNSPECIFIED\" /* EnforcementState.ENFORCEMENT_STATE_UNSPECIFIED */ ;\n    }\n}\nclass NetworkTimeout {\n    constructor(auth){\n        this.auth = auth;\n        // Node timers and browser timers are fundamentally incompatible, but we\n        // don't care about the value here\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.timer = null;\n        this.promise = new Promise((_, reject)=>{\n            this.timer = setTimeout(()=>{\n                return reject(_createError(this.auth, \"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */ ));\n            }, DEFAULT_API_TIMEOUT_MS.get());\n        });\n    }\n    clearNetworkTimeout() {\n        clearTimeout(this.timer);\n    }\n}\nfunction _makeTaggedError(auth, code, response) {\n    const errorParams = {\n        appName: auth.name\n    };\n    if (response.email) {\n        errorParams.email = response.email;\n    }\n    if (response.phoneNumber) {\n        errorParams.phoneNumber = response.phoneNumber;\n    }\n    const error = _createError(auth, code, errorParams);\n    // We know customData is defined on error because errorParams is defined\n    error.customData._tokenResponse = response;\n    return error;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function isEnterprise(grecaptcha) {\n    return grecaptcha !== undefined && grecaptcha.enterprise !== undefined;\n}\nclass RecaptchaConfig {\n    constructor(response){\n        /**\r\n         * The reCAPTCHA site key.\r\n         */ this.siteKey = \"\";\n        /**\r\n         * The list of providers and their enablement status for reCAPTCHA Enterprise.\r\n         */ this.recaptchaEnforcementState = [];\n        if (response.recaptchaKey === undefined) {\n            throw new Error(\"recaptchaKey undefined\");\n        }\n        // Example response.recaptchaKey: \"projects/proj123/keys/sitekey123\"\n        this.siteKey = response.recaptchaKey.split(\"/\")[3];\n        this.recaptchaEnforcementState = response.recaptchaEnforcementState;\n    }\n    /**\r\n     * Returns the reCAPTCHA Enterprise enforcement state for the given provider.\r\n     *\r\n     * @param providerStr - The provider whose enforcement state is to be returned.\r\n     * @returns The reCAPTCHA Enterprise enforcement state for the given provider.\r\n     */ getProviderEnforcementState(providerStr) {\n        if (!this.recaptchaEnforcementState || this.recaptchaEnforcementState.length === 0) {\n            return null;\n        }\n        for (const recaptchaEnforcementState of this.recaptchaEnforcementState){\n            if (recaptchaEnforcementState.provider && recaptchaEnforcementState.provider === providerStr) {\n                return _parseEnforcementState(recaptchaEnforcementState.enforcementState);\n            }\n        }\n        return null;\n    }\n    /**\r\n     * Returns true if the reCAPTCHA Enterprise enforcement state for the provider is set to ENFORCE or AUDIT.\r\n     *\r\n     * @param providerStr - The provider whose enablement state is to be returned.\r\n     * @returns Whether or not reCAPTCHA Enterprise protection is enabled for the given provider.\r\n     */ isProviderEnabled(providerStr) {\n        return this.getProviderEnforcementState(providerStr) === \"ENFORCE\" /* EnforcementState.ENFORCE */  || this.getProviderEnforcementState(providerStr) === \"AUDIT\" /* EnforcementState.AUDIT */ ;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function getRecaptchaConfig(auth, request) {\n    return _performApiRequest(auth, \"GET\" /* HttpMethod.GET */ , \"/v2/recaptchaConfig\" /* Endpoint.GET_RECAPTCHA_CONFIG */ , _addTidIfNecessary(auth, request));\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function deleteAccount(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:delete\" /* Endpoint.DELETE_ACCOUNT */ , request);\n}\nasync function deleteLinkedAccounts(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */ , request);\n}\nasync function getAccountInfo(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:lookup\" /* Endpoint.GET_ACCOUNT_INFO */ , request);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function utcTimestampToDateString(utcTimestamp) {\n    if (!utcTimestamp) {\n        return undefined;\n    }\n    try {\n        // Convert to date object.\n        const date = new Date(Number(utcTimestamp));\n        // Test date is valid.\n        if (!isNaN(date.getTime())) {\n            // Convert to UTC date string.\n            return date.toUTCString();\n        }\n    } catch (e) {\n    // Do nothing. undefined will be returned.\n    }\n    return undefined;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Returns a JSON Web Token (JWT) used to identify the user to a Firebase service.\r\n *\r\n * @remarks\r\n * Returns the current token if it has not expired or if it will not expire in the next five\r\n * minutes. Otherwise, this will refresh the token and return a new one.\r\n *\r\n * @param user - The user.\r\n * @param forceRefresh - Force refresh regardless of token expiration.\r\n *\r\n * @public\r\n */ function getIdToken(user, forceRefresh = false) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user).getIdToken(forceRefresh);\n}\n/**\r\n * Returns a deserialized JSON Web Token (JWT) used to identify the user to a Firebase service.\r\n *\r\n * @remarks\r\n * Returns the current token if it has not expired or if it will not expire in the next five\r\n * minutes. Otherwise, this will refresh the token and return a new one.\r\n *\r\n * @param user - The user.\r\n * @param forceRefresh - Force refresh regardless of token expiration.\r\n *\r\n * @public\r\n */ async function getIdTokenResult(user, forceRefresh = false) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    const token = await userInternal.getIdToken(forceRefresh);\n    const claims = _parseToken(token);\n    _assert(claims && claims.exp && claims.auth_time && claims.iat, userInternal.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n    const firebase = typeof claims.firebase === \"object\" ? claims.firebase : undefined;\n    const signInProvider = firebase === null || firebase === void 0 ? void 0 : firebase[\"sign_in_provider\"];\n    return {\n        claims,\n        token,\n        authTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.auth_time)),\n        issuedAtTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.iat)),\n        expirationTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.exp)),\n        signInProvider: signInProvider || null,\n        signInSecondFactor: (firebase === null || firebase === void 0 ? void 0 : firebase[\"sign_in_second_factor\"]) || null\n    };\n}\nfunction secondsStringToMilliseconds(seconds) {\n    return Number(seconds) * 1000;\n}\nfunction _parseToken(token) {\n    const [algorithm, payload, signature] = token.split(\".\");\n    if (algorithm === undefined || payload === undefined || signature === undefined) {\n        _logError(\"JWT malformed, contained fewer than 3 sections\");\n        return null;\n    }\n    try {\n        const decoded = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.base64Decode)(payload);\n        if (!decoded) {\n            _logError(\"Failed to decode base64 JWT payload\");\n            return null;\n        }\n        return JSON.parse(decoded);\n    } catch (e) {\n        _logError(\"Caught error parsing JWT payload as JSON\", e === null || e === void 0 ? void 0 : e.toString());\n        return null;\n    }\n}\n/**\r\n * Extract expiresIn TTL from a token by subtracting the expiration from the issuance.\r\n */ function _tokenExpiresIn(token) {\n    const parsedToken = _parseToken(token);\n    _assert(parsedToken, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n    _assert(typeof parsedToken.exp !== \"undefined\", \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n    _assert(typeof parsedToken.iat !== \"undefined\", \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n    return Number(parsedToken.exp) - Number(parsedToken.iat);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function _logoutIfInvalidated(user, promise, bypassAuthState = false) {\n    if (bypassAuthState) {\n        return promise;\n    }\n    try {\n        return await promise;\n    } catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError && isUserInvalidated(e)) {\n            if (user.auth.currentUser === user) {\n                await user.auth.signOut();\n            }\n        }\n        throw e;\n    }\n}\nfunction isUserInvalidated({ code }) {\n    return code === `auth/${\"user-disabled\" /* AuthErrorCode.USER_DISABLED */ }` || code === `auth/${\"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */ }`;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class ProactiveRefresh {\n    constructor(user){\n        this.user = user;\n        this.isRunning = false;\n        // Node timers and browser timers return fundamentally different types.\n        // We don't actually care what the value is but TS won't accept unknown and\n        // we can't cast properly in both environments.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.timerId = null;\n        this.errorBackoff = 30000 /* Duration.RETRY_BACKOFF_MIN */ ;\n    }\n    _start() {\n        if (this.isRunning) {\n            return;\n        }\n        this.isRunning = true;\n        this.schedule();\n    }\n    _stop() {\n        if (!this.isRunning) {\n            return;\n        }\n        this.isRunning = false;\n        if (this.timerId !== null) {\n            clearTimeout(this.timerId);\n        }\n    }\n    getInterval(wasError) {\n        var _a;\n        if (wasError) {\n            const interval = this.errorBackoff;\n            this.errorBackoff = Math.min(this.errorBackoff * 2, 960000 /* Duration.RETRY_BACKOFF_MAX */ );\n            return interval;\n        } else {\n            // Reset the error backoff\n            this.errorBackoff = 30000 /* Duration.RETRY_BACKOFF_MIN */ ;\n            const expTime = (_a = this.user.stsTokenManager.expirationTime) !== null && _a !== void 0 ? _a : 0;\n            const interval = expTime - Date.now() - 300000 /* Duration.OFFSET */ ;\n            return Math.max(0, interval);\n        }\n    }\n    schedule(wasError = false) {\n        if (!this.isRunning) {\n            // Just in case...\n            return;\n        }\n        const interval = this.getInterval(wasError);\n        this.timerId = setTimeout(async ()=>{\n            await this.iteration();\n        }, interval);\n    }\n    async iteration() {\n        try {\n            await this.user.getIdToken(true);\n        } catch (e) {\n            // Only retry on network errors\n            if ((e === null || e === void 0 ? void 0 : e.code) === `auth/${\"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */ }`) {\n                this.schedule(/* wasError */ true);\n            }\n            return;\n        }\n        this.schedule();\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class UserMetadata {\n    constructor(createdAt, lastLoginAt){\n        this.createdAt = createdAt;\n        this.lastLoginAt = lastLoginAt;\n        this._initializeTime();\n    }\n    _initializeTime() {\n        this.lastSignInTime = utcTimestampToDateString(this.lastLoginAt);\n        this.creationTime = utcTimestampToDateString(this.createdAt);\n    }\n    _copy(metadata) {\n        this.createdAt = metadata.createdAt;\n        this.lastLoginAt = metadata.lastLoginAt;\n        this._initializeTime();\n    }\n    toJSON() {\n        return {\n            createdAt: this.createdAt,\n            lastLoginAt: this.lastLoginAt\n        };\n    }\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function _reloadWithoutSaving(user) {\n    var _a;\n    const auth = user.auth;\n    const idToken = await user.getIdToken();\n    const response = await _logoutIfInvalidated(user, getAccountInfo(auth, {\n        idToken\n    }));\n    _assert(response === null || response === void 0 ? void 0 : response.users.length, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n    const coreAccount = response.users[0];\n    user._notifyReloadListener(coreAccount);\n    const newProviderData = ((_a = coreAccount.providerUserInfo) === null || _a === void 0 ? void 0 : _a.length) ? extractProviderData(coreAccount.providerUserInfo) : [];\n    const providerData = mergeProviderData(user.providerData, newProviderData);\n    // Preserves the non-nonymous status of the stored user, even if no more\n    // credentials (federated or email/password) are linked to the user. If\n    // the user was previously anonymous, then use provider data to update.\n    // On the other hand, if it was not anonymous before, it should never be\n    // considered anonymous now.\n    const oldIsAnonymous = user.isAnonymous;\n    const newIsAnonymous = !(user.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);\n    const isAnonymous = !oldIsAnonymous ? false : newIsAnonymous;\n    const updates = {\n        uid: coreAccount.localId,\n        displayName: coreAccount.displayName || null,\n        photoURL: coreAccount.photoUrl || null,\n        email: coreAccount.email || null,\n        emailVerified: coreAccount.emailVerified || false,\n        phoneNumber: coreAccount.phoneNumber || null,\n        tenantId: coreAccount.tenantId || null,\n        providerData,\n        metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),\n        isAnonymous\n    };\n    Object.assign(user, updates);\n}\n/**\r\n * Reloads user account data, if signed in.\r\n *\r\n * @param user - The user.\r\n *\r\n * @public\r\n */ async function reload(user) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    await _reloadWithoutSaving(userInternal);\n    // Even though the current user hasn't changed, update\n    // current user will trigger a persistence update w/ the\n    // new info.\n    await userInternal.auth._persistUserIfCurrent(userInternal);\n    userInternal.auth._notifyListenersIfCurrent(userInternal);\n}\nfunction mergeProviderData(original, newData) {\n    const deduped = original.filter((o)=>!newData.some((n)=>n.providerId === o.providerId));\n    return [\n        ...deduped,\n        ...newData\n    ];\n}\nfunction extractProviderData(providers) {\n    return providers.map((_a)=>{\n        var { providerId } = _a, provider = (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__rest)(_a, [\n            \"providerId\"\n        ]);\n        return {\n            providerId,\n            uid: provider.rawId || \"\",\n            displayName: provider.displayName || null,\n            email: provider.email || null,\n            phoneNumber: provider.phoneNumber || null,\n            photoURL: provider.photoUrl || null\n        };\n    });\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function requestStsToken(auth, refreshToken) {\n    const response = await _performFetchWithErrorHandling(auth, {}, async ()=>{\n        const body = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystring)({\n            \"grant_type\": \"refresh_token\",\n            \"refresh_token\": refreshToken\n        }).slice(1);\n        const { tokenApiHost, apiKey } = auth.config;\n        const url = _getFinalTarget(auth, tokenApiHost, \"/v1/token\" /* Endpoint.TOKEN */ , `key=${apiKey}`);\n        const headers = await auth._getAdditionalHeaders();\n        headers[\"Content-Type\" /* HttpHeader.CONTENT_TYPE */ ] = \"application/x-www-form-urlencoded\";\n        return FetchProvider.fetch()(url, {\n            method: \"POST\" /* HttpMethod.POST */ ,\n            headers,\n            body\n        });\n    });\n    // The response comes back in snake_case. Convert to camel:\n    return {\n        accessToken: response.access_token,\n        expiresIn: response.expires_in,\n        refreshToken: response.refresh_token\n    };\n}\nasync function revokeToken(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v2/accounts:revokeToken\" /* Endpoint.REVOKE_TOKEN */ , _addTidIfNecessary(auth, request));\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * We need to mark this class as internal explicitly to exclude it in the public typings, because\r\n * it references AuthInternal which has a circular dependency with UserInternal.\r\n *\r\n * @internal\r\n */ class StsTokenManager {\n    constructor(){\n        this.refreshToken = null;\n        this.accessToken = null;\n        this.expirationTime = null;\n    }\n    get isExpired() {\n        return !this.expirationTime || Date.now() > this.expirationTime - 30000 /* Buffer.TOKEN_REFRESH */ ;\n    }\n    updateFromServerResponse(response) {\n        _assert(response.idToken, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        _assert(typeof response.idToken !== \"undefined\", \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        _assert(typeof response.refreshToken !== \"undefined\", \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        const expiresIn = \"expiresIn\" in response && typeof response.expiresIn !== \"undefined\" ? Number(response.expiresIn) : _tokenExpiresIn(response.idToken);\n        this.updateTokensAndExpiration(response.idToken, response.refreshToken, expiresIn);\n    }\n    updateFromIdToken(idToken) {\n        _assert(idToken.length !== 0, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        const expiresIn = _tokenExpiresIn(idToken);\n        this.updateTokensAndExpiration(idToken, null, expiresIn);\n    }\n    async getToken(auth, forceRefresh = false) {\n        if (!forceRefresh && this.accessToken && !this.isExpired) {\n            return this.accessToken;\n        }\n        _assert(this.refreshToken, auth, \"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */ );\n        if (this.refreshToken) {\n            await this.refresh(auth, this.refreshToken);\n            return this.accessToken;\n        }\n        return null;\n    }\n    clearRefreshToken() {\n        this.refreshToken = null;\n    }\n    async refresh(auth, oldToken) {\n        const { accessToken, refreshToken, expiresIn } = await requestStsToken(auth, oldToken);\n        this.updateTokensAndExpiration(accessToken, refreshToken, Number(expiresIn));\n    }\n    updateTokensAndExpiration(accessToken, refreshToken, expiresInSec) {\n        this.refreshToken = refreshToken || null;\n        this.accessToken = accessToken || null;\n        this.expirationTime = Date.now() + expiresInSec * 1000;\n    }\n    static fromJSON(appName, object) {\n        const { refreshToken, accessToken, expirationTime } = object;\n        const manager = new StsTokenManager();\n        if (refreshToken) {\n            _assert(typeof refreshToken === \"string\", \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ , {\n                appName\n            });\n            manager.refreshToken = refreshToken;\n        }\n        if (accessToken) {\n            _assert(typeof accessToken === \"string\", \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ , {\n                appName\n            });\n            manager.accessToken = accessToken;\n        }\n        if (expirationTime) {\n            _assert(typeof expirationTime === \"number\", \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ , {\n                appName\n            });\n            manager.expirationTime = expirationTime;\n        }\n        return manager;\n    }\n    toJSON() {\n        return {\n            refreshToken: this.refreshToken,\n            accessToken: this.accessToken,\n            expirationTime: this.expirationTime\n        };\n    }\n    _assign(stsTokenManager) {\n        this.accessToken = stsTokenManager.accessToken;\n        this.refreshToken = stsTokenManager.refreshToken;\n        this.expirationTime = stsTokenManager.expirationTime;\n    }\n    _clone() {\n        return Object.assign(new StsTokenManager(), this.toJSON());\n    }\n    _performRefresh() {\n        return debugFail(\"not implemented\");\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function assertStringOrUndefined(assertion, appName) {\n    _assert(typeof assertion === \"string\" || typeof assertion === \"undefined\", \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ , {\n        appName\n    });\n}\nclass UserImpl {\n    constructor(_a){\n        var { uid, auth, stsTokenManager } = _a, opt = (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__rest)(_a, [\n            \"uid\",\n            \"auth\",\n            \"stsTokenManager\"\n        ]);\n        // For the user object, provider is always Firebase.\n        this.providerId = \"firebase\" /* ProviderId.FIREBASE */ ;\n        this.proactiveRefresh = new ProactiveRefresh(this);\n        this.reloadUserInfo = null;\n        this.reloadListener = null;\n        this.uid = uid;\n        this.auth = auth;\n        this.stsTokenManager = stsTokenManager;\n        this.accessToken = stsTokenManager.accessToken;\n        this.displayName = opt.displayName || null;\n        this.email = opt.email || null;\n        this.emailVerified = opt.emailVerified || false;\n        this.phoneNumber = opt.phoneNumber || null;\n        this.photoURL = opt.photoURL || null;\n        this.isAnonymous = opt.isAnonymous || false;\n        this.tenantId = opt.tenantId || null;\n        this.providerData = opt.providerData ? [\n            ...opt.providerData\n        ] : [];\n        this.metadata = new UserMetadata(opt.createdAt || undefined, opt.lastLoginAt || undefined);\n    }\n    async getIdToken(forceRefresh) {\n        const accessToken = await _logoutIfInvalidated(this, this.stsTokenManager.getToken(this.auth, forceRefresh));\n        _assert(accessToken, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        if (this.accessToken !== accessToken) {\n            this.accessToken = accessToken;\n            await this.auth._persistUserIfCurrent(this);\n            this.auth._notifyListenersIfCurrent(this);\n        }\n        return accessToken;\n    }\n    getIdTokenResult(forceRefresh) {\n        return getIdTokenResult(this, forceRefresh);\n    }\n    reload() {\n        return reload(this);\n    }\n    _assign(user) {\n        if (this === user) {\n            return;\n        }\n        _assert(this.uid === user.uid, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        this.displayName = user.displayName;\n        this.photoURL = user.photoURL;\n        this.email = user.email;\n        this.emailVerified = user.emailVerified;\n        this.phoneNumber = user.phoneNumber;\n        this.isAnonymous = user.isAnonymous;\n        this.tenantId = user.tenantId;\n        this.providerData = user.providerData.map((userInfo)=>Object.assign({}, userInfo));\n        this.metadata._copy(user.metadata);\n        this.stsTokenManager._assign(user.stsTokenManager);\n    }\n    _clone(auth) {\n        const newUser = new UserImpl(Object.assign(Object.assign({}, this), {\n            auth,\n            stsTokenManager: this.stsTokenManager._clone()\n        }));\n        newUser.metadata._copy(this.metadata);\n        return newUser;\n    }\n    _onReload(callback) {\n        // There should only ever be one listener, and that is a single instance of MultiFactorUser\n        _assert(!this.reloadListener, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        this.reloadListener = callback;\n        if (this.reloadUserInfo) {\n            this._notifyReloadListener(this.reloadUserInfo);\n            this.reloadUserInfo = null;\n        }\n    }\n    _notifyReloadListener(userInfo) {\n        if (this.reloadListener) {\n            this.reloadListener(userInfo);\n        } else {\n            // If no listener is subscribed yet, save the result so it's available when they do subscribe\n            this.reloadUserInfo = userInfo;\n        }\n    }\n    _startProactiveRefresh() {\n        this.proactiveRefresh._start();\n    }\n    _stopProactiveRefresh() {\n        this.proactiveRefresh._stop();\n    }\n    async _updateTokensIfNecessary(response, reload = false) {\n        let tokensRefreshed = false;\n        if (response.idToken && response.idToken !== this.stsTokenManager.accessToken) {\n            this.stsTokenManager.updateFromServerResponse(response);\n            tokensRefreshed = true;\n        }\n        if (reload) {\n            await _reloadWithoutSaving(this);\n        }\n        await this.auth._persistUserIfCurrent(this);\n        if (tokensRefreshed) {\n            this.auth._notifyListenersIfCurrent(this);\n        }\n    }\n    async delete() {\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.auth.app)) {\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this.auth));\n        }\n        const idToken = await this.getIdToken();\n        await _logoutIfInvalidated(this, deleteAccount(this.auth, {\n            idToken\n        }));\n        this.stsTokenManager.clearRefreshToken();\n        // TODO: Determine if cancellable-promises are necessary to use in this class so that delete()\n        //       cancels pending actions...\n        return this.auth.signOut();\n    }\n    toJSON() {\n        return Object.assign(Object.assign({\n            uid: this.uid,\n            email: this.email || undefined,\n            emailVerified: this.emailVerified,\n            displayName: this.displayName || undefined,\n            isAnonymous: this.isAnonymous,\n            photoURL: this.photoURL || undefined,\n            phoneNumber: this.phoneNumber || undefined,\n            tenantId: this.tenantId || undefined,\n            providerData: this.providerData.map((userInfo)=>Object.assign({}, userInfo)),\n            stsTokenManager: this.stsTokenManager.toJSON(),\n            // Redirect event ID must be maintained in case there is a pending\n            // redirect event.\n            _redirectEventId: this._redirectEventId\n        }, this.metadata.toJSON()), {\n            // Required for compatibility with the legacy SDK (go/firebase-auth-sdk-persistence-parsing):\n            apiKey: this.auth.config.apiKey,\n            appName: this.auth.name\n        });\n    }\n    get refreshToken() {\n        return this.stsTokenManager.refreshToken || \"\";\n    }\n    static _fromJSON(auth, object) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        const displayName = (_a = object.displayName) !== null && _a !== void 0 ? _a : undefined;\n        const email = (_b = object.email) !== null && _b !== void 0 ? _b : undefined;\n        const phoneNumber = (_c = object.phoneNumber) !== null && _c !== void 0 ? _c : undefined;\n        const photoURL = (_d = object.photoURL) !== null && _d !== void 0 ? _d : undefined;\n        const tenantId = (_e = object.tenantId) !== null && _e !== void 0 ? _e : undefined;\n        const _redirectEventId = (_f = object._redirectEventId) !== null && _f !== void 0 ? _f : undefined;\n        const createdAt = (_g = object.createdAt) !== null && _g !== void 0 ? _g : undefined;\n        const lastLoginAt = (_h = object.lastLoginAt) !== null && _h !== void 0 ? _h : undefined;\n        const { uid, emailVerified, isAnonymous, providerData, stsTokenManager: plainObjectTokenManager } = object;\n        _assert(uid && plainObjectTokenManager, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        const stsTokenManager = StsTokenManager.fromJSON(this.name, plainObjectTokenManager);\n        _assert(typeof uid === \"string\", auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        assertStringOrUndefined(displayName, auth.name);\n        assertStringOrUndefined(email, auth.name);\n        _assert(typeof emailVerified === \"boolean\", auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        _assert(typeof isAnonymous === \"boolean\", auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        assertStringOrUndefined(phoneNumber, auth.name);\n        assertStringOrUndefined(photoURL, auth.name);\n        assertStringOrUndefined(tenantId, auth.name);\n        assertStringOrUndefined(_redirectEventId, auth.name);\n        assertStringOrUndefined(createdAt, auth.name);\n        assertStringOrUndefined(lastLoginAt, auth.name);\n        const user = new UserImpl({\n            uid,\n            auth,\n            email,\n            emailVerified,\n            displayName,\n            isAnonymous,\n            photoURL,\n            phoneNumber,\n            tenantId,\n            stsTokenManager,\n            createdAt,\n            lastLoginAt\n        });\n        if (providerData && Array.isArray(providerData)) {\n            user.providerData = providerData.map((userInfo)=>Object.assign({}, userInfo));\n        }\n        if (_redirectEventId) {\n            user._redirectEventId = _redirectEventId;\n        }\n        return user;\n    }\n    /**\r\n     * Initialize a User from an idToken server response\r\n     * @param auth\r\n     * @param idTokenResponse\r\n     */ static async _fromIdTokenResponse(auth, idTokenResponse, isAnonymous = false) {\n        const stsTokenManager = new StsTokenManager();\n        stsTokenManager.updateFromServerResponse(idTokenResponse);\n        // Initialize the Firebase Auth user.\n        const user = new UserImpl({\n            uid: idTokenResponse.localId,\n            auth,\n            stsTokenManager,\n            isAnonymous\n        });\n        // Updates the user info and data and resolves with a user instance.\n        await _reloadWithoutSaving(user);\n        return user;\n    }\n    /**\r\n     * Initialize a User from an idToken server response\r\n     * @param auth\r\n     * @param idTokenResponse\r\n     */ static async _fromGetAccountInfoResponse(auth, response, idToken) {\n        const coreAccount = response.users[0];\n        _assert(coreAccount.localId !== undefined, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        const providerData = coreAccount.providerUserInfo !== undefined ? extractProviderData(coreAccount.providerUserInfo) : [];\n        const isAnonymous = !(coreAccount.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);\n        const stsTokenManager = new StsTokenManager();\n        stsTokenManager.updateFromIdToken(idToken);\n        // Initialize the Firebase Auth user.\n        const user = new UserImpl({\n            uid: coreAccount.localId,\n            auth,\n            stsTokenManager,\n            isAnonymous\n        });\n        // update the user with data from the GetAccountInfo response.\n        const updates = {\n            uid: coreAccount.localId,\n            displayName: coreAccount.displayName || null,\n            photoURL: coreAccount.photoUrl || null,\n            email: coreAccount.email || null,\n            emailVerified: coreAccount.emailVerified || false,\n            phoneNumber: coreAccount.phoneNumber || null,\n            tenantId: coreAccount.tenantId || null,\n            providerData,\n            metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),\n            isAnonymous: !(coreAccount.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length)\n        };\n        Object.assign(user, updates);\n        return user;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const instanceCache = new Map();\nfunction _getInstance(cls) {\n    debugAssert(cls instanceof Function, \"Expected a class definition\");\n    let instance = instanceCache.get(cls);\n    if (instance) {\n        debugAssert(instance instanceof cls, \"Instance stored in cache mismatched with class\");\n        return instance;\n    }\n    instance = new cls();\n    instanceCache.set(cls, instance);\n    return instance;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class InMemoryPersistence {\n    constructor(){\n        this.type = \"NONE\" /* PersistenceType.NONE */ ;\n        this.storage = {};\n    }\n    async _isAvailable() {\n        return true;\n    }\n    async _set(key, value) {\n        this.storage[key] = value;\n    }\n    async _get(key) {\n        const value = this.storage[key];\n        return value === undefined ? null : value;\n    }\n    async _remove(key) {\n        delete this.storage[key];\n    }\n    _addListener(_key, _listener) {\n        // Listeners are not supported for in-memory storage since it cannot be shared across windows/workers\n        return;\n    }\n    _removeListener(_key, _listener) {\n        // Listeners are not supported for in-memory storage since it cannot be shared across windows/workers\n        return;\n    }\n}\nInMemoryPersistence.type = \"NONE\";\n/**\r\n * An implementation of {@link Persistence} of type 'NONE'.\r\n *\r\n * @public\r\n */ const inMemoryPersistence = InMemoryPersistence;\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function _persistenceKeyName(key, apiKey, appName) {\n    return `${\"firebase\" /* Namespace.PERSISTENCE */ }:${key}:${apiKey}:${appName}`;\n}\nclass PersistenceUserManager {\n    constructor(persistence, auth, userKey){\n        this.persistence = persistence;\n        this.auth = auth;\n        this.userKey = userKey;\n        const { config, name } = this.auth;\n        this.fullUserKey = _persistenceKeyName(this.userKey, config.apiKey, name);\n        this.fullPersistenceKey = _persistenceKeyName(\"persistence\" /* KeyName.PERSISTENCE_USER */ , config.apiKey, name);\n        this.boundEventHandler = auth._onStorageEvent.bind(auth);\n        this.persistence._addListener(this.fullUserKey, this.boundEventHandler);\n    }\n    setCurrentUser(user) {\n        return this.persistence._set(this.fullUserKey, user.toJSON());\n    }\n    async getCurrentUser() {\n        const blob = await this.persistence._get(this.fullUserKey);\n        return blob ? UserImpl._fromJSON(this.auth, blob) : null;\n    }\n    removeCurrentUser() {\n        return this.persistence._remove(this.fullUserKey);\n    }\n    savePersistenceForRedirect() {\n        return this.persistence._set(this.fullPersistenceKey, this.persistence.type);\n    }\n    async setPersistence(newPersistence) {\n        if (this.persistence === newPersistence) {\n            return;\n        }\n        const currentUser = await this.getCurrentUser();\n        await this.removeCurrentUser();\n        this.persistence = newPersistence;\n        if (currentUser) {\n            return this.setCurrentUser(currentUser);\n        }\n    }\n    delete() {\n        this.persistence._removeListener(this.fullUserKey, this.boundEventHandler);\n    }\n    static async create(auth, persistenceHierarchy, userKey = \"authUser\" /* KeyName.AUTH_USER */ ) {\n        if (!persistenceHierarchy.length) {\n            return new PersistenceUserManager(_getInstance(inMemoryPersistence), auth, userKey);\n        }\n        // Eliminate any persistences that are not available\n        const availablePersistences = (await Promise.all(persistenceHierarchy.map(async (persistence)=>{\n            if (await persistence._isAvailable()) {\n                return persistence;\n            }\n            return undefined;\n        }))).filter((persistence)=>persistence);\n        // Fall back to the first persistence listed, or in memory if none available\n        let selectedPersistence = availablePersistences[0] || _getInstance(inMemoryPersistence);\n        const key = _persistenceKeyName(userKey, auth.config.apiKey, auth.name);\n        // Pull out the existing user, setting the chosen persistence to that\n        // persistence if the user exists.\n        let userToMigrate = null;\n        // Note, here we check for a user in _all_ persistences, not just the\n        // ones deemed available. If we can migrate a user out of a broken\n        // persistence, we will (but only if that persistence supports migration).\n        for (const persistence of persistenceHierarchy){\n            try {\n                const blob = await persistence._get(key);\n                if (blob) {\n                    const user = UserImpl._fromJSON(auth, blob); // throws for unparsable blob (wrong format)\n                    if (persistence !== selectedPersistence) {\n                        userToMigrate = user;\n                    }\n                    selectedPersistence = persistence;\n                    break;\n                }\n            } catch (_a) {}\n        }\n        // If we find the user in a persistence that does support migration, use\n        // that migration path (of only persistences that support migration)\n        const migrationHierarchy = availablePersistences.filter((p)=>p._shouldAllowMigration);\n        // If the persistence does _not_ allow migration, just finish off here\n        if (!selectedPersistence._shouldAllowMigration || !migrationHierarchy.length) {\n            return new PersistenceUserManager(selectedPersistence, auth, userKey);\n        }\n        selectedPersistence = migrationHierarchy[0];\n        if (userToMigrate) {\n            // This normally shouldn't throw since chosenPersistence.isAvailable() is true, but if it does\n            // we'll just let it bubble to surface the error.\n            await selectedPersistence._set(key, userToMigrate.toJSON());\n        }\n        // Attempt to clear the key in other persistences but ignore errors. This helps prevent issues\n        // such as users getting stuck with a previous account after signing out and refreshing the tab.\n        await Promise.all(persistenceHierarchy.map(async (persistence)=>{\n            if (persistence !== selectedPersistence) {\n                try {\n                    await persistence._remove(key);\n                } catch (_a) {}\n            }\n        }));\n        return new PersistenceUserManager(selectedPersistence, auth, userKey);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Determine the browser for the purposes of reporting usage to the API\r\n */ function _getBrowserName(userAgent) {\n    const ua = userAgent.toLowerCase();\n    if (ua.includes(\"opera/\") || ua.includes(\"opr/\") || ua.includes(\"opios/\")) {\n        return \"Opera\" /* BrowserName.OPERA */ ;\n    } else if (_isIEMobile(ua)) {\n        // Windows phone IEMobile browser.\n        return \"IEMobile\" /* BrowserName.IEMOBILE */ ;\n    } else if (ua.includes(\"msie\") || ua.includes(\"trident/\")) {\n        return \"IE\" /* BrowserName.IE */ ;\n    } else if (ua.includes(\"edge/\")) {\n        return \"Edge\" /* BrowserName.EDGE */ ;\n    } else if (_isFirefox(ua)) {\n        return \"Firefox\" /* BrowserName.FIREFOX */ ;\n    } else if (ua.includes(\"silk/\")) {\n        return \"Silk\" /* BrowserName.SILK */ ;\n    } else if (_isBlackBerry(ua)) {\n        // Blackberry browser.\n        return \"Blackberry\" /* BrowserName.BLACKBERRY */ ;\n    } else if (_isWebOS(ua)) {\n        // WebOS default browser.\n        return \"Webos\" /* BrowserName.WEBOS */ ;\n    } else if (_isSafari(ua)) {\n        return \"Safari\" /* BrowserName.SAFARI */ ;\n    } else if ((ua.includes(\"chrome/\") || _isChromeIOS(ua)) && !ua.includes(\"edge/\")) {\n        return \"Chrome\" /* BrowserName.CHROME */ ;\n    } else if (_isAndroid(ua)) {\n        // Android stock browser.\n        return \"Android\" /* BrowserName.ANDROID */ ;\n    } else {\n        // Most modern browsers have name/version at end of user agent string.\n        const re = /([a-zA-Z\\d\\.]+)\\/[a-zA-Z\\d\\.]*$/;\n        const matches = userAgent.match(re);\n        if ((matches === null || matches === void 0 ? void 0 : matches.length) === 2) {\n            return matches[1];\n        }\n    }\n    return \"Other\" /* BrowserName.OTHER */ ;\n}\nfunction _isFirefox(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /firefox\\//i.test(ua);\n}\nfunction _isSafari(userAgent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    const ua = userAgent.toLowerCase();\n    return ua.includes(\"safari/\") && !ua.includes(\"chrome/\") && !ua.includes(\"crios/\") && !ua.includes(\"android\");\n}\nfunction _isChromeIOS(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /crios\\//i.test(ua);\n}\nfunction _isIEMobile(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /iemobile/i.test(ua);\n}\nfunction _isAndroid(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /android/i.test(ua);\n}\nfunction _isBlackBerry(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /blackberry/i.test(ua);\n}\nfunction _isWebOS(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /webos/i.test(ua);\n}\nfunction _isIOS(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /iphone|ipad|ipod/i.test(ua) || /macintosh/i.test(ua) && /mobile/i.test(ua);\n}\nfunction _isIOS7Or8(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /(iPad|iPhone|iPod).*OS 7_\\d/i.test(ua) || /(iPad|iPhone|iPod).*OS 8_\\d/i.test(ua);\n}\nfunction _isIE10() {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isIE)() && document.documentMode === 10;\n}\nfunction _isMobileBrowser(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    // TODO: implement getBrowserName equivalent for OS.\n    return _isIOS(ua) || _isAndroid(ua) || _isWebOS(ua) || _isBlackBerry(ua) || /windows phone/i.test(ua) || _isIEMobile(ua);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /*\r\n * Determine the SDK version string\r\n */ function _getClientVersion(clientPlatform, frameworks = []) {\n    let reportedPlatform;\n    switch(clientPlatform){\n        case \"Browser\" /* ClientPlatform.BROWSER */ :\n            // In a browser environment, report the browser name.\n            reportedPlatform = _getBrowserName((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)());\n            break;\n        case \"Worker\" /* ClientPlatform.WORKER */ :\n            // Technically a worker runs from a browser but we need to differentiate a\n            // worker from a browser.\n            // For example: Chrome-Worker/JsCore/4.9.1/FirebaseCore-web.\n            reportedPlatform = `${_getBrowserName((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)())}-${clientPlatform}`;\n            break;\n        default:\n            reportedPlatform = clientPlatform;\n    }\n    const reportedFrameworks = frameworks.length ? frameworks.join(\",\") : \"FirebaseCore-web\"; /* default value if no other framework is used */ \n    return `${reportedPlatform}/${\"JsCore\" /* ClientImplementation.CORE */ }/${_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION}/${reportedFrameworks}`;\n}\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class AuthMiddlewareQueue {\n    constructor(auth){\n        this.auth = auth;\n        this.queue = [];\n    }\n    pushCallback(callback, onAbort) {\n        // The callback could be sync or async. Wrap it into a\n        // function that is always async.\n        const wrappedCallback = (user)=>new Promise((resolve, reject)=>{\n                try {\n                    const result = callback(user);\n                    // Either resolve with existing promise or wrap a non-promise\n                    // return value into a promise.\n                    resolve(result);\n                } catch (e) {\n                    // Sync callback throws.\n                    reject(e);\n                }\n            });\n        // Attach the onAbort if present\n        wrappedCallback.onAbort = onAbort;\n        this.queue.push(wrappedCallback);\n        const index = this.queue.length - 1;\n        return ()=>{\n            // Unsubscribe. Replace with no-op. Do not remove from array, or it will disturb\n            // indexing of other elements.\n            this.queue[index] = ()=>Promise.resolve();\n        };\n    }\n    async runMiddleware(nextUser) {\n        if (this.auth.currentUser === nextUser) {\n            return;\n        }\n        // While running the middleware, build a temporary stack of onAbort\n        // callbacks to call if one middleware callback rejects.\n        const onAbortStack = [];\n        try {\n            for (const beforeStateCallback of this.queue){\n                await beforeStateCallback(nextUser);\n                // Only push the onAbort if the callback succeeds\n                if (beforeStateCallback.onAbort) {\n                    onAbortStack.push(beforeStateCallback.onAbort);\n                }\n            }\n        } catch (e) {\n            // Run all onAbort, with separate try/catch to ignore any errors and\n            // continue\n            onAbortStack.reverse();\n            for (const onAbort of onAbortStack){\n                try {\n                    onAbort();\n                } catch (_) {\n                /* swallow error */ }\n            }\n            throw this.auth._errorFactory.create(\"login-blocked\" /* AuthErrorCode.LOGIN_BLOCKED */ , {\n                originalMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Fetches the password policy for the currently set tenant or the project if no tenant is set.\r\n *\r\n * @param auth Auth object.\r\n * @param request Password policy request.\r\n * @returns Password policy response.\r\n */ async function _getPasswordPolicy(auth, request = {}) {\n    return _performApiRequest(auth, \"GET\" /* HttpMethod.GET */ , \"/v2/passwordPolicy\" /* Endpoint.GET_PASSWORD_POLICY */ , _addTidIfNecessary(auth, request));\n}\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Minimum min password length enforced by the backend, even if no minimum length is set.\nconst MINIMUM_MIN_PASSWORD_LENGTH = 6;\n/**\r\n * Stores password policy requirements and provides password validation against the policy.\r\n *\r\n * @internal\r\n */ class PasswordPolicyImpl {\n    constructor(response){\n        var _a, _b, _c, _d;\n        // Only include custom strength options defined in the response.\n        const responseOptions = response.customStrengthOptions;\n        this.customStrengthOptions = {};\n        // TODO: Remove once the backend is updated to include the minimum min password length instead of undefined when there is no minimum length set.\n        this.customStrengthOptions.minPasswordLength = (_a = responseOptions.minPasswordLength) !== null && _a !== void 0 ? _a : MINIMUM_MIN_PASSWORD_LENGTH;\n        if (responseOptions.maxPasswordLength) {\n            this.customStrengthOptions.maxPasswordLength = responseOptions.maxPasswordLength;\n        }\n        if (responseOptions.containsLowercaseCharacter !== undefined) {\n            this.customStrengthOptions.containsLowercaseLetter = responseOptions.containsLowercaseCharacter;\n        }\n        if (responseOptions.containsUppercaseCharacter !== undefined) {\n            this.customStrengthOptions.containsUppercaseLetter = responseOptions.containsUppercaseCharacter;\n        }\n        if (responseOptions.containsNumericCharacter !== undefined) {\n            this.customStrengthOptions.containsNumericCharacter = responseOptions.containsNumericCharacter;\n        }\n        if (responseOptions.containsNonAlphanumericCharacter !== undefined) {\n            this.customStrengthOptions.containsNonAlphanumericCharacter = responseOptions.containsNonAlphanumericCharacter;\n        }\n        this.enforcementState = response.enforcementState;\n        if (this.enforcementState === \"ENFORCEMENT_STATE_UNSPECIFIED\") {\n            this.enforcementState = \"OFF\";\n        }\n        // Use an empty string if no non-alphanumeric characters are specified in the response.\n        this.allowedNonAlphanumericCharacters = (_c = (_b = response.allowedNonAlphanumericCharacters) === null || _b === void 0 ? void 0 : _b.join(\"\")) !== null && _c !== void 0 ? _c : \"\";\n        this.forceUpgradeOnSignin = (_d = response.forceUpgradeOnSignin) !== null && _d !== void 0 ? _d : false;\n        this.schemaVersion = response.schemaVersion;\n    }\n    validatePassword(password) {\n        var _a, _b, _c, _d, _e, _f;\n        const status = {\n            isValid: true,\n            passwordPolicy: this\n        };\n        // Check the password length and character options.\n        this.validatePasswordLengthOptions(password, status);\n        this.validatePasswordCharacterOptions(password, status);\n        // Combine the status into single isValid property.\n        status.isValid && (status.isValid = (_a = status.meetsMinPasswordLength) !== null && _a !== void 0 ? _a : true);\n        status.isValid && (status.isValid = (_b = status.meetsMaxPasswordLength) !== null && _b !== void 0 ? _b : true);\n        status.isValid && (status.isValid = (_c = status.containsLowercaseLetter) !== null && _c !== void 0 ? _c : true);\n        status.isValid && (status.isValid = (_d = status.containsUppercaseLetter) !== null && _d !== void 0 ? _d : true);\n        status.isValid && (status.isValid = (_e = status.containsNumericCharacter) !== null && _e !== void 0 ? _e : true);\n        status.isValid && (status.isValid = (_f = status.containsNonAlphanumericCharacter) !== null && _f !== void 0 ? _f : true);\n        return status;\n    }\n    /**\r\n     * Validates that the password meets the length options for the policy.\r\n     *\r\n     * @param password Password to validate.\r\n     * @param status Validation status.\r\n     */ validatePasswordLengthOptions(password, status) {\n        const minPasswordLength = this.customStrengthOptions.minPasswordLength;\n        const maxPasswordLength = this.customStrengthOptions.maxPasswordLength;\n        if (minPasswordLength) {\n            status.meetsMinPasswordLength = password.length >= minPasswordLength;\n        }\n        if (maxPasswordLength) {\n            status.meetsMaxPasswordLength = password.length <= maxPasswordLength;\n        }\n    }\n    /**\r\n     * Validates that the password meets the character options for the policy.\r\n     *\r\n     * @param password Password to validate.\r\n     * @param status Validation status.\r\n     */ validatePasswordCharacterOptions(password, status) {\n        // Assign statuses for requirements even if the password is an empty string.\n        this.updatePasswordCharacterOptionsStatuses(status, /* containsLowercaseCharacter= */ false, /* containsUppercaseCharacter= */ false, /* containsNumericCharacter= */ false, /* containsNonAlphanumericCharacter= */ false);\n        let passwordChar;\n        for(let i = 0; i < password.length; i++){\n            passwordChar = password.charAt(i);\n            this.updatePasswordCharacterOptionsStatuses(status, /* containsLowercaseCharacter= */ passwordChar >= \"a\" && passwordChar <= \"z\", /* containsUppercaseCharacter= */ passwordChar >= \"A\" && passwordChar <= \"Z\", /* containsNumericCharacter= */ passwordChar >= \"0\" && passwordChar <= \"9\", /* containsNonAlphanumericCharacter= */ this.allowedNonAlphanumericCharacters.includes(passwordChar));\n        }\n    }\n    /**\r\n     * Updates the running validation status with the statuses for the character options.\r\n     * Expected to be called each time a character is processed to update each option status\r\n     * based on the current character.\r\n     *\r\n     * @param status Validation status.\r\n     * @param containsLowercaseCharacter Whether the character is a lowercase letter.\r\n     * @param containsUppercaseCharacter Whether the character is an uppercase letter.\r\n     * @param containsNumericCharacter Whether the character is a numeric character.\r\n     * @param containsNonAlphanumericCharacter Whether the character is a non-alphanumeric character.\r\n     */ updatePasswordCharacterOptionsStatuses(status, containsLowercaseCharacter, containsUppercaseCharacter, containsNumericCharacter, containsNonAlphanumericCharacter) {\n        if (this.customStrengthOptions.containsLowercaseLetter) {\n            status.containsLowercaseLetter || (status.containsLowercaseLetter = containsLowercaseCharacter);\n        }\n        if (this.customStrengthOptions.containsUppercaseLetter) {\n            status.containsUppercaseLetter || (status.containsUppercaseLetter = containsUppercaseCharacter);\n        }\n        if (this.customStrengthOptions.containsNumericCharacter) {\n            status.containsNumericCharacter || (status.containsNumericCharacter = containsNumericCharacter);\n        }\n        if (this.customStrengthOptions.containsNonAlphanumericCharacter) {\n            status.containsNonAlphanumericCharacter || (status.containsNonAlphanumericCharacter = containsNonAlphanumericCharacter);\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class AuthImpl {\n    constructor(app, heartbeatServiceProvider, appCheckServiceProvider, config){\n        this.app = app;\n        this.heartbeatServiceProvider = heartbeatServiceProvider;\n        this.appCheckServiceProvider = appCheckServiceProvider;\n        this.config = config;\n        this.currentUser = null;\n        this.emulatorConfig = null;\n        this.operations = Promise.resolve();\n        this.authStateSubscription = new Subscription(this);\n        this.idTokenSubscription = new Subscription(this);\n        this.beforeStateQueue = new AuthMiddlewareQueue(this);\n        this.redirectUser = null;\n        this.isProactiveRefreshEnabled = false;\n        this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION = 1;\n        // Any network calls will set this to true and prevent subsequent emulator\n        // initialization\n        this._canInitEmulator = true;\n        this._isInitialized = false;\n        this._deleted = false;\n        this._initializationPromise = null;\n        this._popupRedirectResolver = null;\n        this._errorFactory = _DEFAULT_AUTH_ERROR_FACTORY;\n        this._agentRecaptchaConfig = null;\n        this._tenantRecaptchaConfigs = {};\n        this._projectPasswordPolicy = null;\n        this._tenantPasswordPolicies = {};\n        // Tracks the last notified UID for state change listeners to prevent\n        // repeated calls to the callbacks. Undefined means it's never been\n        // called, whereas null means it's been called with a signed out user\n        this.lastNotifiedUid = undefined;\n        this.languageCode = null;\n        this.tenantId = null;\n        this.settings = {\n            appVerificationDisabledForTesting: false\n        };\n        this.frameworks = [];\n        this.name = app.name;\n        this.clientVersion = config.sdkClientVersion;\n    }\n    _initializeWithPersistence(persistenceHierarchy, popupRedirectResolver) {\n        if (popupRedirectResolver) {\n            this._popupRedirectResolver = _getInstance(popupRedirectResolver);\n        }\n        // Have to check for app deletion throughout initialization (after each\n        // promise resolution)\n        this._initializationPromise = this.queue(async ()=>{\n            var _a, _b;\n            if (this._deleted) {\n                return;\n            }\n            this.persistenceManager = await PersistenceUserManager.create(this, persistenceHierarchy);\n            if (this._deleted) {\n                return;\n            }\n            // Initialize the resolver early if necessary (only applicable to web:\n            // this will cause the iframe to load immediately in certain cases)\n            if ((_a = this._popupRedirectResolver) === null || _a === void 0 ? void 0 : _a._shouldInitProactively) {\n                // If this fails, don't halt auth loading\n                try {\n                    await this._popupRedirectResolver._initialize(this);\n                } catch (e) {\n                /* Ignore the error */ }\n            }\n            await this.initializeCurrentUser(popupRedirectResolver);\n            this.lastNotifiedUid = ((_b = this.currentUser) === null || _b === void 0 ? void 0 : _b.uid) || null;\n            if (this._deleted) {\n                return;\n            }\n            this._isInitialized = true;\n        });\n        return this._initializationPromise;\n    }\n    /**\r\n     * If the persistence is changed in another window, the user manager will let us know\r\n     */ async _onStorageEvent() {\n        if (this._deleted) {\n            return;\n        }\n        const user = await this.assertedPersistence.getCurrentUser();\n        if (!this.currentUser && !user) {\n            // No change, do nothing (was signed out and remained signed out).\n            return;\n        }\n        // If the same user is to be synchronized.\n        if (this.currentUser && user && this.currentUser.uid === user.uid) {\n            // Data update, simply copy data changes.\n            this._currentUser._assign(user);\n            // If tokens changed from previous user tokens, this will trigger\n            // notifyAuthListeners_.\n            await this.currentUser.getIdToken();\n            return;\n        }\n        // Update current Auth state. Either a new login or logout.\n        // Skip blocking callbacks, they should not apply to a change in another tab.\n        await this._updateCurrentUser(user, /* skipBeforeStateCallbacks */ true);\n    }\n    async initializeCurrentUserFromIdToken(idToken) {\n        try {\n            const response = await getAccountInfo(this, {\n                idToken\n            });\n            const user = await UserImpl._fromGetAccountInfoResponse(this, response, idToken);\n            await this.directlySetCurrentUser(user);\n        } catch (err) {\n            console.warn(\"FirebaseServerApp could not login user with provided authIdToken: \", err);\n            await this.directlySetCurrentUser(null);\n        }\n    }\n    async initializeCurrentUser(popupRedirectResolver) {\n        var _a;\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app)) {\n            const idToken = this.app.settings.authIdToken;\n            if (idToken) {\n                // Start the auth operation in the next tick to allow a moment for the customer's app to\n                // attach an emulator, if desired.\n                return new Promise((resolve)=>{\n                    setTimeout(()=>this.initializeCurrentUserFromIdToken(idToken).then(resolve, resolve));\n                });\n            } else {\n                return this.directlySetCurrentUser(null);\n            }\n        }\n        // First check to see if we have a pending redirect event.\n        const previouslyStoredUser = await this.assertedPersistence.getCurrentUser();\n        let futureCurrentUser = previouslyStoredUser;\n        let needsTocheckMiddleware = false;\n        if (popupRedirectResolver && this.config.authDomain) {\n            await this.getOrInitRedirectPersistenceManager();\n            const redirectUserEventId = (_a = this.redirectUser) === null || _a === void 0 ? void 0 : _a._redirectEventId;\n            const storedUserEventId = futureCurrentUser === null || futureCurrentUser === void 0 ? void 0 : futureCurrentUser._redirectEventId;\n            const result = await this.tryRedirectSignIn(popupRedirectResolver);\n            // If the stored user (i.e. the old \"currentUser\") has a redirectId that\n            // matches the redirect user, then we want to initially sign in with the\n            // new user object from result.\n            // TODO(samgho): More thoroughly test all of this\n            if ((!redirectUserEventId || redirectUserEventId === storedUserEventId) && (result === null || result === void 0 ? void 0 : result.user)) {\n                futureCurrentUser = result.user;\n                needsTocheckMiddleware = true;\n            }\n        }\n        // If no user in persistence, there is no current user. Set to null.\n        if (!futureCurrentUser) {\n            return this.directlySetCurrentUser(null);\n        }\n        if (!futureCurrentUser._redirectEventId) {\n            // This isn't a redirect link operation, we can reload and bail.\n            // First though, ensure that we check the middleware is happy.\n            if (needsTocheckMiddleware) {\n                try {\n                    await this.beforeStateQueue.runMiddleware(futureCurrentUser);\n                } catch (e) {\n                    futureCurrentUser = previouslyStoredUser;\n                    // We know this is available since the bit is only set when the\n                    // resolver is available\n                    this._popupRedirectResolver._overrideRedirectResult(this, ()=>Promise.reject(e));\n                }\n            }\n            if (futureCurrentUser) {\n                return this.reloadAndSetCurrentUserOrClear(futureCurrentUser);\n            } else {\n                return this.directlySetCurrentUser(null);\n            }\n        }\n        _assert(this._popupRedirectResolver, this, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n        await this.getOrInitRedirectPersistenceManager();\n        // If the redirect user's event ID matches the current user's event ID,\n        // DO NOT reload the current user, otherwise they'll be cleared from storage.\n        // This is important for the reauthenticateWithRedirect() flow.\n        if (this.redirectUser && this.redirectUser._redirectEventId === futureCurrentUser._redirectEventId) {\n            return this.directlySetCurrentUser(futureCurrentUser);\n        }\n        return this.reloadAndSetCurrentUserOrClear(futureCurrentUser);\n    }\n    async tryRedirectSignIn(redirectResolver) {\n        // The redirect user needs to be checked (and signed in if available)\n        // during auth initialization. All of the normal sign in and link/reauth\n        // flows call back into auth and push things onto the promise queue. We\n        // need to await the result of the redirect sign in *inside the promise\n        // queue*. This presents a problem: we run into deadlock. See:\n        //    > [Initialization] \n        //    > [<other queue tasks>] \n        //     [getRedirectResult] <\n        //    where [] are tasks on the queue and arrows denote awaits\n        // Initialization will never complete because it's waiting on something\n        // that's waiting for initialization to complete!\n        //\n        // Instead, this method calls getRedirectResult() (stored in\n        // _completeRedirectFn) with an optional parameter that instructs all of\n        // the underlying auth operations to skip anything that mutates auth state.\n        let result = null;\n        try {\n            // We know this._popupRedirectResolver is set since redirectResolver\n            // is passed in. The _completeRedirectFn expects the unwrapped extern.\n            result = await this._popupRedirectResolver._completeRedirectFn(this, redirectResolver, true);\n        } catch (e) {\n            // Swallow any errors here; the code can retrieve them in\n            // getRedirectResult().\n            await this._setRedirectUser(null);\n        }\n        return result;\n    }\n    async reloadAndSetCurrentUserOrClear(user) {\n        try {\n            await _reloadWithoutSaving(user);\n        } catch (e) {\n            if ((e === null || e === void 0 ? void 0 : e.code) !== `auth/${\"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */ }`) {\n                // Something's wrong with the user's token. Log them out and remove\n                // them from storage\n                return this.directlySetCurrentUser(null);\n            }\n        }\n        return this.directlySetCurrentUser(user);\n    }\n    useDeviceLanguage() {\n        this.languageCode = _getUserLanguage();\n    }\n    async _delete() {\n        this._deleted = true;\n    }\n    async updateCurrentUser(userExtern) {\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app)) {\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));\n        }\n        // The public updateCurrentUser method needs to make a copy of the user,\n        // and also check that the project matches\n        const user = userExtern ? (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(userExtern) : null;\n        if (user) {\n            _assert(user.auth.config.apiKey === this.config.apiKey, this, \"invalid-user-token\" /* AuthErrorCode.INVALID_AUTH */ );\n        }\n        return this._updateCurrentUser(user && user._clone(this));\n    }\n    async _updateCurrentUser(user, skipBeforeStateCallbacks = false) {\n        if (this._deleted) {\n            return;\n        }\n        if (user) {\n            _assert(this.tenantId === user.tenantId, this, \"tenant-id-mismatch\" /* AuthErrorCode.TENANT_ID_MISMATCH */ );\n        }\n        if (!skipBeforeStateCallbacks) {\n            await this.beforeStateQueue.runMiddleware(user);\n        }\n        return this.queue(async ()=>{\n            await this.directlySetCurrentUser(user);\n            this.notifyAuthListeners();\n        });\n    }\n    async signOut() {\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app)) {\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));\n        }\n        // Run first, to block _setRedirectUser() if any callbacks fail.\n        await this.beforeStateQueue.runMiddleware(null);\n        // Clear the redirect user when signOut is called\n        if (this.redirectPersistenceManager || this._popupRedirectResolver) {\n            await this._setRedirectUser(null);\n        }\n        // Prevent callbacks from being called again in _updateCurrentUser, as\n        // they were already called in the first line.\n        return this._updateCurrentUser(null, /* skipBeforeStateCallbacks */ true);\n    }\n    setPersistence(persistence) {\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app)) {\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));\n        }\n        return this.queue(async ()=>{\n            await this.assertedPersistence.setPersistence(_getInstance(persistence));\n        });\n    }\n    _getRecaptchaConfig() {\n        if (this.tenantId == null) {\n            return this._agentRecaptchaConfig;\n        } else {\n            return this._tenantRecaptchaConfigs[this.tenantId];\n        }\n    }\n    async validatePassword(password) {\n        if (!this._getPasswordPolicyInternal()) {\n            await this._updatePasswordPolicy();\n        }\n        // Password policy will be defined after fetching.\n        const passwordPolicy = this._getPasswordPolicyInternal();\n        // Check that the policy schema version is supported by the SDK.\n        // TODO: Update this logic to use a max supported policy schema version once we have multiple schema versions.\n        if (passwordPolicy.schemaVersion !== this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION) {\n            return Promise.reject(this._errorFactory.create(\"unsupported-password-policy-schema-version\" /* AuthErrorCode.UNSUPPORTED_PASSWORD_POLICY_SCHEMA_VERSION */ , {}));\n        }\n        return passwordPolicy.validatePassword(password);\n    }\n    _getPasswordPolicyInternal() {\n        if (this.tenantId === null) {\n            return this._projectPasswordPolicy;\n        } else {\n            return this._tenantPasswordPolicies[this.tenantId];\n        }\n    }\n    async _updatePasswordPolicy() {\n        const response = await _getPasswordPolicy(this);\n        const passwordPolicy = new PasswordPolicyImpl(response);\n        if (this.tenantId === null) {\n            this._projectPasswordPolicy = passwordPolicy;\n        } else {\n            this._tenantPasswordPolicies[this.tenantId] = passwordPolicy;\n        }\n    }\n    _getPersistence() {\n        return this.assertedPersistence.persistence.type;\n    }\n    _updateErrorMap(errorMap) {\n        this._errorFactory = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.ErrorFactory(\"auth\", \"Firebase\", errorMap());\n    }\n    onAuthStateChanged(nextOrObserver, error, completed) {\n        return this.registerStateListener(this.authStateSubscription, nextOrObserver, error, completed);\n    }\n    beforeAuthStateChanged(callback, onAbort) {\n        return this.beforeStateQueue.pushCallback(callback, onAbort);\n    }\n    onIdTokenChanged(nextOrObserver, error, completed) {\n        return this.registerStateListener(this.idTokenSubscription, nextOrObserver, error, completed);\n    }\n    authStateReady() {\n        return new Promise((resolve, reject)=>{\n            if (this.currentUser) {\n                resolve();\n            } else {\n                const unsubscribe = this.onAuthStateChanged(()=>{\n                    unsubscribe();\n                    resolve();\n                }, reject);\n            }\n        });\n    }\n    /**\r\n     * Revokes the given access token. Currently only supports Apple OAuth access tokens.\r\n     */ async revokeAccessToken(token) {\n        if (this.currentUser) {\n            const idToken = await this.currentUser.getIdToken();\n            // Generalize this to accept other providers once supported.\n            const request = {\n                providerId: \"apple.com\",\n                tokenType: \"ACCESS_TOKEN\" /* TokenType.ACCESS_TOKEN */ ,\n                token,\n                idToken\n            };\n            if (this.tenantId != null) {\n                request.tenantId = this.tenantId;\n            }\n            await revokeToken(this, request);\n        }\n    }\n    toJSON() {\n        var _a;\n        return {\n            apiKey: this.config.apiKey,\n            authDomain: this.config.authDomain,\n            appName: this.name,\n            currentUser: (_a = this._currentUser) === null || _a === void 0 ? void 0 : _a.toJSON()\n        };\n    }\n    async _setRedirectUser(user, popupRedirectResolver) {\n        const redirectManager = await this.getOrInitRedirectPersistenceManager(popupRedirectResolver);\n        return user === null ? redirectManager.removeCurrentUser() : redirectManager.setCurrentUser(user);\n    }\n    async getOrInitRedirectPersistenceManager(popupRedirectResolver) {\n        if (!this.redirectPersistenceManager) {\n            const resolver = popupRedirectResolver && _getInstance(popupRedirectResolver) || this._popupRedirectResolver;\n            _assert(resolver, this, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n            this.redirectPersistenceManager = await PersistenceUserManager.create(this, [\n                _getInstance(resolver._redirectPersistence)\n            ], \"redirectUser\" /* KeyName.REDIRECT_USER */ );\n            this.redirectUser = await this.redirectPersistenceManager.getCurrentUser();\n        }\n        return this.redirectPersistenceManager;\n    }\n    async _redirectUserForId(id) {\n        var _a, _b;\n        // Make sure we've cleared any pending persistence actions if we're not in\n        // the initializer\n        if (this._isInitialized) {\n            await this.queue(async ()=>{});\n        }\n        if (((_a = this._currentUser) === null || _a === void 0 ? void 0 : _a._redirectEventId) === id) {\n            return this._currentUser;\n        }\n        if (((_b = this.redirectUser) === null || _b === void 0 ? void 0 : _b._redirectEventId) === id) {\n            return this.redirectUser;\n        }\n        return null;\n    }\n    async _persistUserIfCurrent(user) {\n        if (user === this.currentUser) {\n            return this.queue(async ()=>this.directlySetCurrentUser(user));\n        }\n    }\n    /** Notifies listeners only if the user is current */ _notifyListenersIfCurrent(user) {\n        if (user === this.currentUser) {\n            this.notifyAuthListeners();\n        }\n    }\n    _key() {\n        return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`;\n    }\n    _startProactiveRefresh() {\n        this.isProactiveRefreshEnabled = true;\n        if (this.currentUser) {\n            this._currentUser._startProactiveRefresh();\n        }\n    }\n    _stopProactiveRefresh() {\n        this.isProactiveRefreshEnabled = false;\n        if (this.currentUser) {\n            this._currentUser._stopProactiveRefresh();\n        }\n    }\n    /** Returns the current user cast as the internal type */ get _currentUser() {\n        return this.currentUser;\n    }\n    notifyAuthListeners() {\n        var _a, _b;\n        if (!this._isInitialized) {\n            return;\n        }\n        this.idTokenSubscription.next(this.currentUser);\n        const currentUid = (_b = (_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.uid) !== null && _b !== void 0 ? _b : null;\n        if (this.lastNotifiedUid !== currentUid) {\n            this.lastNotifiedUid = currentUid;\n            this.authStateSubscription.next(this.currentUser);\n        }\n    }\n    registerStateListener(subscription, nextOrObserver, error, completed) {\n        if (this._deleted) {\n            return ()=>{};\n        }\n        const cb = typeof nextOrObserver === \"function\" ? nextOrObserver : nextOrObserver.next.bind(nextOrObserver);\n        let isUnsubscribed = false;\n        const promise = this._isInitialized ? Promise.resolve() : this._initializationPromise;\n        _assert(promise, this, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        // The callback needs to be called asynchronously per the spec.\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        promise.then(()=>{\n            if (isUnsubscribed) {\n                return;\n            }\n            cb(this.currentUser);\n        });\n        if (typeof nextOrObserver === \"function\") {\n            const unsubscribe = subscription.addObserver(nextOrObserver, error, completed);\n            return ()=>{\n                isUnsubscribed = true;\n                unsubscribe();\n            };\n        } else {\n            const unsubscribe = subscription.addObserver(nextOrObserver);\n            return ()=>{\n                isUnsubscribed = true;\n                unsubscribe();\n            };\n        }\n    }\n    /**\r\n     * Unprotected (from race conditions) method to set the current user. This\r\n     * should only be called from within a queued callback. This is necessary\r\n     * because the queue shouldn't rely on another queued callback.\r\n     */ async directlySetCurrentUser(user) {\n        if (this.currentUser && this.currentUser !== user) {\n            this._currentUser._stopProactiveRefresh();\n        }\n        if (user && this.isProactiveRefreshEnabled) {\n            user._startProactiveRefresh();\n        }\n        this.currentUser = user;\n        if (user) {\n            await this.assertedPersistence.setCurrentUser(user);\n        } else {\n            await this.assertedPersistence.removeCurrentUser();\n        }\n    }\n    queue(action) {\n        // In case something errors, the callback still should be called in order\n        // to keep the promise chain alive\n        this.operations = this.operations.then(action, action);\n        return this.operations;\n    }\n    get assertedPersistence() {\n        _assert(this.persistenceManager, this, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        return this.persistenceManager;\n    }\n    _logFramework(framework) {\n        if (!framework || this.frameworks.includes(framework)) {\n            return;\n        }\n        this.frameworks.push(framework);\n        // Sort alphabetically so that \"FirebaseCore-web,FirebaseUI-web\" and\n        // \"FirebaseUI-web,FirebaseCore-web\" aren't viewed as different.\n        this.frameworks.sort();\n        this.clientVersion = _getClientVersion(this.config.clientPlatform, this._getFrameworks());\n    }\n    _getFrameworks() {\n        return this.frameworks;\n    }\n    async _getAdditionalHeaders() {\n        var _a;\n        // Additional headers on every request\n        const headers = {\n            [\"X-Client-Version\" /* HttpHeader.X_CLIENT_VERSION */ ]: this.clientVersion\n        };\n        if (this.app.options.appId) {\n            headers[\"X-Firebase-gmpid\" /* HttpHeader.X_FIREBASE_GMPID */ ] = this.app.options.appId;\n        }\n        // If the heartbeat service exists, add the heartbeat string\n        const heartbeatsHeader = await ((_a = this.heartbeatServiceProvider.getImmediate({\n            optional: true\n        })) === null || _a === void 0 ? void 0 : _a.getHeartbeatsHeader());\n        if (heartbeatsHeader) {\n            headers[\"X-Firebase-Client\" /* HttpHeader.X_FIREBASE_CLIENT */ ] = heartbeatsHeader;\n        }\n        // If the App Check service exists, add the App Check token in the headers\n        const appCheckToken = await this._getAppCheckToken();\n        if (appCheckToken) {\n            headers[\"X-Firebase-AppCheck\" /* HttpHeader.X_FIREBASE_APP_CHECK */ ] = appCheckToken;\n        }\n        return headers;\n    }\n    async _getAppCheckToken() {\n        var _a;\n        const appCheckTokenResult = await ((_a = this.appCheckServiceProvider.getImmediate({\n            optional: true\n        })) === null || _a === void 0 ? void 0 : _a.getToken());\n        if (appCheckTokenResult === null || appCheckTokenResult === void 0 ? void 0 : appCheckTokenResult.error) {\n            // Context: appCheck.getToken() will never throw even if an error happened.\n            // In the error case, a dummy token will be returned along with an error field describing\n            // the error. In general, we shouldn't care about the error condition and just use\n            // the token (actual or dummy) to send requests.\n            _logWarn(`Error while retrieving App Check token: ${appCheckTokenResult.error}`);\n        }\n        return appCheckTokenResult === null || appCheckTokenResult === void 0 ? void 0 : appCheckTokenResult.token;\n    }\n}\n/**\r\n * Method to be used to cast down to our private implementation of Auth.\r\n * It will also handle unwrapping from the compat type if necessary\r\n *\r\n * @param auth Auth object passed in from developer\r\n */ function _castAuth(auth) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth);\n}\n/** Helper class to wrap subscriber logic */ class Subscription {\n    constructor(auth){\n        this.auth = auth;\n        this.observer = null;\n        this.addObserver = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.createSubscribe)((observer)=>this.observer = observer);\n    }\n    get next() {\n        _assert(this.observer, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        return this.observer.next.bind(this.observer);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let externalJSProvider = {\n    async loadJS () {\n        throw new Error(\"Unable to load external scripts\");\n    },\n    recaptchaV2Script: \"\",\n    recaptchaEnterpriseScript: \"\",\n    gapiScript: \"\"\n};\nfunction _loadJS(url) {\n    return externalJSProvider.loadJS(url);\n}\nfunction _recaptchaEnterpriseScriptUrl() {\n    return externalJSProvider.recaptchaEnterpriseScript;\n}\n/* eslint-disable @typescript-eslint/no-require-imports */ const RECAPTCHA_ENTERPRISE_VERIFIER_TYPE = \"recaptcha-enterprise\";\nconst FAKE_TOKEN = \"NO_RECAPTCHA\";\nclass RecaptchaEnterpriseVerifier {\n    /**\r\n     *\r\n     * @param authExtern - The corresponding Firebase {@link Auth} instance.\r\n     *\r\n     */ constructor(authExtern){\n        /**\r\n         * Identifies the type of application verifier (e.g. \"recaptcha-enterprise\").\r\n         */ this.type = RECAPTCHA_ENTERPRISE_VERIFIER_TYPE;\n        this.auth = _castAuth(authExtern);\n    }\n    /**\r\n     * Executes the verification process.\r\n     *\r\n     * @returns A Promise for a token that can be used to assert the validity of a request.\r\n     */ async verify(action = \"verify\", forceRefresh = false) {\n        async function retrieveSiteKey(auth) {\n            if (!forceRefresh) {\n                if (auth.tenantId == null && auth._agentRecaptchaConfig != null) {\n                    return auth._agentRecaptchaConfig.siteKey;\n                }\n                if (auth.tenantId != null && auth._tenantRecaptchaConfigs[auth.tenantId] !== undefined) {\n                    return auth._tenantRecaptchaConfigs[auth.tenantId].siteKey;\n                }\n            }\n            return new Promise(async (resolve, reject)=>{\n                getRecaptchaConfig(auth, {\n                    clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */ ,\n                    version: \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */ \n                }).then((response)=>{\n                    if (response.recaptchaKey === undefined) {\n                        reject(new Error(\"recaptcha Enterprise site key undefined\"));\n                    } else {\n                        const config = new RecaptchaConfig(response);\n                        if (auth.tenantId == null) {\n                            auth._agentRecaptchaConfig = config;\n                        } else {\n                            auth._tenantRecaptchaConfigs[auth.tenantId] = config;\n                        }\n                        return resolve(config.siteKey);\n                    }\n                }).catch((error)=>{\n                    reject(error);\n                });\n            });\n        }\n        function retrieveRecaptchaToken(siteKey, resolve, reject) {\n            const grecaptcha = window.grecaptcha;\n            if (isEnterprise(grecaptcha)) {\n                grecaptcha.enterprise.ready(()=>{\n                    grecaptcha.enterprise.execute(siteKey, {\n                        action\n                    }).then((token)=>{\n                        resolve(token);\n                    }).catch(()=>{\n                        resolve(FAKE_TOKEN);\n                    });\n                });\n            } else {\n                reject(Error(\"No reCAPTCHA enterprise script loaded.\"));\n            }\n        }\n        return new Promise((resolve, reject)=>{\n            retrieveSiteKey(this.auth).then((siteKey)=>{\n                if (!forceRefresh && isEnterprise(window.grecaptcha)) {\n                    retrieveRecaptchaToken(siteKey, resolve, reject);\n                } else {\n                    if (true) {\n                        reject(new Error(\"RecaptchaVerifier is only supported in browser\"));\n                        return;\n                    }\n                    let url = _recaptchaEnterpriseScriptUrl();\n                    if (url.length !== 0) {\n                        url += siteKey;\n                    }\n                    _loadJS(url).then(()=>{\n                        retrieveRecaptchaToken(siteKey, resolve, reject);\n                    }).catch((error)=>{\n                        reject(error);\n                    });\n                }\n            }).catch((error)=>{\n                reject(error);\n            });\n        });\n    }\n}\nasync function injectRecaptchaFields(auth, request, action, captchaResp = false) {\n    const verifier = new RecaptchaEnterpriseVerifier(auth);\n    let captchaResponse;\n    try {\n        captchaResponse = await verifier.verify(action);\n    } catch (error) {\n        captchaResponse = await verifier.verify(action, true);\n    }\n    const newRequest = Object.assign({}, request);\n    if (!captchaResp) {\n        Object.assign(newRequest, {\n            captchaResponse\n        });\n    } else {\n        Object.assign(newRequest, {\n            \"captchaResp\": captchaResponse\n        });\n    }\n    Object.assign(newRequest, {\n        \"clientType\": \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */ \n    });\n    Object.assign(newRequest, {\n        \"recaptchaVersion\": \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */ \n    });\n    return newRequest;\n}\nasync function handleRecaptchaFlow(authInstance, request, actionName, actionMethod) {\n    var _a;\n    if ((_a = authInstance._getRecaptchaConfig()) === null || _a === void 0 ? void 0 : _a.isProviderEnabled(\"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaProvider.EMAIL_PASSWORD_PROVIDER */ )) {\n        const requestWithRecaptcha = await injectRecaptchaFields(authInstance, request, actionName, actionName === \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */ );\n        return actionMethod(authInstance, requestWithRecaptcha);\n    } else {\n        return actionMethod(authInstance, request).catch(async (error)=>{\n            if (error.code === `auth/${\"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */ }`) {\n                console.log(`${actionName} is protected by reCAPTCHA Enterprise for this project. Automatically triggering the reCAPTCHA flow and restarting the flow.`);\n                const requestWithRecaptcha = await injectRecaptchaFields(authInstance, request, actionName, actionName === \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */ );\n                return actionMethod(authInstance, requestWithRecaptcha);\n            } else {\n                return Promise.reject(error);\n            }\n        });\n    }\n}\nasync function _initializeRecaptchaConfig(auth) {\n    const authInternal = _castAuth(auth);\n    const response = await getRecaptchaConfig(authInternal, {\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */ ,\n        version: \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */ \n    });\n    const config = new RecaptchaConfig(response);\n    if (authInternal.tenantId == null) {\n        authInternal._agentRecaptchaConfig = config;\n    } else {\n        authInternal._tenantRecaptchaConfigs[authInternal.tenantId] = config;\n    }\n    if (config.isProviderEnabled(\"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaProvider.EMAIL_PASSWORD_PROVIDER */ )) {\n        const verifier = new RecaptchaEnterpriseVerifier(authInternal);\n        void verifier.verify();\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Initializes an {@link Auth} instance with fine-grained control over\r\n * {@link Dependencies}.\r\n *\r\n * @remarks\r\n *\r\n * This function allows more control over the {@link Auth} instance than\r\n * {@link getAuth}. `getAuth` uses platform-specific defaults to supply\r\n * the {@link Dependencies}. In general, `getAuth` is the easiest way to\r\n * initialize Auth and works for most use cases. Use `initializeAuth` if you\r\n * need control over which persistence layer is used, or to minimize bundle\r\n * size if you're not using either `signInWithPopup` or `signInWithRedirect`.\r\n *\r\n * For example, if your app only uses anonymous accounts and you only want\r\n * accounts saved for the current session, initialize `Auth` with:\r\n *\r\n * ```js\r\n * const auth = initializeAuth(app, {\r\n *   persistence: browserSessionPersistence,\r\n *   popupRedirectResolver: undefined,\r\n * });\r\n * ```\r\n *\r\n * @public\r\n */ function initializeAuth(app, deps) {\n    const provider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, \"auth\");\n    if (provider.isInitialized()) {\n        const auth = provider.getImmediate();\n        const initialOptions = provider.getOptions();\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.deepEqual)(initialOptions, deps !== null && deps !== void 0 ? deps : {})) {\n            return auth;\n        } else {\n            _fail(auth, \"already-initialized\" /* AuthErrorCode.ALREADY_INITIALIZED */ );\n        }\n    }\n    const auth = provider.initialize({\n        options: deps\n    });\n    return auth;\n}\nfunction _initializeAuthInstance(auth, deps) {\n    const persistence = (deps === null || deps === void 0 ? void 0 : deps.persistence) || [];\n    const hierarchy = (Array.isArray(persistence) ? persistence : [\n        persistence\n    ]).map(_getInstance);\n    if (deps === null || deps === void 0 ? void 0 : deps.errorMap) {\n        auth._updateErrorMap(deps.errorMap);\n    }\n    // This promise is intended to float; auth initialization happens in the\n    // background, meanwhile the auth object may be used by the app.\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    auth._initializeWithPersistence(hierarchy, deps === null || deps === void 0 ? void 0 : deps.popupRedirectResolver);\n}\n/**\r\n * Changes the {@link Auth} instance to communicate with the Firebase Auth Emulator, instead of production\r\n * Firebase Auth services.\r\n *\r\n * @remarks\r\n * This must be called synchronously immediately following the first call to\r\n * {@link initializeAuth}.  Do not use with production credentials as emulator\r\n * traffic is not encrypted.\r\n *\r\n *\r\n * @example\r\n * ```javascript\r\n * connectAuthEmulator(auth, 'http://127.0.0.1:9099', { disableWarnings: true });\r\n * ```\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param url - The URL at which the emulator is running (eg, 'http://localhost:9099').\r\n * @param options - Optional. `options.disableWarnings` defaults to `false`. Set it to\r\n * `true` to disable the warning banner attached to the DOM.\r\n *\r\n * @public\r\n */ function connectAuthEmulator(auth, url, options) {\n    const authInternal = _castAuth(auth);\n    _assert(authInternal._canInitEmulator, authInternal, \"emulator-config-failed\" /* AuthErrorCode.EMULATOR_CONFIG_FAILED */ );\n    _assert(/^https?:\\/\\//.test(url), authInternal, \"invalid-emulator-scheme\" /* AuthErrorCode.INVALID_EMULATOR_SCHEME */ );\n    const disableWarnings = !!(options === null || options === void 0 ? void 0 : options.disableWarnings);\n    const protocol = extractProtocol(url);\n    const { host, port } = extractHostAndPort(url);\n    const portStr = port === null ? \"\" : `:${port}`;\n    // Always replace path with \"/\" (even if input url had no path at all, or had a different one).\n    authInternal.config.emulator = {\n        url: `${protocol}//${host}${portStr}/`\n    };\n    authInternal.settings.appVerificationDisabledForTesting = true;\n    authInternal.emulatorConfig = Object.freeze({\n        host,\n        port,\n        protocol: protocol.replace(\":\", \"\"),\n        options: Object.freeze({\n            disableWarnings\n        })\n    });\n    if (!disableWarnings) {\n        emitEmulatorWarning();\n    }\n}\nfunction extractProtocol(url) {\n    const protocolEnd = url.indexOf(\":\");\n    return protocolEnd < 0 ? \"\" : url.substr(0, protocolEnd + 1);\n}\nfunction extractHostAndPort(url) {\n    const protocol = extractProtocol(url);\n    const authority = /(\\/\\/)?([^?#/]+)/.exec(url.substr(protocol.length)); // Between // and /, ? or #.\n    if (!authority) {\n        return {\n            host: \"\",\n            port: null\n        };\n    }\n    const hostAndPort = authority[2].split(\"@\").pop() || \"\"; // Strip out \"username:password@\".\n    const bracketedIPv6 = /^(\\[[^\\]]+\\])(:|$)/.exec(hostAndPort);\n    if (bracketedIPv6) {\n        const host = bracketedIPv6[1];\n        return {\n            host,\n            port: parsePort(hostAndPort.substr(host.length + 1))\n        };\n    } else {\n        const [host, port] = hostAndPort.split(\":\");\n        return {\n            host,\n            port: parsePort(port)\n        };\n    }\n}\nfunction parsePort(portStr) {\n    if (!portStr) {\n        return null;\n    }\n    const port = Number(portStr);\n    if (isNaN(port)) {\n        return null;\n    }\n    return port;\n}\nfunction emitEmulatorWarning() {\n    function attachBanner() {\n        const el = document.createElement(\"p\");\n        const sty = el.style;\n        el.innerText = \"Running in emulator mode. Do not use with production credentials.\";\n        sty.position = \"fixed\";\n        sty.width = \"100%\";\n        sty.backgroundColor = \"#ffffff\";\n        sty.border = \".1em solid #000000\";\n        sty.color = \"#b50000\";\n        sty.bottom = \"0px\";\n        sty.left = \"0px\";\n        sty.margin = \"0px\";\n        sty.zIndex = \"10000\";\n        sty.textAlign = \"center\";\n        el.classList.add(\"firebase-emulator-warning\");\n        document.body.appendChild(el);\n    }\n    if (typeof console !== \"undefined\" && typeof console.info === \"function\") {\n        console.info(\"WARNING: You are using the Auth Emulator,\" + \" which is intended for local testing only.  Do not use with\" + \" production credentials.\");\n    }\n    if (false) {}\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Interface that represents the credentials returned by an {@link AuthProvider}.\r\n *\r\n * @remarks\r\n * Implementations specify the details about each auth provider's credential requirements.\r\n *\r\n * @public\r\n */ class AuthCredential {\n    /** @internal */ constructor(/**\r\n     * The authentication provider ID for the credential.\r\n     *\r\n     * @remarks\r\n     * For example, 'facebook.com', or 'google.com'.\r\n     */ providerId, /**\r\n     * The authentication sign in method for the credential.\r\n     *\r\n     * @remarks\r\n     * For example, {@link SignInMethod}.EMAIL_PASSWORD, or\r\n     * {@link SignInMethod}.EMAIL_LINK. This corresponds to the sign-in method\r\n     * identifier as returned in {@link fetchSignInMethodsForEmail}.\r\n     */ signInMethod){\n        this.providerId = providerId;\n        this.signInMethod = signInMethod;\n    }\n    /**\r\n     * Returns a JSON-serializable representation of this object.\r\n     *\r\n     * @returns a JSON-serializable representation of this object.\r\n     */ toJSON() {\n        return debugFail(\"not implemented\");\n    }\n    /** @internal */ _getIdTokenResponse(_auth) {\n        return debugFail(\"not implemented\");\n    }\n    /** @internal */ _linkToIdToken(_auth, _idToken) {\n        return debugFail(\"not implemented\");\n    }\n    /** @internal */ _getReauthenticationResolver(_auth) {\n        return debugFail(\"not implemented\");\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function resetPassword(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:resetPassword\" /* Endpoint.RESET_PASSWORD */ , _addTidIfNecessary(auth, request));\n}\nasync function updateEmailPassword(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */ , request);\n}\n// Used for linking an email/password account to an existing idToken. Uses the same request/response\n// format as updateEmailPassword.\nasync function linkEmailPassword(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:signUp\" /* Endpoint.SIGN_UP */ , request);\n}\nasync function applyActionCode$1(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */ , _addTidIfNecessary(auth, request));\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function signInWithPassword(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:signInWithPassword\" /* Endpoint.SIGN_IN_WITH_PASSWORD */ , _addTidIfNecessary(auth, request));\n}\nasync function sendOobCode(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:sendOobCode\" /* Endpoint.SEND_OOB_CODE */ , _addTidIfNecessary(auth, request));\n}\nasync function sendEmailVerification$1(auth, request) {\n    return sendOobCode(auth, request);\n}\nasync function sendPasswordResetEmail$1(auth, request) {\n    return sendOobCode(auth, request);\n}\nasync function sendSignInLinkToEmail$1(auth, request) {\n    return sendOobCode(auth, request);\n}\nasync function verifyAndChangeEmail(auth, request) {\n    return sendOobCode(auth, request);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function signInWithEmailLink$1(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:signInWithEmailLink\" /* Endpoint.SIGN_IN_WITH_EMAIL_LINK */ , _addTidIfNecessary(auth, request));\n}\nasync function signInWithEmailLinkForLinking(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:signInWithEmailLink\" /* Endpoint.SIGN_IN_WITH_EMAIL_LINK */ , _addTidIfNecessary(auth, request));\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Interface that represents the credentials returned by {@link EmailAuthProvider} for\r\n * {@link ProviderId}.PASSWORD\r\n *\r\n * @remarks\r\n * Covers both {@link SignInMethod}.EMAIL_PASSWORD and\r\n * {@link SignInMethod}.EMAIL_LINK.\r\n *\r\n * @public\r\n */ class EmailAuthCredential extends AuthCredential {\n    /** @internal */ constructor(/** @internal */ _email, /** @internal */ _password, signInMethod, /** @internal */ _tenantId = null){\n        super(\"password\" /* ProviderId.PASSWORD */ , signInMethod);\n        this._email = _email;\n        this._password = _password;\n        this._tenantId = _tenantId;\n    }\n    /** @internal */ static _fromEmailAndPassword(email, password) {\n        return new EmailAuthCredential(email, password, \"password\" /* SignInMethod.EMAIL_PASSWORD */ );\n    }\n    /** @internal */ static _fromEmailAndCode(email, oobCode, tenantId = null) {\n        return new EmailAuthCredential(email, oobCode, \"emailLink\" /* SignInMethod.EMAIL_LINK */ , tenantId);\n    }\n    /** {@inheritdoc AuthCredential.toJSON} */ toJSON() {\n        return {\n            email: this._email,\n            password: this._password,\n            signInMethod: this.signInMethod,\n            tenantId: this._tenantId\n        };\n    }\n    /**\r\n     * Static method to deserialize a JSON representation of an object into an {@link  AuthCredential}.\r\n     *\r\n     * @param json - Either `object` or the stringified representation of the object. When string is\r\n     * provided, `JSON.parse` would be called first.\r\n     *\r\n     * @returns If the JSON input does not represent an {@link AuthCredential}, null is returned.\r\n     */ static fromJSON(json) {\n        const obj = typeof json === \"string\" ? JSON.parse(json) : json;\n        if ((obj === null || obj === void 0 ? void 0 : obj.email) && (obj === null || obj === void 0 ? void 0 : obj.password)) {\n            if (obj.signInMethod === \"password\" /* SignInMethod.EMAIL_PASSWORD */ ) {\n                return this._fromEmailAndPassword(obj.email, obj.password);\n            } else if (obj.signInMethod === \"emailLink\" /* SignInMethod.EMAIL_LINK */ ) {\n                return this._fromEmailAndCode(obj.email, obj.password, obj.tenantId);\n            }\n        }\n        return null;\n    }\n    /** @internal */ async _getIdTokenResponse(auth) {\n        switch(this.signInMethod){\n            case \"password\" /* SignInMethod.EMAIL_PASSWORD */ :\n                const request = {\n                    returnSecureToken: true,\n                    email: this._email,\n                    password: this._password,\n                    clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */ \n                };\n                return handleRecaptchaFlow(auth, request, \"signInWithPassword\" /* RecaptchaActionName.SIGN_IN_WITH_PASSWORD */ , signInWithPassword);\n            case \"emailLink\" /* SignInMethod.EMAIL_LINK */ :\n                return signInWithEmailLink$1(auth, {\n                    email: this._email,\n                    oobCode: this._password\n                });\n            default:\n                _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        }\n    }\n    /** @internal */ async _linkToIdToken(auth, idToken) {\n        switch(this.signInMethod){\n            case \"password\" /* SignInMethod.EMAIL_PASSWORD */ :\n                const request = {\n                    idToken,\n                    returnSecureToken: true,\n                    email: this._email,\n                    password: this._password,\n                    clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */ \n                };\n                return handleRecaptchaFlow(auth, request, \"signUpPassword\" /* RecaptchaActionName.SIGN_UP_PASSWORD */ , linkEmailPassword);\n            case \"emailLink\" /* SignInMethod.EMAIL_LINK */ :\n                return signInWithEmailLinkForLinking(auth, {\n                    idToken,\n                    email: this._email,\n                    oobCode: this._password\n                });\n            default:\n                _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        }\n    }\n    /** @internal */ _getReauthenticationResolver(auth) {\n        return this._getIdTokenResponse(auth);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function signInWithIdp(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:signInWithIdp\" /* Endpoint.SIGN_IN_WITH_IDP */ , _addTidIfNecessary(auth, request));\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const IDP_REQUEST_URI$1 = \"http://localhost\";\n/**\r\n * Represents the OAuth credentials returned by an {@link OAuthProvider}.\r\n *\r\n * @remarks\r\n * Implementations specify the details about each auth provider's credential requirements.\r\n *\r\n * @public\r\n */ class OAuthCredential extends AuthCredential {\n    constructor(){\n        super(...arguments);\n        this.pendingToken = null;\n    }\n    /** @internal */ static _fromParams(params) {\n        const cred = new OAuthCredential(params.providerId, params.signInMethod);\n        if (params.idToken || params.accessToken) {\n            // OAuth 2 and either ID token or access token.\n            if (params.idToken) {\n                cred.idToken = params.idToken;\n            }\n            if (params.accessToken) {\n                cred.accessToken = params.accessToken;\n            }\n            // Add nonce if available and no pendingToken is present.\n            if (params.nonce && !params.pendingToken) {\n                cred.nonce = params.nonce;\n            }\n            if (params.pendingToken) {\n                cred.pendingToken = params.pendingToken;\n            }\n        } else if (params.oauthToken && params.oauthTokenSecret) {\n            // OAuth 1 and OAuth token with token secret\n            cred.accessToken = params.oauthToken;\n            cred.secret = params.oauthTokenSecret;\n        } else {\n            _fail(\"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n        }\n        return cred;\n    }\n    /** {@inheritdoc AuthCredential.toJSON}  */ toJSON() {\n        return {\n            idToken: this.idToken,\n            accessToken: this.accessToken,\n            secret: this.secret,\n            nonce: this.nonce,\n            pendingToken: this.pendingToken,\n            providerId: this.providerId,\n            signInMethod: this.signInMethod\n        };\n    }\n    /**\r\n     * Static method to deserialize a JSON representation of an object into an\r\n     * {@link  AuthCredential}.\r\n     *\r\n     * @param json - Input can be either Object or the stringified representation of the object.\r\n     * When string is provided, JSON.parse would be called first.\r\n     *\r\n     * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.\r\n     */ static fromJSON(json) {\n        const obj = typeof json === \"string\" ? JSON.parse(json) : json;\n        const { providerId, signInMethod } = obj, rest = (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__rest)(obj, [\n            \"providerId\",\n            \"signInMethod\"\n        ]);\n        if (!providerId || !signInMethod) {\n            return null;\n        }\n        const cred = new OAuthCredential(providerId, signInMethod);\n        cred.idToken = rest.idToken || undefined;\n        cred.accessToken = rest.accessToken || undefined;\n        cred.secret = rest.secret;\n        cred.nonce = rest.nonce;\n        cred.pendingToken = rest.pendingToken || null;\n        return cred;\n    }\n    /** @internal */ _getIdTokenResponse(auth) {\n        const request = this.buildRequest();\n        return signInWithIdp(auth, request);\n    }\n    /** @internal */ _linkToIdToken(auth, idToken) {\n        const request = this.buildRequest();\n        request.idToken = idToken;\n        return signInWithIdp(auth, request);\n    }\n    /** @internal */ _getReauthenticationResolver(auth) {\n        const request = this.buildRequest();\n        request.autoCreate = false;\n        return signInWithIdp(auth, request);\n    }\n    buildRequest() {\n        const request = {\n            requestUri: IDP_REQUEST_URI$1,\n            returnSecureToken: true\n        };\n        if (this.pendingToken) {\n            request.pendingToken = this.pendingToken;\n        } else {\n            const postBody = {};\n            if (this.idToken) {\n                postBody[\"id_token\"] = this.idToken;\n            }\n            if (this.accessToken) {\n                postBody[\"access_token\"] = this.accessToken;\n            }\n            if (this.secret) {\n                postBody[\"oauth_token_secret\"] = this.secret;\n            }\n            postBody[\"providerId\"] = this.providerId;\n            if (this.nonce && !this.pendingToken) {\n                postBody[\"nonce\"] = this.nonce;\n            }\n            request.postBody = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystring)(postBody);\n        }\n        return request;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function signInWithPhoneNumber$1(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:signInWithPhoneNumber\" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */ , _addTidIfNecessary(auth, request));\n}\nasync function linkWithPhoneNumber$1(auth, request) {\n    const response = await _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:signInWithPhoneNumber\" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */ , _addTidIfNecessary(auth, request));\n    if (response.temporaryProof) {\n        throw _makeTaggedError(auth, \"account-exists-with-different-credential\" /* AuthErrorCode.NEED_CONFIRMATION */ , response);\n    }\n    return response;\n}\nconst VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_ = {\n    [\"USER_NOT_FOUND\" /* ServerError.USER_NOT_FOUND */ ]: \"user-not-found\" /* AuthErrorCode.USER_DELETED */ \n};\nasync function verifyPhoneNumberForExisting(auth, request) {\n    const apiRequest = Object.assign(Object.assign({}, request), {\n        operation: \"REAUTH\"\n    });\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:signInWithPhoneNumber\" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */ , _addTidIfNecessary(auth, apiRequest), VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Represents the credentials returned by {@link PhoneAuthProvider}.\r\n *\r\n * @public\r\n */ class PhoneAuthCredential extends AuthCredential {\n    constructor(params){\n        super(\"phone\" /* ProviderId.PHONE */ , \"phone\" /* SignInMethod.PHONE */ );\n        this.params = params;\n    }\n    /** @internal */ static _fromVerification(verificationId, verificationCode) {\n        return new PhoneAuthCredential({\n            verificationId,\n            verificationCode\n        });\n    }\n    /** @internal */ static _fromTokenResponse(phoneNumber, temporaryProof) {\n        return new PhoneAuthCredential({\n            phoneNumber,\n            temporaryProof\n        });\n    }\n    /** @internal */ _getIdTokenResponse(auth) {\n        return signInWithPhoneNumber$1(auth, this._makeVerificationRequest());\n    }\n    /** @internal */ _linkToIdToken(auth, idToken) {\n        return linkWithPhoneNumber$1(auth, Object.assign({\n            idToken\n        }, this._makeVerificationRequest()));\n    }\n    /** @internal */ _getReauthenticationResolver(auth) {\n        return verifyPhoneNumberForExisting(auth, this._makeVerificationRequest());\n    }\n    /** @internal */ _makeVerificationRequest() {\n        const { temporaryProof, phoneNumber, verificationId, verificationCode } = this.params;\n        if (temporaryProof && phoneNumber) {\n            return {\n                temporaryProof,\n                phoneNumber\n            };\n        }\n        return {\n            sessionInfo: verificationId,\n            code: verificationCode\n        };\n    }\n    /** {@inheritdoc AuthCredential.toJSON} */ toJSON() {\n        const obj = {\n            providerId: this.providerId\n        };\n        if (this.params.phoneNumber) {\n            obj.phoneNumber = this.params.phoneNumber;\n        }\n        if (this.params.temporaryProof) {\n            obj.temporaryProof = this.params.temporaryProof;\n        }\n        if (this.params.verificationCode) {\n            obj.verificationCode = this.params.verificationCode;\n        }\n        if (this.params.verificationId) {\n            obj.verificationId = this.params.verificationId;\n        }\n        return obj;\n    }\n    /** Generates a phone credential based on a plain object or a JSON string. */ static fromJSON(json) {\n        if (typeof json === \"string\") {\n            json = JSON.parse(json);\n        }\n        const { verificationId, verificationCode, phoneNumber, temporaryProof } = json;\n        if (!verificationCode && !verificationId && !phoneNumber && !temporaryProof) {\n            return null;\n        }\n        return new PhoneAuthCredential({\n            verificationId,\n            verificationCode,\n            phoneNumber,\n            temporaryProof\n        });\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Maps the mode string in action code URL to Action Code Info operation.\r\n *\r\n * @param mode\r\n */ function parseMode(mode) {\n    switch(mode){\n        case \"recoverEmail\":\n            return \"RECOVER_EMAIL\" /* ActionCodeOperation.RECOVER_EMAIL */ ;\n        case \"resetPassword\":\n            return \"PASSWORD_RESET\" /* ActionCodeOperation.PASSWORD_RESET */ ;\n        case \"signIn\":\n            return \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */ ;\n        case \"verifyEmail\":\n            return \"VERIFY_EMAIL\" /* ActionCodeOperation.VERIFY_EMAIL */ ;\n        case \"verifyAndChangeEmail\":\n            return \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */ ;\n        case \"revertSecondFactorAddition\":\n            return \"REVERT_SECOND_FACTOR_ADDITION\" /* ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION */ ;\n        default:\n            return null;\n    }\n}\n/**\r\n * Helper to parse FDL links\r\n *\r\n * @param url\r\n */ function parseDeepLink(url) {\n    const link = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(url))[\"link\"];\n    // Double link case (automatic redirect).\n    const doubleDeepLink = link ? (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(link))[\"deep_link_id\"] : null;\n    // iOS custom scheme links.\n    const iOSDeepLink = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(url))[\"deep_link_id\"];\n    const iOSDoubleDeepLink = iOSDeepLink ? (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(iOSDeepLink))[\"link\"] : null;\n    return iOSDoubleDeepLink || iOSDeepLink || doubleDeepLink || link || url;\n}\n/**\r\n * A utility class to parse email action URLs such as password reset, email verification,\r\n * email link sign in, etc.\r\n *\r\n * @public\r\n */ class ActionCodeURL {\n    /**\r\n     * @param actionLink - The link from which to extract the URL.\r\n     * @returns The {@link ActionCodeURL} object, or null if the link is invalid.\r\n     *\r\n     * @internal\r\n     */ constructor(actionLink){\n        var _a, _b, _c, _d, _e, _f;\n        const searchParams = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(actionLink));\n        const apiKey = (_a = searchParams[\"apiKey\" /* QueryField.API_KEY */ ]) !== null && _a !== void 0 ? _a : null;\n        const code = (_b = searchParams[\"oobCode\" /* QueryField.CODE */ ]) !== null && _b !== void 0 ? _b : null;\n        const operation = parseMode((_c = searchParams[\"mode\" /* QueryField.MODE */ ]) !== null && _c !== void 0 ? _c : null);\n        // Validate API key, code and mode.\n        _assert(apiKey && code && operation, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n        this.apiKey = apiKey;\n        this.operation = operation;\n        this.code = code;\n        this.continueUrl = (_d = searchParams[\"continueUrl\" /* QueryField.CONTINUE_URL */ ]) !== null && _d !== void 0 ? _d : null;\n        this.languageCode = (_e = searchParams[\"languageCode\" /* QueryField.LANGUAGE_CODE */ ]) !== null && _e !== void 0 ? _e : null;\n        this.tenantId = (_f = searchParams[\"tenantId\" /* QueryField.TENANT_ID */ ]) !== null && _f !== void 0 ? _f : null;\n    }\n    /**\r\n     * Parses the email action link string and returns an {@link ActionCodeURL} if the link is valid,\r\n     * otherwise returns null.\r\n     *\r\n     * @param link  - The email action link string.\r\n     * @returns The {@link ActionCodeURL} object, or null if the link is invalid.\r\n     *\r\n     * @public\r\n     */ static parseLink(link) {\n        const actionLink = parseDeepLink(link);\n        try {\n            return new ActionCodeURL(actionLink);\n        } catch (_a) {\n            return null;\n        }\n    }\n}\n/**\r\n * Parses the email action link string and returns an {@link ActionCodeURL} if\r\n * the link is valid, otherwise returns null.\r\n *\r\n * @public\r\n */ function parseActionCodeURL(link) {\n    return ActionCodeURL.parseLink(link);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Provider for generating {@link EmailAuthCredential}.\r\n *\r\n * @public\r\n */ class EmailAuthProvider {\n    constructor(){\n        /**\r\n         * Always set to {@link ProviderId}.PASSWORD, even for email link.\r\n         */ this.providerId = EmailAuthProvider.PROVIDER_ID;\n    }\n    /**\r\n     * Initialize an {@link AuthCredential} using an email and password.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * const authCredential = EmailAuthProvider.credential(email, password);\r\n     * const userCredential = await signInWithCredential(auth, authCredential);\r\n     * ```\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * const userCredential = await signInWithEmailAndPassword(auth, email, password);\r\n     * ```\r\n     *\r\n     * @param email - Email address.\r\n     * @param password - User account password.\r\n     * @returns The auth provider credential.\r\n     */ static credential(email, password) {\n        return EmailAuthCredential._fromEmailAndPassword(email, password);\n    }\n    /**\r\n     * Initialize an {@link AuthCredential} using an email and an email link after a sign in with\r\n     * email link operation.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * const authCredential = EmailAuthProvider.credentialWithLink(auth, email, emailLink);\r\n     * const userCredential = await signInWithCredential(auth, authCredential);\r\n     * ```\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * await sendSignInLinkToEmail(auth, email);\r\n     * // Obtain emailLink from user.\r\n     * const userCredential = await signInWithEmailLink(auth, email, emailLink);\r\n     * ```\r\n     *\r\n     * @param auth - The {@link Auth} instance used to verify the link.\r\n     * @param email - Email address.\r\n     * @param emailLink - Sign-in email link.\r\n     * @returns - The auth provider credential.\r\n     */ static credentialWithLink(email, emailLink) {\n        const actionCodeUrl = ActionCodeURL.parseLink(emailLink);\n        _assert(actionCodeUrl, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n        return EmailAuthCredential._fromEmailAndCode(email, actionCodeUrl.code, actionCodeUrl.tenantId);\n    }\n}\n/**\r\n * Always set to {@link ProviderId}.PASSWORD, even for email link.\r\n */ EmailAuthProvider.PROVIDER_ID = \"password\" /* ProviderId.PASSWORD */ ;\n/**\r\n * Always set to {@link SignInMethod}.EMAIL_PASSWORD.\r\n */ EmailAuthProvider.EMAIL_PASSWORD_SIGN_IN_METHOD = \"password\" /* SignInMethod.EMAIL_PASSWORD */ ;\n/**\r\n * Always set to {@link SignInMethod}.EMAIL_LINK.\r\n */ EmailAuthProvider.EMAIL_LINK_SIGN_IN_METHOD = \"emailLink\" /* SignInMethod.EMAIL_LINK */ ;\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The base class for all Federated providers (OAuth (including OIDC), SAML).\r\n *\r\n * This class is not meant to be instantiated directly.\r\n *\r\n * @public\r\n */ class FederatedAuthProvider {\n    /**\r\n     * Constructor for generic OAuth providers.\r\n     *\r\n     * @param providerId - Provider for which credentials should be generated.\r\n     */ constructor(providerId){\n        this.providerId = providerId;\n        /** @internal */ this.defaultLanguageCode = null;\n        /** @internal */ this.customParameters = {};\n    }\n    /**\r\n     * Set the language gode.\r\n     *\r\n     * @param languageCode - language code\r\n     */ setDefaultLanguage(languageCode) {\n        this.defaultLanguageCode = languageCode;\n    }\n    /**\r\n     * Sets the OAuth custom parameters to pass in an OAuth request for popup and redirect sign-in\r\n     * operations.\r\n     *\r\n     * @remarks\r\n     * For a detailed list, check the reserved required OAuth 2.0 parameters such as `client_id`,\r\n     * `redirect_uri`, `scope`, `response_type`, and `state` are not allowed and will be ignored.\r\n     *\r\n     * @param customOAuthParameters - The custom OAuth parameters to pass in the OAuth request.\r\n     */ setCustomParameters(customOAuthParameters) {\n        this.customParameters = customOAuthParameters;\n        return this;\n    }\n    /**\r\n     * Retrieve the current list of {@link CustomParameters}.\r\n     */ getCustomParameters() {\n        return this.customParameters;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Common code to all OAuth providers. This is separate from the\r\n * {@link OAuthProvider} so that child providers (like\r\n * {@link GoogleAuthProvider}) don't inherit the `credential` instance method.\r\n * Instead, they rely on a static `credential` method.\r\n */ class BaseOAuthProvider extends FederatedAuthProvider {\n    constructor(){\n        super(...arguments);\n        /** @internal */ this.scopes = [];\n    }\n    /**\r\n     * Add an OAuth scope to the credential.\r\n     *\r\n     * @param scope - Provider OAuth scope to add.\r\n     */ addScope(scope) {\n        // If not already added, add scope to list.\n        if (!this.scopes.includes(scope)) {\n            this.scopes.push(scope);\n        }\n        return this;\n    }\n    /**\r\n     * Retrieve the current list of OAuth scopes.\r\n     */ getScopes() {\n        return [\n            ...this.scopes\n        ];\n    }\n}\n/**\r\n * Provider for generating generic {@link OAuthCredential}.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a redirect.\r\n * const provider = new OAuthProvider('google.com');\r\n * // Start a sign in process for an unauthenticated user.\r\n * provider.addScope('profile');\r\n * provider.addScope('email');\r\n * await signInWithRedirect(auth, provider);\r\n * // This will trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * if (result) {\r\n *   // This is the signed-in user\r\n *   const user = result.user;\r\n *   // This gives you a OAuth Access Token for the provider.\r\n *   const credential = provider.credentialFromResult(auth, result);\r\n *   const token = credential.accessToken;\r\n * }\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a popup.\r\n * const provider = new OAuthProvider('google.com');\r\n * provider.addScope('profile');\r\n * provider.addScope('email');\r\n * const result = await signInWithPopup(auth, provider);\r\n *\r\n * // The signed-in user info.\r\n * const user = result.user;\r\n * // This gives you a OAuth Access Token for the provider.\r\n * const credential = provider.credentialFromResult(auth, result);\r\n * const token = credential.accessToken;\r\n * ```\r\n * @public\r\n */ class OAuthProvider extends BaseOAuthProvider {\n    /**\r\n     * Creates an {@link OAuthCredential} from a JSON string or a plain object.\r\n     * @param json - A plain object or a JSON string\r\n     */ static credentialFromJSON(json) {\n        const obj = typeof json === \"string\" ? JSON.parse(json) : json;\n        _assert(\"providerId\" in obj && \"signInMethod\" in obj, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n        return OAuthCredential._fromParams(obj);\n    }\n    /**\r\n     * Creates a {@link OAuthCredential} from a generic OAuth provider's access token or ID token.\r\n     *\r\n     * @remarks\r\n     * The raw nonce is required when an ID token with a nonce field is provided. The SHA-256 hash of\r\n     * the raw nonce must match the nonce field in the ID token.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // `googleUser` from the onsuccess Google Sign In callback.\r\n     * // Initialize a generate OAuth provider with a `google.com` providerId.\r\n     * const provider = new OAuthProvider('google.com');\r\n     * const credential = provider.credential({\r\n     *   idToken: googleUser.getAuthResponse().id_token,\r\n     * });\r\n     * const result = await signInWithCredential(credential);\r\n     * ```\r\n     *\r\n     * @param params - Either the options object containing the ID token, access token and raw nonce\r\n     * or the ID token string.\r\n     */ credential(params) {\n        return this._credential(Object.assign(Object.assign({}, params), {\n            nonce: params.rawNonce\n        }));\n    }\n    /** An internal credential method that accepts more permissive options */ _credential(params) {\n        _assert(params.idToken || params.accessToken, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n        // For OAuthCredential, sign in method is same as providerId.\n        return OAuthCredential._fromParams(Object.assign(Object.assign({}, params), {\n            providerId: this.providerId,\n            signInMethod: this.providerId\n        }));\n    }\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */ static credentialFromResult(userCredential) {\n        return OAuthProvider.oauthCredentialFromTaggedObject(userCredential);\n    }\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\r\n     * thrown during a sign-in, link, or reauthenticate operation.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */ static credentialFromError(error) {\n        return OAuthProvider.oauthCredentialFromTaggedObject(error.customData || {});\n    }\n    static oauthCredentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse) {\n            return null;\n        }\n        const { oauthIdToken, oauthAccessToken, oauthTokenSecret, pendingToken, nonce, providerId } = tokenResponse;\n        if (!oauthAccessToken && !oauthTokenSecret && !oauthIdToken && !pendingToken) {\n            return null;\n        }\n        if (!providerId) {\n            return null;\n        }\n        try {\n            return new OAuthProvider(providerId)._credential({\n                idToken: oauthIdToken,\n                accessToken: oauthAccessToken,\n                nonce,\n                pendingToken\n            });\n        } catch (e) {\n            return null;\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.FACEBOOK.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a redirect.\r\n * const provider = new FacebookAuthProvider();\r\n * // Start a sign in process for an unauthenticated user.\r\n * provider.addScope('user_birthday');\r\n * await signInWithRedirect(auth, provider);\r\n * // This will trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * if (result) {\r\n *   // This is the signed-in user\r\n *   const user = result.user;\r\n *   // This gives you a Facebook Access Token.\r\n *   const credential = FacebookAuthProvider.credentialFromResult(result);\r\n *   const token = credential.accessToken;\r\n * }\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a popup.\r\n * const provider = new FacebookAuthProvider();\r\n * provider.addScope('user_birthday');\r\n * const result = await signInWithPopup(auth, provider);\r\n *\r\n * // The signed-in user info.\r\n * const user = result.user;\r\n * // This gives you a Facebook Access Token.\r\n * const credential = FacebookAuthProvider.credentialFromResult(result);\r\n * const token = credential.accessToken;\r\n * ```\r\n *\r\n * @public\r\n */ class FacebookAuthProvider extends BaseOAuthProvider {\n    constructor(){\n        super(\"facebook.com\" /* ProviderId.FACEBOOK */ );\n    }\n    /**\r\n     * Creates a credential for Facebook.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // `event` from the Facebook auth.authResponseChange callback.\r\n     * const credential = FacebookAuthProvider.credential(event.authResponse.accessToken);\r\n     * const result = await signInWithCredential(credential);\r\n     * ```\r\n     *\r\n     * @param accessToken - Facebook access token.\r\n     */ static credential(accessToken) {\n        return OAuthCredential._fromParams({\n            providerId: FacebookAuthProvider.PROVIDER_ID,\n            signInMethod: FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD,\n            accessToken\n        });\n    }\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */ static credentialFromResult(userCredential) {\n        return FacebookAuthProvider.credentialFromTaggedObject(userCredential);\n    }\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\r\n     * thrown during a sign-in, link, or reauthenticate operation.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */ static credentialFromError(error) {\n        return FacebookAuthProvider.credentialFromTaggedObject(error.customData || {});\n    }\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse || !(\"oauthAccessToken\" in tokenResponse)) {\n            return null;\n        }\n        if (!tokenResponse.oauthAccessToken) {\n            return null;\n        }\n        try {\n            return FacebookAuthProvider.credential(tokenResponse.oauthAccessToken);\n        } catch (_a) {\n            return null;\n        }\n    }\n}\n/** Always set to {@link SignInMethod}.FACEBOOK. */ FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD = \"facebook.com\" /* SignInMethod.FACEBOOK */ ;\n/** Always set to {@link ProviderId}.FACEBOOK. */ FacebookAuthProvider.PROVIDER_ID = \"facebook.com\" /* ProviderId.FACEBOOK */ ;\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.GOOGLE.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a redirect.\r\n * const provider = new GoogleAuthProvider();\r\n * // Start a sign in process for an unauthenticated user.\r\n * provider.addScope('profile');\r\n * provider.addScope('email');\r\n * await signInWithRedirect(auth, provider);\r\n * // This will trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * if (result) {\r\n *   // This is the signed-in user\r\n *   const user = result.user;\r\n *   // This gives you a Google Access Token.\r\n *   const credential = GoogleAuthProvider.credentialFromResult(result);\r\n *   const token = credential.accessToken;\r\n * }\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a popup.\r\n * const provider = new GoogleAuthProvider();\r\n * provider.addScope('profile');\r\n * provider.addScope('email');\r\n * const result = await signInWithPopup(auth, provider);\r\n *\r\n * // The signed-in user info.\r\n * const user = result.user;\r\n * // This gives you a Google Access Token.\r\n * const credential = GoogleAuthProvider.credentialFromResult(result);\r\n * const token = credential.accessToken;\r\n * ```\r\n *\r\n * @public\r\n */ class GoogleAuthProvider extends BaseOAuthProvider {\n    constructor(){\n        super(\"google.com\" /* ProviderId.GOOGLE */ );\n        this.addScope(\"profile\");\n    }\n    /**\r\n     * Creates a credential for Google. At least one of ID token and access token is required.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // \\`googleUser\\` from the onsuccess Google Sign In callback.\r\n     * const credential = GoogleAuthProvider.credential(googleUser.getAuthResponse().id_token);\r\n     * const result = await signInWithCredential(credential);\r\n     * ```\r\n     *\r\n     * @param idToken - Google ID token.\r\n     * @param accessToken - Google access token.\r\n     */ static credential(idToken, accessToken) {\n        return OAuthCredential._fromParams({\n            providerId: GoogleAuthProvider.PROVIDER_ID,\n            signInMethod: GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD,\n            idToken,\n            accessToken\n        });\n    }\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */ static credentialFromResult(userCredential) {\n        return GoogleAuthProvider.credentialFromTaggedObject(userCredential);\n    }\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\r\n     * thrown during a sign-in, link, or reauthenticate operation.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */ static credentialFromError(error) {\n        return GoogleAuthProvider.credentialFromTaggedObject(error.customData || {});\n    }\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse) {\n            return null;\n        }\n        const { oauthIdToken, oauthAccessToken } = tokenResponse;\n        if (!oauthIdToken && !oauthAccessToken) {\n            // This could be an oauth 1 credential or a phone credential\n            return null;\n        }\n        try {\n            return GoogleAuthProvider.credential(oauthIdToken, oauthAccessToken);\n        } catch (_a) {\n            return null;\n        }\n    }\n}\n/** Always set to {@link SignInMethod}.GOOGLE. */ GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD = \"google.com\" /* SignInMethod.GOOGLE */ ;\n/** Always set to {@link ProviderId}.GOOGLE. */ GoogleAuthProvider.PROVIDER_ID = \"google.com\" /* ProviderId.GOOGLE */ ;\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.GITHUB.\r\n *\r\n * @remarks\r\n * GitHub requires an OAuth 2.0 redirect, so you can either handle the redirect directly, or use\r\n * the {@link signInWithPopup} handler:\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a redirect.\r\n * const provider = new GithubAuthProvider();\r\n * // Start a sign in process for an unauthenticated user.\r\n * provider.addScope('repo');\r\n * await signInWithRedirect(auth, provider);\r\n * // This will trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * if (result) {\r\n *   // This is the signed-in user\r\n *   const user = result.user;\r\n *   // This gives you a GitHub Access Token.\r\n *   const credential = GithubAuthProvider.credentialFromResult(result);\r\n *   const token = credential.accessToken;\r\n * }\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a popup.\r\n * const provider = new GithubAuthProvider();\r\n * provider.addScope('repo');\r\n * const result = await signInWithPopup(auth, provider);\r\n *\r\n * // The signed-in user info.\r\n * const user = result.user;\r\n * // This gives you a GitHub Access Token.\r\n * const credential = GithubAuthProvider.credentialFromResult(result);\r\n * const token = credential.accessToken;\r\n * ```\r\n * @public\r\n */ class GithubAuthProvider extends BaseOAuthProvider {\n    constructor(){\n        super(\"github.com\" /* ProviderId.GITHUB */ );\n    }\n    /**\r\n     * Creates a credential for GitHub.\r\n     *\r\n     * @param accessToken - GitHub access token.\r\n     */ static credential(accessToken) {\n        return OAuthCredential._fromParams({\n            providerId: GithubAuthProvider.PROVIDER_ID,\n            signInMethod: GithubAuthProvider.GITHUB_SIGN_IN_METHOD,\n            accessToken\n        });\n    }\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */ static credentialFromResult(userCredential) {\n        return GithubAuthProvider.credentialFromTaggedObject(userCredential);\n    }\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\r\n     * thrown during a sign-in, link, or reauthenticate operation.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */ static credentialFromError(error) {\n        return GithubAuthProvider.credentialFromTaggedObject(error.customData || {});\n    }\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse || !(\"oauthAccessToken\" in tokenResponse)) {\n            return null;\n        }\n        if (!tokenResponse.oauthAccessToken) {\n            return null;\n        }\n        try {\n            return GithubAuthProvider.credential(tokenResponse.oauthAccessToken);\n        } catch (_a) {\n            return null;\n        }\n    }\n}\n/** Always set to {@link SignInMethod}.GITHUB. */ GithubAuthProvider.GITHUB_SIGN_IN_METHOD = \"github.com\" /* SignInMethod.GITHUB */ ;\n/** Always set to {@link ProviderId}.GITHUB. */ GithubAuthProvider.PROVIDER_ID = \"github.com\" /* ProviderId.GITHUB */ ;\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const IDP_REQUEST_URI = \"http://localhost\";\n/**\r\n * @public\r\n */ class SAMLAuthCredential extends AuthCredential {\n    /** @internal */ constructor(providerId, pendingToken){\n        super(providerId, providerId);\n        this.pendingToken = pendingToken;\n    }\n    /** @internal */ _getIdTokenResponse(auth) {\n        const request = this.buildRequest();\n        return signInWithIdp(auth, request);\n    }\n    /** @internal */ _linkToIdToken(auth, idToken) {\n        const request = this.buildRequest();\n        request.idToken = idToken;\n        return signInWithIdp(auth, request);\n    }\n    /** @internal */ _getReauthenticationResolver(auth) {\n        const request = this.buildRequest();\n        request.autoCreate = false;\n        return signInWithIdp(auth, request);\n    }\n    /** {@inheritdoc AuthCredential.toJSON}  */ toJSON() {\n        return {\n            signInMethod: this.signInMethod,\n            providerId: this.providerId,\n            pendingToken: this.pendingToken\n        };\n    }\n    /**\r\n     * Static method to deserialize a JSON representation of an object into an\r\n     * {@link  AuthCredential}.\r\n     *\r\n     * @param json - Input can be either Object or the stringified representation of the object.\r\n     * When string is provided, JSON.parse would be called first.\r\n     *\r\n     * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.\r\n     */ static fromJSON(json) {\n        const obj = typeof json === \"string\" ? JSON.parse(json) : json;\n        const { providerId, signInMethod, pendingToken } = obj;\n        if (!providerId || !signInMethod || !pendingToken || providerId !== signInMethod) {\n            return null;\n        }\n        return new SAMLAuthCredential(providerId, pendingToken);\n    }\n    /**\r\n     * Helper static method to avoid exposing the constructor to end users.\r\n     *\r\n     * @internal\r\n     */ static _create(providerId, pendingToken) {\n        return new SAMLAuthCredential(providerId, pendingToken);\n    }\n    buildRequest() {\n        return {\n            requestUri: IDP_REQUEST_URI,\n            returnSecureToken: true,\n            pendingToken: this.pendingToken\n        };\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const SAML_PROVIDER_PREFIX = \"saml.\";\n/**\r\n * An {@link AuthProvider} for SAML.\r\n *\r\n * @public\r\n */ class SAMLAuthProvider extends FederatedAuthProvider {\n    /**\r\n     * Constructor. The providerId must start with \"saml.\"\r\n     * @param providerId - SAML provider ID.\r\n     */ constructor(providerId){\n        _assert(providerId.startsWith(SAML_PROVIDER_PREFIX), \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n        super(providerId);\n    }\n    /**\r\n     * Generates an {@link AuthCredential} from a {@link UserCredential} after a\r\n     * successful SAML flow completes.\r\n     *\r\n     * @remarks\r\n     *\r\n     * For example, to get an {@link AuthCredential}, you could write the\r\n     * following code:\r\n     *\r\n     * ```js\r\n     * const userCredential = await signInWithPopup(auth, samlProvider);\r\n     * const credential = SAMLAuthProvider.credentialFromResult(userCredential);\r\n     * ```\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */ static credentialFromResult(userCredential) {\n        return SAMLAuthProvider.samlCredentialFromTaggedObject(userCredential);\n    }\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\r\n     * thrown during a sign-in, link, or reauthenticate operation.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */ static credentialFromError(error) {\n        return SAMLAuthProvider.samlCredentialFromTaggedObject(error.customData || {});\n    }\n    /**\r\n     * Creates an {@link AuthCredential} from a JSON string or a plain object.\r\n     * @param json - A plain object or a JSON string\r\n     */ static credentialFromJSON(json) {\n        const credential = SAMLAuthCredential.fromJSON(json);\n        _assert(credential, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n        return credential;\n    }\n    static samlCredentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse) {\n            return null;\n        }\n        const { pendingToken, providerId } = tokenResponse;\n        if (!pendingToken || !providerId) {\n            return null;\n        }\n        try {\n            return SAMLAuthCredential._create(providerId, pendingToken);\n        } catch (e) {\n            return null;\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.TWITTER.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a redirect.\r\n * const provider = new TwitterAuthProvider();\r\n * // Start a sign in process for an unauthenticated user.\r\n * await signInWithRedirect(auth, provider);\r\n * // This will trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * if (result) {\r\n *   // This is the signed-in user\r\n *   const user = result.user;\r\n *   // This gives you a Twitter Access Token and Secret.\r\n *   const credential = TwitterAuthProvider.credentialFromResult(result);\r\n *   const token = credential.accessToken;\r\n *   const secret = credential.secret;\r\n * }\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a popup.\r\n * const provider = new TwitterAuthProvider();\r\n * const result = await signInWithPopup(auth, provider);\r\n *\r\n * // The signed-in user info.\r\n * const user = result.user;\r\n * // This gives you a Twitter Access Token and Secret.\r\n * const credential = TwitterAuthProvider.credentialFromResult(result);\r\n * const token = credential.accessToken;\r\n * const secret = credential.secret;\r\n * ```\r\n *\r\n * @public\r\n */ class TwitterAuthProvider extends BaseOAuthProvider {\n    constructor(){\n        super(\"twitter.com\" /* ProviderId.TWITTER */ );\n    }\n    /**\r\n     * Creates a credential for Twitter.\r\n     *\r\n     * @param token - Twitter access token.\r\n     * @param secret - Twitter secret.\r\n     */ static credential(token, secret) {\n        return OAuthCredential._fromParams({\n            providerId: TwitterAuthProvider.PROVIDER_ID,\n            signInMethod: TwitterAuthProvider.TWITTER_SIGN_IN_METHOD,\n            oauthToken: token,\n            oauthTokenSecret: secret\n        });\n    }\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */ static credentialFromResult(userCredential) {\n        return TwitterAuthProvider.credentialFromTaggedObject(userCredential);\n    }\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\r\n     * thrown during a sign-in, link, or reauthenticate operation.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */ static credentialFromError(error) {\n        return TwitterAuthProvider.credentialFromTaggedObject(error.customData || {});\n    }\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse) {\n            return null;\n        }\n        const { oauthAccessToken, oauthTokenSecret } = tokenResponse;\n        if (!oauthAccessToken || !oauthTokenSecret) {\n            return null;\n        }\n        try {\n            return TwitterAuthProvider.credential(oauthAccessToken, oauthTokenSecret);\n        } catch (_a) {\n            return null;\n        }\n    }\n}\n/** Always set to {@link SignInMethod}.TWITTER. */ TwitterAuthProvider.TWITTER_SIGN_IN_METHOD = \"twitter.com\" /* SignInMethod.TWITTER */ ;\n/** Always set to {@link ProviderId}.TWITTER. */ TwitterAuthProvider.PROVIDER_ID = \"twitter.com\" /* ProviderId.TWITTER */ ;\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function signUp(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:signUp\" /* Endpoint.SIGN_UP */ , _addTidIfNecessary(auth, request));\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class UserCredentialImpl {\n    constructor(params){\n        this.user = params.user;\n        this.providerId = params.providerId;\n        this._tokenResponse = params._tokenResponse;\n        this.operationType = params.operationType;\n    }\n    static async _fromIdTokenResponse(auth, operationType, idTokenResponse, isAnonymous = false) {\n        const user = await UserImpl._fromIdTokenResponse(auth, idTokenResponse, isAnonymous);\n        const providerId = providerIdForResponse(idTokenResponse);\n        const userCred = new UserCredentialImpl({\n            user,\n            providerId,\n            _tokenResponse: idTokenResponse,\n            operationType\n        });\n        return userCred;\n    }\n    static async _forOperation(user, operationType, response) {\n        await user._updateTokensIfNecessary(response, /* reload */ true);\n        const providerId = providerIdForResponse(response);\n        return new UserCredentialImpl({\n            user,\n            providerId,\n            _tokenResponse: response,\n            operationType\n        });\n    }\n}\nfunction providerIdForResponse(response) {\n    if (response.providerId) {\n        return response.providerId;\n    }\n    if (\"phoneNumber\" in response) {\n        return \"phone\" /* ProviderId.PHONE */ ;\n    }\n    return null;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Asynchronously signs in as an anonymous user.\r\n *\r\n * @remarks\r\n * If there is already an anonymous user signed in, that user will be returned; otherwise, a\r\n * new anonymous user identity will be created and returned.\r\n *\r\n * This method is not supported by {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n *\r\n * @public\r\n */ async function signInAnonymously(auth) {\n    var _a;\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const authInternal = _castAuth(auth);\n    await authInternal._initializationPromise;\n    if ((_a = authInternal.currentUser) === null || _a === void 0 ? void 0 : _a.isAnonymous) {\n        // If an anonymous user is already signed in, no need to sign them in again.\n        return new UserCredentialImpl({\n            user: authInternal.currentUser,\n            providerId: null,\n            operationType: \"signIn\" /* OperationType.SIGN_IN */ \n        });\n    }\n    const response = await signUp(authInternal, {\n        returnSecureToken: true\n    });\n    const userCredential = await UserCredentialImpl._fromIdTokenResponse(authInternal, \"signIn\" /* OperationType.SIGN_IN */ , response, true);\n    await authInternal._updateCurrentUser(userCredential.user);\n    return userCredential;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class MultiFactorError extends _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError {\n    constructor(auth, error, operationType, user){\n        var _a;\n        super(error.code, error.message);\n        this.operationType = operationType;\n        this.user = user;\n        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, MultiFactorError.prototype);\n        this.customData = {\n            appName: auth.name,\n            tenantId: (_a = auth.tenantId) !== null && _a !== void 0 ? _a : undefined,\n            _serverResponse: error.customData._serverResponse,\n            operationType\n        };\n    }\n    static _fromErrorAndOperation(auth, error, operationType, user) {\n        return new MultiFactorError(auth, error, operationType, user);\n    }\n}\nfunction _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user) {\n    const idTokenProvider = operationType === \"reauthenticate\" /* OperationType.REAUTHENTICATE */  ? credential._getReauthenticationResolver(auth) : credential._getIdTokenResponse(auth);\n    return idTokenProvider.catch((error)=>{\n        if (error.code === `auth/${\"multi-factor-auth-required\" /* AuthErrorCode.MFA_REQUIRED */ }`) {\n            throw MultiFactorError._fromErrorAndOperation(auth, error, operationType, user);\n        }\n        throw error;\n    });\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Takes a set of UserInfo provider data and converts it to a set of names\r\n */ function providerDataAsNames(providerData) {\n    return new Set(providerData.map(({ providerId })=>providerId).filter((pid)=>!!pid));\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Unlinks a provider from a user account.\r\n *\r\n * @param user - The user.\r\n * @param providerId - The provider to unlink.\r\n *\r\n * @public\r\n */ async function unlink(user, providerId) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    await _assertLinkedStatus(true, userInternal, providerId);\n    const { providerUserInfo } = await deleteLinkedAccounts(userInternal.auth, {\n        idToken: await userInternal.getIdToken(),\n        deleteProvider: [\n            providerId\n        ]\n    });\n    const providersLeft = providerDataAsNames(providerUserInfo || []);\n    userInternal.providerData = userInternal.providerData.filter((pd)=>providersLeft.has(pd.providerId));\n    if (!providersLeft.has(\"phone\" /* ProviderId.PHONE */ )) {\n        userInternal.phoneNumber = null;\n    }\n    await userInternal.auth._persistUserIfCurrent(userInternal);\n    return userInternal;\n}\nasync function _link(user, credential, bypassAuthState = false) {\n    const response = await _logoutIfInvalidated(user, credential._linkToIdToken(user.auth, await user.getIdToken()), bypassAuthState);\n    return UserCredentialImpl._forOperation(user, \"link\" /* OperationType.LINK */ , response);\n}\nasync function _assertLinkedStatus(expected, user, provider) {\n    await _reloadWithoutSaving(user);\n    const providerIds = providerDataAsNames(user.providerData);\n    const code = expected === false ? \"provider-already-linked\" /* AuthErrorCode.PROVIDER_ALREADY_LINKED */  : \"no-such-provider\" /* AuthErrorCode.NO_SUCH_PROVIDER */ ;\n    _assert(providerIds.has(provider) === expected, user.auth, code);\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function _reauthenticate(user, credential, bypassAuthState = false) {\n    const { auth } = user;\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const operationType = \"reauthenticate\" /* OperationType.REAUTHENTICATE */ ;\n    try {\n        const response = await _logoutIfInvalidated(user, _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user), bypassAuthState);\n        _assert(response.idToken, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        const parsed = _parseToken(response.idToken);\n        _assert(parsed, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        const { sub: localId } = parsed;\n        _assert(user.uid === localId, auth, \"user-mismatch\" /* AuthErrorCode.USER_MISMATCH */ );\n        return UserCredentialImpl._forOperation(user, operationType, response);\n    } catch (e) {\n        // Convert user deleted error into user mismatch\n        if ((e === null || e === void 0 ? void 0 : e.code) === `auth/${\"user-not-found\" /* AuthErrorCode.USER_DELETED */ }`) {\n            _fail(auth, \"user-mismatch\" /* AuthErrorCode.USER_MISMATCH */ );\n        }\n        throw e;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function _signInWithCredential(auth, credential, bypassAuthState = false) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const operationType = \"signIn\" /* OperationType.SIGN_IN */ ;\n    const response = await _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential);\n    const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth, operationType, response);\n    if (!bypassAuthState) {\n        await auth._updateCurrentUser(userCredential.user);\n    }\n    return userCredential;\n}\n/**\r\n * Asynchronously signs in with the given credentials.\r\n *\r\n * @remarks\r\n * An {@link AuthProvider} can be used to generate the credential.\r\n *\r\n * This method is not supported by {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param credential - The auth credential.\r\n *\r\n * @public\r\n */ async function signInWithCredential(auth, credential) {\n    return _signInWithCredential(_castAuth(auth), credential);\n}\n/**\r\n * Links the user account with the given credentials.\r\n *\r\n * @remarks\r\n * An {@link AuthProvider} can be used to generate the credential.\r\n *\r\n * @param user - The user.\r\n * @param credential - The auth credential.\r\n *\r\n * @public\r\n */ async function linkWithCredential(user, credential) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    await _assertLinkedStatus(false, userInternal, credential.providerId);\n    return _link(userInternal, credential);\n}\n/**\r\n * Re-authenticates a user using a fresh credential.\r\n *\r\n * @remarks\r\n * Use before operations such as {@link updatePassword} that require tokens from recent sign-in\r\n * attempts. This method can be used to recover from a `CREDENTIAL_TOO_OLD_LOGIN_AGAIN` error\r\n * or a `TOKEN_EXPIRED` error.\r\n *\r\n * This method is not supported on any {@link User} signed in by {@link Auth} instances\r\n * created with a {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * @param user - The user.\r\n * @param credential - The auth credential.\r\n *\r\n * @public\r\n */ async function reauthenticateWithCredential(user, credential) {\n    return _reauthenticate((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user), credential);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function signInWithCustomToken$1(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:signInWithCustomToken\" /* Endpoint.SIGN_IN_WITH_CUSTOM_TOKEN */ , _addTidIfNecessary(auth, request));\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Asynchronously signs in using a custom token.\r\n *\r\n * @remarks\r\n * Custom tokens are used to integrate Firebase Auth with existing auth systems, and must\r\n * be generated by an auth backend using the\r\n * {@link https://firebase.google.com/docs/reference/admin/node/admin.auth.Auth#createcustomtoken | createCustomToken}\r\n * method in the {@link https://firebase.google.com/docs/auth/admin | Admin SDK} .\r\n *\r\n * Fails with an error if the token is invalid, expired, or not accepted by the Firebase Auth service.\r\n *\r\n * This method is not supported by {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param customToken - The custom token to sign in with.\r\n *\r\n * @public\r\n */ async function signInWithCustomToken(auth, customToken) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const authInternal = _castAuth(auth);\n    const response = await signInWithCustomToken$1(authInternal, {\n        token: customToken,\n        returnSecureToken: true\n    });\n    const cred = await UserCredentialImpl._fromIdTokenResponse(authInternal, \"signIn\" /* OperationType.SIGN_IN */ , response);\n    await authInternal._updateCurrentUser(cred.user);\n    return cred;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class MultiFactorInfoImpl {\n    constructor(factorId, response){\n        this.factorId = factorId;\n        this.uid = response.mfaEnrollmentId;\n        this.enrollmentTime = new Date(response.enrolledAt).toUTCString();\n        this.displayName = response.displayName;\n    }\n    static _fromServerResponse(auth, enrollment) {\n        if (\"phoneInfo\" in enrollment) {\n            return PhoneMultiFactorInfoImpl._fromServerResponse(auth, enrollment);\n        } else if (\"totpInfo\" in enrollment) {\n            return TotpMultiFactorInfoImpl._fromServerResponse(auth, enrollment);\n        }\n        return _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n    }\n}\nclass PhoneMultiFactorInfoImpl extends MultiFactorInfoImpl {\n    constructor(response){\n        super(\"phone\" /* FactorId.PHONE */ , response);\n        this.phoneNumber = response.phoneInfo;\n    }\n    static _fromServerResponse(_auth, enrollment) {\n        return new PhoneMultiFactorInfoImpl(enrollment);\n    }\n}\nclass TotpMultiFactorInfoImpl extends MultiFactorInfoImpl {\n    constructor(response){\n        super(\"totp\" /* FactorId.TOTP */ , response);\n    }\n    static _fromServerResponse(_auth, enrollment) {\n        return new TotpMultiFactorInfoImpl(enrollment);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function _setActionCodeSettingsOnRequest(auth, request, actionCodeSettings) {\n    var _a;\n    _assert(((_a = actionCodeSettings.url) === null || _a === void 0 ? void 0 : _a.length) > 0, auth, \"invalid-continue-uri\" /* AuthErrorCode.INVALID_CONTINUE_URI */ );\n    _assert(typeof actionCodeSettings.dynamicLinkDomain === \"undefined\" || actionCodeSettings.dynamicLinkDomain.length > 0, auth, \"invalid-dynamic-link-domain\" /* AuthErrorCode.INVALID_DYNAMIC_LINK_DOMAIN */ );\n    request.continueUrl = actionCodeSettings.url;\n    request.dynamicLinkDomain = actionCodeSettings.dynamicLinkDomain;\n    request.canHandleCodeInApp = actionCodeSettings.handleCodeInApp;\n    if (actionCodeSettings.iOS) {\n        _assert(actionCodeSettings.iOS.bundleId.length > 0, auth, \"missing-ios-bundle-id\" /* AuthErrorCode.MISSING_IOS_BUNDLE_ID */ );\n        request.iOSBundleId = actionCodeSettings.iOS.bundleId;\n    }\n    if (actionCodeSettings.android) {\n        _assert(actionCodeSettings.android.packageName.length > 0, auth, \"missing-android-pkg-name\" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */ );\n        request.androidInstallApp = actionCodeSettings.android.installApp;\n        request.androidMinimumVersionCode = actionCodeSettings.android.minimumVersion;\n        request.androidPackageName = actionCodeSettings.android.packageName;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Updates the password policy cached in the {@link Auth} instance if a policy is already\r\n * cached for the project or tenant.\r\n *\r\n * @remarks\r\n * We only fetch the password policy if the password did not meet policy requirements and\r\n * there is an existing policy cached. A developer must call validatePassword at least\r\n * once for the cache to be automatically updated.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n *\r\n * @private\r\n */ async function recachePasswordPolicy(auth) {\n    const authInternal = _castAuth(auth);\n    if (authInternal._getPasswordPolicyInternal()) {\n        await authInternal._updatePasswordPolicy();\n    }\n}\n/**\r\n * Sends a password reset email to the given email address. This method does not throw an error when\r\n * there's no user account with the given email address and\r\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\r\n * is enabled.\r\n *\r\n * @remarks\r\n * To complete the password reset, call {@link confirmPasswordReset} with the code supplied in\r\n * the email sent to the user, along with the new password specified by the user.\r\n *\r\n * @example\r\n * ```javascript\r\n * const actionCodeSettings = {\r\n *   url: 'https://www.example.com/?email=user@example.com',\r\n *   iOS: {\r\n *      bundleId: 'com.example.ios'\r\n *   },\r\n *   android: {\r\n *     packageName: 'com.example.android',\r\n *     installApp: true,\r\n *     minimumVersion: '12'\r\n *   },\r\n *   handleCodeInApp: true\r\n * };\r\n * await sendPasswordResetEmail(auth, 'user@example.com', actionCodeSettings);\r\n * // Obtain code from user.\r\n * await confirmPasswordReset('user@example.com', code);\r\n * ```\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param email - The user's email address.\r\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\r\n *\r\n * @public\r\n */ async function sendPasswordResetEmail(auth, email, actionCodeSettings) {\n    const authInternal = _castAuth(auth);\n    const request = {\n        requestType: \"PASSWORD_RESET\" /* ActionCodeOperation.PASSWORD_RESET */ ,\n        email,\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */ \n    };\n    if (actionCodeSettings) {\n        _setActionCodeSettingsOnRequest(authInternal, request, actionCodeSettings);\n    }\n    await handleRecaptchaFlow(authInternal, request, \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */ , sendPasswordResetEmail$1);\n}\n/**\r\n * Completes the password reset process, given a confirmation code and new password.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param oobCode - A confirmation code sent to the user.\r\n * @param newPassword - The new password.\r\n *\r\n * @public\r\n */ async function confirmPasswordReset(auth, oobCode, newPassword) {\n    await resetPassword((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), {\n        oobCode,\n        newPassword\n    }).catch(async (error)=>{\n        if (error.code === `auth/${\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */ }`) {\n            void recachePasswordPolicy(auth);\n        }\n        throw error;\n    });\n// Do not return the email.\n}\n/**\r\n * Applies a verification code sent to the user by email or other out-of-band mechanism.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param oobCode - A verification code sent to the user.\r\n *\r\n * @public\r\n */ async function applyActionCode(auth, oobCode) {\n    await applyActionCode$1((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), {\n        oobCode\n    });\n}\n/**\r\n * Checks a verification code sent to the user by email or other out-of-band mechanism.\r\n *\r\n * @returns metadata about the code.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param oobCode - A verification code sent to the user.\r\n *\r\n * @public\r\n */ async function checkActionCode(auth, oobCode) {\n    const authModular = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth);\n    const response = await resetPassword(authModular, {\n        oobCode\n    });\n    // Email could be empty only if the request type is EMAIL_SIGNIN or\n    // VERIFY_AND_CHANGE_EMAIL.\n    // New email should not be empty if the request type is\n    // VERIFY_AND_CHANGE_EMAIL.\n    // Multi-factor info could not be empty if the request type is\n    // REVERT_SECOND_FACTOR_ADDITION.\n    const operation = response.requestType;\n    _assert(operation, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n    switch(operation){\n        case \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */ :\n            break;\n        case \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */ :\n            _assert(response.newEmail, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n            break;\n        case \"REVERT_SECOND_FACTOR_ADDITION\" /* ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION */ :\n            _assert(response.mfaInfo, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        // fall through\n        default:\n            _assert(response.email, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n    }\n    // The multi-factor info for revert second factor addition\n    let multiFactorInfo = null;\n    if (response.mfaInfo) {\n        multiFactorInfo = MultiFactorInfoImpl._fromServerResponse(_castAuth(authModular), response.mfaInfo);\n    }\n    return {\n        data: {\n            email: (response.requestType === \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */  ? response.newEmail : response.email) || null,\n            previousEmail: (response.requestType === \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */  ? response.email : response.newEmail) || null,\n            multiFactorInfo\n        },\n        operation\n    };\n}\n/**\r\n * Checks a password reset code sent to the user by email or other out-of-band mechanism.\r\n *\r\n * @returns the user's email address if valid.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param code - A verification code sent to the user.\r\n *\r\n * @public\r\n */ async function verifyPasswordResetCode(auth, code) {\n    const { data } = await checkActionCode((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), code);\n    // Email should always be present since a code was sent to it\n    return data.email;\n}\n/**\r\n * Creates a new user account associated with the specified email address and password.\r\n *\r\n * @remarks\r\n * On successful creation of the user account, this user will also be signed in to your application.\r\n *\r\n * User account creation can fail if the account already exists or the password is invalid.\r\n *\r\n * This method is not supported on {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * Note: The email address acts as a unique identifier for the user and enables an email-based\r\n * password reset. This function will create a new user account and set the initial user password.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param email - The user's email address.\r\n * @param password - The user's chosen password.\r\n *\r\n * @public\r\n */ async function createUserWithEmailAndPassword(auth, email, password) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const authInternal = _castAuth(auth);\n    const request = {\n        returnSecureToken: true,\n        email,\n        password,\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */ \n    };\n    const signUpResponse = handleRecaptchaFlow(authInternal, request, \"signUpPassword\" /* RecaptchaActionName.SIGN_UP_PASSWORD */ , signUp);\n    const response = await signUpResponse.catch((error)=>{\n        if (error.code === `auth/${\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */ }`) {\n            void recachePasswordPolicy(auth);\n        }\n        throw error;\n    });\n    const userCredential = await UserCredentialImpl._fromIdTokenResponse(authInternal, \"signIn\" /* OperationType.SIGN_IN */ , response);\n    await authInternal._updateCurrentUser(userCredential.user);\n    return userCredential;\n}\n/**\r\n * Asynchronously signs in using an email and password.\r\n *\r\n * @remarks\r\n * Fails with an error if the email address and password do not match. When\r\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\r\n * is enabled, this method fails with \"auth/invalid-credential\" in case of an invalid\r\n * email/password.\r\n *\r\n * This method is not supported on {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * Note: The user's password is NOT the password used to access the user's email account. The\r\n * email address serves as a unique identifier for the user, and the password is used to access\r\n * the user's account in your Firebase project. See also: {@link createUserWithEmailAndPassword}.\r\n *\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param email - The users email address.\r\n * @param password - The users password.\r\n *\r\n * @public\r\n */ function signInWithEmailAndPassword(auth, email, password) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    return signInWithCredential((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), EmailAuthProvider.credential(email, password)).catch(async (error)=>{\n        if (error.code === `auth/${\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */ }`) {\n            void recachePasswordPolicy(auth);\n        }\n        throw error;\n    });\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Sends a sign-in email link to the user with the specified email.\r\n *\r\n * @remarks\r\n * The sign-in operation has to always be completed in the app unlike other out of band email\r\n * actions (password reset and email verifications). This is because, at the end of the flow,\r\n * the user is expected to be signed in and their Auth state persisted within the app.\r\n *\r\n * To complete sign in with the email link, call {@link signInWithEmailLink} with the email\r\n * address and the email link supplied in the email sent to the user.\r\n *\r\n * @example\r\n * ```javascript\r\n * const actionCodeSettings = {\r\n *   url: 'https://www.example.com/?email=user@example.com',\r\n *   iOS: {\r\n *      bundleId: 'com.example.ios'\r\n *   },\r\n *   android: {\r\n *     packageName: 'com.example.android',\r\n *     installApp: true,\r\n *     minimumVersion: '12'\r\n *   },\r\n *   handleCodeInApp: true\r\n * };\r\n * await sendSignInLinkToEmail(auth, 'user@example.com', actionCodeSettings);\r\n * // Obtain emailLink from the user.\r\n * if(isSignInWithEmailLink(auth, emailLink)) {\r\n *   await signInWithEmailLink(auth, 'user@example.com', emailLink);\r\n * }\r\n * ```\r\n *\r\n * @param authInternal - The {@link Auth} instance.\r\n * @param email - The user's email address.\r\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\r\n *\r\n * @public\r\n */ async function sendSignInLinkToEmail(auth, email, actionCodeSettings) {\n    const authInternal = _castAuth(auth);\n    const request = {\n        requestType: \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */ ,\n        email,\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */ \n    };\n    function setActionCodeSettings(request, actionCodeSettings) {\n        _assert(actionCodeSettings.handleCodeInApp, authInternal, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n        if (actionCodeSettings) {\n            _setActionCodeSettingsOnRequest(authInternal, request, actionCodeSettings);\n        }\n    }\n    setActionCodeSettings(request, actionCodeSettings);\n    await handleRecaptchaFlow(authInternal, request, \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */ , sendSignInLinkToEmail$1);\n}\n/**\r\n * Checks if an incoming link is a sign-in with email link suitable for {@link signInWithEmailLink}.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param emailLink - The link sent to the user's email address.\r\n *\r\n * @public\r\n */ function isSignInWithEmailLink(auth, emailLink) {\n    const actionCodeUrl = ActionCodeURL.parseLink(emailLink);\n    return (actionCodeUrl === null || actionCodeUrl === void 0 ? void 0 : actionCodeUrl.operation) === \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */ ;\n}\n/**\r\n * Asynchronously signs in using an email and sign-in email link.\r\n *\r\n * @remarks\r\n * If no link is passed, the link is inferred from the current URL.\r\n *\r\n * Fails with an error if the email address is invalid or OTP in email link expires.\r\n *\r\n * This method is not supported by {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * Note: Confirm the link is a sign-in email link before calling this method firebase.auth.Auth.isSignInWithEmailLink.\r\n *\r\n * @example\r\n * ```javascript\r\n * const actionCodeSettings = {\r\n *   url: 'https://www.example.com/?email=user@example.com',\r\n *   iOS: {\r\n *      bundleId: 'com.example.ios'\r\n *   },\r\n *   android: {\r\n *     packageName: 'com.example.android',\r\n *     installApp: true,\r\n *     minimumVersion: '12'\r\n *   },\r\n *   handleCodeInApp: true\r\n * };\r\n * await sendSignInLinkToEmail(auth, 'user@example.com', actionCodeSettings);\r\n * // Obtain emailLink from the user.\r\n * if(isSignInWithEmailLink(auth, emailLink)) {\r\n *   await signInWithEmailLink(auth, 'user@example.com', emailLink);\r\n * }\r\n * ```\r\n *\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param email - The user's email address.\r\n * @param emailLink - The link sent to the user's email address.\r\n *\r\n * @public\r\n */ async function signInWithEmailLink(auth, email, emailLink) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const authModular = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth);\n    const credential = EmailAuthProvider.credentialWithLink(email, emailLink || _getCurrentUrl());\n    // Check if the tenant ID in the email link matches the tenant ID on Auth\n    // instance.\n    _assert(credential._tenantId === (authModular.tenantId || null), authModular, \"tenant-id-mismatch\" /* AuthErrorCode.TENANT_ID_MISMATCH */ );\n    return signInWithCredential(authModular, credential);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function createAuthUri(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:createAuthUri\" /* Endpoint.CREATE_AUTH_URI */ , _addTidIfNecessary(auth, request));\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Gets the list of possible sign in methods for the given email address. This method returns an\r\n * empty list when\r\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\r\n * is enabled, irrespective of the number of authentication methods available for the given email.\r\n *\r\n * @remarks\r\n * This is useful to differentiate methods of sign-in for the same provider, eg.\r\n * {@link EmailAuthProvider} which has 2 methods of sign-in,\r\n * {@link SignInMethod}.EMAIL_PASSWORD and\r\n * {@link SignInMethod}.EMAIL_LINK.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param email - The user's email address.\r\n *\r\n * Deprecated. Migrating off of this method is recommended as a security best-practice.\r\n * Learn more in the Identity Platform documentation for\r\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}.\r\n * @public\r\n */ async function fetchSignInMethodsForEmail(auth, email) {\n    // createAuthUri returns an error if continue URI is not http or https.\n    // For environments like Cordova, Chrome extensions, native frameworks, file\n    // systems, etc, use http://localhost as continue URL.\n    const continueUri = _isHttpOrHttps() ? _getCurrentUrl() : \"http://localhost\";\n    const request = {\n        identifier: email,\n        continueUri\n    };\n    const { signinMethods } = await createAuthUri((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), request);\n    return signinMethods || [];\n}\n/**\r\n * Sends a verification email to a user.\r\n *\r\n * @remarks\r\n * The verification process is completed by calling {@link applyActionCode}.\r\n *\r\n * @example\r\n * ```javascript\r\n * const actionCodeSettings = {\r\n *   url: 'https://www.example.com/?email=user@example.com',\r\n *   iOS: {\r\n *      bundleId: 'com.example.ios'\r\n *   },\r\n *   android: {\r\n *     packageName: 'com.example.android',\r\n *     installApp: true,\r\n *     minimumVersion: '12'\r\n *   },\r\n *   handleCodeInApp: true\r\n * };\r\n * await sendEmailVerification(user, actionCodeSettings);\r\n * // Obtain code from the user.\r\n * await applyActionCode(auth, code);\r\n * ```\r\n *\r\n * @param user - The user.\r\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\r\n *\r\n * @public\r\n */ async function sendEmailVerification(user, actionCodeSettings) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    const idToken = await user.getIdToken();\n    const request = {\n        requestType: \"VERIFY_EMAIL\" /* ActionCodeOperation.VERIFY_EMAIL */ ,\n        idToken\n    };\n    if (actionCodeSettings) {\n        _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);\n    }\n    const { email } = await sendEmailVerification$1(userInternal.auth, request);\n    if (email !== user.email) {\n        await user.reload();\n    }\n}\n/**\r\n * Sends a verification email to a new email address.\r\n *\r\n * @remarks\r\n * The user's email will be updated to the new one after being verified.\r\n *\r\n * If you have a custom email action handler, you can complete the verification process by calling\r\n * {@link applyActionCode}.\r\n *\r\n * @example\r\n * ```javascript\r\n * const actionCodeSettings = {\r\n *   url: 'https://www.example.com/?email=user@example.com',\r\n *   iOS: {\r\n *      bundleId: 'com.example.ios'\r\n *   },\r\n *   android: {\r\n *     packageName: 'com.example.android',\r\n *     installApp: true,\r\n *     minimumVersion: '12'\r\n *   },\r\n *   handleCodeInApp: true\r\n * };\r\n * await verifyBeforeUpdateEmail(user, 'newemail@example.com', actionCodeSettings);\r\n * // Obtain code from the user.\r\n * await applyActionCode(auth, code);\r\n * ```\r\n *\r\n * @param user - The user.\r\n * @param newEmail - The new email address to be verified before update.\r\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\r\n *\r\n * @public\r\n */ async function verifyBeforeUpdateEmail(user, newEmail, actionCodeSettings) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    const idToken = await user.getIdToken();\n    const request = {\n        requestType: \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */ ,\n        idToken,\n        newEmail\n    };\n    if (actionCodeSettings) {\n        _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);\n    }\n    const { email } = await verifyAndChangeEmail(userInternal.auth, request);\n    if (email !== user.email) {\n        // If the local copy of the email on user is outdated, reload the\n        // user.\n        await user.reload();\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function updateProfile$1(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */ , request);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Updates a user's profile data.\r\n *\r\n * @param user - The user.\r\n * @param profile - The profile's `displayName` and `photoURL` to update.\r\n *\r\n * @public\r\n */ async function updateProfile(user, { displayName, photoURL: photoUrl }) {\n    if (displayName === undefined && photoUrl === undefined) {\n        return;\n    }\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    const idToken = await userInternal.getIdToken();\n    const profileRequest = {\n        idToken,\n        displayName,\n        photoUrl,\n        returnSecureToken: true\n    };\n    const response = await _logoutIfInvalidated(userInternal, updateProfile$1(userInternal.auth, profileRequest));\n    userInternal.displayName = response.displayName || null;\n    userInternal.photoURL = response.photoUrl || null;\n    // Update the password provider as well\n    const passwordProvider = userInternal.providerData.find(({ providerId })=>providerId === \"password\" /* ProviderId.PASSWORD */ );\n    if (passwordProvider) {\n        passwordProvider.displayName = userInternal.displayName;\n        passwordProvider.photoURL = userInternal.photoURL;\n    }\n    await userInternal._updateTokensIfNecessary(response);\n}\n/**\r\n * Updates the user's email address.\r\n *\r\n * @remarks\r\n * An email will be sent to the original email address (if it was set) that allows to revoke the\r\n * email address change, in order to protect them from account hijacking.\r\n *\r\n * This method is not supported on any {@link User} signed in by {@link Auth} instances\r\n * created with a {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * Important: this is a security sensitive operation that requires the user to have recently signed\r\n * in. If this requirement isn't met, ask the user to authenticate again and then call\r\n * {@link reauthenticateWithCredential}.\r\n *\r\n * @param user - The user.\r\n * @param newEmail - The new email address.\r\n *\r\n * Throws \"auth/operation-not-allowed\" error when\r\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\r\n * is enabled.\r\n * Deprecated - Use {@link verifyBeforeUpdateEmail} instead.\r\n *\r\n * @public\r\n */ function updateEmail(user, newEmail) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(userInternal.auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(userInternal.auth));\n    }\n    return updateEmailOrPassword(userInternal, newEmail, null);\n}\n/**\r\n * Updates the user's password.\r\n *\r\n * @remarks\r\n * Important: this is a security sensitive operation that requires the user to have recently signed\r\n * in. If this requirement isn't met, ask the user to authenticate again and then call\r\n * {@link reauthenticateWithCredential}.\r\n *\r\n * @param user - The user.\r\n * @param newPassword - The new password.\r\n *\r\n * @public\r\n */ function updatePassword(user, newPassword) {\n    return updateEmailOrPassword((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user), null, newPassword);\n}\nasync function updateEmailOrPassword(user, email, password) {\n    const { auth } = user;\n    const idToken = await user.getIdToken();\n    const request = {\n        idToken,\n        returnSecureToken: true\n    };\n    if (email) {\n        request.email = email;\n    }\n    if (password) {\n        request.password = password;\n    }\n    const response = await _logoutIfInvalidated(user, updateEmailPassword(auth, request));\n    await user._updateTokensIfNecessary(response, /* reload */ true);\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Parse the `AdditionalUserInfo` from the ID token response.\r\n *\r\n */ function _fromIdTokenResponse(idTokenResponse) {\n    var _a, _b;\n    if (!idTokenResponse) {\n        return null;\n    }\n    const { providerId } = idTokenResponse;\n    const profile = idTokenResponse.rawUserInfo ? JSON.parse(idTokenResponse.rawUserInfo) : {};\n    const isNewUser = idTokenResponse.isNewUser || idTokenResponse.kind === \"identitytoolkit#SignupNewUserResponse\" /* IdTokenResponseKind.SignupNewUser */ ;\n    if (!providerId && (idTokenResponse === null || idTokenResponse === void 0 ? void 0 : idTokenResponse.idToken)) {\n        const signInProvider = (_b = (_a = _parseToken(idTokenResponse.idToken)) === null || _a === void 0 ? void 0 : _a.firebase) === null || _b === void 0 ? void 0 : _b[\"sign_in_provider\"];\n        if (signInProvider) {\n            const filteredProviderId = signInProvider !== \"anonymous\" /* ProviderId.ANONYMOUS */  && signInProvider !== \"custom\" /* ProviderId.CUSTOM */  ? signInProvider : null;\n            // Uses generic class in accordance with the legacy SDK.\n            return new GenericAdditionalUserInfo(isNewUser, filteredProviderId);\n        }\n    }\n    if (!providerId) {\n        return null;\n    }\n    switch(providerId){\n        case \"facebook.com\" /* ProviderId.FACEBOOK */ :\n            return new FacebookAdditionalUserInfo(isNewUser, profile);\n        case \"github.com\" /* ProviderId.GITHUB */ :\n            return new GithubAdditionalUserInfo(isNewUser, profile);\n        case \"google.com\" /* ProviderId.GOOGLE */ :\n            return new GoogleAdditionalUserInfo(isNewUser, profile);\n        case \"twitter.com\" /* ProviderId.TWITTER */ :\n            return new TwitterAdditionalUserInfo(isNewUser, profile, idTokenResponse.screenName || null);\n        case \"custom\" /* ProviderId.CUSTOM */ :\n        case \"anonymous\" /* ProviderId.ANONYMOUS */ :\n            return new GenericAdditionalUserInfo(isNewUser, null);\n        default:\n            return new GenericAdditionalUserInfo(isNewUser, providerId, profile);\n    }\n}\nclass GenericAdditionalUserInfo {\n    constructor(isNewUser, providerId, profile = {}){\n        this.isNewUser = isNewUser;\n        this.providerId = providerId;\n        this.profile = profile;\n    }\n}\nclass FederatedAdditionalUserInfoWithUsername extends GenericAdditionalUserInfo {\n    constructor(isNewUser, providerId, profile, username){\n        super(isNewUser, providerId, profile);\n        this.username = username;\n    }\n}\nclass FacebookAdditionalUserInfo extends GenericAdditionalUserInfo {\n    constructor(isNewUser, profile){\n        super(isNewUser, \"facebook.com\" /* ProviderId.FACEBOOK */ , profile);\n    }\n}\nclass GithubAdditionalUserInfo extends FederatedAdditionalUserInfoWithUsername {\n    constructor(isNewUser, profile){\n        super(isNewUser, \"github.com\" /* ProviderId.GITHUB */ , profile, typeof (profile === null || profile === void 0 ? void 0 : profile.login) === \"string\" ? profile === null || profile === void 0 ? void 0 : profile.login : null);\n    }\n}\nclass GoogleAdditionalUserInfo extends GenericAdditionalUserInfo {\n    constructor(isNewUser, profile){\n        super(isNewUser, \"google.com\" /* ProviderId.GOOGLE */ , profile);\n    }\n}\nclass TwitterAdditionalUserInfo extends FederatedAdditionalUserInfoWithUsername {\n    constructor(isNewUser, profile, screenName){\n        super(isNewUser, \"twitter.com\" /* ProviderId.TWITTER */ , profile, screenName);\n    }\n}\n/**\r\n * Extracts provider specific {@link AdditionalUserInfo} for the given credential.\r\n *\r\n * @param userCredential - The user credential.\r\n *\r\n * @public\r\n */ function getAdditionalUserInfo(userCredential) {\n    const { user, _tokenResponse } = userCredential;\n    if (user.isAnonymous && !_tokenResponse) {\n        // Handle the special case where signInAnonymously() gets called twice.\n        // No network call is made so there's nothing to actually fill this in\n        return {\n            providerId: null,\n            isNewUser: false,\n            profile: null\n        };\n    }\n    return _fromIdTokenResponse(_tokenResponse);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Non-optional auth methods.\n/**\r\n * Changes the type of persistence on the {@link Auth} instance for the currently saved\r\n * `Auth` session and applies this type of persistence for future sign-in requests, including\r\n * sign-in with redirect requests.\r\n *\r\n * @remarks\r\n * This makes it easy for a user signing in to specify whether their session should be\r\n * remembered or not. It also makes it easier to never persist the `Auth` state for applications\r\n * that are shared by other users or have sensitive data.\r\n *\r\n * This method does not work in a Node.js environment or with {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * @example\r\n * ```javascript\r\n * setPersistence(auth, browserSessionPersistence);\r\n * ```\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param persistence - The {@link Persistence} to use.\r\n * @returns A `Promise` that resolves once the persistence change has completed\r\n *\r\n * @public\r\n */ function setPersistence(auth, persistence) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).setPersistence(persistence);\n}\n/**\r\n * Loads the reCAPTCHA configuration into the `Auth` instance.\r\n *\r\n * @remarks\r\n * This will load the reCAPTCHA config, which indicates whether the reCAPTCHA\r\n * verification flow should be triggered for each auth provider, into the\r\n * current Auth session.\r\n *\r\n * If initializeRecaptchaConfig() is not invoked, the auth flow will always start\r\n * without reCAPTCHA verification. If the provider is configured to require reCAPTCHA\r\n * verification, the SDK will transparently load the reCAPTCHA config and restart the\r\n * auth flows.\r\n *\r\n * Thus, by calling this optional method, you will reduce the latency of future auth flows.\r\n * Loading the reCAPTCHA config early will also enhance the signal collected by reCAPTCHA.\r\n *\r\n * This method does not work in a Node.js environment.\r\n *\r\n * @example\r\n * ```javascript\r\n * initializeRecaptchaConfig(auth);\r\n * ```\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n *\r\n * @public\r\n */ function initializeRecaptchaConfig(auth) {\n    return _initializeRecaptchaConfig(auth);\n}\n/**\r\n * Validates the password against the password policy configured for the project or tenant.\r\n *\r\n * @remarks\r\n * If no tenant ID is set on the `Auth` instance, then this method will use the password\r\n * policy configured for the project. Otherwise, this method will use the policy configured\r\n * for the tenant. If a password policy has not been configured, then the default policy\r\n * configured for all projects will be used.\r\n *\r\n * If an auth flow fails because a submitted password does not meet the password policy\r\n * requirements and this method has previously been called, then this method will use the\r\n * most recent policy available when called again.\r\n *\r\n * @example\r\n * ```javascript\r\n * validatePassword(auth, 'some-password');\r\n * ```\r\n *\r\n * @param auth The {@link Auth} instance.\r\n * @param password The password to validate.\r\n *\r\n * @public\r\n */ async function validatePassword(auth, password) {\n    const authInternal = _castAuth(auth);\n    return authInternal.validatePassword(password);\n}\n/**\r\n * Adds an observer for changes to the signed-in user's ID token.\r\n *\r\n * @remarks\r\n * This includes sign-in, sign-out, and token refresh events.\r\n * This will not be triggered automatically upon ID token expiration. Use {@link User.getIdToken} to refresh the ID token.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param nextOrObserver - callback triggered on change.\r\n * @param error - Deprecated. This callback is never triggered. Errors\r\n * on signing in/out can be caught in promises returned from\r\n * sign-in/sign-out functions.\r\n * @param completed - Deprecated. This callback is never triggered.\r\n *\r\n * @public\r\n */ function onIdTokenChanged(auth, nextOrObserver, error, completed) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).onIdTokenChanged(nextOrObserver, error, completed);\n}\n/**\r\n * Adds a blocking callback that runs before an auth state change\r\n * sets a new user.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param callback - callback triggered before new user value is set.\r\n *   If this throws, it blocks the user from being set.\r\n * @param onAbort - callback triggered if a later `beforeAuthStateChanged()`\r\n *   callback throws, allowing you to undo any side effects.\r\n */ function beforeAuthStateChanged(auth, callback, onAbort) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).beforeAuthStateChanged(callback, onAbort);\n}\n/**\r\n * Adds an observer for changes to the user's sign-in state.\r\n *\r\n * @remarks\r\n * To keep the old behavior, see {@link onIdTokenChanged}.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param nextOrObserver - callback triggered on change.\r\n * @param error - Deprecated. This callback is never triggered. Errors\r\n * on signing in/out can be caught in promises returned from\r\n * sign-in/sign-out functions.\r\n * @param completed - Deprecated. This callback is never triggered.\r\n *\r\n * @public\r\n */ function onAuthStateChanged(auth, nextOrObserver, error, completed) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).onAuthStateChanged(nextOrObserver, error, completed);\n}\n/**\r\n * Sets the current language to the default device/browser preference.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n *\r\n * @public\r\n */ function useDeviceLanguage(auth) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).useDeviceLanguage();\n}\n/**\r\n * Asynchronously sets the provided user as {@link Auth.currentUser} on the\r\n * {@link Auth} instance.\r\n *\r\n * @remarks\r\n * A new instance copy of the user provided will be made and set as currentUser.\r\n *\r\n * This will trigger {@link onAuthStateChanged} and {@link onIdTokenChanged} listeners\r\n * like other sign in methods.\r\n *\r\n * The operation fails with an error if the user to be updated belongs to a different Firebase\r\n * project.\r\n *\r\n * This method is not supported by {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param user - The new {@link User}.\r\n *\r\n * @public\r\n */ function updateCurrentUser(auth, user) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).updateCurrentUser(user);\n}\n/**\r\n * Signs out the current user.\r\n *\r\n * @remarks\r\n * This method is not supported by {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n *\r\n * @public\r\n */ function signOut(auth) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).signOut();\n}\n/**\r\n * Revokes the given access token. Currently only supports Apple OAuth access tokens.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param token - The Apple OAuth access token.\r\n *\r\n * @public\r\n */ function revokeAccessToken(auth, token) {\n    const authInternal = _castAuth(auth);\n    return authInternal.revokeAccessToken(token);\n}\n/**\r\n * Deletes and signs out the user.\r\n *\r\n * @remarks\r\n * Important: this is a security-sensitive operation that requires the user to have recently\r\n * signed in. If this requirement isn't met, ask the user to authenticate again and then call\r\n * {@link reauthenticateWithCredential}.\r\n *\r\n * @param user - The user.\r\n *\r\n * @public\r\n */ async function deleteUser(user) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user).delete();\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class MultiFactorSessionImpl {\n    constructor(type, credential, user){\n        this.type = type;\n        this.credential = credential;\n        this.user = user;\n    }\n    static _fromIdtoken(idToken, user) {\n        return new MultiFactorSessionImpl(\"enroll\" /* MultiFactorSessionType.ENROLL */ , idToken, user);\n    }\n    static _fromMfaPendingCredential(mfaPendingCredential) {\n        return new MultiFactorSessionImpl(\"signin\" /* MultiFactorSessionType.SIGN_IN */ , mfaPendingCredential);\n    }\n    toJSON() {\n        const key = this.type === \"enroll\" /* MultiFactorSessionType.ENROLL */  ? \"idToken\" : \"pendingCredential\";\n        return {\n            multiFactorSession: {\n                [key]: this.credential\n            }\n        };\n    }\n    static fromJSON(obj) {\n        var _a, _b;\n        if (obj === null || obj === void 0 ? void 0 : obj.multiFactorSession) {\n            if ((_a = obj.multiFactorSession) === null || _a === void 0 ? void 0 : _a.pendingCredential) {\n                return MultiFactorSessionImpl._fromMfaPendingCredential(obj.multiFactorSession.pendingCredential);\n            } else if ((_b = obj.multiFactorSession) === null || _b === void 0 ? void 0 : _b.idToken) {\n                return MultiFactorSessionImpl._fromIdtoken(obj.multiFactorSession.idToken);\n            }\n        }\n        return null;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class MultiFactorResolverImpl {\n    constructor(session, hints, signInResolver){\n        this.session = session;\n        this.hints = hints;\n        this.signInResolver = signInResolver;\n    }\n    /** @internal */ static _fromError(authExtern, error) {\n        const auth = _castAuth(authExtern);\n        const serverResponse = error.customData._serverResponse;\n        const hints = (serverResponse.mfaInfo || []).map((enrollment)=>MultiFactorInfoImpl._fromServerResponse(auth, enrollment));\n        _assert(serverResponse.mfaPendingCredential, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        const session = MultiFactorSessionImpl._fromMfaPendingCredential(serverResponse.mfaPendingCredential);\n        return new MultiFactorResolverImpl(session, hints, async (assertion)=>{\n            const mfaResponse = await assertion._process(auth, session);\n            // Clear out the unneeded fields from the old login response\n            delete serverResponse.mfaInfo;\n            delete serverResponse.mfaPendingCredential;\n            // Use in the new token & refresh token in the old response\n            const idTokenResponse = Object.assign(Object.assign({}, serverResponse), {\n                idToken: mfaResponse.idToken,\n                refreshToken: mfaResponse.refreshToken\n            });\n            // TODO: we should collapse this switch statement into UserCredentialImpl._forOperation and have it support the SIGN_IN case\n            switch(error.operationType){\n                case \"signIn\" /* OperationType.SIGN_IN */ :\n                    const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth, error.operationType, idTokenResponse);\n                    await auth._updateCurrentUser(userCredential.user);\n                    return userCredential;\n                case \"reauthenticate\" /* OperationType.REAUTHENTICATE */ :\n                    _assert(error.user, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n                    return UserCredentialImpl._forOperation(error.user, error.operationType, idTokenResponse);\n                default:\n                    _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n            }\n        });\n    }\n    async resolveSignIn(assertionExtern) {\n        const assertion = assertionExtern;\n        return this.signInResolver(assertion);\n    }\n}\n/**\r\n * Provides a {@link MultiFactorResolver} suitable for completion of a\r\n * multi-factor flow.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param error - The {@link MultiFactorError} raised during a sign-in, or\r\n * reauthentication operation.\r\n *\r\n * @public\r\n */ function getMultiFactorResolver(auth, error) {\n    var _a;\n    const authModular = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth);\n    const errorInternal = error;\n    _assert(error.customData.operationType, authModular, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n    _assert((_a = errorInternal.customData._serverResponse) === null || _a === void 0 ? void 0 : _a.mfaPendingCredential, authModular, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n    return MultiFactorResolverImpl._fromError(authModular, errorInternal);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function startEnrollTotpMfa(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v2/accounts/mfaEnrollment:start\" /* Endpoint.START_MFA_ENROLLMENT */ , _addTidIfNecessary(auth, request));\n}\nfunction finalizeEnrollTotpMfa(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v2/accounts/mfaEnrollment:finalize\" /* Endpoint.FINALIZE_MFA_ENROLLMENT */ , _addTidIfNecessary(auth, request));\n}\nfunction withdrawMfa(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v2/accounts/mfaEnrollment:withdraw\" /* Endpoint.WITHDRAW_MFA */ , _addTidIfNecessary(auth, request));\n}\nclass MultiFactorUserImpl {\n    constructor(user){\n        this.user = user;\n        this.enrolledFactors = [];\n        user._onReload((userInfo)=>{\n            if (userInfo.mfaInfo) {\n                this.enrolledFactors = userInfo.mfaInfo.map((enrollment)=>MultiFactorInfoImpl._fromServerResponse(user.auth, enrollment));\n            }\n        });\n    }\n    static _fromUser(user) {\n        return new MultiFactorUserImpl(user);\n    }\n    async getSession() {\n        return MultiFactorSessionImpl._fromIdtoken(await this.user.getIdToken(), this.user);\n    }\n    async enroll(assertionExtern, displayName) {\n        const assertion = assertionExtern;\n        const session = await this.getSession();\n        const finalizeMfaResponse = await _logoutIfInvalidated(this.user, assertion._process(this.user.auth, session, displayName));\n        // New tokens will be issued after enrollment of the new second factors.\n        // They need to be updated on the user.\n        await this.user._updateTokensIfNecessary(finalizeMfaResponse);\n        // The user needs to be reloaded to get the new multi-factor information\n        // from server. USER_RELOADED event will be triggered and `enrolledFactors`\n        // will be updated.\n        return this.user.reload();\n    }\n    async unenroll(infoOrUid) {\n        const mfaEnrollmentId = typeof infoOrUid === \"string\" ? infoOrUid : infoOrUid.uid;\n        const idToken = await this.user.getIdToken();\n        try {\n            const idTokenResponse = await _logoutIfInvalidated(this.user, withdrawMfa(this.user.auth, {\n                idToken,\n                mfaEnrollmentId\n            }));\n            // Remove the second factor from the user's list.\n            this.enrolledFactors = this.enrolledFactors.filter(({ uid })=>uid !== mfaEnrollmentId);\n            // Depending on whether the backend decided to revoke the user's session,\n            // the tokenResponse may be empty. If the tokens were not updated (and they\n            // are now invalid), reloading the user will discover this and invalidate\n            // the user's state accordingly.\n            await this.user._updateTokensIfNecessary(idTokenResponse);\n            await this.user.reload();\n        } catch (e) {\n            throw e;\n        }\n    }\n}\nconst multiFactorUserCache = new WeakMap();\n/**\r\n * The {@link MultiFactorUser} corresponding to the user.\r\n *\r\n * @remarks\r\n * This is used to access all multi-factor properties and operations related to the user.\r\n *\r\n * @param user - The user.\r\n *\r\n * @public\r\n */ function multiFactor(user) {\n    const userModular = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    if (!multiFactorUserCache.has(userModular)) {\n        multiFactorUserCache.set(userModular, MultiFactorUserImpl._fromUser(userModular));\n    }\n    return multiFactorUserCache.get(userModular);\n}\nvar name = \"@firebase/auth\";\nvar version = \"1.7.9\";\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class AuthInterop {\n    constructor(auth){\n        this.auth = auth;\n        this.internalListeners = new Map();\n    }\n    getUid() {\n        var _a;\n        this.assertAuthConfigured();\n        return ((_a = this.auth.currentUser) === null || _a === void 0 ? void 0 : _a.uid) || null;\n    }\n    async getToken(forceRefresh) {\n        this.assertAuthConfigured();\n        await this.auth._initializationPromise;\n        if (!this.auth.currentUser) {\n            return null;\n        }\n        const accessToken = await this.auth.currentUser.getIdToken(forceRefresh);\n        return {\n            accessToken\n        };\n    }\n    addAuthTokenListener(listener) {\n        this.assertAuthConfigured();\n        if (this.internalListeners.has(listener)) {\n            return;\n        }\n        const unsubscribe = this.auth.onIdTokenChanged((user)=>{\n            listener((user === null || user === void 0 ? void 0 : user.stsTokenManager.accessToken) || null);\n        });\n        this.internalListeners.set(listener, unsubscribe);\n        this.updateProactiveRefresh();\n    }\n    removeAuthTokenListener(listener) {\n        this.assertAuthConfigured();\n        const unsubscribe = this.internalListeners.get(listener);\n        if (!unsubscribe) {\n            return;\n        }\n        this.internalListeners.delete(listener);\n        unsubscribe();\n        this.updateProactiveRefresh();\n    }\n    assertAuthConfigured() {\n        _assert(this.auth._initializationPromise, \"dependent-sdk-initialized-before-auth\" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */ );\n    }\n    updateProactiveRefresh() {\n        if (this.internalListeners.size > 0) {\n            this.auth._startProactiveRefresh();\n        } else {\n            this.auth._stopProactiveRefresh();\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function getVersionForPlatform(clientPlatform) {\n    switch(clientPlatform){\n        case \"Node\" /* ClientPlatform.NODE */ :\n            return \"node\";\n        case \"ReactNative\" /* ClientPlatform.REACT_NATIVE */ :\n            return \"rn\";\n        case \"Worker\" /* ClientPlatform.WORKER */ :\n            return \"webworker\";\n        case \"Cordova\" /* ClientPlatform.CORDOVA */ :\n            return \"cordova\";\n        case \"WebExtension\" /* ClientPlatform.WEB_EXTENSION */ :\n            return \"web-extension\";\n        default:\n            return undefined;\n    }\n}\n/** @internal */ function registerAuth(clientPlatform) {\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_2__.Component(\"auth\" /* _ComponentName.AUTH */ , (container, { options: deps })=>{\n        const app = container.getProvider(\"app\").getImmediate();\n        const heartbeatServiceProvider = container.getProvider(\"heartbeat\");\n        const appCheckServiceProvider = container.getProvider(\"app-check-internal\");\n        const { apiKey, authDomain } = app.options;\n        _assert(apiKey && !apiKey.includes(\":\"), \"invalid-api-key\" /* AuthErrorCode.INVALID_API_KEY */ , {\n            appName: app.name\n        });\n        const config = {\n            apiKey,\n            authDomain,\n            clientPlatform,\n            apiHost: \"identitytoolkit.googleapis.com\" /* DefaultConfig.API_HOST */ ,\n            tokenApiHost: \"securetoken.googleapis.com\" /* DefaultConfig.TOKEN_API_HOST */ ,\n            apiScheme: \"https\" /* DefaultConfig.API_SCHEME */ ,\n            sdkClientVersion: _getClientVersion(clientPlatform)\n        };\n        const authInstance = new AuthImpl(app, heartbeatServiceProvider, appCheckServiceProvider, config);\n        _initializeAuthInstance(authInstance, deps);\n        return authInstance;\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */ )/**\r\n         * Auth can only be initialized by explicitly calling getAuth() or initializeAuth()\r\n         * For why we do this, See go/firebase-next-auth-init\r\n         */ .setInstantiationMode(\"EXPLICIT\" /* InstantiationMode.EXPLICIT */ )/**\r\n         * Because all firebase products that depend on auth depend on auth-internal directly,\r\n         * we need to initialize auth-internal after auth is initialized to make it available to other firebase products.\r\n         */ .setInstanceCreatedCallback((container, _instanceIdentifier, _instance)=>{\n        const authInternalProvider = container.getProvider(\"auth-internal\" /* _ComponentName.AUTH_INTERNAL */ );\n        authInternalProvider.initialize();\n    }));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_2__.Component(\"auth-internal\" /* _ComponentName.AUTH_INTERNAL */ , (container)=>{\n        const auth = _castAuth(container.getProvider(\"auth\" /* _ComponentName.AUTH */ ).getImmediate());\n        return ((auth)=>new AuthInterop(auth))(auth);\n    }, \"PRIVATE\" /* ComponentType.PRIVATE */ ).setInstantiationMode(\"EXPLICIT\" /* InstantiationMode.EXPLICIT */ ));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, getVersionForPlatform(clientPlatform));\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, \"esm2017\");\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Initialize the fetch polyfill, the types are slightly off so just cast and hope for the best\nFetchProvider.initialize(undici__WEBPACK_IMPORTED_MODULE_3__.fetch, undici__WEBPACK_IMPORTED_MODULE_3__.Headers, undici__WEBPACK_IMPORTED_MODULE_3__.Response);\n// First, we set up the various platform-specific features for Node (register\n// the version and declare the Node getAuth function)\nfunction getAuth(app = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)()) {\n    const provider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, \"auth\");\n    if (provider.isInitialized()) {\n        return provider.getImmediate();\n    }\n    const auth = initializeAuth(app);\n    const authEmulatorHost = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getDefaultEmulatorHost)(\"auth\");\n    if (authEmulatorHost) {\n        connectAuthEmulator(auth, `http://${authEmulatorHost}`);\n    }\n    return auth;\n}\nregisterAuth(\"Node\" /* ClientPlatform.NODE */ );\n// The rest of this file contains no-ops and errors for browser-specific\n// methods. We keep the browser and Node entry points the same, but features\n// that only work in browsers are set to either do nothing (setPersistence) or\n// to reject with an auth/operation-not-supported-in-this-environment error.\n// The below exports are pulled into the main entry point by a rollup alias\n// plugin (overwriting the default browser imports).\n/** auth/operation-not-supported-in-this-environment */ const NOT_AVAILABLE_ERROR = _createError(\"operation-not-supported-in-this-environment\" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */ );\n/** Reject with auth/operation-not-supported-in-this-environment */ async function fail() {\n    throw NOT_AVAILABLE_ERROR;\n}\n/**\r\n * A class which will throw with\r\n * auth/operation-not-supported-in-this-environment if instantiated\r\n */ class FailClass {\n    constructor(){\n        throw NOT_AVAILABLE_ERROR;\n    }\n}\nconst browserLocalPersistence = inMemoryPersistence;\nconst browserSessionPersistence = inMemoryPersistence;\nconst indexedDBLocalPersistence = inMemoryPersistence;\nconst browserPopupRedirectResolver = NOT_AVAILABLE_ERROR;\nconst PhoneAuthProvider = FailClass;\nconst signInWithPhoneNumber = fail;\nconst linkWithPhoneNumber = fail;\nconst reauthenticateWithPhoneNumber = fail;\nconst updatePhoneNumber = fail;\nconst signInWithPopup = fail;\nconst linkWithPopup = fail;\nconst reauthenticateWithPopup = fail;\nconst signInWithRedirect = fail;\nconst linkWithRedirect = fail;\nconst reauthenticateWithRedirect = fail;\nconst getRedirectResult = fail;\nconst RecaptchaVerifier = FailClass;\nclass PhoneMultiFactorGenerator {\n    static assertion() {\n        throw NOT_AVAILABLE_ERROR;\n    }\n}\n// Set persistence should no-op instead of fail. Changing the prototype will\n// make sure both setPersistence(auth, persistence) and\n// auth.setPersistence(persistence) are covered.\nAuthImpl.prototype.setPersistence = async ()=>{};\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function finalizeSignInTotpMfa(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v2/accounts/mfaSignIn:finalize\" /* Endpoint.FINALIZE_MFA_SIGN_IN */ , _addTidIfNecessary(auth, request));\n}\nclass MultiFactorAssertionImpl {\n    constructor(factorId){\n        this.factorId = factorId;\n    }\n    _process(auth, session, displayName) {\n        switch(session.type){\n            case \"enroll\" /* MultiFactorSessionType.ENROLL */ :\n                return this._finalizeEnroll(auth, session.credential, displayName);\n            case \"signin\" /* MultiFactorSessionType.SIGN_IN */ :\n                return this._finalizeSignIn(auth, session.credential);\n            default:\n                return debugFail(\"unexpected MultiFactorSessionType\");\n        }\n    }\n}\n/**\r\n * Provider for generating a {@link TotpMultiFactorAssertion}.\r\n *\r\n * @public\r\n */ class TotpMultiFactorGenerator {\n    /**\r\n     * Provides a {@link TotpMultiFactorAssertion} to confirm ownership of\r\n     * the TOTP (time-based one-time password) second factor.\r\n     * This assertion is used to complete enrollment in TOTP second factor.\r\n     *\r\n     * @param secret A {@link TotpSecret} containing the shared secret key and other TOTP parameters.\r\n     * @param oneTimePassword One-time password from TOTP App.\r\n     * @returns A {@link TotpMultiFactorAssertion} which can be used with\r\n     * {@link MultiFactorUser.enroll}.\r\n     */ static assertionForEnrollment(secret, oneTimePassword) {\n        return TotpMultiFactorAssertionImpl._fromSecret(secret, oneTimePassword);\n    }\n    /**\r\n     * Provides a {@link TotpMultiFactorAssertion} to confirm ownership of the TOTP second factor.\r\n     * This assertion is used to complete signIn with TOTP as the second factor.\r\n     *\r\n     * @param enrollmentId identifies the enrolled TOTP second factor.\r\n     * @param oneTimePassword One-time password from TOTP App.\r\n     * @returns A {@link TotpMultiFactorAssertion} which can be used with\r\n     * {@link MultiFactorResolver.resolveSignIn}.\r\n     */ static assertionForSignIn(enrollmentId, oneTimePassword) {\n        return TotpMultiFactorAssertionImpl._fromEnrollmentId(enrollmentId, oneTimePassword);\n    }\n    /**\r\n     * Returns a promise to {@link TotpSecret} which contains the TOTP shared secret key and other parameters.\r\n     * Creates a TOTP secret as part of enrolling a TOTP second factor.\r\n     * Used for generating a QR code URL or inputting into a TOTP app.\r\n     * This method uses the auth instance corresponding to the user in the multiFactorSession.\r\n     *\r\n     * @param session The {@link MultiFactorSession} that the user is part of.\r\n     * @returns A promise to {@link TotpSecret}.\r\n     */ static async generateSecret(session) {\n        var _a;\n        const mfaSession = session;\n        _assert(typeof ((_a = mfaSession.user) === null || _a === void 0 ? void 0 : _a.auth) !== \"undefined\", \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        const response = await startEnrollTotpMfa(mfaSession.user.auth, {\n            idToken: mfaSession.credential,\n            totpEnrollmentInfo: {}\n        });\n        return TotpSecret._fromStartTotpMfaEnrollmentResponse(response, mfaSession.user.auth);\n    }\n}\n/**\r\n * The identifier of the TOTP second factor: `totp`.\r\n */ TotpMultiFactorGenerator.FACTOR_ID = \"totp\" /* FactorId.TOTP */ ;\nclass TotpMultiFactorAssertionImpl extends MultiFactorAssertionImpl {\n    constructor(otp, enrollmentId, secret){\n        super(\"totp\" /* FactorId.TOTP */ );\n        this.otp = otp;\n        this.enrollmentId = enrollmentId;\n        this.secret = secret;\n    }\n    /** @internal */ static _fromSecret(secret, otp) {\n        return new TotpMultiFactorAssertionImpl(otp, undefined, secret);\n    }\n    /** @internal */ static _fromEnrollmentId(enrollmentId, otp) {\n        return new TotpMultiFactorAssertionImpl(otp, enrollmentId);\n    }\n    /** @internal */ async _finalizeEnroll(auth, idToken, displayName) {\n        _assert(typeof this.secret !== \"undefined\", auth, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n        return finalizeEnrollTotpMfa(auth, {\n            idToken,\n            displayName,\n            totpVerificationInfo: this.secret._makeTotpVerificationInfo(this.otp)\n        });\n    }\n    /** @internal */ async _finalizeSignIn(auth, mfaPendingCredential) {\n        _assert(this.enrollmentId !== undefined && this.otp !== undefined, auth, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n        const totpVerificationInfo = {\n            verificationCode: this.otp\n        };\n        return finalizeSignInTotpMfa(auth, {\n            mfaPendingCredential,\n            mfaEnrollmentId: this.enrollmentId,\n            totpVerificationInfo\n        });\n    }\n}\n/**\r\n * Provider for generating a {@link TotpMultiFactorAssertion}.\r\n *\r\n * Stores the shared secret key and other parameters to generate time-based OTPs.\r\n * Implements methods to retrieve the shared secret key and generate a QR code URL.\r\n * @public\r\n */ class TotpSecret {\n    // The public members are declared outside the constructor so the docs can be generated.\n    constructor(secretKey, hashingAlgorithm, codeLength, codeIntervalSeconds, enrollmentCompletionDeadline, sessionInfo, auth){\n        this.sessionInfo = sessionInfo;\n        this.auth = auth;\n        this.secretKey = secretKey;\n        this.hashingAlgorithm = hashingAlgorithm;\n        this.codeLength = codeLength;\n        this.codeIntervalSeconds = codeIntervalSeconds;\n        this.enrollmentCompletionDeadline = enrollmentCompletionDeadline;\n    }\n    /** @internal */ static _fromStartTotpMfaEnrollmentResponse(response, auth) {\n        return new TotpSecret(response.totpSessionInfo.sharedSecretKey, response.totpSessionInfo.hashingAlgorithm, response.totpSessionInfo.verificationCodeLength, response.totpSessionInfo.periodSec, new Date(response.totpSessionInfo.finalizeEnrollmentTime).toUTCString(), response.totpSessionInfo.sessionInfo, auth);\n    }\n    /** @internal */ _makeTotpVerificationInfo(otp) {\n        return {\n            sessionInfo: this.sessionInfo,\n            verificationCode: otp\n        };\n    }\n    /**\r\n     * Returns a QR code URL as described in\r\n     * https://github.com/google/google-authenticator/wiki/Key-Uri-Format\r\n     * This can be displayed to the user as a QR code to be scanned into a TOTP app like Google Authenticator.\r\n     * If the optional parameters are unspecified, an accountName of <userEmail> and issuer of <firebaseAppName> are used.\r\n     *\r\n     * @param accountName the name of the account/app along with a user identifier.\r\n     * @param issuer issuer of the TOTP (likely the app name).\r\n     * @returns A QR code URL string.\r\n     */ generateQrCodeUrl(accountName, issuer) {\n        var _a;\n        let useDefaults = false;\n        if (_isEmptyString(accountName) || _isEmptyString(issuer)) {\n            useDefaults = true;\n        }\n        if (useDefaults) {\n            if (_isEmptyString(accountName)) {\n                accountName = ((_a = this.auth.currentUser) === null || _a === void 0 ? void 0 : _a.email) || \"unknownuser\";\n            }\n            if (_isEmptyString(issuer)) {\n                issuer = this.auth.name;\n            }\n        }\n        return `otpauth://totp/${issuer}:${accountName}?secret=${this.secretKey}&issuer=${issuer}&algorithm=${this.hashingAlgorithm}&digits=${this.codeLength}`;\n    }\n}\n/** @internal */ function _isEmptyString(input) {\n    return typeof input === \"undefined\" || (input === null || input === void 0 ? void 0 : input.length) === 0;\n}\n //# sourceMappingURL=totp-219bb96f.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL2Rpc3Qvbm9kZS1lc20vdG90cC0yMTliYjk2Zi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2SDtBQUMrSjtBQUM3UDtBQUNpQjtBQUN3QztBQUNwQztBQUVwRDs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRDs7OztDQUlDLEdBQ0QsTUFBTWdDLFdBQVc7SUFDYiwyQkFBMkIsR0FDM0JDLE9BQU87SUFDUEMsTUFBTTtBQUNWO0FBQ0E7Ozs7Q0FJQyxHQUNELE1BQU1DLGFBQWE7SUFDZix5QkFBeUIsR0FDekJDLFVBQVU7SUFDVix1QkFBdUIsR0FDdkJDLFFBQVE7SUFDUix1QkFBdUIsR0FDdkJDLFFBQVE7SUFDUixzQkFBc0IsR0FDdEJDLFVBQVU7SUFDVixtQkFBbUIsR0FDbkJOLE9BQU87SUFDUCx3QkFBd0IsR0FDeEJPLFNBQVM7QUFDYjtBQUNBOzs7O0NBSUMsR0FDRCxNQUFNQyxlQUFlO0lBQ2pCLDhCQUE4QixHQUM5QkMsWUFBWTtJQUNaLGtDQUFrQyxHQUNsQ0MsZ0JBQWdCO0lBQ2hCLDRCQUE0QixHQUM1QlAsVUFBVTtJQUNWLDBCQUEwQixHQUMxQkMsUUFBUTtJQUNSLDBCQUEwQixHQUMxQkMsUUFBUTtJQUNSLHlCQUF5QixHQUN6QkwsT0FBTztJQUNQLDJCQUEyQixHQUMzQk8sU0FBUztBQUNiO0FBQ0E7Ozs7Q0FJQyxHQUNELE1BQU1JLGdCQUFnQjtJQUNsQixxRkFBcUYsR0FDckZDLE1BQU07SUFDTixzRkFBc0YsR0FDdEZDLGdCQUFnQjtJQUNoQiwyQ0FBMkMsR0FDM0NDLFNBQVM7QUFDYjtBQUNBOzs7O0NBSUMsR0FDRCxNQUFNQyxzQkFBc0I7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QU8sT0FBT0EsVUFBVSxlQUFlLENBQUNBLFVBQVUsUUFBUUEsVUFBVSxLQUFLLElBQUksS0FBSyxJQUFJQSxNQUFNN3hCLE1BQU0sTUFBTTtBQUM1RztBQUUrb0YsQ0FDL29GLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9kaXN0L25vZGUtZXNtL3RvdHAtMjE5YmI5NmYuanM/ZjcwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTREtfVkVSU0lPTiwgX2lzRmlyZWJhc2VTZXJ2ZXJBcHAsIF9nZXRQcm92aWRlciwgX3JlZ2lzdGVyQ29tcG9uZW50LCByZWdpc3RlclZlcnNpb24sIGdldEFwcCB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgRXJyb3JGYWN0b3J5LCBpc0Jyb3dzZXJFeHRlbnNpb24sIGlzTW9iaWxlQ29yZG92YSwgaXNSZWFjdE5hdGl2ZSwgRmlyZWJhc2VFcnJvciwgcXVlcnlzdHJpbmcsIGlzQ2xvdWRmbGFyZVdvcmtlciwgZ2V0TW9kdWxhckluc3RhbmNlLCBiYXNlNjREZWNvZGUsIGdldFVBLCBpc0lFLCBjcmVhdGVTdWJzY3JpYmUsIGRlZXBFcXVhbCwgcXVlcnlzdHJpbmdEZWNvZGUsIGV4dHJhY3RRdWVyeXN0cmluZywgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IF9fcmVzdCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IHsgZmV0Y2ggYXMgZmV0Y2gkMSwgSGVhZGVycyBhcyBIZWFkZXJzJDEsIFJlc3BvbnNlIGFzIFJlc3BvbnNlJDEgfSBmcm9tICd1bmRpY2knO1xuaW1wb3J0IHsgTG9nZ2VyLCBMb2dMZXZlbCB9IGZyb20gJ0BmaXJlYmFzZS9sb2dnZXInO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gZW51bSBvZiBmYWN0b3JzIHRoYXQgbWF5IGJlIHVzZWQgZm9yIG11bHRpZmFjdG9yIGF1dGhlbnRpY2F0aW9uLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBGYWN0b3JJZCA9IHtcclxuICAgIC8qKiBQaG9uZSBhcyBzZWNvbmQgZmFjdG9yICovXHJcbiAgICBQSE9ORTogJ3Bob25lJyxcclxuICAgIFRPVFA6ICd0b3RwJ1xyXG59O1xyXG4vKipcclxuICogRW51bWVyYXRpb24gb2Ygc3VwcG9ydGVkIHByb3ZpZGVycy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgUHJvdmlkZXJJZCA9IHtcclxuICAgIC8qKiBGYWNlYm9vayBwcm92aWRlciBJRCAqL1xyXG4gICAgRkFDRUJPT0s6ICdmYWNlYm9vay5jb20nLFxyXG4gICAgLyoqIEdpdEh1YiBwcm92aWRlciBJRCAqL1xyXG4gICAgR0lUSFVCOiAnZ2l0aHViLmNvbScsXHJcbiAgICAvKiogR29vZ2xlIHByb3ZpZGVyIElEICovXHJcbiAgICBHT09HTEU6ICdnb29nbGUuY29tJyxcclxuICAgIC8qKiBQYXNzd29yZCBwcm92aWRlciAqL1xyXG4gICAgUEFTU1dPUkQ6ICdwYXNzd29yZCcsXHJcbiAgICAvKiogUGhvbmUgcHJvdmlkZXIgKi9cclxuICAgIFBIT05FOiAncGhvbmUnLFxyXG4gICAgLyoqIFR3aXR0ZXIgcHJvdmlkZXIgSUQgKi9cclxuICAgIFRXSVRURVI6ICd0d2l0dGVyLmNvbSdcclxufTtcclxuLyoqXHJcbiAqIEVudW1lcmF0aW9uIG9mIHN1cHBvcnRlZCBzaWduLWluIG1ldGhvZHMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IFNpZ25Jbk1ldGhvZCA9IHtcclxuICAgIC8qKiBFbWFpbCBsaW5rIHNpZ24gaW4gbWV0aG9kICovXHJcbiAgICBFTUFJTF9MSU5LOiAnZW1haWxMaW5rJyxcclxuICAgIC8qKiBFbWFpbC9wYXNzd29yZCBzaWduIGluIG1ldGhvZCAqL1xyXG4gICAgRU1BSUxfUEFTU1dPUkQ6ICdwYXNzd29yZCcsXHJcbiAgICAvKiogRmFjZWJvb2sgc2lnbiBpbiBtZXRob2QgKi9cclxuICAgIEZBQ0VCT09LOiAnZmFjZWJvb2suY29tJyxcclxuICAgIC8qKiBHaXRIdWIgc2lnbiBpbiBtZXRob2QgKi9cclxuICAgIEdJVEhVQjogJ2dpdGh1Yi5jb20nLFxyXG4gICAgLyoqIEdvb2dsZSBzaWduIGluIG1ldGhvZCAqL1xyXG4gICAgR09PR0xFOiAnZ29vZ2xlLmNvbScsXHJcbiAgICAvKiogUGhvbmUgc2lnbiBpbiBtZXRob2QgKi9cclxuICAgIFBIT05FOiAncGhvbmUnLFxyXG4gICAgLyoqIFR3aXR0ZXIgc2lnbiBpbiBtZXRob2QgKi9cclxuICAgIFRXSVRURVI6ICd0d2l0dGVyLmNvbSdcclxufTtcclxuLyoqXHJcbiAqIEVudW1lcmF0aW9uIG9mIHN1cHBvcnRlZCBvcGVyYXRpb24gdHlwZXMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IE9wZXJhdGlvblR5cGUgPSB7XHJcbiAgICAvKiogT3BlcmF0aW9uIGludm9sdmluZyBsaW5raW5nIGFuIGFkZGl0aW9uYWwgcHJvdmlkZXIgdG8gYW4gYWxyZWFkeSBzaWduZWQtaW4gdXNlci4gKi9cclxuICAgIExJTks6ICdsaW5rJyxcclxuICAgIC8qKiBPcGVyYXRpb24gaW52b2x2aW5nIHVzaW5nIGEgcHJvdmlkZXIgdG8gcmVhdXRoZW50aWNhdGUgYW4gYWxyZWFkeSBzaWduZWQtaW4gdXNlci4gKi9cclxuICAgIFJFQVVUSEVOVElDQVRFOiAncmVhdXRoZW50aWNhdGUnLFxyXG4gICAgLyoqIE9wZXJhdGlvbiBpbnZvbHZpbmcgc2lnbmluZyBpbiBhIHVzZXIuICovXHJcbiAgICBTSUdOX0lOOiAnc2lnbkluJ1xyXG59O1xyXG4vKipcclxuICogQW4gZW51bWVyYXRpb24gb2YgdGhlIHBvc3NpYmxlIGVtYWlsIGFjdGlvbiB0eXBlcy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgQWN0aW9uQ29kZU9wZXJhdGlvbiA9IHtcclxuICAgIC8qKiBUaGUgZW1haWwgbGluayBzaWduLWluIGFjdGlvbi4gKi9cclxuICAgIEVNQUlMX1NJR05JTjogJ0VNQUlMX1NJR05JTicsXHJcbiAgICAvKiogVGhlIHBhc3N3b3JkIHJlc2V0IGFjdGlvbi4gKi9cclxuICAgIFBBU1NXT1JEX1JFU0VUOiAnUEFTU1dPUkRfUkVTRVQnLFxyXG4gICAgLyoqIFRoZSBlbWFpbCByZXZvY2F0aW9uIGFjdGlvbi4gKi9cclxuICAgIFJFQ09WRVJfRU1BSUw6ICdSRUNPVkVSX0VNQUlMJyxcclxuICAgIC8qKiBUaGUgcmV2ZXJ0IHNlY29uZCBmYWN0b3IgYWRkaXRpb24gZW1haWwgYWN0aW9uLiAqL1xyXG4gICAgUkVWRVJUX1NFQ09ORF9GQUNUT1JfQURESVRJT046ICdSRVZFUlRfU0VDT05EX0ZBQ1RPUl9BRERJVElPTicsXHJcbiAgICAvKiogVGhlIHJldmVydCBzZWNvbmQgZmFjdG9yIGFkZGl0aW9uIGVtYWlsIGFjdGlvbi4gKi9cclxuICAgIFZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMOiAnVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwnLFxyXG4gICAgLyoqIFRoZSBlbWFpbCB2ZXJpZmljYXRpb24gYWN0aW9uLiAqL1xyXG4gICAgVkVSSUZZX0VNQUlMOiAnVkVSSUZZX0VNQUlMJ1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBfZGVidWdFcnJvck1hcCgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgW1wiYWRtaW4tcmVzdHJpY3RlZC1vcGVyYXRpb25cIiAvKiBBdXRoRXJyb3JDb2RlLkFETUlOX09OTFlfT1BFUkFUSU9OICovXTogJ1RoaXMgb3BlcmF0aW9uIGlzIHJlc3RyaWN0ZWQgdG8gYWRtaW5pc3RyYXRvcnMgb25seS4nLFxyXG4gICAgICAgIFtcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqL106ICcnLFxyXG4gICAgICAgIFtcImFwcC1ub3QtYXV0aG9yaXplZFwiIC8qIEF1dGhFcnJvckNvZGUuQVBQX05PVF9BVVRIT1JJWkVEICovXTogXCJUaGlzIGFwcCwgaWRlbnRpZmllZCBieSB0aGUgZG9tYWluIHdoZXJlIGl0J3MgaG9zdGVkLCBpcyBub3QgXCIgK1xyXG4gICAgICAgICAgICAnYXV0aG9yaXplZCB0byB1c2UgRmlyZWJhc2UgQXV0aGVudGljYXRpb24gd2l0aCB0aGUgcHJvdmlkZWQgQVBJIGtleS4gJyArXHJcbiAgICAgICAgICAgICdSZXZpZXcgeW91ciBrZXkgY29uZmlndXJhdGlvbiBpbiB0aGUgR29vZ2xlIEFQSSBjb25zb2xlLicsXHJcbiAgICAgICAgW1wiYXBwLW5vdC1pbnN0YWxsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkFQUF9OT1RfSU5TVEFMTEVEICovXTogJ1RoZSByZXF1ZXN0ZWQgbW9iaWxlIGFwcGxpY2F0aW9uIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGlkZW50aWZpZXIgKCcgK1xyXG4gICAgICAgICAgICAnQW5kcm9pZCBwYWNrYWdlIG5hbWUgb3IgaU9TIGJ1bmRsZSBJRCkgcHJvdmlkZWQgaXMgbm90IGluc3RhbGxlZCBvbiAnICtcclxuICAgICAgICAgICAgJ3RoaXMgZGV2aWNlLicsXHJcbiAgICAgICAgW1wiY2FwdGNoYS1jaGVjay1mYWlsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkNBUFRDSEFfQ0hFQ0tfRkFJTEVEICovXTogJ1RoZSByZUNBUFRDSEEgcmVzcG9uc2UgdG9rZW4gcHJvdmlkZWQgaXMgZWl0aGVyIGludmFsaWQsIGV4cGlyZWQsICcgK1xyXG4gICAgICAgICAgICAnYWxyZWFkeSB1c2VkIG9yIHRoZSBkb21haW4gYXNzb2NpYXRlZCB3aXRoIGl0IGRvZXMgbm90IG1hdGNoIHRoZSBsaXN0ICcgK1xyXG4gICAgICAgICAgICAnb2Ygd2hpdGVsaXN0ZWQgZG9tYWlucy4nLFxyXG4gICAgICAgIFtcImNvZGUtZXhwaXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuQ09ERV9FWFBJUkVEICovXTogJ1RoZSBTTVMgY29kZSBoYXMgZXhwaXJlZC4gUGxlYXNlIHJlLXNlbmQgdGhlIHZlcmlmaWNhdGlvbiBjb2RlIHRvIHRyeSAnICtcclxuICAgICAgICAgICAgJ2FnYWluLicsXHJcbiAgICAgICAgW1wiY29yZG92YS1ub3QtcmVhZHlcIiAvKiBBdXRoRXJyb3JDb2RlLkNPUkRPVkFfTk9UX1JFQURZICovXTogJ0NvcmRvdmEgZnJhbWV3b3JrIGlzIG5vdCByZWFkeS4nLFxyXG4gICAgICAgIFtcImNvcnMtdW5zdXBwb3J0ZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkNPUlNfVU5TVVBQT1JURUQgKi9dOiAnVGhpcyBicm93c2VyIGlzIG5vdCBzdXBwb3J0ZWQuJyxcclxuICAgICAgICBbXCJjcmVkZW50aWFsLWFscmVhZHktaW4tdXNlXCIgLyogQXV0aEVycm9yQ29kZS5DUkVERU5USUFMX0FMUkVBRFlfSU5fVVNFICovXTogJ1RoaXMgY3JlZGVudGlhbCBpcyBhbHJlYWR5IGFzc29jaWF0ZWQgd2l0aCBhIGRpZmZlcmVudCB1c2VyIGFjY291bnQuJyxcclxuICAgICAgICBbXCJjdXN0b20tdG9rZW4tbWlzbWF0Y2hcIiAvKiBBdXRoRXJyb3JDb2RlLkNSRURFTlRJQUxfTUlTTUFUQ0ggKi9dOiAnVGhlIGN1c3RvbSB0b2tlbiBjb3JyZXNwb25kcyB0byBhIGRpZmZlcmVudCBhdWRpZW5jZS4nLFxyXG4gICAgICAgIFtcInJlcXVpcmVzLXJlY2VudC1sb2dpblwiIC8qIEF1dGhFcnJvckNvZGUuQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOICovXTogJ1RoaXMgb3BlcmF0aW9uIGlzIHNlbnNpdGl2ZSBhbmQgcmVxdWlyZXMgcmVjZW50IGF1dGhlbnRpY2F0aW9uLiBMb2cgaW4gJyArXHJcbiAgICAgICAgICAgICdhZ2FpbiBiZWZvcmUgcmV0cnlpbmcgdGhpcyByZXF1ZXN0LicsXHJcbiAgICAgICAgW1wiZGVwZW5kZW50LXNkay1pbml0aWFsaXplZC1iZWZvcmUtYXV0aFwiIC8qIEF1dGhFcnJvckNvZGUuREVQRU5ERU5UX1NES19JTklUX0JFRk9SRV9BVVRIICovXTogJ0Fub3RoZXIgRmlyZWJhc2UgU0RLIHdhcyBpbml0aWFsaXplZCBhbmQgaXMgdHJ5aW5nIHRvIHVzZSBBdXRoIGJlZm9yZSBBdXRoIGlzICcgK1xyXG4gICAgICAgICAgICAnaW5pdGlhbGl6ZWQuIFBsZWFzZSBiZSBzdXJlIHRvIGNhbGwgYGluaXRpYWxpemVBdXRoYCBvciBgZ2V0QXV0aGAgYmVmb3JlICcgK1xyXG4gICAgICAgICAgICAnc3RhcnRpbmcgYW55IG90aGVyIEZpcmViYXNlIFNESy4nLFxyXG4gICAgICAgIFtcImR5bmFtaWMtbGluay1ub3QtYWN0aXZhdGVkXCIgLyogQXV0aEVycm9yQ29kZS5EWU5BTUlDX0xJTktfTk9UX0FDVElWQVRFRCAqL106ICdQbGVhc2UgYWN0aXZhdGUgRHluYW1pYyBMaW5rcyBpbiB0aGUgRmlyZWJhc2UgQ29uc29sZSBhbmQgYWdyZWUgdG8gdGhlIHRlcm1zIGFuZCAnICtcclxuICAgICAgICAgICAgJ2NvbmRpdGlvbnMuJyxcclxuICAgICAgICBbXCJlbWFpbC1jaGFuZ2UtbmVlZHMtdmVyaWZpY2F0aW9uXCIgLyogQXV0aEVycm9yQ29kZS5FTUFJTF9DSEFOR0VfTkVFRFNfVkVSSUZJQ0FUSU9OICovXTogJ011bHRpLWZhY3RvciB1c2VycyBtdXN0IGFsd2F5cyBoYXZlIGEgdmVyaWZpZWQgZW1haWwuJyxcclxuICAgICAgICBbXCJlbWFpbC1hbHJlYWR5LWluLXVzZVwiIC8qIEF1dGhFcnJvckNvZGUuRU1BSUxfRVhJU1RTICovXTogJ1RoZSBlbWFpbCBhZGRyZXNzIGlzIGFscmVhZHkgaW4gdXNlIGJ5IGFub3RoZXIgYWNjb3VudC4nLFxyXG4gICAgICAgIFtcImVtdWxhdG9yLWNvbmZpZy1mYWlsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkVNVUxBVE9SX0NPTkZJR19GQUlMRUQgKi9dOiAnQXV0aCBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWQgdG8gbWFrZSBhIG5ldHdvcmsgY2FsbC4gQXV0aCBjYW4gJyArXHJcbiAgICAgICAgICAgICdubyBsb25nZXIgYmUgY29uZmlndXJlZCB0byB1c2UgdGhlIGVtdWxhdG9yLiBUcnkgY2FsbGluZyAnICtcclxuICAgICAgICAgICAgJ1wiY29ubmVjdEF1dGhFbXVsYXRvcigpXCIgc29vbmVyLicsXHJcbiAgICAgICAgW1wiZXhwaXJlZC1hY3Rpb24tY29kZVwiIC8qIEF1dGhFcnJvckNvZGUuRVhQSVJFRF9PT0JfQ09ERSAqL106ICdUaGUgYWN0aW9uIGNvZGUgaGFzIGV4cGlyZWQuJyxcclxuICAgICAgICBbXCJjYW5jZWxsZWQtcG9wdXAtcmVxdWVzdFwiIC8qIEF1dGhFcnJvckNvZGUuRVhQSVJFRF9QT1BVUF9SRVFVRVNUICovXTogJ1RoaXMgb3BlcmF0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZCBkdWUgdG8gYW5vdGhlciBjb25mbGljdGluZyBwb3B1cCBiZWluZyBvcGVuZWQuJyxcclxuICAgICAgICBbXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi9dOiAnQW4gaW50ZXJuYWwgQXV0aEVycm9yIGhhcyBvY2N1cnJlZC4nLFxyXG4gICAgICAgIFtcImludmFsaWQtYXBwLWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQVBQX0NSRURFTlRJQUwgKi9dOiAnVGhlIHBob25lIHZlcmlmaWNhdGlvbiByZXF1ZXN0IGNvbnRhaW5zIGFuIGludmFsaWQgYXBwbGljYXRpb24gdmVyaWZpZXIuJyArXHJcbiAgICAgICAgICAgICcgVGhlIHJlQ0FQVENIQSB0b2tlbiByZXNwb25zZSBpcyBlaXRoZXIgaW52YWxpZCBvciBleHBpcmVkLicsXHJcbiAgICAgICAgW1wiaW52YWxpZC1hcHAtaWRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQVBQX0lEICovXTogJ1RoZSBtb2JpbGUgYXBwIGlkZW50aWZpZXIgaXMgbm90IHJlZ2lzdGVyZWQgZm9yIHRoZSBjdXJyZW50IHByb2plY3QuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLXVzZXItdG9rZW5cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQVVUSCAqL106IFwiVGhpcyB1c2VyJ3MgY3JlZGVudGlhbCBpc24ndCB2YWxpZCBmb3IgdGhpcyBwcm9qZWN0LiBUaGlzIGNhbiBoYXBwZW4gXCIgK1xyXG4gICAgICAgICAgICBcImlmIHRoZSB1c2VyJ3MgdG9rZW4gaGFzIGJlZW4gdGFtcGVyZWQgd2l0aCwgb3IgaWYgdGhlIHVzZXIgaXNuJ3QgZm9yIFwiICtcclxuICAgICAgICAgICAgJ3RoZSBwcm9qZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIEFQSSBrZXkuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLWF1dGgtZXZlbnRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQVVUSF9FVkVOVCAqL106ICdBbiBpbnRlcm5hbCBBdXRoRXJyb3IgaGFzIG9jY3VycmVkLicsXHJcbiAgICAgICAgW1wiaW52YWxpZC12ZXJpZmljYXRpb24tY29kZVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DT0RFICovXTogJ1RoZSBTTVMgdmVyaWZpY2F0aW9uIGNvZGUgdXNlZCB0byBjcmVhdGUgdGhlIHBob25lIGF1dGggY3JlZGVudGlhbCBpcyAnICtcclxuICAgICAgICAgICAgJ2ludmFsaWQuIFBsZWFzZSByZXNlbmQgdGhlIHZlcmlmaWNhdGlvbiBjb2RlIHNtcyBhbmQgYmUgc3VyZSB0byB1c2UgdGhlICcgK1xyXG4gICAgICAgICAgICAndmVyaWZpY2F0aW9uIGNvZGUgcHJvdmlkZWQgYnkgdGhlIHVzZXIuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLWNvbnRpbnVlLXVyaVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DT05USU5VRV9VUkkgKi9dOiAnVGhlIGNvbnRpbnVlIFVSTCBwcm92aWRlZCBpbiB0aGUgcmVxdWVzdCBpcyBpbnZhbGlkLicsXHJcbiAgICAgICAgW1wiaW52YWxpZC1jb3Jkb3ZhLWNvbmZpZ3VyYXRpb25cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ09SRE9WQV9DT05GSUdVUkFUSU9OICovXTogJ1RoZSBmb2xsb3dpbmcgQ29yZG92YSBwbHVnaW5zIG11c3QgYmUgaW5zdGFsbGVkIHRvIGVuYWJsZSBPQXV0aCBzaWduLWluOiAnICtcclxuICAgICAgICAgICAgJ2NvcmRvdmEtcGx1Z2luLWJ1aWxkaW5mbywgY29yZG92YS11bml2ZXJzYWwtbGlua3MtcGx1Z2luLCAnICtcclxuICAgICAgICAgICAgJ2NvcmRvdmEtcGx1Z2luLWJyb3dzZXJ0YWIsIGNvcmRvdmEtcGx1Z2luLWluYXBwYnJvd3NlciBhbmQgJyArXHJcbiAgICAgICAgICAgICdjb3Jkb3ZhLXBsdWdpbi1jdXN0b211cmxzY2hlbWUuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLWN1c3RvbS10b2tlblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DVVNUT01fVE9LRU4gKi9dOiAnVGhlIGN1c3RvbSB0b2tlbiBmb3JtYXQgaXMgaW5jb3JyZWN0LiBQbGVhc2UgY2hlY2sgdGhlIGRvY3VtZW50YXRpb24uJyxcclxuICAgICAgICBbXCJpbnZhbGlkLWR5bmFtaWMtbGluay1kb21haW5cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfRFlOQU1JQ19MSU5LX0RPTUFJTiAqL106ICdUaGUgcHJvdmlkZWQgZHluYW1pYyBsaW5rIGRvbWFpbiBpcyBub3QgY29uZmlndXJlZCBvciBhdXRob3JpemVkIGZvciB0aGUgY3VycmVudCBwcm9qZWN0LicsXHJcbiAgICAgICAgW1wiaW52YWxpZC1lbWFpbFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9FTUFJTCAqL106ICdUaGUgZW1haWwgYWRkcmVzcyBpcyBiYWRseSBmb3JtYXR0ZWQuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLWVtdWxhdG9yLXNjaGVtZVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9FTVVMQVRPUl9TQ0hFTUUgKi9dOiAnRW11bGF0b3IgVVJMIG11c3Qgc3RhcnQgd2l0aCBhIHZhbGlkIHNjaGVtZSAoaHR0cDovLyBvciBodHRwczovLykuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLWFwaS1rZXlcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQVBJX0tFWSAqL106ICdZb3VyIEFQSSBrZXkgaXMgaW52YWxpZCwgcGxlYXNlIGNoZWNrIHlvdSBoYXZlIGNvcGllZCBpdCBjb3JyZWN0bHkuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLWNlcnQtaGFzaFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DRVJUX0hBU0ggKi9dOiAnVGhlIFNIQS0xIGNlcnRpZmljYXRlIGhhc2ggcHJvdmlkZWQgaXMgaW52YWxpZC4nLFxyXG4gICAgICAgIFtcImludmFsaWQtY3JlZGVudGlhbFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DUkVERU5USUFMICovXTogJ1RoZSBzdXBwbGllZCBhdXRoIGNyZWRlbnRpYWwgaXMgaW5jb3JyZWN0LCBtYWxmb3JtZWQgb3IgaGFzIGV4cGlyZWQuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLW1lc3NhZ2UtcGF5bG9hZFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9NRVNTQUdFX1BBWUxPQUQgKi9dOiAnVGhlIGVtYWlsIHRlbXBsYXRlIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBhY3Rpb24gY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIGluIGl0cyBtZXNzYWdlLiAnICtcclxuICAgICAgICAgICAgJ1BsZWFzZSBmaXggYnkgZ29pbmcgdG8gdGhlIEF1dGggZW1haWwgdGVtcGxhdGVzIHNlY3Rpb24gaW4gdGhlIEZpcmViYXNlIENvbnNvbGUuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLW11bHRpLWZhY3Rvci1zZXNzaW9uXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX01GQV9TRVNTSU9OICovXTogJ1RoZSByZXF1ZXN0IGRvZXMgbm90IGNvbnRhaW4gYSB2YWxpZCBwcm9vZiBvZiBmaXJzdCBmYWN0b3Igc3VjY2Vzc2Z1bCBzaWduLWluLicsXHJcbiAgICAgICAgW1wiaW52YWxpZC1vYXV0aC1wcm92aWRlclwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9PQVVUSF9QUk9WSURFUiAqL106ICdFbWFpbEF1dGhQcm92aWRlciBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIG9wZXJhdGlvbi4gVGhpcyBvcGVyYXRpb24gJyArXHJcbiAgICAgICAgICAgICdvbmx5IHN1cHBvcnRzIE9BdXRoIHByb3ZpZGVycy4nLFxyXG4gICAgICAgIFtcImludmFsaWQtb2F1dGgtY2xpZW50LWlkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX09BVVRIX0NMSUVOVF9JRCAqL106ICdUaGUgT0F1dGggY2xpZW50IElEIHByb3ZpZGVkIGlzIGVpdGhlciBpbnZhbGlkIG9yIGRvZXMgbm90IG1hdGNoIHRoZSAnICtcclxuICAgICAgICAgICAgJ3NwZWNpZmllZCBBUEkga2V5LicsXHJcbiAgICAgICAgW1widW5hdXRob3JpemVkLWRvbWFpblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9PUklHSU4gKi9dOiAnVGhpcyBkb21haW4gaXMgbm90IGF1dGhvcml6ZWQgZm9yIE9BdXRoIG9wZXJhdGlvbnMgZm9yIHlvdXIgRmlyZWJhc2UgJyArXHJcbiAgICAgICAgICAgICdwcm9qZWN0LiBFZGl0IHRoZSBsaXN0IG9mIGF1dGhvcml6ZWQgZG9tYWlucyBmcm9tIHRoZSBGaXJlYmFzZSBjb25zb2xlLicsXHJcbiAgICAgICAgW1wiaW52YWxpZC1hY3Rpb24tY29kZVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9PT0JfQ09ERSAqL106ICdUaGUgYWN0aW9uIGNvZGUgaXMgaW52YWxpZC4gVGhpcyBjYW4gaGFwcGVuIGlmIHRoZSBjb2RlIGlzIG1hbGZvcm1lZCwgJyArXHJcbiAgICAgICAgICAgICdleHBpcmVkLCBvciBoYXMgYWxyZWFkeSBiZWVuIHVzZWQuJyxcclxuICAgICAgICBbXCJ3cm9uZy1wYXNzd29yZFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9QQVNTV09SRCAqL106ICdUaGUgcGFzc3dvcmQgaXMgaW52YWxpZCBvciB0aGUgdXNlciBkb2VzIG5vdCBoYXZlIGEgcGFzc3dvcmQuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLXBlcnNpc3RlbmNlLXR5cGVcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUEVSU0lTVEVOQ0UgKi9dOiAnVGhlIHNwZWNpZmllZCBwZXJzaXN0ZW5jZSB0eXBlIGlzIGludmFsaWQuIEl0IGNhbiBvbmx5IGJlIGxvY2FsLCBzZXNzaW9uIG9yIG5vbmUuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLXBob25lLW51bWJlclwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9QSE9ORV9OVU1CRVIgKi9dOiAnVGhlIGZvcm1hdCBvZiB0aGUgcGhvbmUgbnVtYmVyIHByb3ZpZGVkIGlzIGluY29ycmVjdC4gUGxlYXNlIGVudGVyIHRoZSAnICtcclxuICAgICAgICAgICAgJ3Bob25lIG51bWJlciBpbiBhIGZvcm1hdCB0aGF0IGNhbiBiZSBwYXJzZWQgaW50byBFLjE2NCBmb3JtYXQuIEUuMTY0ICcgK1xyXG4gICAgICAgICAgICAncGhvbmUgbnVtYmVycyBhcmUgd3JpdHRlbiBpbiB0aGUgZm9ybWF0IFsrXVtjb3VudHJ5IGNvZGVdW3N1YnNjcmliZXIgJyArXHJcbiAgICAgICAgICAgICdudW1iZXIgaW5jbHVkaW5nIGFyZWEgY29kZV0uJyxcclxuICAgICAgICBbXCJpbnZhbGlkLXByb3ZpZGVyLWlkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1BST1ZJREVSX0lEICovXTogJ1RoZSBzcGVjaWZpZWQgcHJvdmlkZXIgSUQgaXMgaW52YWxpZC4nLFxyXG4gICAgICAgIFtcImludmFsaWQtcmVjaXBpZW50LWVtYWlsXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFQ0lQSUVOVF9FTUFJTCAqL106ICdUaGUgZW1haWwgY29ycmVzcG9uZGluZyB0byB0aGlzIGFjdGlvbiBmYWlsZWQgdG8gc2VuZCBhcyB0aGUgcHJvdmlkZWQgJyArXHJcbiAgICAgICAgICAgICdyZWNpcGllbnQgZW1haWwgYWRkcmVzcyBpcyBpbnZhbGlkLicsXHJcbiAgICAgICAgW1wiaW52YWxpZC1zZW5kZXJcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfU0VOREVSICovXTogJ1RoZSBlbWFpbCB0ZW1wbGF0ZSBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYWN0aW9uIGNvbnRhaW5zIGFuIGludmFsaWQgc2VuZGVyIGVtYWlsIG9yIG5hbWUuICcgK1xyXG4gICAgICAgICAgICAnUGxlYXNlIGZpeCBieSBnb2luZyB0byB0aGUgQXV0aCBlbWFpbCB0ZW1wbGF0ZXMgc2VjdGlvbiBpbiB0aGUgRmlyZWJhc2UgQ29uc29sZS4nLFxyXG4gICAgICAgIFtcImludmFsaWQtdmVyaWZpY2F0aW9uLWlkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1NFU1NJT05fSU5GTyAqL106ICdUaGUgdmVyaWZpY2F0aW9uIElEIHVzZWQgdG8gY3JlYXRlIHRoZSBwaG9uZSBhdXRoIGNyZWRlbnRpYWwgaXMgaW52YWxpZC4nLFxyXG4gICAgICAgIFtcImludmFsaWQtdGVuYW50LWlkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1RFTkFOVF9JRCAqL106IFwiVGhlIEF1dGggaW5zdGFuY2UncyB0ZW5hbnQgSUQgaXMgaW52YWxpZC5cIixcclxuICAgICAgICBbXCJsb2dpbi1ibG9ja2VkXCIgLyogQXV0aEVycm9yQ29kZS5MT0dJTl9CTE9DS0VEICovXTogJ0xvZ2luIGJsb2NrZWQgYnkgdXNlci1wcm92aWRlZCBtZXRob2Q6IHskb3JpZ2luYWxNZXNzYWdlfScsXHJcbiAgICAgICAgW1wibWlzc2luZy1hbmRyb2lkLXBrZy1uYW1lXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0FORFJPSURfUEFDS0FHRV9OQU1FICovXTogJ0FuIEFuZHJvaWQgUGFja2FnZSBOYW1lIG11c3QgYmUgcHJvdmlkZWQgaWYgdGhlIEFuZHJvaWQgQXBwIGlzIHJlcXVpcmVkIHRvIGJlIGluc3RhbGxlZC4nLFxyXG4gICAgICAgIFtcImF1dGgtZG9tYWluLWNvbmZpZy1yZXF1aXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19BVVRIX0RPTUFJTiAqL106ICdCZSBzdXJlIHRvIGluY2x1ZGUgYXV0aERvbWFpbiB3aGVuIGNhbGxpbmcgZmlyZWJhc2UuaW5pdGlhbGl6ZUFwcCgpLCAnICtcclxuICAgICAgICAgICAgJ2J5IGZvbGxvd2luZyB0aGUgaW5zdHJ1Y3Rpb25zIGluIHRoZSBGaXJlYmFzZSBjb25zb2xlLicsXHJcbiAgICAgICAgW1wibWlzc2luZy1hcHAtY3JlZGVudGlhbFwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19BUFBfQ1JFREVOVElBTCAqL106ICdUaGUgcGhvbmUgdmVyaWZpY2F0aW9uIHJlcXVlc3QgaXMgbWlzc2luZyBhbiBhcHBsaWNhdGlvbiB2ZXJpZmllciAnICtcclxuICAgICAgICAgICAgJ2Fzc2VydGlvbi4gQSByZUNBUFRDSEEgcmVzcG9uc2UgdG9rZW4gbmVlZHMgdG8gYmUgcHJvdmlkZWQuJyxcclxuICAgICAgICBbXCJtaXNzaW5nLXZlcmlmaWNhdGlvbi1jb2RlXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0NPREUgKi9dOiAnVGhlIHBob25lIGF1dGggY3JlZGVudGlhbCB3YXMgY3JlYXRlZCB3aXRoIGFuIGVtcHR5IFNNUyB2ZXJpZmljYXRpb24gY29kZS4nLFxyXG4gICAgICAgIFtcIm1pc3NpbmctY29udGludWUtdXJpXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0NPTlRJTlVFX1VSSSAqL106ICdBIGNvbnRpbnVlIFVSTCBtdXN0IGJlIHByb3ZpZGVkIGluIHRoZSByZXF1ZXN0LicsXHJcbiAgICAgICAgW1wibWlzc2luZy1pZnJhbWUtc3RhcnRcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfSUZSQU1FX1NUQVJUICovXTogJ0FuIGludGVybmFsIEF1dGhFcnJvciBoYXMgb2NjdXJyZWQuJyxcclxuICAgICAgICBbXCJtaXNzaW5nLWlvcy1idW5kbGUtaWRcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfSU9TX0JVTkRMRV9JRCAqL106ICdBbiBpT1MgQnVuZGxlIElEIG11c3QgYmUgcHJvdmlkZWQgaWYgYW4gQXBwIFN0b3JlIElEIGlzIHByb3ZpZGVkLicsXHJcbiAgICAgICAgW1wibWlzc2luZy1vci1pbnZhbGlkLW5vbmNlXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX09SX0lOVkFMSURfTk9OQ0UgKi9dOiAnVGhlIHJlcXVlc3QgZG9lcyBub3QgY29udGFpbiBhIHZhbGlkIG5vbmNlLiBUaGlzIGNhbiBvY2N1ciBpZiB0aGUgJyArXHJcbiAgICAgICAgICAgICdTSEEtMjU2IGhhc2ggb2YgdGhlIHByb3ZpZGVkIHJhdyBub25jZSBkb2VzIG5vdCBtYXRjaCB0aGUgaGFzaGVkIG5vbmNlICcgK1xyXG4gICAgICAgICAgICAnaW4gdGhlIElEIHRva2VuIHBheWxvYWQuJyxcclxuICAgICAgICBbXCJtaXNzaW5nLXBhc3N3b3JkXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1BBU1NXT1JEICovXTogJ0Egbm9uLWVtcHR5IHBhc3N3b3JkIG11c3QgYmUgcHJvdmlkZWQnLFxyXG4gICAgICAgIFtcIm1pc3NpbmctbXVsdGktZmFjdG9yLWluZm9cIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfTUZBX0lORk8gKi9dOiAnTm8gc2Vjb25kIGZhY3RvciBpZGVudGlmaWVyIGlzIHByb3ZpZGVkLicsXHJcbiAgICAgICAgW1wibWlzc2luZy1tdWx0aS1mYWN0b3Itc2Vzc2lvblwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19NRkFfU0VTU0lPTiAqL106ICdUaGUgcmVxdWVzdCBpcyBtaXNzaW5nIHByb29mIG9mIGZpcnN0IGZhY3RvciBzdWNjZXNzZnVsIHNpZ24taW4uJyxcclxuICAgICAgICBbXCJtaXNzaW5nLXBob25lLW51bWJlclwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19QSE9ORV9OVU1CRVIgKi9dOiAnVG8gc2VuZCB2ZXJpZmljYXRpb24gY29kZXMsIHByb3ZpZGUgYSBwaG9uZSBudW1iZXIgZm9yIHRoZSByZWNpcGllbnQuJyxcclxuICAgICAgICBbXCJtaXNzaW5nLXZlcmlmaWNhdGlvbi1pZFwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19TRVNTSU9OX0lORk8gKi9dOiAnVGhlIHBob25lIGF1dGggY3JlZGVudGlhbCB3YXMgY3JlYXRlZCB3aXRoIGFuIGVtcHR5IHZlcmlmaWNhdGlvbiBJRC4nLFxyXG4gICAgICAgIFtcImFwcC1kZWxldGVkXCIgLyogQXV0aEVycm9yQ29kZS5NT0RVTEVfREVTVFJPWUVEICovXTogJ1RoaXMgaW5zdGFuY2Ugb2YgRmlyZWJhc2VBcHAgaGFzIGJlZW4gZGVsZXRlZC4nLFxyXG4gICAgICAgIFtcIm11bHRpLWZhY3Rvci1pbmZvLW5vdC1mb3VuZFwiIC8qIEF1dGhFcnJvckNvZGUuTUZBX0lORk9fTk9UX0ZPVU5EICovXTogJ1RoZSB1c2VyIGRvZXMgbm90IGhhdmUgYSBzZWNvbmQgZmFjdG9yIG1hdGNoaW5nIHRoZSBpZGVudGlmaWVyIHByb3ZpZGVkLicsXHJcbiAgICAgICAgW1wibXVsdGktZmFjdG9yLWF1dGgtcmVxdWlyZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk1GQV9SRVFVSVJFRCAqL106ICdQcm9vZiBvZiBvd25lcnNoaXAgb2YgYSBzZWNvbmQgZmFjdG9yIGlzIHJlcXVpcmVkIHRvIGNvbXBsZXRlIHNpZ24taW4uJyxcclxuICAgICAgICBbXCJhY2NvdW50LWV4aXN0cy13aXRoLWRpZmZlcmVudC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5ORUVEX0NPTkZJUk1BVElPTiAqL106ICdBbiBhY2NvdW50IGFscmVhZHkgZXhpc3RzIHdpdGggdGhlIHNhbWUgZW1haWwgYWRkcmVzcyBidXQgZGlmZmVyZW50ICcgK1xyXG4gICAgICAgICAgICAnc2lnbi1pbiBjcmVkZW50aWFscy4gU2lnbiBpbiB1c2luZyBhIHByb3ZpZGVyIGFzc29jaWF0ZWQgd2l0aCB0aGlzICcgK1xyXG4gICAgICAgICAgICAnZW1haWwgYWRkcmVzcy4nLFxyXG4gICAgICAgIFtcIm5ldHdvcmstcmVxdWVzdC1mYWlsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk5FVFdPUktfUkVRVUVTVF9GQUlMRUQgKi9dOiAnQSBuZXR3b3JrIEF1dGhFcnJvciAoc3VjaCBhcyB0aW1lb3V0LCBpbnRlcnJ1cHRlZCBjb25uZWN0aW9uIG9yIHVucmVhY2hhYmxlIGhvc3QpIGhhcyBvY2N1cnJlZC4nLFxyXG4gICAgICAgIFtcIm5vLWF1dGgtZXZlbnRcIiAvKiBBdXRoRXJyb3JDb2RlLk5PX0FVVEhfRVZFTlQgKi9dOiAnQW4gaW50ZXJuYWwgQXV0aEVycm9yIGhhcyBvY2N1cnJlZC4nLFxyXG4gICAgICAgIFtcIm5vLXN1Y2gtcHJvdmlkZXJcIiAvKiBBdXRoRXJyb3JDb2RlLk5PX1NVQ0hfUFJPVklERVIgKi9dOiAnVXNlciB3YXMgbm90IGxpbmtlZCB0byBhbiBhY2NvdW50IHdpdGggdGhlIGdpdmVuIHByb3ZpZGVyLicsXHJcbiAgICAgICAgW1wibnVsbC11c2VyXCIgLyogQXV0aEVycm9yQ29kZS5OVUxMX1VTRVIgKi9dOiAnQSBudWxsIHVzZXIgb2JqZWN0IHdhcyBwcm92aWRlZCBhcyB0aGUgYXJndW1lbnQgZm9yIGFuIG9wZXJhdGlvbiB3aGljaCAnICtcclxuICAgICAgICAgICAgJ3JlcXVpcmVzIGEgbm9uLW51bGwgdXNlciBvYmplY3QuJyxcclxuICAgICAgICBbXCJvcGVyYXRpb24tbm90LWFsbG93ZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk9QRVJBVElPTl9OT1RfQUxMT1dFRCAqL106ICdUaGUgZ2l2ZW4gc2lnbi1pbiBwcm92aWRlciBpcyBkaXNhYmxlZCBmb3IgdGhpcyBGaXJlYmFzZSBwcm9qZWN0LiAnICtcclxuICAgICAgICAgICAgJ0VuYWJsZSBpdCBpbiB0aGUgRmlyZWJhc2UgY29uc29sZSwgdW5kZXIgdGhlIHNpZ24taW4gbWV0aG9kIHRhYiBvZiB0aGUgJyArXHJcbiAgICAgICAgICAgICdBdXRoIHNlY3Rpb24uJyxcclxuICAgICAgICBbXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIgLyogQXV0aEVycm9yQ29kZS5PUEVSQVRJT05fTk9UX1NVUFBPUlRFRCAqL106ICdUaGlzIG9wZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBlbnZpcm9ubWVudCB0aGlzIGFwcGxpY2F0aW9uIGlzICcgK1xyXG4gICAgICAgICAgICAncnVubmluZyBvbi4gXCJsb2NhdGlvbi5wcm90b2NvbFwiIG11c3QgYmUgaHR0cCwgaHR0cHMgb3IgY2hyb21lLWV4dGVuc2lvbicgK1xyXG4gICAgICAgICAgICAnIGFuZCB3ZWIgc3RvcmFnZSBtdXN0IGJlIGVuYWJsZWQuJyxcclxuICAgICAgICBbXCJwb3B1cC1ibG9ja2VkXCIgLyogQXV0aEVycm9yQ29kZS5QT1BVUF9CTE9DS0VEICovXTogJ1VuYWJsZSB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uIHdpdGggdGhlIHBvcHVwLiBJdCBtYXkgaGF2ZSBiZWVuIGJsb2NrZWQgYnkgdGhlIGJyb3dzZXIuJyxcclxuICAgICAgICBbXCJwb3B1cC1jbG9zZWQtYnktdXNlclwiIC8qIEF1dGhFcnJvckNvZGUuUE9QVVBfQ0xPU0VEX0JZX1VTRVIgKi9dOiAnVGhlIHBvcHVwIGhhcyBiZWVuIGNsb3NlZCBieSB0aGUgdXNlciBiZWZvcmUgZmluYWxpemluZyB0aGUgb3BlcmF0aW9uLicsXHJcbiAgICAgICAgW1wicHJvdmlkZXItYWxyZWFkeS1saW5rZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlBST1ZJREVSX0FMUkVBRFlfTElOS0VEICovXTogJ1VzZXIgY2FuIG9ubHkgYmUgbGlua2VkIHRvIG9uZSBpZGVudGl0eSBmb3IgdGhlIGdpdmVuIHByb3ZpZGVyLicsXHJcbiAgICAgICAgW1wicXVvdGEtZXhjZWVkZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlFVT1RBX0VYQ0VFREVEICovXTogXCJUaGUgcHJvamVjdCdzIHF1b3RhIGZvciB0aGlzIG9wZXJhdGlvbiBoYXMgYmVlbiBleGNlZWRlZC5cIixcclxuICAgICAgICBbXCJyZWRpcmVjdC1jYW5jZWxsZWQtYnktdXNlclwiIC8qIEF1dGhFcnJvckNvZGUuUkVESVJFQ1RfQ0FOQ0VMTEVEX0JZX1VTRVIgKi9dOiAnVGhlIHJlZGlyZWN0IG9wZXJhdGlvbiBoYXMgYmVlbiBjYW5jZWxsZWQgYnkgdGhlIHVzZXIgYmVmb3JlIGZpbmFsaXppbmcuJyxcclxuICAgICAgICBbXCJyZWRpcmVjdC1vcGVyYXRpb24tcGVuZGluZ1wiIC8qIEF1dGhFcnJvckNvZGUuUkVESVJFQ1RfT1BFUkFUSU9OX1BFTkRJTkcgKi9dOiAnQSByZWRpcmVjdCBzaWduLWluIG9wZXJhdGlvbiBpcyBhbHJlYWR5IHBlbmRpbmcuJyxcclxuICAgICAgICBbXCJyZWplY3RlZC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5SRUpFQ1RFRF9DUkVERU5USUFMICovXTogJ1RoZSByZXF1ZXN0IGNvbnRhaW5zIG1hbGZvcm1lZCBvciBtaXNtYXRjaGluZyBjcmVkZW50aWFscy4nLFxyXG4gICAgICAgIFtcInNlY29uZC1mYWN0b3ItYWxyZWFkeS1pbi11c2VcIiAvKiBBdXRoRXJyb3JDb2RlLlNFQ09ORF9GQUNUT1JfQUxSRUFEWV9FTlJPTExFRCAqL106ICdUaGUgc2Vjb25kIGZhY3RvciBpcyBhbHJlYWR5IGVucm9sbGVkIG9uIHRoaXMgYWNjb3VudC4nLFxyXG4gICAgICAgIFtcIm1heGltdW0tc2Vjb25kLWZhY3Rvci1jb3VudC1leGNlZWRlZFwiIC8qIEF1dGhFcnJvckNvZGUuU0VDT05EX0ZBQ1RPUl9MSU1JVF9FWENFRURFRCAqL106ICdUaGUgbWF4aW11bSBhbGxvd2VkIG51bWJlciBvZiBzZWNvbmQgZmFjdG9ycyBvbiBhIHVzZXIgaGFzIGJlZW4gZXhjZWVkZWQuJyxcclxuICAgICAgICBbXCJ0ZW5hbnQtaWQtbWlzbWF0Y2hcIiAvKiBBdXRoRXJyb3JDb2RlLlRFTkFOVF9JRF9NSVNNQVRDSCAqL106IFwiVGhlIHByb3ZpZGVkIHRlbmFudCBJRCBkb2VzIG5vdCBtYXRjaCB0aGUgQXV0aCBpbnN0YW5jZSdzIHRlbmFudCBJRFwiLFxyXG4gICAgICAgIFtcInRpbWVvdXRcIiAvKiBBdXRoRXJyb3JDb2RlLlRJTUVPVVQgKi9dOiAnVGhlIG9wZXJhdGlvbiBoYXMgdGltZWQgb3V0LicsXHJcbiAgICAgICAgW1widXNlci10b2tlbi1leHBpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5UT0tFTl9FWFBJUkVEICovXTogXCJUaGUgdXNlcidzIGNyZWRlbnRpYWwgaXMgbm8gbG9uZ2VyIHZhbGlkLiBUaGUgdXNlciBtdXN0IHNpZ24gaW4gYWdhaW4uXCIsXHJcbiAgICAgICAgW1widG9vLW1hbnktcmVxdWVzdHNcIiAvKiBBdXRoRXJyb3JDb2RlLlRPT19NQU5ZX0FUVEVNUFRTX1RSWV9MQVRFUiAqL106ICdXZSBoYXZlIGJsb2NrZWQgYWxsIHJlcXVlc3RzIGZyb20gdGhpcyBkZXZpY2UgZHVlIHRvIHVudXN1YWwgYWN0aXZpdHkuICcgK1xyXG4gICAgICAgICAgICAnVHJ5IGFnYWluIGxhdGVyLicsXHJcbiAgICAgICAgW1widW5hdXRob3JpemVkLWNvbnRpbnVlLXVyaVwiIC8qIEF1dGhFcnJvckNvZGUuVU5BVVRIT1JJWkVEX0RPTUFJTiAqL106ICdUaGUgZG9tYWluIG9mIHRoZSBjb250aW51ZSBVUkwgaXMgbm90IHdoaXRlbGlzdGVkLiAgUGxlYXNlIHdoaXRlbGlzdCAnICtcclxuICAgICAgICAgICAgJ3RoZSBkb21haW4gaW4gdGhlIEZpcmViYXNlIGNvbnNvbGUuJyxcclxuICAgICAgICBbXCJ1bnN1cHBvcnRlZC1maXJzdC1mYWN0b3JcIiAvKiBBdXRoRXJyb3JDb2RlLlVOU1VQUE9SVEVEX0ZJUlNUX0ZBQ1RPUiAqL106ICdFbnJvbGxpbmcgYSBzZWNvbmQgZmFjdG9yIG9yIHNpZ25pbmcgaW4gd2l0aCBhIG11bHRpLWZhY3RvciBhY2NvdW50IHJlcXVpcmVzIHNpZ24taW4gd2l0aCBhIHN1cHBvcnRlZCBmaXJzdCBmYWN0b3IuJyxcclxuICAgICAgICBbXCJ1bnN1cHBvcnRlZC1wZXJzaXN0ZW5jZS10eXBlXCIgLyogQXV0aEVycm9yQ29kZS5VTlNVUFBPUlRFRF9QRVJTSVNURU5DRSAqL106ICdUaGUgY3VycmVudCBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBzcGVjaWZpZWQgcGVyc2lzdGVuY2UgdHlwZS4nLFxyXG4gICAgICAgIFtcInVuc3VwcG9ydGVkLXRlbmFudC1vcGVyYXRpb25cIiAvKiBBdXRoRXJyb3JDb2RlLlVOU1VQUE9SVEVEX1RFTkFOVF9PUEVSQVRJT04gKi9dOiAnVGhpcyBvcGVyYXRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiBhIG11bHRpLXRlbmFudCBjb250ZXh0LicsXHJcbiAgICAgICAgW1widW52ZXJpZmllZC1lbWFpbFwiIC8qIEF1dGhFcnJvckNvZGUuVU5WRVJJRklFRF9FTUFJTCAqL106ICdUaGUgb3BlcmF0aW9uIHJlcXVpcmVzIGEgdmVyaWZpZWQgZW1haWwuJyxcclxuICAgICAgICBbXCJ1c2VyLWNhbmNlbGxlZFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9DQU5DRUxMRUQgKi9dOiAnVGhlIHVzZXIgZGlkIG5vdCBncmFudCB5b3VyIGFwcGxpY2F0aW9uIHRoZSBwZXJtaXNzaW9ucyBpdCByZXF1ZXN0ZWQuJyxcclxuICAgICAgICBbXCJ1c2VyLW5vdC1mb3VuZFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9ERUxFVEVEICovXTogJ1RoZXJlIGlzIG5vIHVzZXIgcmVjb3JkIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBpZGVudGlmaWVyLiBUaGUgdXNlciBtYXkgJyArXHJcbiAgICAgICAgICAgICdoYXZlIGJlZW4gZGVsZXRlZC4nLFxyXG4gICAgICAgIFtcInVzZXItZGlzYWJsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlVTRVJfRElTQUJMRUQgKi9dOiAnVGhlIHVzZXIgYWNjb3VudCBoYXMgYmVlbiBkaXNhYmxlZCBieSBhbiBhZG1pbmlzdHJhdG9yLicsXHJcbiAgICAgICAgW1widXNlci1taXNtYXRjaFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9NSVNNQVRDSCAqL106ICdUaGUgc3VwcGxpZWQgY3JlZGVudGlhbHMgZG8gbm90IGNvcnJlc3BvbmQgdG8gdGhlIHByZXZpb3VzbHkgc2lnbmVkIGluIHVzZXIuJyxcclxuICAgICAgICBbXCJ1c2VyLXNpZ25lZC1vdXRcIiAvKiBBdXRoRXJyb3JDb2RlLlVTRVJfU0lHTkVEX09VVCAqL106ICcnLFxyXG4gICAgICAgIFtcIndlYWstcGFzc3dvcmRcIiAvKiBBdXRoRXJyb3JDb2RlLldFQUtfUEFTU1dPUkQgKi9dOiAnVGhlIHBhc3N3b3JkIG11c3QgYmUgNiBjaGFyYWN0ZXJzIGxvbmcgb3IgbW9yZS4nLFxyXG4gICAgICAgIFtcIndlYi1zdG9yYWdlLXVuc3VwcG9ydGVkXCIgLyogQXV0aEVycm9yQ29kZS5XRUJfU1RPUkFHRV9VTlNVUFBPUlRFRCAqL106ICdUaGlzIGJyb3dzZXIgaXMgbm90IHN1cHBvcnRlZCBvciAzcmQgcGFydHkgY29va2llcyBhbmQgZGF0YSBtYXkgYmUgZGlzYWJsZWQuJyxcclxuICAgICAgICBbXCJhbHJlYWR5LWluaXRpYWxpemVkXCIgLyogQXV0aEVycm9yQ29kZS5BTFJFQURZX0lOSVRJQUxJWkVEICovXTogJ2luaXRpYWxpemVBdXRoKCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQgd2l0aCAnICtcclxuICAgICAgICAgICAgJ2RpZmZlcmVudCBvcHRpb25zLiBUbyBhdm9pZCB0aGlzIGVycm9yLCBjYWxsIGluaXRpYWxpemVBdXRoKCkgd2l0aCB0aGUgJyArXHJcbiAgICAgICAgICAgICdzYW1lIG9wdGlvbnMgYXMgd2hlbiBpdCB3YXMgb3JpZ2luYWxseSBjYWxsZWQsIG9yIGNhbGwgZ2V0QXV0aCgpIHRvIHJldHVybiB0aGUnICtcclxuICAgICAgICAgICAgJyBhbHJlYWR5IGluaXRpYWxpemVkIGluc3RhbmNlLicsXHJcbiAgICAgICAgW1wibWlzc2luZy1yZWNhcHRjaGEtdG9rZW5cIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOICovXTogJ1RoZSByZUNBUFRDSEEgdG9rZW4gaXMgbWlzc2luZyB3aGVuIHNlbmRpbmcgcmVxdWVzdCB0byB0aGUgYmFja2VuZC4nLFxyXG4gICAgICAgIFtcImludmFsaWQtcmVjYXB0Y2hhLXRva2VuXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFQ0FQVENIQV9UT0tFTiAqL106ICdUaGUgcmVDQVBUQ0hBIHRva2VuIGlzIGludmFsaWQgd2hlbiBzZW5kaW5nIHJlcXVlc3QgdG8gdGhlIGJhY2tlbmQuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLXJlY2FwdGNoYS1hY3Rpb25cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDQVBUQ0hBX0FDVElPTiAqL106ICdUaGUgcmVDQVBUQ0hBIGFjdGlvbiBpcyBpbnZhbGlkIHdoZW4gc2VuZGluZyByZXF1ZXN0IHRvIHRoZSBiYWNrZW5kLicsXHJcbiAgICAgICAgW1wicmVjYXB0Y2hhLW5vdC1lbmFibGVkXCIgLyogQXV0aEVycm9yQ29kZS5SRUNBUFRDSEFfTk9UX0VOQUJMRUQgKi9dOiAncmVDQVBUQ0hBIEVudGVycHJpc2UgaW50ZWdyYXRpb24gaXMgbm90IGVuYWJsZWQgZm9yIHRoaXMgcHJvamVjdC4nLFxyXG4gICAgICAgIFtcIm1pc3NpbmctY2xpZW50LXR5cGVcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQ0xJRU5UX1RZUEUgKi9dOiAnVGhlIHJlQ0FQVENIQSBjbGllbnQgdHlwZSBpcyBtaXNzaW5nIHdoZW4gc2VuZGluZyByZXF1ZXN0IHRvIHRoZSBiYWNrZW5kLicsXHJcbiAgICAgICAgW1wibWlzc2luZy1yZWNhcHRjaGEtdmVyc2lvblwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19SRUNBUFRDSEFfVkVSU0lPTiAqL106ICdUaGUgcmVDQVBUQ0hBIHZlcnNpb24gaXMgbWlzc2luZyB3aGVuIHNlbmRpbmcgcmVxdWVzdCB0byB0aGUgYmFja2VuZC4nLFxyXG4gICAgICAgIFtcImludmFsaWQtcmVxLXR5cGVcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVRX1RZUEUgKi9dOiAnSW52YWxpZCByZXF1ZXN0IHBhcmFtZXRlcnMuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLXJlY2FwdGNoYS12ZXJzaW9uXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFQ0FQVENIQV9WRVJTSU9OICovXTogJ1RoZSByZUNBUFRDSEEgdmVyc2lvbiBpcyBpbnZhbGlkIHdoZW4gc2VuZGluZyByZXF1ZXN0IHRvIHRoZSBiYWNrZW5kLicsXHJcbiAgICAgICAgW1widW5zdXBwb3J0ZWQtcGFzc3dvcmQtcG9saWN5LXNjaGVtYS12ZXJzaW9uXCIgLyogQXV0aEVycm9yQ29kZS5VTlNVUFBPUlRFRF9QQVNTV09SRF9QT0xJQ1lfU0NIRU1BX1ZFUlNJT04gKi9dOiAnVGhlIHBhc3N3b3JkIHBvbGljeSByZWNlaXZlZCBmcm9tIHRoZSBiYWNrZW5kIHVzZXMgYSBzY2hlbWEgdmVyc2lvbiB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyB2ZXJzaW9uIG9mIHRoZSBGaXJlYmFzZSBTREsuJyxcclxuICAgICAgICBbXCJwYXNzd29yZC1kb2VzLW5vdC1tZWV0LXJlcXVpcmVtZW50c1wiIC8qIEF1dGhFcnJvckNvZGUuUEFTU1dPUkRfRE9FU19OT1RfTUVFVF9SRVFVSVJFTUVOVFMgKi9dOiAnVGhlIHBhc3N3b3JkIGRvZXMgbm90IG1lZXQgdGhlIHJlcXVpcmVtZW50cy4nXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIF9wcm9kRXJyb3JNYXAoKSB7XHJcbiAgICAvLyBXZSB3aWxsIGluY2x1ZGUgdGhpcyBvbmUgbWVzc2FnZSBpbiB0aGUgcHJvZCBlcnJvciBtYXAgc2luY2UgYnkgdGhlIHZlcnlcclxuICAgIC8vIG5hdHVyZSBvZiB0aGlzIGVycm9yLCBkZXZlbG9wZXJzIHdpbGwgbmV2ZXIgYmUgYWJsZSB0byBzZWUgdGhlIG1lc3NhZ2VcclxuICAgIC8vIHVzaW5nIHRoZSBkZWJ1Z0Vycm9yTWFwICh3aGljaCBpcyBpbnN0YWxsZWQgZHVyaW5nIGF1dGggaW5pdGlhbGl6YXRpb24pLlxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBbXCJkZXBlbmRlbnQtc2RrLWluaXRpYWxpemVkLWJlZm9yZS1hdXRoXCIgLyogQXV0aEVycm9yQ29kZS5ERVBFTkRFTlRfU0RLX0lOSVRfQkVGT1JFX0FVVEggKi9dOiAnQW5vdGhlciBGaXJlYmFzZSBTREsgd2FzIGluaXRpYWxpemVkIGFuZCBpcyB0cnlpbmcgdG8gdXNlIEF1dGggYmVmb3JlIEF1dGggaXMgJyArXHJcbiAgICAgICAgICAgICdpbml0aWFsaXplZC4gUGxlYXNlIGJlIHN1cmUgdG8gY2FsbCBgaW5pdGlhbGl6ZUF1dGhgIG9yIGBnZXRBdXRoYCBiZWZvcmUgJyArXHJcbiAgICAgICAgICAgICdzdGFydGluZyBhbnkgb3RoZXIgRmlyZWJhc2UgU0RLLidcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIEEgdmVyYm9zZSBlcnJvciBtYXAgd2l0aCBkZXRhaWxlZCBkZXNjcmlwdGlvbnMgZm9yIG1vc3QgZXJyb3IgY29kZXMuXHJcbiAqXHJcbiAqIFNlZSBkaXNjdXNzaW9uIGF0IHtAbGluayBBdXRoRXJyb3JNYXB9XHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IGRlYnVnRXJyb3JNYXAgPSBfZGVidWdFcnJvck1hcDtcclxuLyoqXHJcbiAqIEEgbWluaW1hbCBlcnJvciBtYXAgd2l0aCBhbGwgdmVyYm9zZSBlcnJvciBtZXNzYWdlcyBzdHJpcHBlZC5cclxuICpcclxuICogU2VlIGRpc2N1c3Npb24gYXQge0BsaW5rIEF1dGhFcnJvck1hcH1cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgcHJvZEVycm9yTWFwID0gX3Byb2RFcnJvck1hcDtcclxuY29uc3QgX0RFRkFVTFRfQVVUSF9FUlJPUl9GQUNUT1JZID0gbmV3IEVycm9yRmFjdG9yeSgnYXV0aCcsICdGaXJlYmFzZScsIF9wcm9kRXJyb3JNYXAoKSk7XHJcbi8qKlxyXG4gKiBBIG1hcCBvZiBwb3RlbnRpYWwgYEF1dGhgIGVycm9yIGNvZGVzLCBmb3IgZWFzaWVyIGNvbXBhcmlzb24gd2l0aCBlcnJvcnNcclxuICogdGhyb3duIGJ5IHRoZSBTREsuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIE5vdGUgdGhhdCB5b3UgY2FuJ3QgdHJlZS1zaGFrZSBpbmRpdmlkdWFsIGtleXNcclxuICogaW4gdGhlIG1hcCwgc28gYnkgdXNpbmcgdGhlIG1hcCB5b3UgbWlnaHQgc3Vic3RhbnRpYWxseSBpbmNyZWFzZSB5b3VyXHJcbiAqIGJ1bmRsZSBzaXplLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBBVVRIX0VSUk9SX0NPREVTX01BUF9ET19OT1RfVVNFX0lOVEVSTkFMTFkgPSB7XHJcbiAgICBBRE1JTl9PTkxZX09QRVJBVElPTjogJ2F1dGgvYWRtaW4tcmVzdHJpY3RlZC1vcGVyYXRpb24nLFxyXG4gICAgQVJHVU1FTlRfRVJST1I6ICdhdXRoL2FyZ3VtZW50LWVycm9yJyxcclxuICAgIEFQUF9OT1RfQVVUSE9SSVpFRDogJ2F1dGgvYXBwLW5vdC1hdXRob3JpemVkJyxcclxuICAgIEFQUF9OT1RfSU5TVEFMTEVEOiAnYXV0aC9hcHAtbm90LWluc3RhbGxlZCcsXHJcbiAgICBDQVBUQ0hBX0NIRUNLX0ZBSUxFRDogJ2F1dGgvY2FwdGNoYS1jaGVjay1mYWlsZWQnLFxyXG4gICAgQ09ERV9FWFBJUkVEOiAnYXV0aC9jb2RlLWV4cGlyZWQnLFxyXG4gICAgQ09SRE9WQV9OT1RfUkVBRFk6ICdhdXRoL2NvcmRvdmEtbm90LXJlYWR5JyxcclxuICAgIENPUlNfVU5TVVBQT1JURUQ6ICdhdXRoL2NvcnMtdW5zdXBwb3J0ZWQnLFxyXG4gICAgQ1JFREVOVElBTF9BTFJFQURZX0lOX1VTRTogJ2F1dGgvY3JlZGVudGlhbC1hbHJlYWR5LWluLXVzZScsXHJcbiAgICBDUkVERU5USUFMX01JU01BVENIOiAnYXV0aC9jdXN0b20tdG9rZW4tbWlzbWF0Y2gnLFxyXG4gICAgQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOOiAnYXV0aC9yZXF1aXJlcy1yZWNlbnQtbG9naW4nLFxyXG4gICAgREVQRU5ERU5UX1NES19JTklUX0JFRk9SRV9BVVRIOiAnYXV0aC9kZXBlbmRlbnQtc2RrLWluaXRpYWxpemVkLWJlZm9yZS1hdXRoJyxcclxuICAgIERZTkFNSUNfTElOS19OT1RfQUNUSVZBVEVEOiAnYXV0aC9keW5hbWljLWxpbmstbm90LWFjdGl2YXRlZCcsXHJcbiAgICBFTUFJTF9DSEFOR0VfTkVFRFNfVkVSSUZJQ0FUSU9OOiAnYXV0aC9lbWFpbC1jaGFuZ2UtbmVlZHMtdmVyaWZpY2F0aW9uJyxcclxuICAgIEVNQUlMX0VYSVNUUzogJ2F1dGgvZW1haWwtYWxyZWFkeS1pbi11c2UnLFxyXG4gICAgRU1VTEFUT1JfQ09ORklHX0ZBSUxFRDogJ2F1dGgvZW11bGF0b3ItY29uZmlnLWZhaWxlZCcsXHJcbiAgICBFWFBJUkVEX09PQl9DT0RFOiAnYXV0aC9leHBpcmVkLWFjdGlvbi1jb2RlJyxcclxuICAgIEVYUElSRURfUE9QVVBfUkVRVUVTVDogJ2F1dGgvY2FuY2VsbGVkLXBvcHVwLXJlcXVlc3QnLFxyXG4gICAgSU5URVJOQUxfRVJST1I6ICdhdXRoL2ludGVybmFsLWVycm9yJyxcclxuICAgIElOVkFMSURfQVBJX0tFWTogJ2F1dGgvaW52YWxpZC1hcGkta2V5JyxcclxuICAgIElOVkFMSURfQVBQX0NSRURFTlRJQUw6ICdhdXRoL2ludmFsaWQtYXBwLWNyZWRlbnRpYWwnLFxyXG4gICAgSU5WQUxJRF9BUFBfSUQ6ICdhdXRoL2ludmFsaWQtYXBwLWlkJyxcclxuICAgIElOVkFMSURfQVVUSDogJ2F1dGgvaW52YWxpZC11c2VyLXRva2VuJyxcclxuICAgIElOVkFMSURfQVVUSF9FVkVOVDogJ2F1dGgvaW52YWxpZC1hdXRoLWV2ZW50JyxcclxuICAgIElOVkFMSURfQ0VSVF9IQVNIOiAnYXV0aC9pbnZhbGlkLWNlcnQtaGFzaCcsXHJcbiAgICBJTlZBTElEX0NPREU6ICdhdXRoL2ludmFsaWQtdmVyaWZpY2F0aW9uLWNvZGUnLFxyXG4gICAgSU5WQUxJRF9DT05USU5VRV9VUkk6ICdhdXRoL2ludmFsaWQtY29udGludWUtdXJpJyxcclxuICAgIElOVkFMSURfQ09SRE9WQV9DT05GSUdVUkFUSU9OOiAnYXV0aC9pbnZhbGlkLWNvcmRvdmEtY29uZmlndXJhdGlvbicsXHJcbiAgICBJTlZBTElEX0NVU1RPTV9UT0tFTjogJ2F1dGgvaW52YWxpZC1jdXN0b20tdG9rZW4nLFxyXG4gICAgSU5WQUxJRF9EWU5BTUlDX0xJTktfRE9NQUlOOiAnYXV0aC9pbnZhbGlkLWR5bmFtaWMtbGluay1kb21haW4nLFxyXG4gICAgSU5WQUxJRF9FTUFJTDogJ2F1dGgvaW52YWxpZC1lbWFpbCcsXHJcbiAgICBJTlZBTElEX0VNVUxBVE9SX1NDSEVNRTogJ2F1dGgvaW52YWxpZC1lbXVsYXRvci1zY2hlbWUnLFxyXG4gICAgSU5WQUxJRF9JRFBfUkVTUE9OU0U6ICdhdXRoL2ludmFsaWQtY3JlZGVudGlhbCcsXHJcbiAgICBJTlZBTElEX0xPR0lOX0NSRURFTlRJQUxTOiAnYXV0aC9pbnZhbGlkLWNyZWRlbnRpYWwnLFxyXG4gICAgSU5WQUxJRF9NRVNTQUdFX1BBWUxPQUQ6ICdhdXRoL2ludmFsaWQtbWVzc2FnZS1wYXlsb2FkJyxcclxuICAgIElOVkFMSURfTUZBX1NFU1NJT046ICdhdXRoL2ludmFsaWQtbXVsdGktZmFjdG9yLXNlc3Npb24nLFxyXG4gICAgSU5WQUxJRF9PQVVUSF9DTElFTlRfSUQ6ICdhdXRoL2ludmFsaWQtb2F1dGgtY2xpZW50LWlkJyxcclxuICAgIElOVkFMSURfT0FVVEhfUFJPVklERVI6ICdhdXRoL2ludmFsaWQtb2F1dGgtcHJvdmlkZXInLFxyXG4gICAgSU5WQUxJRF9PT0JfQ09ERTogJ2F1dGgvaW52YWxpZC1hY3Rpb24tY29kZScsXHJcbiAgICBJTlZBTElEX09SSUdJTjogJ2F1dGgvdW5hdXRob3JpemVkLWRvbWFpbicsXHJcbiAgICBJTlZBTElEX1BBU1NXT1JEOiAnYXV0aC93cm9uZy1wYXNzd29yZCcsXHJcbiAgICBJTlZBTElEX1BFUlNJU1RFTkNFOiAnYXV0aC9pbnZhbGlkLXBlcnNpc3RlbmNlLXR5cGUnLFxyXG4gICAgSU5WQUxJRF9QSE9ORV9OVU1CRVI6ICdhdXRoL2ludmFsaWQtcGhvbmUtbnVtYmVyJyxcclxuICAgIElOVkFMSURfUFJPVklERVJfSUQ6ICdhdXRoL2ludmFsaWQtcHJvdmlkZXItaWQnLFxyXG4gICAgSU5WQUxJRF9SRUNJUElFTlRfRU1BSUw6ICdhdXRoL2ludmFsaWQtcmVjaXBpZW50LWVtYWlsJyxcclxuICAgIElOVkFMSURfU0VOREVSOiAnYXV0aC9pbnZhbGlkLXNlbmRlcicsXHJcbiAgICBJTlZBTElEX1NFU1NJT05fSU5GTzogJ2F1dGgvaW52YWxpZC12ZXJpZmljYXRpb24taWQnLFxyXG4gICAgSU5WQUxJRF9URU5BTlRfSUQ6ICdhdXRoL2ludmFsaWQtdGVuYW50LWlkJyxcclxuICAgIE1GQV9JTkZPX05PVF9GT1VORDogJ2F1dGgvbXVsdGktZmFjdG9yLWluZm8tbm90LWZvdW5kJyxcclxuICAgIE1GQV9SRVFVSVJFRDogJ2F1dGgvbXVsdGktZmFjdG9yLWF1dGgtcmVxdWlyZWQnLFxyXG4gICAgTUlTU0lOR19BTkRST0lEX1BBQ0tBR0VfTkFNRTogJ2F1dGgvbWlzc2luZy1hbmRyb2lkLXBrZy1uYW1lJyxcclxuICAgIE1JU1NJTkdfQVBQX0NSRURFTlRJQUw6ICdhdXRoL21pc3NpbmctYXBwLWNyZWRlbnRpYWwnLFxyXG4gICAgTUlTU0lOR19BVVRIX0RPTUFJTjogJ2F1dGgvYXV0aC1kb21haW4tY29uZmlnLXJlcXVpcmVkJyxcclxuICAgIE1JU1NJTkdfQ09ERTogJ2F1dGgvbWlzc2luZy12ZXJpZmljYXRpb24tY29kZScsXHJcbiAgICBNSVNTSU5HX0NPTlRJTlVFX1VSSTogJ2F1dGgvbWlzc2luZy1jb250aW51ZS11cmknLFxyXG4gICAgTUlTU0lOR19JRlJBTUVfU1RBUlQ6ICdhdXRoL21pc3NpbmctaWZyYW1lLXN0YXJ0JyxcclxuICAgIE1JU1NJTkdfSU9TX0JVTkRMRV9JRDogJ2F1dGgvbWlzc2luZy1pb3MtYnVuZGxlLWlkJyxcclxuICAgIE1JU1NJTkdfT1JfSU5WQUxJRF9OT05DRTogJ2F1dGgvbWlzc2luZy1vci1pbnZhbGlkLW5vbmNlJyxcclxuICAgIE1JU1NJTkdfTUZBX0lORk86ICdhdXRoL21pc3NpbmctbXVsdGktZmFjdG9yLWluZm8nLFxyXG4gICAgTUlTU0lOR19NRkFfU0VTU0lPTjogJ2F1dGgvbWlzc2luZy1tdWx0aS1mYWN0b3Itc2Vzc2lvbicsXHJcbiAgICBNSVNTSU5HX1BIT05FX05VTUJFUjogJ2F1dGgvbWlzc2luZy1waG9uZS1udW1iZXInLFxyXG4gICAgTUlTU0lOR19TRVNTSU9OX0lORk86ICdhdXRoL21pc3NpbmctdmVyaWZpY2F0aW9uLWlkJyxcclxuICAgIE1PRFVMRV9ERVNUUk9ZRUQ6ICdhdXRoL2FwcC1kZWxldGVkJyxcclxuICAgIE5FRURfQ09ORklSTUFUSU9OOiAnYXV0aC9hY2NvdW50LWV4aXN0cy13aXRoLWRpZmZlcmVudC1jcmVkZW50aWFsJyxcclxuICAgIE5FVFdPUktfUkVRVUVTVF9GQUlMRUQ6ICdhdXRoL25ldHdvcmstcmVxdWVzdC1mYWlsZWQnLFxyXG4gICAgTlVMTF9VU0VSOiAnYXV0aC9udWxsLXVzZXInLFxyXG4gICAgTk9fQVVUSF9FVkVOVDogJ2F1dGgvbm8tYXV0aC1ldmVudCcsXHJcbiAgICBOT19TVUNIX1BST1ZJREVSOiAnYXV0aC9uby1zdWNoLXByb3ZpZGVyJyxcclxuICAgIE9QRVJBVElPTl9OT1RfQUxMT1dFRDogJ2F1dGgvb3BlcmF0aW9uLW5vdC1hbGxvd2VkJyxcclxuICAgIE9QRVJBVElPTl9OT1RfU1VQUE9SVEVEOiAnYXV0aC9vcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50JyxcclxuICAgIFBPUFVQX0JMT0NLRUQ6ICdhdXRoL3BvcHVwLWJsb2NrZWQnLFxyXG4gICAgUE9QVVBfQ0xPU0VEX0JZX1VTRVI6ICdhdXRoL3BvcHVwLWNsb3NlZC1ieS11c2VyJyxcclxuICAgIFBST1ZJREVSX0FMUkVBRFlfTElOS0VEOiAnYXV0aC9wcm92aWRlci1hbHJlYWR5LWxpbmtlZCcsXHJcbiAgICBRVU9UQV9FWENFRURFRDogJ2F1dGgvcXVvdGEtZXhjZWVkZWQnLFxyXG4gICAgUkVESVJFQ1RfQ0FOQ0VMTEVEX0JZX1VTRVI6ICdhdXRoL3JlZGlyZWN0LWNhbmNlbGxlZC1ieS11c2VyJyxcclxuICAgIFJFRElSRUNUX09QRVJBVElPTl9QRU5ESU5HOiAnYXV0aC9yZWRpcmVjdC1vcGVyYXRpb24tcGVuZGluZycsXHJcbiAgICBSRUpFQ1RFRF9DUkVERU5USUFMOiAnYXV0aC9yZWplY3RlZC1jcmVkZW50aWFsJyxcclxuICAgIFNFQ09ORF9GQUNUT1JfQUxSRUFEWV9FTlJPTExFRDogJ2F1dGgvc2Vjb25kLWZhY3Rvci1hbHJlYWR5LWluLXVzZScsXHJcbiAgICBTRUNPTkRfRkFDVE9SX0xJTUlUX0VYQ0VFREVEOiAnYXV0aC9tYXhpbXVtLXNlY29uZC1mYWN0b3ItY291bnQtZXhjZWVkZWQnLFxyXG4gICAgVEVOQU5UX0lEX01JU01BVENIOiAnYXV0aC90ZW5hbnQtaWQtbWlzbWF0Y2gnLFxyXG4gICAgVElNRU9VVDogJ2F1dGgvdGltZW91dCcsXHJcbiAgICBUT0tFTl9FWFBJUkVEOiAnYXV0aC91c2VyLXRva2VuLWV4cGlyZWQnLFxyXG4gICAgVE9PX01BTllfQVRURU1QVFNfVFJZX0xBVEVSOiAnYXV0aC90b28tbWFueS1yZXF1ZXN0cycsXHJcbiAgICBVTkFVVEhPUklaRURfRE9NQUlOOiAnYXV0aC91bmF1dGhvcml6ZWQtY29udGludWUtdXJpJyxcclxuICAgIFVOU1VQUE9SVEVEX0ZJUlNUX0ZBQ1RPUjogJ2F1dGgvdW5zdXBwb3J0ZWQtZmlyc3QtZmFjdG9yJyxcclxuICAgIFVOU1VQUE9SVEVEX1BFUlNJU1RFTkNFOiAnYXV0aC91bnN1cHBvcnRlZC1wZXJzaXN0ZW5jZS10eXBlJyxcclxuICAgIFVOU1VQUE9SVEVEX1RFTkFOVF9PUEVSQVRJT046ICdhdXRoL3Vuc3VwcG9ydGVkLXRlbmFudC1vcGVyYXRpb24nLFxyXG4gICAgVU5WRVJJRklFRF9FTUFJTDogJ2F1dGgvdW52ZXJpZmllZC1lbWFpbCcsXHJcbiAgICBVU0VSX0NBTkNFTExFRDogJ2F1dGgvdXNlci1jYW5jZWxsZWQnLFxyXG4gICAgVVNFUl9ERUxFVEVEOiAnYXV0aC91c2VyLW5vdC1mb3VuZCcsXHJcbiAgICBVU0VSX0RJU0FCTEVEOiAnYXV0aC91c2VyLWRpc2FibGVkJyxcclxuICAgIFVTRVJfTUlTTUFUQ0g6ICdhdXRoL3VzZXItbWlzbWF0Y2gnLFxyXG4gICAgVVNFUl9TSUdORURfT1VUOiAnYXV0aC91c2VyLXNpZ25lZC1vdXQnLFxyXG4gICAgV0VBS19QQVNTV09SRDogJ2F1dGgvd2Vhay1wYXNzd29yZCcsXHJcbiAgICBXRUJfU1RPUkFHRV9VTlNVUFBPUlRFRDogJ2F1dGgvd2ViLXN0b3JhZ2UtdW5zdXBwb3J0ZWQnLFxyXG4gICAgQUxSRUFEWV9JTklUSUFMSVpFRDogJ2F1dGgvYWxyZWFkeS1pbml0aWFsaXplZCcsXHJcbiAgICBSRUNBUFRDSEFfTk9UX0VOQUJMRUQ6ICdhdXRoL3JlY2FwdGNoYS1ub3QtZW5hYmxlZCcsXHJcbiAgICBNSVNTSU5HX1JFQ0FQVENIQV9UT0tFTjogJ2F1dGgvbWlzc2luZy1yZWNhcHRjaGEtdG9rZW4nLFxyXG4gICAgSU5WQUxJRF9SRUNBUFRDSEFfVE9LRU46ICdhdXRoL2ludmFsaWQtcmVjYXB0Y2hhLXRva2VuJyxcclxuICAgIElOVkFMSURfUkVDQVBUQ0hBX0FDVElPTjogJ2F1dGgvaW52YWxpZC1yZWNhcHRjaGEtYWN0aW9uJyxcclxuICAgIE1JU1NJTkdfQ0xJRU5UX1RZUEU6ICdhdXRoL21pc3NpbmctY2xpZW50LXR5cGUnLFxyXG4gICAgTUlTU0lOR19SRUNBUFRDSEFfVkVSU0lPTjogJ2F1dGgvbWlzc2luZy1yZWNhcHRjaGEtdmVyc2lvbicsXHJcbiAgICBJTlZBTElEX1JFQ0FQVENIQV9WRVJTSU9OOiAnYXV0aC9pbnZhbGlkLXJlY2FwdGNoYS12ZXJzaW9uJyxcclxuICAgIElOVkFMSURfUkVRX1RZUEU6ICdhdXRoL2ludmFsaWQtcmVxLXR5cGUnXHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IGxvZ0NsaWVudCA9IG5ldyBMb2dnZXIoJ0BmaXJlYmFzZS9hdXRoJyk7XHJcbmZ1bmN0aW9uIF9sb2dXYXJuKG1zZywgLi4uYXJncykge1xyXG4gICAgaWYgKGxvZ0NsaWVudC5sb2dMZXZlbCA8PSBMb2dMZXZlbC5XQVJOKSB7XHJcbiAgICAgICAgbG9nQ2xpZW50Lndhcm4oYEF1dGggKCR7U0RLX1ZFUlNJT059KTogJHttc2d9YCwgLi4uYXJncyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gX2xvZ0Vycm9yKG1zZywgLi4uYXJncykge1xyXG4gICAgaWYgKGxvZ0NsaWVudC5sb2dMZXZlbCA8PSBMb2dMZXZlbC5FUlJPUikge1xyXG4gICAgICAgIGxvZ0NsaWVudC5lcnJvcihgQXV0aCAoJHtTREtfVkVSU0lPTn0pOiAke21zZ31gLCAuLi5hcmdzKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBfZmFpbChhdXRoT3JDb2RlLCAuLi5yZXN0KSB7XHJcbiAgICB0aHJvdyBjcmVhdGVFcnJvckludGVybmFsKGF1dGhPckNvZGUsIC4uLnJlc3QpO1xyXG59XHJcbmZ1bmN0aW9uIF9jcmVhdGVFcnJvcihhdXRoT3JDb2RlLCAuLi5yZXN0KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlRXJyb3JJbnRlcm5hbChhdXRoT3JDb2RlLCAuLi5yZXN0KTtcclxufVxyXG5mdW5jdGlvbiBfZXJyb3JXaXRoQ3VzdG9tTWVzc2FnZShhdXRoLCBjb2RlLCBtZXNzYWdlKSB7XHJcbiAgICBjb25zdCBlcnJvck1hcCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvZEVycm9yTWFwKCkpLCB7IFtjb2RlXTogbWVzc2FnZSB9KTtcclxuICAgIGNvbnN0IGZhY3RvcnkgPSBuZXcgRXJyb3JGYWN0b3J5KCdhdXRoJywgJ0ZpcmViYXNlJywgZXJyb3JNYXApO1xyXG4gICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlKGNvZGUsIHtcclxuICAgICAgICBhcHBOYW1lOiBhdXRoLm5hbWVcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKGF1dGgpIHtcclxuICAgIHJldHVybiBfZXJyb3JXaXRoQ3VzdG9tTWVzc2FnZShhdXRoLCBcIm9wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnRcIiAvKiBBdXRoRXJyb3JDb2RlLk9QRVJBVElPTl9OT1RfU1VQUE9SVEVEICovLCAnT3BlcmF0aW9ucyB0aGF0IGFsdGVyIHRoZSBjdXJyZW50IHVzZXIgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gY29uanVuY3Rpb24gd2l0aCBGaXJlYmFzZVNlcnZlckFwcCcpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUVycm9ySW50ZXJuYWwoYXV0aE9yQ29kZSwgLi4ucmVzdCkge1xyXG4gICAgaWYgKHR5cGVvZiBhdXRoT3JDb2RlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGNvbnN0IGNvZGUgPSByZXN0WzBdO1xyXG4gICAgICAgIGNvbnN0IGZ1bGxQYXJhbXMgPSBbLi4ucmVzdC5zbGljZSgxKV07XHJcbiAgICAgICAgaWYgKGZ1bGxQYXJhbXNbMF0pIHtcclxuICAgICAgICAgICAgZnVsbFBhcmFtc1swXS5hcHBOYW1lID0gYXV0aE9yQ29kZS5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXV0aE9yQ29kZS5fZXJyb3JGYWN0b3J5LmNyZWF0ZShjb2RlLCAuLi5mdWxsUGFyYW1zKTtcclxuICAgIH1cclxuICAgIHJldHVybiBfREVGQVVMVF9BVVRIX0VSUk9SX0ZBQ1RPUlkuY3JlYXRlKGF1dGhPckNvZGUsIC4uLnJlc3QpO1xyXG59XHJcbmZ1bmN0aW9uIF9hc3NlcnQoYXNzZXJ0aW9uLCBhdXRoT3JDb2RlLCAuLi5yZXN0KSB7XHJcbiAgICBpZiAoIWFzc2VydGlvbikge1xyXG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9ySW50ZXJuYWwoYXV0aE9yQ29kZSwgLi4ucmVzdCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFVuY29uZGl0aW9uYWxseSBmYWlscywgdGhyb3dpbmcgYW4gaW50ZXJuYWwgZXJyb3Igd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZS5cclxuICpcclxuICogQHBhcmFtIGZhaWx1cmUgdHlwZSBvZiBmYWlsdXJlIGVuY291bnRlcmVkXHJcbiAqIEB0aHJvd3MgRXJyb3JcclxuICovXHJcbmZ1bmN0aW9uIGRlYnVnRmFpbChmYWlsdXJlKSB7XHJcbiAgICAvLyBMb2cgdGhlIGZhaWx1cmUgaW4gYWRkaXRpb24gdG8gdGhyb3cgYW4gZXhjZXB0aW9uLCBqdXN0IGluIGNhc2UgdGhlXHJcbiAgICAvLyBleGNlcHRpb24gaXMgc3dhbGxvd2VkLlxyXG4gICAgY29uc3QgbWVzc2FnZSA9IGBJTlRFUk5BTCBBU1NFUlRJT04gRkFJTEVEOiBgICsgZmFpbHVyZTtcclxuICAgIF9sb2dFcnJvcihtZXNzYWdlKTtcclxuICAgIC8vIE5PVEU6IFdlIGRvbid0IHVzZSBGaXJlYmFzZUVycm9yIGhlcmUgYmVjYXVzZSB0aGVzZSBhcmUgaW50ZXJuYWwgZmFpbHVyZXNcclxuICAgIC8vIHRoYXQgY2Fubm90IGJlIGhhbmRsZWQgYnkgdGhlIHVzZXIuIChBbHNvIGl0IHdvdWxkIGNyZWF0ZSBhIGNpcmN1bGFyXHJcbiAgICAvLyBkZXBlbmRlbmN5IGJldHdlZW4gdGhlIGVycm9yIGFuZCBhc3NlcnQgbW9kdWxlcyB3aGljaCBkb2Vzbid0IHdvcmsuKVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG59XHJcbi8qKlxyXG4gKiBGYWlscyBpZiB0aGUgZ2l2ZW4gYXNzZXJ0aW9uIGNvbmRpdGlvbiBpcyBmYWxzZSwgdGhyb3dpbmcgYW4gRXJyb3Igd2l0aCB0aGVcclxuICogZ2l2ZW4gbWVzc2FnZSBpZiBpdCBkaWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBhc3NlcnRpb25cclxuICogQHBhcmFtIG1lc3NhZ2VcclxuICovXHJcbmZ1bmN0aW9uIGRlYnVnQXNzZXJ0KGFzc2VydGlvbiwgbWVzc2FnZSkge1xyXG4gICAgaWYgKCFhc3NlcnRpb24pIHtcclxuICAgICAgICBkZWJ1Z0ZhaWwobWVzc2FnZSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gX2dldEN1cnJlbnRVcmwoKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAoKF9hID0gc2VsZi5sb2NhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhyZWYpKSB8fCAnJztcclxufVxyXG5mdW5jdGlvbiBfaXNIdHRwT3JIdHRwcygpIHtcclxuICAgIHJldHVybiBfZ2V0Q3VycmVudFNjaGVtZSgpID09PSAnaHR0cDonIHx8IF9nZXRDdXJyZW50U2NoZW1lKCkgPT09ICdodHRwczonO1xyXG59XHJcbmZ1bmN0aW9uIF9nZXRDdXJyZW50U2NoZW1lKCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgcmV0dXJuICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgKChfYSA9IHNlbGYubG9jYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcm90b2NvbCkpIHx8IG51bGw7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIERldGVybWluZSB3aGV0aGVyIHRoZSBicm93c2VyIGlzIHdvcmtpbmcgb25saW5lXHJcbiAqL1xyXG5mdW5jdGlvbiBfaXNPbmxpbmUoKSB7XHJcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICBuYXZpZ2F0b3IgJiZcclxuICAgICAgICAnb25MaW5lJyBpbiBuYXZpZ2F0b3IgJiZcclxuICAgICAgICB0eXBlb2YgbmF2aWdhdG9yLm9uTGluZSA9PT0gJ2Jvb2xlYW4nICYmXHJcbiAgICAgICAgLy8gQXBwbHkgb25seSBmb3IgdHJhZGl0aW9uYWwgd2ViIGFwcHMgYW5kIENocm9tZSBleHRlbnNpb25zLlxyXG4gICAgICAgIC8vIFRoaXMgaXMgZXNwZWNpYWxseSB0cnVlIGZvciBDb3Jkb3ZhIGFwcHMgd2hpY2ggaGF2ZSB1bnJlbGlhYmxlXHJcbiAgICAgICAgLy8gbmF2aWdhdG9yLm9uTGluZSBiZWhhdmlvciB1bmxlc3MgY29yZG92YS1wbHVnaW4tbmV0d29yay1pbmZvcm1hdGlvbiBpc1xyXG4gICAgICAgIC8vIGluc3RhbGxlZCB3aGljaCBvdmVyd3JpdGVzIHRoZSBuYXRpdmUgbmF2aWdhdG9yLm9uTGluZSB2YWx1ZSBhbmRcclxuICAgICAgICAvLyBkZWZpbmVzIG5hdmlnYXRvci5jb25uZWN0aW9uLlxyXG4gICAgICAgIChfaXNIdHRwT3JIdHRwcygpIHx8IGlzQnJvd3NlckV4dGVuc2lvbigpIHx8ICdjb25uZWN0aW9uJyBpbiBuYXZpZ2F0b3IpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5vbkxpbmU7XHJcbiAgICB9XHJcbiAgICAvLyBJZiB3ZSBjYW4ndCBkZXRlcm1pbmUgdGhlIHN0YXRlLCBhc3N1bWUgaXQgaXMgb25saW5lLlxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gX2dldFVzZXJMYW5ndWFnZSgpIHtcclxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmF2aWdhdG9yTGFuZ3VhZ2UgPSBuYXZpZ2F0b3I7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgLy8gTW9zdCByZWxpYWJsZSwgYnV0IG9ubHkgc3VwcG9ydGVkIGluIENocm9tZS9GaXJlZm94LlxyXG4gICAgKG5hdmlnYXRvckxhbmd1YWdlLmxhbmd1YWdlcyAmJiBuYXZpZ2F0b3JMYW5ndWFnZS5sYW5ndWFnZXNbMF0pIHx8XHJcbiAgICAgICAgLy8gU3VwcG9ydGVkIGluIG1vc3QgYnJvd3NlcnMsIGJ1dCByZXR1cm5zIHRoZSBsYW5ndWFnZSBvZiB0aGUgYnJvd3NlclxyXG4gICAgICAgIC8vIFVJLCBub3QgdGhlIGxhbmd1YWdlIHNldCBpbiBicm93c2VyIHNldHRpbmdzLlxyXG4gICAgICAgIG5hdmlnYXRvckxhbmd1YWdlLmxhbmd1YWdlIHx8XHJcbiAgICAgICAgLy8gQ291bGRuJ3QgZGV0ZXJtaW5lIGxhbmd1YWdlLlxyXG4gICAgICAgIG51bGwpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIHN0cnVjdHVyZSB0byBoZWxwIHBpY2sgYmV0d2VlbiBhIHJhbmdlIG9mIGxvbmcgYW5kIHNob3J0IGRlbGF5IGR1cmF0aW9uc1xyXG4gKiBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuIEluIGdlbmVyYWwsIHRoZSBsb25nIGRlbGF5IGlzIHVzZWQgZm9yXHJcbiAqIG1vYmlsZSBlbnZpcm9ubWVudHMgd2hlcmVhcyBzaG9ydCBkZWxheXMgYXJlIHVzZWQgZm9yIGRlc2t0b3AgZW52aXJvbm1lbnRzLlxyXG4gKi9cclxuY2xhc3MgRGVsYXkge1xyXG4gICAgY29uc3RydWN0b3Ioc2hvcnREZWxheSwgbG9uZ0RlbGF5KSB7XHJcbiAgICAgICAgdGhpcy5zaG9ydERlbGF5ID0gc2hvcnREZWxheTtcclxuICAgICAgICB0aGlzLmxvbmdEZWxheSA9IGxvbmdEZWxheTtcclxuICAgICAgICAvLyBJbnRlcm5hbCBlcnJvciB3aGVuIGltcHJvcGVybHkgaW5pdGlhbGl6ZWQuXHJcbiAgICAgICAgZGVidWdBc3NlcnQobG9uZ0RlbGF5ID4gc2hvcnREZWxheSwgJ1Nob3J0IGRlbGF5IHNob3VsZCBiZSBsZXNzIHRoYW4gbG9uZyBkZWxheSEnKTtcclxuICAgICAgICB0aGlzLmlzTW9iaWxlID0gaXNNb2JpbGVDb3Jkb3ZhKCkgfHwgaXNSZWFjdE5hdGl2ZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0KCkge1xyXG4gICAgICAgIGlmICghX2lzT25saW5lKCkpIHtcclxuICAgICAgICAgICAgLy8gUGljayB0aGUgc2hvcnRlciB0aW1lb3V0LlxyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4oNTAwMCAvKiBEZWxheU1pbi5PRkZMSU5FICovLCB0aGlzLnNob3J0RGVsYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBydW5uaW5nIGluIGEgbW9iaWxlIGVudmlyb25tZW50LCByZXR1cm4gdGhlIGxvbmcgZGVsYXksIG90aGVyd2lzZVxyXG4gICAgICAgIC8vIHJldHVybiB0aGUgc2hvcnQgZGVsYXkuXHJcbiAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBpbXByb3ZlZCBpbiB0aGUgZnV0dXJlIHRvIGR5bmFtaWNhbGx5IGNoYW5nZSBiYXNlZCBvbiBvdGhlclxyXG4gICAgICAgIC8vIHZhcmlhYmxlcyBpbnN0ZWFkIG9mIGp1c3QgcmVhZGluZyB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cclxuICAgICAgICByZXR1cm4gdGhpcy5pc01vYmlsZSA/IHRoaXMubG9uZ0RlbGF5IDogdGhpcy5zaG9ydERlbGF5O1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIF9lbXVsYXRvclVybChjb25maWcsIHBhdGgpIHtcclxuICAgIGRlYnVnQXNzZXJ0KGNvbmZpZy5lbXVsYXRvciwgJ0VtdWxhdG9yIHNob3VsZCBhbHdheXMgYmUgc2V0IGhlcmUnKTtcclxuICAgIGNvbnN0IHsgdXJsIH0gPSBjb25maWcuZW11bGF0b3I7XHJcbiAgICBpZiAoIXBhdGgpIHtcclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGAke3VybH0ke3BhdGguc3RhcnRzV2l0aCgnLycpID8gcGF0aC5zbGljZSgxKSA6IHBhdGh9YDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBGZXRjaFByb3ZpZGVyIHtcclxuICAgIHN0YXRpYyBpbml0aWFsaXplKGZldGNoSW1wbCwgaGVhZGVyc0ltcGwsIHJlc3BvbnNlSW1wbCkge1xyXG4gICAgICAgIHRoaXMuZmV0Y2hJbXBsID0gZmV0Y2hJbXBsO1xyXG4gICAgICAgIGlmIChoZWFkZXJzSW1wbCkge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWRlcnNJbXBsID0gaGVhZGVyc0ltcGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXNwb25zZUltcGwpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNwb25zZUltcGwgPSByZXNwb25zZUltcGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGZldGNoKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZldGNoSW1wbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEltcGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2ZldGNoJyBpbiBzZWxmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmZldGNoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMuZmV0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuZmV0Y2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgZmV0Y2ggIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmZXRjaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVidWdGYWlsKCdDb3VsZCBub3QgZmluZCBmZXRjaCBpbXBsZW1lbnRhdGlvbiwgbWFrZSBzdXJlIHlvdSBjYWxsIEZldGNoUHJvdmlkZXIuaW5pdGlhbGl6ZSgpIHdpdGggYW4gYXBwcm9wcmlhdGUgcG9seWZpbGwnKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBoZWFkZXJzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmhlYWRlcnNJbXBsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlYWRlcnNJbXBsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICdIZWFkZXJzJyBpbiBzZWxmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLkhlYWRlcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcy5IZWFkZXJzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxUaGlzLkhlYWRlcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgSGVhZGVycyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEhlYWRlcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlYnVnRmFpbCgnQ291bGQgbm90IGZpbmQgSGVhZGVycyBpbXBsZW1lbnRhdGlvbiwgbWFrZSBzdXJlIHlvdSBjYWxsIEZldGNoUHJvdmlkZXIuaW5pdGlhbGl6ZSgpIHdpdGggYW4gYXBwcm9wcmlhdGUgcG9seWZpbGwnKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyByZXNwb25zZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5yZXNwb25zZUltcGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2VJbXBsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICdSZXNwb25zZScgaW4gc2VsZikge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5SZXNwb25zZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWxUaGlzLlJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxUaGlzLlJlc3BvbnNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIFJlc3BvbnNlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICByZXR1cm4gUmVzcG9uc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlYnVnRmFpbCgnQ291bGQgbm90IGZpbmQgUmVzcG9uc2UgaW1wbGVtZW50YXRpb24sIG1ha2Ugc3VyZSB5b3UgY2FsbCBGZXRjaFByb3ZpZGVyLmluaXRpYWxpemUoKSB3aXRoIGFuIGFwcHJvcHJpYXRlIHBvbHlmaWxsJyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIE1hcCBmcm9tIGVycm9ycyByZXR1cm5lZCBieSB0aGUgc2VydmVyIHRvIGVycm9ycyB0byBkZXZlbG9wZXIgdmlzaWJsZSBlcnJvcnNcclxuICovXHJcbmNvbnN0IFNFUlZFUl9FUlJPUl9NQVAgPSB7XHJcbiAgICAvLyBDdXN0b20gdG9rZW4gZXJyb3JzLlxyXG4gICAgW1wiQ1JFREVOVElBTF9NSVNNQVRDSFwiIC8qIFNlcnZlckVycm9yLkNSRURFTlRJQUxfTUlTTUFUQ0ggKi9dOiBcImN1c3RvbS10b2tlbi1taXNtYXRjaFwiIC8qIEF1dGhFcnJvckNvZGUuQ1JFREVOVElBTF9NSVNNQVRDSCAqLyxcclxuICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBTREsgc2VuZHMgYSBiYWQgcmVxdWVzdC5cclxuICAgIFtcIk1JU1NJTkdfQ1VTVE9NX1RPS0VOXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19DVVNUT01fVE9LRU4gKi9dOiBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyxcclxuICAgIC8vIENyZWF0ZSBBdXRoIFVSSSBlcnJvcnMuXHJcbiAgICBbXCJJTlZBTElEX0lERU5USUZJRVJcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX0lERU5USUZJRVIgKi9dOiBcImludmFsaWQtZW1haWxcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfRU1BSUwgKi8sXHJcbiAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbiBpZiB0aGUgU0RLIHNlbmRzIGEgYmFkIHJlcXVlc3QuXHJcbiAgICBbXCJNSVNTSU5HX0NPTlRJTlVFX1VSSVwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfQ09OVElOVUVfVVJJICovXTogXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8sXHJcbiAgICAvLyBTaWduIGluIHdpdGggZW1haWwgYW5kIHBhc3N3b3JkIGVycm9ycyAoc29tZSBhcHBseSB0byBzaWduIHVwIHRvbykuXHJcbiAgICBbXCJJTlZBTElEX1BBU1NXT1JEXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9QQVNTV09SRCAqL106IFwid3JvbmctcGFzc3dvcmRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUEFTU1dPUkQgKi8sXHJcbiAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbiBpZiB0aGUgU0RLIHNlbmRzIGEgYmFkIHJlcXVlc3QuXHJcbiAgICBbXCJNSVNTSU5HX1BBU1NXT1JEXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19QQVNTV09SRCAqL106IFwibWlzc2luZy1wYXNzd29yZFwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19QQVNTV09SRCAqLyxcclxuICAgIC8vIFRocm93biBpZiBFbWFpbCBFbnVtZXJhdGlvbiBQcm90ZWN0aW9uIGlzIGVuYWJsZWQgaW4gdGhlIHByb2plY3QgYW5kIHRoZSBlbWFpbCBvciBwYXNzd29yZCBpc1xyXG4gICAgLy8gaW52YWxpZC5cclxuICAgIFtcIklOVkFMSURfTE9HSU5fQ1JFREVOVElBTFNcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX0xPR0lOX0NSRURFTlRJQUxTICovXTogXCJpbnZhbGlkLWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ1JFREVOVElBTCAqLyxcclxuICAgIC8vIFNpZ24gdXAgd2l0aCBlbWFpbCBhbmQgcGFzc3dvcmQgZXJyb3JzLlxyXG4gICAgW1wiRU1BSUxfRVhJU1RTXCIgLyogU2VydmVyRXJyb3IuRU1BSUxfRVhJU1RTICovXTogXCJlbWFpbC1hbHJlYWR5LWluLXVzZVwiIC8qIEF1dGhFcnJvckNvZGUuRU1BSUxfRVhJU1RTICovLFxyXG4gICAgW1wiUEFTU1dPUkRfTE9HSU5fRElTQUJMRURcIiAvKiBTZXJ2ZXJFcnJvci5QQVNTV09SRF9MT0dJTl9ESVNBQkxFRCAqL106IFwib3BlcmF0aW9uLW5vdC1hbGxvd2VkXCIgLyogQXV0aEVycm9yQ29kZS5PUEVSQVRJT05fTk9UX0FMTE9XRUQgKi8sXHJcbiAgICAvLyBWZXJpZnkgYXNzZXJ0aW9uIGZvciBzaWduIGluIHdpdGggY3JlZGVudGlhbCBlcnJvcnM6XHJcbiAgICBbXCJJTlZBTElEX0lEUF9SRVNQT05TRVwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfSURQX1JFU1BPTlNFICovXTogXCJpbnZhbGlkLWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ1JFREVOVElBTCAqLyxcclxuICAgIFtcIklOVkFMSURfUEVORElOR19UT0tFTlwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfUEVORElOR19UT0tFTiAqL106IFwiaW52YWxpZC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NSRURFTlRJQUwgKi8sXHJcbiAgICBbXCJGRURFUkFURURfVVNFUl9JRF9BTFJFQURZX0xJTktFRFwiIC8qIFNlcnZlckVycm9yLkZFREVSQVRFRF9VU0VSX0lEX0FMUkVBRFlfTElOS0VEICovXTogXCJjcmVkZW50aWFsLWFscmVhZHktaW4tdXNlXCIgLyogQXV0aEVycm9yQ29kZS5DUkVERU5USUFMX0FMUkVBRFlfSU5fVVNFICovLFxyXG4gICAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW4gaWYgdGhlIFNESyBzZW5kcyBhIGJhZCByZXF1ZXN0LlxyXG4gICAgW1wiTUlTU0lOR19SRVFfVFlQRVwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfUkVRX1RZUEUgKi9dOiBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyxcclxuICAgIC8vIFNlbmQgUGFzc3dvcmQgcmVzZXQgZW1haWwgZXJyb3JzOlxyXG4gICAgW1wiRU1BSUxfTk9UX0ZPVU5EXCIgLyogU2VydmVyRXJyb3IuRU1BSUxfTk9UX0ZPVU5EICovXTogXCJ1c2VyLW5vdC1mb3VuZFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9ERUxFVEVEICovLFxyXG4gICAgW1wiUkVTRVRfUEFTU1dPUkRfRVhDRUVEX0xJTUlUXCIgLyogU2VydmVyRXJyb3IuUkVTRVRfUEFTU1dPUkRfRVhDRUVEX0xJTUlUICovXTogXCJ0b28tbWFueS1yZXF1ZXN0c1wiIC8qIEF1dGhFcnJvckNvZGUuVE9PX01BTllfQVRURU1QVFNfVFJZX0xBVEVSICovLFxyXG4gICAgW1wiRVhQSVJFRF9PT0JfQ09ERVwiIC8qIFNlcnZlckVycm9yLkVYUElSRURfT09CX0NPREUgKi9dOiBcImV4cGlyZWQtYWN0aW9uLWNvZGVcIiAvKiBBdXRoRXJyb3JDb2RlLkVYUElSRURfT09CX0NPREUgKi8sXHJcbiAgICBbXCJJTlZBTElEX09PQl9DT0RFXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9PT0JfQ09ERSAqL106IFwiaW52YWxpZC1hY3Rpb24tY29kZVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9PT0JfQ09ERSAqLyxcclxuICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBTREsgc2VuZHMgYSBiYWQgcmVxdWVzdC5cclxuICAgIFtcIk1JU1NJTkdfT09CX0NPREVcIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX09PQl9DT0RFICovXTogXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8sXHJcbiAgICAvLyBPcGVyYXRpb25zIHRoYXQgcmVxdWlyZSBJRCB0b2tlbiBpbiByZXF1ZXN0OlxyXG4gICAgW1wiQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOXCIgLyogU2VydmVyRXJyb3IuQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOICovXTogXCJyZXF1aXJlcy1yZWNlbnQtbG9naW5cIiAvKiBBdXRoRXJyb3JDb2RlLkNSRURFTlRJQUxfVE9PX09MRF9MT0dJTl9BR0FJTiAqLyxcclxuICAgIFtcIklOVkFMSURfSURfVE9LRU5cIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX0lEX1RPS0VOICovXTogXCJpbnZhbGlkLXVzZXItdG9rZW5cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQVVUSCAqLyxcclxuICAgIFtcIlRPS0VOX0VYUElSRURcIiAvKiBTZXJ2ZXJFcnJvci5UT0tFTl9FWFBJUkVEICovXTogXCJ1c2VyLXRva2VuLWV4cGlyZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlRPS0VOX0VYUElSRUQgKi8sXHJcbiAgICBbXCJVU0VSX05PVF9GT1VORFwiIC8qIFNlcnZlckVycm9yLlVTRVJfTk9UX0ZPVU5EICovXTogXCJ1c2VyLXRva2VuLWV4cGlyZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlRPS0VOX0VYUElSRUQgKi8sXHJcbiAgICAvLyBPdGhlciBlcnJvcnMuXHJcbiAgICBbXCJUT09fTUFOWV9BVFRFTVBUU19UUllfTEFURVJcIiAvKiBTZXJ2ZXJFcnJvci5UT09fTUFOWV9BVFRFTVBUU19UUllfTEFURVIgKi9dOiBcInRvby1tYW55LXJlcXVlc3RzXCIgLyogQXV0aEVycm9yQ29kZS5UT09fTUFOWV9BVFRFTVBUU19UUllfTEFURVIgKi8sXHJcbiAgICBbXCJQQVNTV09SRF9ET0VTX05PVF9NRUVUX1JFUVVJUkVNRU5UU1wiIC8qIFNlcnZlckVycm9yLlBBU1NXT1JEX0RPRVNfTk9UX01FRVRfUkVRVUlSRU1FTlRTICovXTogXCJwYXNzd29yZC1kb2VzLW5vdC1tZWV0LXJlcXVpcmVtZW50c1wiIC8qIEF1dGhFcnJvckNvZGUuUEFTU1dPUkRfRE9FU19OT1RfTUVFVF9SRVFVSVJFTUVOVFMgKi8sXHJcbiAgICAvLyBQaG9uZSBBdXRoIHJlbGF0ZWQgZXJyb3JzLlxyXG4gICAgW1wiSU5WQUxJRF9DT0RFXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9DT0RFICovXTogXCJpbnZhbGlkLXZlcmlmaWNhdGlvbi1jb2RlXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NPREUgKi8sXHJcbiAgICBbXCJJTlZBTElEX1NFU1NJT05fSU5GT1wiIC8qIFNlcnZlckVycm9yLklOVkFMSURfU0VTU0lPTl9JTkZPICovXTogXCJpbnZhbGlkLXZlcmlmaWNhdGlvbi1pZFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9TRVNTSU9OX0lORk8gKi8sXHJcbiAgICBbXCJJTlZBTElEX1RFTVBPUkFSWV9QUk9PRlwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfVEVNUE9SQVJZX1BST09GICovXTogXCJpbnZhbGlkLWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ1JFREVOVElBTCAqLyxcclxuICAgIFtcIk1JU1NJTkdfU0VTU0lPTl9JTkZPXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19TRVNTSU9OX0lORk8gKi9dOiBcIm1pc3NpbmctdmVyaWZpY2F0aW9uLWlkXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1NFU1NJT05fSU5GTyAqLyxcclxuICAgIFtcIlNFU1NJT05fRVhQSVJFRFwiIC8qIFNlcnZlckVycm9yLlNFU1NJT05fRVhQSVJFRCAqL106IFwiY29kZS1leHBpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5DT0RFX0VYUElSRUQgKi8sXHJcbiAgICAvLyBPdGhlciBhY3Rpb24gY29kZSBlcnJvcnMgd2hlbiBhZGRpdGlvbmFsIHNldHRpbmdzIHBhc3NlZC5cclxuICAgIC8vIE1JU1NJTkdfQ09OVElOVUVfVVJJIGlzIGdldHRpbmcgbWFwcGVkIHRvIElOVEVSTkFMX0VSUk9SIGFib3ZlLlxyXG4gICAgLy8gVGhpcyBpcyBPSyBhcyB0aGlzIGVycm9yIHdpbGwgYmUgY2F1Z2h0IGJ5IGNsaWVudCBzaWRlIHZhbGlkYXRpb24uXHJcbiAgICBbXCJNSVNTSU5HX0FORFJPSURfUEFDS0FHRV9OQU1FXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19BTkRST0lEX1BBQ0tBR0VfTkFNRSAqL106IFwibWlzc2luZy1hbmRyb2lkLXBrZy1uYW1lXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0FORFJPSURfUEFDS0FHRV9OQU1FICovLFxyXG4gICAgW1wiVU5BVVRIT1JJWkVEX0RPTUFJTlwiIC8qIFNlcnZlckVycm9yLlVOQVVUSE9SSVpFRF9ET01BSU4gKi9dOiBcInVuYXV0aG9yaXplZC1jb250aW51ZS11cmlcIiAvKiBBdXRoRXJyb3JDb2RlLlVOQVVUSE9SSVpFRF9ET01BSU4gKi8sXHJcbiAgICAvLyBnZXRQcm9qZWN0Q29uZmlnIGVycm9ycyB3aGVuIGNsaWVudElkIGlzIHBhc3NlZC5cclxuICAgIFtcIklOVkFMSURfT0FVVEhfQ0xJRU5UX0lEXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9PQVVUSF9DTElFTlRfSUQgKi9dOiBcImludmFsaWQtb2F1dGgtY2xpZW50LWlkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX09BVVRIX0NMSUVOVF9JRCAqLyxcclxuICAgIC8vIFVzZXIgYWN0aW9ucyAoc2lnbi11cCBvciBkZWxldGlvbikgZGlzYWJsZWQgZXJyb3JzLlxyXG4gICAgW1wiQURNSU5fT05MWV9PUEVSQVRJT05cIiAvKiBTZXJ2ZXJFcnJvci5BRE1JTl9PTkxZX09QRVJBVElPTiAqL106IFwiYWRtaW4tcmVzdHJpY3RlZC1vcGVyYXRpb25cIiAvKiBBdXRoRXJyb3JDb2RlLkFETUlOX09OTFlfT1BFUkFUSU9OICovLFxyXG4gICAgLy8gTXVsdGkgZmFjdG9yIHJlbGF0ZWQgZXJyb3JzLlxyXG4gICAgW1wiSU5WQUxJRF9NRkFfUEVORElOR19DUkVERU5USUFMXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9NRkFfUEVORElOR19DUkVERU5USUFMICovXTogXCJpbnZhbGlkLW11bHRpLWZhY3Rvci1zZXNzaW9uXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX01GQV9TRVNTSU9OICovLFxyXG4gICAgW1wiTUZBX0VOUk9MTE1FTlRfTk9UX0ZPVU5EXCIgLyogU2VydmVyRXJyb3IuTUZBX0VOUk9MTE1FTlRfTk9UX0ZPVU5EICovXTogXCJtdWx0aS1mYWN0b3ItaW5mby1ub3QtZm91bmRcIiAvKiBBdXRoRXJyb3JDb2RlLk1GQV9JTkZPX05PVF9GT1VORCAqLyxcclxuICAgIFtcIk1JU1NJTkdfTUZBX0VOUk9MTE1FTlRfSURcIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX01GQV9FTlJPTExNRU5UX0lEICovXTogXCJtaXNzaW5nLW11bHRpLWZhY3Rvci1pbmZvXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX01GQV9JTkZPICovLFxyXG4gICAgW1wiTUlTU0lOR19NRkFfUEVORElOR19DUkVERU5USUFMXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19NRkFfUEVORElOR19DUkVERU5USUFMICovXTogXCJtaXNzaW5nLW11bHRpLWZhY3Rvci1zZXNzaW9uXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX01GQV9TRVNTSU9OICovLFxyXG4gICAgW1wiU0VDT05EX0ZBQ1RPUl9FWElTVFNcIiAvKiBTZXJ2ZXJFcnJvci5TRUNPTkRfRkFDVE9SX0VYSVNUUyAqL106IFwic2Vjb25kLWZhY3Rvci1hbHJlYWR5LWluLXVzZVwiIC8qIEF1dGhFcnJvckNvZGUuU0VDT05EX0ZBQ1RPUl9BTFJFQURZX0VOUk9MTEVEICovLFxyXG4gICAgW1wiU0VDT05EX0ZBQ1RPUl9MSU1JVF9FWENFRURFRFwiIC8qIFNlcnZlckVycm9yLlNFQ09ORF9GQUNUT1JfTElNSVRfRVhDRUVERUQgKi9dOiBcIm1heGltdW0tc2Vjb25kLWZhY3Rvci1jb3VudC1leGNlZWRlZFwiIC8qIEF1dGhFcnJvckNvZGUuU0VDT05EX0ZBQ1RPUl9MSU1JVF9FWENFRURFRCAqLyxcclxuICAgIC8vIEJsb2NraW5nIGZ1bmN0aW9ucyByZWxhdGVkIGVycm9ycy5cclxuICAgIFtcIkJMT0NLSU5HX0ZVTkNUSU9OX0VSUk9SX1JFU1BPTlNFXCIgLyogU2VydmVyRXJyb3IuQkxPQ0tJTkdfRlVOQ1RJT05fRVJST1JfUkVTUE9OU0UgKi9dOiBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyxcclxuICAgIC8vIFJlY2FwdGNoYSByZWxhdGVkIGVycm9ycy5cclxuICAgIFtcIlJFQ0FQVENIQV9OT1RfRU5BQkxFRFwiIC8qIFNlcnZlckVycm9yLlJFQ0FQVENIQV9OT1RfRU5BQkxFRCAqL106IFwicmVjYXB0Y2hhLW5vdC1lbmFibGVkXCIgLyogQXV0aEVycm9yQ29kZS5SRUNBUFRDSEFfTk9UX0VOQUJMRUQgKi8sXHJcbiAgICBbXCJNSVNTSU5HX1JFQ0FQVENIQV9UT0tFTlwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOICovXTogXCJtaXNzaW5nLXJlY2FwdGNoYS10b2tlblwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19SRUNBUFRDSEFfVE9LRU4gKi8sXHJcbiAgICBbXCJJTlZBTElEX1JFQ0FQVENIQV9UT0tFTlwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfUkVDQVBUQ0hBX1RPS0VOICovXTogXCJpbnZhbGlkLXJlY2FwdGNoYS10b2tlblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9SRUNBUFRDSEFfVE9LRU4gKi8sXHJcbiAgICBbXCJJTlZBTElEX1JFQ0FQVENIQV9BQ1RJT05cIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX1JFQ0FQVENIQV9BQ1RJT04gKi9dOiBcImludmFsaWQtcmVjYXB0Y2hhLWFjdGlvblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9SRUNBUFRDSEFfQUNUSU9OICovLFxyXG4gICAgW1wiTUlTU0lOR19DTElFTlRfVFlQRVwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfQ0xJRU5UX1RZUEUgKi9dOiBcIm1pc3NpbmctY2xpZW50LXR5cGVcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQ0xJRU5UX1RZUEUgKi8sXHJcbiAgICBbXCJNSVNTSU5HX1JFQ0FQVENIQV9WRVJTSU9OXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19SRUNBUFRDSEFfVkVSU0lPTiAqL106IFwibWlzc2luZy1yZWNhcHRjaGEtdmVyc2lvblwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19SRUNBUFRDSEFfVkVSU0lPTiAqLyxcclxuICAgIFtcIklOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT05cIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX1JFQ0FQVENIQV9WRVJTSU9OICovXTogXCJpbnZhbGlkLXJlY2FwdGNoYS12ZXJzaW9uXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFQ0FQVENIQV9WRVJTSU9OICovLFxyXG4gICAgW1wiSU5WQUxJRF9SRVFfVFlQRVwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfUkVRX1RZUEUgKi9dOiBcImludmFsaWQtcmVxLXR5cGVcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVRX1RZUEUgKi9cclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9BUElfVElNRU9VVF9NUyA9IG5ldyBEZWxheSgzMDAwMCwgNjAwMDApO1xyXG5mdW5jdGlvbiBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgaWYgKGF1dGgudGVuYW50SWQgJiYgIXJlcXVlc3QudGVuYW50SWQpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KSwgeyB0ZW5hbnRJZDogYXV0aC50ZW5hbnRJZCB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXF1ZXN0O1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBtZXRob2QsIHBhdGgsIHJlcXVlc3QsIGN1c3RvbUVycm9yTWFwID0ge30pIHtcclxuICAgIHJldHVybiBfcGVyZm9ybUZldGNoV2l0aEVycm9ySGFuZGxpbmcoYXV0aCwgY3VzdG9tRXJyb3JNYXAsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBsZXQgYm9keSA9IHt9O1xyXG4gICAgICAgIGxldCBwYXJhbXMgPSB7fTtcclxuICAgICAgICBpZiAocmVxdWVzdCkge1xyXG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcIkdFVFwiIC8qIEh0dHBNZXRob2QuR0VUICovKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSByZXF1ZXN0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYm9keSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBxdWVyeSA9IHF1ZXJ5c3RyaW5nKE9iamVjdC5hc3NpZ24oeyBrZXk6IGF1dGguY29uZmlnLmFwaUtleSB9LCBwYXJhbXMpKS5zbGljZSgxKTtcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0gYXdhaXQgYXV0aC5fZ2V0QWRkaXRpb25hbEhlYWRlcnMoKTtcclxuICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCIgLyogSHR0cEhlYWRlci5DT05URU5UX1RZUEUgKi9dID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xyXG4gICAgICAgIGlmIChhdXRoLmxhbmd1YWdlQ29kZSkge1xyXG4gICAgICAgICAgICBoZWFkZXJzW1wiWC1GaXJlYmFzZS1Mb2NhbGVcIiAvKiBIdHRwSGVhZGVyLlhfRklSRUJBU0VfTE9DQUxFICovXSA9IGF1dGgubGFuZ3VhZ2VDb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmZXRjaEFyZ3MgPSBPYmplY3QuYXNzaWduKHsgbWV0aG9kLFxyXG4gICAgICAgICAgICBoZWFkZXJzIH0sIGJvZHkpO1xyXG4gICAgICAgIC8qIFNlY3VyaXR5LWNvbnNjaW91cyBzZXJ2ZXItc2lkZSBmcmFtZXdvcmtzIHRlbmQgdG8gaGF2ZSBidWlsdCBpbiBtaXRpZ2F0aW9ucyBmb3IgcmVmZXJyZXJcclxuICAgICAgICAgICBwcm9ibGVtc1wiLiBTZWUgdGhlIENsb3VkZmxhcmUgR2l0SHViIGlzc3VlICM0ODc6IEVycm9yOiBUaGUgJ3JlZmVycmVyUG9saWN5JyBmaWVsZCBvblxyXG4gICAgICAgICAgICdSZXF1ZXN0SW5pdGlhbGl6ZXJEaWN0JyBpcyBub3QgaW1wbGVtZW50ZWQuXCJcclxuICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vY2xvdWRmbGFyZS9uZXh0LW9uLXBhZ2VzL2lzc3Vlcy80ODcgKi9cclxuICAgICAgICBpZiAoIWlzQ2xvdWRmbGFyZVdvcmtlcigpKSB7XHJcbiAgICAgICAgICAgIGZldGNoQXJncy5yZWZlcnJlclBvbGljeSA9ICduby1yZWZlcnJlcic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBGZXRjaFByb3ZpZGVyLmZldGNoKCkoX2dldEZpbmFsVGFyZ2V0KGF1dGgsIGF1dGguY29uZmlnLmFwaUhvc3QsIHBhdGgsIHF1ZXJ5KSwgZmV0Y2hBcmdzKTtcclxuICAgIH0pO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIF9wZXJmb3JtRmV0Y2hXaXRoRXJyb3JIYW5kbGluZyhhdXRoLCBjdXN0b21FcnJvck1hcCwgZmV0Y2hGbikge1xyXG4gICAgYXV0aC5fY2FuSW5pdEVtdWxhdG9yID0gZmFsc2U7XHJcbiAgICBjb25zdCBlcnJvck1hcCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgU0VSVkVSX0VSUk9SX01BUCksIGN1c3RvbUVycm9yTWFwKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgbmV0d29ya1RpbWVvdXQgPSBuZXcgTmV0d29ya1RpbWVvdXQoYXV0aCk7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQcm9taXNlLnJhY2UoW1xyXG4gICAgICAgICAgICBmZXRjaEZuKCksXHJcbiAgICAgICAgICAgIG5ldHdvcmtUaW1lb3V0LnByb21pc2VcclxuICAgICAgICBdKTtcclxuICAgICAgICAvLyBJZiB3ZSd2ZSByZWFjaGVkIHRoaXMgcG9pbnQsIHRoZSBmZXRjaCBzdWNjZWVkZWQgYW5kIHRoZSBuZXR3b3JrVGltZW91dFxyXG4gICAgICAgIC8vIGRpZG4ndCB0aHJvdzsgY2xlYXIgdGhlIG5ldHdvcmsgdGltZW91dCBkZWxheSBzbyB0aGF0IE5vZGUgd29uJ3QgaGFuZ1xyXG4gICAgICAgIG5ldHdvcmtUaW1lb3V0LmNsZWFyTmV0d29ya1RpbWVvdXQoKTtcclxuICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIGlmICgnbmVlZENvbmZpcm1hdGlvbicgaW4ganNvbikge1xyXG4gICAgICAgICAgICB0aHJvdyBfbWFrZVRhZ2dlZEVycm9yKGF1dGgsIFwiYWNjb3VudC1leGlzdHMtd2l0aC1kaWZmZXJlbnQtY3JlZGVudGlhbFwiIC8qIEF1dGhFcnJvckNvZGUuTkVFRF9DT05GSVJNQVRJT04gKi8sIGpzb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVzcG9uc2Uub2sgJiYgISgnZXJyb3JNZXNzYWdlJyBpbiBqc29uKSkge1xyXG4gICAgICAgICAgICByZXR1cm4ganNvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHJlc3BvbnNlLm9rID8ganNvbi5lcnJvck1lc3NhZ2UgOiBqc29uLmVycm9yLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgIGNvbnN0IFtzZXJ2ZXJFcnJvckNvZGUsIHNlcnZlckVycm9yTWVzc2FnZV0gPSBlcnJvck1lc3NhZ2Uuc3BsaXQoJyA6ICcpO1xyXG4gICAgICAgICAgICBpZiAoc2VydmVyRXJyb3JDb2RlID09PSBcIkZFREVSQVRFRF9VU0VSX0lEX0FMUkVBRFlfTElOS0VEXCIgLyogU2VydmVyRXJyb3IuRkVERVJBVEVEX1VTRVJfSURfQUxSRUFEWV9MSU5LRUQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IF9tYWtlVGFnZ2VkRXJyb3IoYXV0aCwgXCJjcmVkZW50aWFsLWFscmVhZHktaW4tdXNlXCIgLyogQXV0aEVycm9yQ29kZS5DUkVERU5USUFMX0FMUkVBRFlfSU5fVVNFICovLCBqc29uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzZXJ2ZXJFcnJvckNvZGUgPT09IFwiRU1BSUxfRVhJU1RTXCIgLyogU2VydmVyRXJyb3IuRU1BSUxfRVhJU1RTICovKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBfbWFrZVRhZ2dlZEVycm9yKGF1dGgsIFwiZW1haWwtYWxyZWFkeS1pbi11c2VcIiAvKiBBdXRoRXJyb3JDb2RlLkVNQUlMX0VYSVNUUyAqLywganNvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2VydmVyRXJyb3JDb2RlID09PSBcIlVTRVJfRElTQUJMRURcIiAvKiBTZXJ2ZXJFcnJvci5VU0VSX0RJU0FCTEVEICovKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBfbWFrZVRhZ2dlZEVycm9yKGF1dGgsIFwidXNlci1kaXNhYmxlZFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9ESVNBQkxFRCAqLywganNvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgYXV0aEVycm9yID0gZXJyb3JNYXBbc2VydmVyRXJyb3JDb2RlXSB8fFxyXG4gICAgICAgICAgICAgICAgc2VydmVyRXJyb3JDb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcclxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW19cXHNdKy9nLCAnLScpO1xyXG4gICAgICAgICAgICBpZiAoc2VydmVyRXJyb3JNZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBfZXJyb3JXaXRoQ3VzdG9tTWVzc2FnZShhdXRoLCBhdXRoRXJyb3IsIHNlcnZlckVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfZmFpbChhdXRoLCBhdXRoRXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hhbmdpbmcgdGhpcyB0byBhIGRpZmZlcmVudCBlcnJvciBjb2RlIHdpbGwgbG9nIHVzZXIgb3V0IHdoZW4gdGhlcmUgaXMgYSBuZXR3b3JrIGVycm9yXHJcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSB0cmVhdCBhbnkgZXJyb3Igb3RoZXIgdGhhbiBORVRXT1JLX1JFUVVFU1RfRkFJTEVEIGFzIHRva2VuIGlzIGludmFsaWQuXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWpzLXNkay9ibG9iLzRmYmM3MzYxMGQ3MGJlNGUwODUyZTdkZTYzYTM5Y2I3ODk3ZTg1NDYvcGFja2FnZXMvYXV0aC9zcmMvY29yZS9hdXRoL2F1dGhfaW1wbC50cyNMMzA5LUwzMTZcclxuICAgICAgICBfZmFpbChhdXRoLCBcIm5ldHdvcmstcmVxdWVzdC1mYWlsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk5FVFdPUktfUkVRVUVTVF9GQUlMRUQgKi8sIHsgJ21lc3NhZ2UnOiBTdHJpbmcoZSkgfSk7XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gX3BlcmZvcm1TaWduSW5SZXF1ZXN0KGF1dGgsIG1ldGhvZCwgcGF0aCwgcmVxdWVzdCwgY3VzdG9tRXJyb3JNYXAgPSB7fSkge1xyXG4gICAgY29uc3Qgc2VydmVyUmVzcG9uc2UgPSAoYXdhaXQgX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIG1ldGhvZCwgcGF0aCwgcmVxdWVzdCwgY3VzdG9tRXJyb3JNYXApKTtcclxuICAgIGlmICgnbWZhUGVuZGluZ0NyZWRlbnRpYWwnIGluIHNlcnZlclJlc3BvbnNlKSB7XHJcbiAgICAgICAgX2ZhaWwoYXV0aCwgXCJtdWx0aS1mYWN0b3ItYXV0aC1yZXF1aXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuTUZBX1JFUVVJUkVEICovLCB7XHJcbiAgICAgICAgICAgIF9zZXJ2ZXJSZXNwb25zZTogc2VydmVyUmVzcG9uc2VcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBzZXJ2ZXJSZXNwb25zZTtcclxufVxyXG5mdW5jdGlvbiBfZ2V0RmluYWxUYXJnZXQoYXV0aCwgaG9zdCwgcGF0aCwgcXVlcnkpIHtcclxuICAgIGNvbnN0IGJhc2UgPSBgJHtob3N0fSR7cGF0aH0/JHtxdWVyeX1gO1xyXG4gICAgaWYgKCFhdXRoLmNvbmZpZy5lbXVsYXRvcikge1xyXG4gICAgICAgIHJldHVybiBgJHthdXRoLmNvbmZpZy5hcGlTY2hlbWV9Oi8vJHtiYXNlfWA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX2VtdWxhdG9yVXJsKGF1dGguY29uZmlnLCBiYXNlKTtcclxufVxyXG5mdW5jdGlvbiBfcGFyc2VFbmZvcmNlbWVudFN0YXRlKGVuZm9yY2VtZW50U3RhdGVTdHIpIHtcclxuICAgIHN3aXRjaCAoZW5mb3JjZW1lbnRTdGF0ZVN0cikge1xyXG4gICAgICAgIGNhc2UgJ0VORk9SQ0UnOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJFTkZPUkNFXCIgLyogRW5mb3JjZW1lbnRTdGF0ZS5FTkZPUkNFICovO1xyXG4gICAgICAgIGNhc2UgJ0FVRElUJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwiQVVESVRcIiAvKiBFbmZvcmNlbWVudFN0YXRlLkFVRElUICovO1xyXG4gICAgICAgIGNhc2UgJ09GRic6XHJcbiAgICAgICAgICAgIHJldHVybiBcIk9GRlwiIC8qIEVuZm9yY2VtZW50U3RhdGUuT0ZGICovO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBcIkVORk9SQ0VNRU5UX1NUQVRFX1VOU1BFQ0lGSUVEXCIgLyogRW5mb3JjZW1lbnRTdGF0ZS5FTkZPUkNFTUVOVF9TVEFURV9VTlNQRUNJRklFRCAqLztcclxuICAgIH1cclxufVxyXG5jbGFzcyBOZXR3b3JrVGltZW91dCB7XHJcbiAgICBjb25zdHJ1Y3RvcihhdXRoKSB7XHJcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcclxuICAgICAgICAvLyBOb2RlIHRpbWVycyBhbmQgYnJvd3NlciB0aW1lcnMgYXJlIGZ1bmRhbWVudGFsbHkgaW5jb21wYXRpYmxlLCBidXQgd2VcclxuICAgICAgICAvLyBkb24ndCBjYXJlIGFib3V0IHRoZSB2YWx1ZSBoZXJlXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoX2NyZWF0ZUVycm9yKHRoaXMuYXV0aCwgXCJuZXR3b3JrLXJlcXVlc3QtZmFpbGVkXCIgLyogQXV0aEVycm9yQ29kZS5ORVRXT1JLX1JFUVVFU1RfRkFJTEVEICovKSk7XHJcbiAgICAgICAgICAgIH0sIERFRkFVTFRfQVBJX1RJTUVPVVRfTVMuZ2V0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY2xlYXJOZXR3b3JrVGltZW91dCgpIHtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gX21ha2VUYWdnZWRFcnJvcihhdXRoLCBjb2RlLCByZXNwb25zZSkge1xyXG4gICAgY29uc3QgZXJyb3JQYXJhbXMgPSB7XHJcbiAgICAgICAgYXBwTmFtZTogYXV0aC5uYW1lXHJcbiAgICB9O1xyXG4gICAgaWYgKHJlc3BvbnNlLmVtYWlsKSB7XHJcbiAgICAgICAgZXJyb3JQYXJhbXMuZW1haWwgPSByZXNwb25zZS5lbWFpbDtcclxuICAgIH1cclxuICAgIGlmIChyZXNwb25zZS5waG9uZU51bWJlcikge1xyXG4gICAgICAgIGVycm9yUGFyYW1zLnBob25lTnVtYmVyID0gcmVzcG9uc2UucGhvbmVOdW1iZXI7XHJcbiAgICB9XHJcbiAgICBjb25zdCBlcnJvciA9IF9jcmVhdGVFcnJvcihhdXRoLCBjb2RlLCBlcnJvclBhcmFtcyk7XHJcbiAgICAvLyBXZSBrbm93IGN1c3RvbURhdGEgaXMgZGVmaW5lZCBvbiBlcnJvciBiZWNhdXNlIGVycm9yUGFyYW1zIGlzIGRlZmluZWRcclxuICAgIGVycm9yLmN1c3RvbURhdGEuX3Rva2VuUmVzcG9uc2UgPSByZXNwb25zZTtcclxuICAgIHJldHVybiBlcnJvcjtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0VudGVycHJpc2UoZ3JlY2FwdGNoYSkge1xyXG4gICAgcmV0dXJuIChncmVjYXB0Y2hhICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICBncmVjYXB0Y2hhLmVudGVycHJpc2UgIT09IHVuZGVmaW5lZCk7XHJcbn1cclxuY2xhc3MgUmVjYXB0Y2hhQ29uZmlnIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHJlQ0FQVENIQSBzaXRlIGtleS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNpdGVLZXkgPSAnJztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbGlzdCBvZiBwcm92aWRlcnMgYW5kIHRoZWlyIGVuYWJsZW1lbnQgc3RhdHVzIGZvciByZUNBUFRDSEEgRW50ZXJwcmlzZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGUgPSBbXTtcclxuICAgICAgICBpZiAocmVzcG9uc2UucmVjYXB0Y2hhS2V5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNhcHRjaGFLZXkgdW5kZWZpbmVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEV4YW1wbGUgcmVzcG9uc2UucmVjYXB0Y2hhS2V5OiBcInByb2plY3RzL3Byb2oxMjMva2V5cy9zaXRla2V5MTIzXCJcclxuICAgICAgICB0aGlzLnNpdGVLZXkgPSByZXNwb25zZS5yZWNhcHRjaGFLZXkuc3BsaXQoJy8nKVszXTtcclxuICAgICAgICB0aGlzLnJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGUgPSByZXNwb25zZS5yZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZUNBUFRDSEEgRW50ZXJwcmlzZSBlbmZvcmNlbWVudCBzdGF0ZSBmb3IgdGhlIGdpdmVuIHByb3ZpZGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwcm92aWRlclN0ciAtIFRoZSBwcm92aWRlciB3aG9zZSBlbmZvcmNlbWVudCBzdGF0ZSBpcyB0byBiZSByZXR1cm5lZC5cclxuICAgICAqIEByZXR1cm5zIFRoZSByZUNBUFRDSEEgRW50ZXJwcmlzZSBlbmZvcmNlbWVudCBzdGF0ZSBmb3IgdGhlIGdpdmVuIHByb3ZpZGVyLlxyXG4gICAgICovXHJcbiAgICBnZXRQcm92aWRlckVuZm9yY2VtZW50U3RhdGUocHJvdmlkZXJTdHIpIHtcclxuICAgICAgICBpZiAoIXRoaXMucmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZSB8fFxyXG4gICAgICAgICAgICB0aGlzLnJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IHJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGUgb2YgdGhpcy5yZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlKSB7XHJcbiAgICAgICAgICAgIGlmIChyZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlLnByb3ZpZGVyICYmXHJcbiAgICAgICAgICAgICAgICByZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlLnByb3ZpZGVyID09PSBwcm92aWRlclN0cikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9wYXJzZUVuZm9yY2VtZW50U3RhdGUocmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZS5lbmZvcmNlbWVudFN0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSByZUNBUFRDSEEgRW50ZXJwcmlzZSBlbmZvcmNlbWVudCBzdGF0ZSBmb3IgdGhlIHByb3ZpZGVyIGlzIHNldCB0byBFTkZPUkNFIG9yIEFVRElULlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwcm92aWRlclN0ciAtIFRoZSBwcm92aWRlciB3aG9zZSBlbmFibGVtZW50IHN0YXRlIGlzIHRvIGJlIHJldHVybmVkLlxyXG4gICAgICogQHJldHVybnMgV2hldGhlciBvciBub3QgcmVDQVBUQ0hBIEVudGVycHJpc2UgcHJvdGVjdGlvbiBpcyBlbmFibGVkIGZvciB0aGUgZ2l2ZW4gcHJvdmlkZXIuXHJcbiAgICAgKi9cclxuICAgIGlzUHJvdmlkZXJFbmFibGVkKHByb3ZpZGVyU3RyKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmdldFByb3ZpZGVyRW5mb3JjZW1lbnRTdGF0ZShwcm92aWRlclN0cikgPT09XHJcbiAgICAgICAgICAgIFwiRU5GT1JDRVwiIC8qIEVuZm9yY2VtZW50U3RhdGUuRU5GT1JDRSAqLyB8fFxyXG4gICAgICAgICAgICB0aGlzLmdldFByb3ZpZGVyRW5mb3JjZW1lbnRTdGF0ZShwcm92aWRlclN0cikgPT09IFwiQVVESVRcIiAvKiBFbmZvcmNlbWVudFN0YXRlLkFVRElUICovKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBnZXRSZWNhcHRjaGFDb25maWcoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIkdFVFwiIC8qIEh0dHBNZXRob2QuR0VUICovLCBcIi92Mi9yZWNhcHRjaGFDb25maWdcIiAvKiBFbmRwb2ludC5HRVRfUkVDQVBUQ0hBX0NPTkZJRyAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBkZWxldGVBY2NvdW50KGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpkZWxldGVcIiAvKiBFbmRwb2ludC5ERUxFVEVfQUNDT1VOVCAqLywgcmVxdWVzdCk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gZGVsZXRlTGlua2VkQWNjb3VudHMoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnVwZGF0ZVwiIC8qIEVuZHBvaW50LlNFVF9BQ0NPVU5UX0lORk8gKi8sIHJlcXVlc3QpO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGdldEFjY291bnRJbmZvKGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpsb29rdXBcIiAvKiBFbmRwb2ludC5HRVRfQUNDT1VOVF9JTkZPICovLCByZXF1ZXN0KTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcodXRjVGltZXN0YW1wKSB7XHJcbiAgICBpZiAoIXV0Y1RpbWVzdGFtcCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIENvbnZlcnQgdG8gZGF0ZSBvYmplY3QuXHJcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKE51bWJlcih1dGNUaW1lc3RhbXApKTtcclxuICAgICAgICAvLyBUZXN0IGRhdGUgaXMgdmFsaWQuXHJcbiAgICAgICAgaWYgKCFpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcclxuICAgICAgICAgICAgLy8gQ29udmVydCB0byBVVEMgZGF0ZSBzdHJpbmcuXHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlLnRvVVRDU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nLiB1bmRlZmluZWQgd2lsbCBiZSByZXR1cm5lZC5cclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgYSBKU09OIFdlYiBUb2tlbiAoSldUKSB1c2VkIHRvIGlkZW50aWZ5IHRoZSB1c2VyIHRvIGEgRmlyZWJhc2Ugc2VydmljZS5cclxuICpcclxuICogQHJlbWFya3NcclxuICogUmV0dXJucyB0aGUgY3VycmVudCB0b2tlbiBpZiBpdCBoYXMgbm90IGV4cGlyZWQgb3IgaWYgaXQgd2lsbCBub3QgZXhwaXJlIGluIHRoZSBuZXh0IGZpdmVcclxuICogbWludXRlcy4gT3RoZXJ3aXNlLCB0aGlzIHdpbGwgcmVmcmVzaCB0aGUgdG9rZW4gYW5kIHJldHVybiBhIG5ldyBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXHJcbiAqIEBwYXJhbSBmb3JjZVJlZnJlc2ggLSBGb3JjZSByZWZyZXNoIHJlZ2FyZGxlc3Mgb2YgdG9rZW4gZXhwaXJhdGlvbi5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SWRUb2tlbih1c2VyLCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKS5nZXRJZFRva2VuKGZvcmNlUmVmcmVzaCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBkZXNlcmlhbGl6ZWQgSlNPTiBXZWIgVG9rZW4gKEpXVCkgdXNlZCB0byBpZGVudGlmeSB0aGUgdXNlciB0byBhIEZpcmViYXNlIHNlcnZpY2UuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgdG9rZW4gaWYgaXQgaGFzIG5vdCBleHBpcmVkIG9yIGlmIGl0IHdpbGwgbm90IGV4cGlyZSBpbiB0aGUgbmV4dCBmaXZlXHJcbiAqIG1pbnV0ZXMuIE90aGVyd2lzZSwgdGhpcyB3aWxsIHJlZnJlc2ggdGhlIHRva2VuIGFuZCByZXR1cm4gYSBuZXcgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxyXG4gKiBAcGFyYW0gZm9yY2VSZWZyZXNoIC0gRm9yY2UgcmVmcmVzaCByZWdhcmRsZXNzIG9mIHRva2VuIGV4cGlyYXRpb24uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGdldElkVG9rZW5SZXN1bHQodXNlciwgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHVzZXJJbnRlcm5hbCA9IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKTtcclxuICAgIGNvbnN0IHRva2VuID0gYXdhaXQgdXNlckludGVybmFsLmdldElkVG9rZW4oZm9yY2VSZWZyZXNoKTtcclxuICAgIGNvbnN0IGNsYWltcyA9IF9wYXJzZVRva2VuKHRva2VuKTtcclxuICAgIF9hc3NlcnQoY2xhaW1zICYmIGNsYWltcy5leHAgJiYgY2xhaW1zLmF1dGhfdGltZSAmJiBjbGFpbXMuaWF0LCB1c2VySW50ZXJuYWwuYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgY29uc3QgZmlyZWJhc2UgPSB0eXBlb2YgY2xhaW1zLmZpcmViYXNlID09PSAnb2JqZWN0JyA/IGNsYWltcy5maXJlYmFzZSA6IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IHNpZ25JblByb3ZpZGVyID0gZmlyZWJhc2UgPT09IG51bGwgfHwgZmlyZWJhc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpcmViYXNlWydzaWduX2luX3Byb3ZpZGVyJ107XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNsYWltcyxcclxuICAgICAgICB0b2tlbixcclxuICAgICAgICBhdXRoVGltZTogdXRjVGltZXN0YW1wVG9EYXRlU3RyaW5nKHNlY29uZHNTdHJpbmdUb01pbGxpc2Vjb25kcyhjbGFpbXMuYXV0aF90aW1lKSksXHJcbiAgICAgICAgaXNzdWVkQXRUaW1lOiB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcoc2Vjb25kc1N0cmluZ1RvTWlsbGlzZWNvbmRzKGNsYWltcy5pYXQpKSxcclxuICAgICAgICBleHBpcmF0aW9uVGltZTogdXRjVGltZXN0YW1wVG9EYXRlU3RyaW5nKHNlY29uZHNTdHJpbmdUb01pbGxpc2Vjb25kcyhjbGFpbXMuZXhwKSksXHJcbiAgICAgICAgc2lnbkluUHJvdmlkZXI6IHNpZ25JblByb3ZpZGVyIHx8IG51bGwsXHJcbiAgICAgICAgc2lnbkluU2Vjb25kRmFjdG9yOiAoZmlyZWJhc2UgPT09IG51bGwgfHwgZmlyZWJhc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpcmViYXNlWydzaWduX2luX3NlY29uZF9mYWN0b3InXSkgfHwgbnVsbFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBzZWNvbmRzU3RyaW5nVG9NaWxsaXNlY29uZHMoc2Vjb25kcykge1xyXG4gICAgcmV0dXJuIE51bWJlcihzZWNvbmRzKSAqIDEwMDA7XHJcbn1cclxuZnVuY3Rpb24gX3BhcnNlVG9rZW4odG9rZW4pIHtcclxuICAgIGNvbnN0IFthbGdvcml0aG0sIHBheWxvYWQsIHNpZ25hdHVyZV0gPSB0b2tlbi5zcGxpdCgnLicpO1xyXG4gICAgaWYgKGFsZ29yaXRobSA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgcGF5bG9hZCA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgc2lnbmF0dXJlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBfbG9nRXJyb3IoJ0pXVCBtYWxmb3JtZWQsIGNvbnRhaW5lZCBmZXdlciB0aGFuIDMgc2VjdGlvbnMnKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IGJhc2U2NERlY29kZShwYXlsb2FkKTtcclxuICAgICAgICBpZiAoIWRlY29kZWQpIHtcclxuICAgICAgICAgICAgX2xvZ0Vycm9yKCdGYWlsZWQgdG8gZGVjb2RlIGJhc2U2NCBKV1QgcGF5bG9hZCcpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlZCk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIF9sb2dFcnJvcignQ2F1Z2h0IGVycm9yIHBhcnNpbmcgSldUIHBheWxvYWQgYXMgSlNPTicsIGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS50b1N0cmluZygpKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRXh0cmFjdCBleHBpcmVzSW4gVFRMIGZyb20gYSB0b2tlbiBieSBzdWJ0cmFjdGluZyB0aGUgZXhwaXJhdGlvbiBmcm9tIHRoZSBpc3N1YW5jZS5cclxuICovXHJcbmZ1bmN0aW9uIF90b2tlbkV4cGlyZXNJbih0b2tlbikge1xyXG4gICAgY29uc3QgcGFyc2VkVG9rZW4gPSBfcGFyc2VUb2tlbih0b2tlbik7XHJcbiAgICBfYXNzZXJ0KHBhcnNlZFRva2VuLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICBfYXNzZXJ0KHR5cGVvZiBwYXJzZWRUb2tlbi5leHAgIT09ICd1bmRlZmluZWQnLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICBfYXNzZXJ0KHR5cGVvZiBwYXJzZWRUb2tlbi5pYXQgIT09ICd1bmRlZmluZWQnLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICByZXR1cm4gTnVtYmVyKHBhcnNlZFRva2VuLmV4cCkgLSBOdW1iZXIocGFyc2VkVG9rZW4uaWF0KTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBfbG9nb3V0SWZJbnZhbGlkYXRlZCh1c2VyLCBwcm9taXNlLCBieXBhc3NBdXRoU3RhdGUgPSBmYWxzZSkge1xyXG4gICAgaWYgKGJ5cGFzc0F1dGhTdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgcHJvbWlzZTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yICYmIGlzVXNlckludmFsaWRhdGVkKGUpKSB7XHJcbiAgICAgICAgICAgIGlmICh1c2VyLmF1dGguY3VycmVudFVzZXIgPT09IHVzZXIpIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHVzZXIuYXV0aC5zaWduT3V0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc1VzZXJJbnZhbGlkYXRlZCh7IGNvZGUgfSkge1xyXG4gICAgcmV0dXJuIChjb2RlID09PSBgYXV0aC8ke1widXNlci1kaXNhYmxlZFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9ESVNBQkxFRCAqL31gIHx8XHJcbiAgICAgICAgY29kZSA9PT0gYGF1dGgvJHtcInVzZXItdG9rZW4tZXhwaXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuVE9LRU5fRVhQSVJFRCAqL31gKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBQcm9hY3RpdmVSZWZyZXNoIHtcclxuICAgIGNvbnN0cnVjdG9yKHVzZXIpIHtcclxuICAgICAgICB0aGlzLnVzZXIgPSB1c2VyO1xyXG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgLy8gTm9kZSB0aW1lcnMgYW5kIGJyb3dzZXIgdGltZXJzIHJldHVybiBmdW5kYW1lbnRhbGx5IGRpZmZlcmVudCB0eXBlcy5cclxuICAgICAgICAvLyBXZSBkb24ndCBhY3R1YWxseSBjYXJlIHdoYXQgdGhlIHZhbHVlIGlzIGJ1dCBUUyB3b24ndCBhY2NlcHQgdW5rbm93biBhbmRcclxuICAgICAgICAvLyB3ZSBjYW4ndCBjYXN0IHByb3Blcmx5IGluIGJvdGggZW52aXJvbm1lbnRzLlxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgdGhpcy50aW1lcklkID0gbnVsbDtcclxuICAgICAgICB0aGlzLmVycm9yQmFja29mZiA9IDMwMDAwIC8qIER1cmF0aW9uLlJFVFJZX0JBQ0tPRkZfTUlOICovO1xyXG4gICAgfVxyXG4gICAgX3N0YXJ0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzUnVubmluZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNjaGVkdWxlKCk7XHJcbiAgICB9XHJcbiAgICBfc3RvcCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy50aW1lcklkICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEludGVydmFsKHdhc0Vycm9yKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICh3YXNFcnJvcikge1xyXG4gICAgICAgICAgICBjb25zdCBpbnRlcnZhbCA9IHRoaXMuZXJyb3JCYWNrb2ZmO1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yQmFja29mZiA9IE1hdGgubWluKHRoaXMuZXJyb3JCYWNrb2ZmICogMiwgOTYwMDAwIC8qIER1cmF0aW9uLlJFVFJZX0JBQ0tPRkZfTUFYICovKTtcclxuICAgICAgICAgICAgcmV0dXJuIGludGVydmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGVycm9yIGJhY2tvZmZcclxuICAgICAgICAgICAgdGhpcy5lcnJvckJhY2tvZmYgPSAzMDAwMCAvKiBEdXJhdGlvbi5SRVRSWV9CQUNLT0ZGX01JTiAqLztcclxuICAgICAgICAgICAgY29uc3QgZXhwVGltZSA9IChfYSA9IHRoaXMudXNlci5zdHNUb2tlbk1hbmFnZXIuZXhwaXJhdGlvblRpbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGludGVydmFsID0gZXhwVGltZSAtIERhdGUubm93KCkgLSAzMDAwMDAgLyogRHVyYXRpb24uT0ZGU0VUICovO1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgaW50ZXJ2YWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNjaGVkdWxlKHdhc0Vycm9yID0gZmFsc2UpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSB7XHJcbiAgICAgICAgICAgIC8vIEp1c3QgaW4gY2FzZS4uLlxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGludGVydmFsID0gdGhpcy5nZXRJbnRlcnZhbCh3YXNFcnJvcik7XHJcbiAgICAgICAgdGhpcy50aW1lcklkID0gc2V0VGltZW91dChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaXRlcmF0aW9uKCk7XHJcbiAgICAgICAgfSwgaW50ZXJ2YWwpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgaXRlcmF0aW9uKCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudXNlci5nZXRJZFRva2VuKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBPbmx5IHJldHJ5IG9uIG5ldHdvcmsgZXJyb3JzXHJcbiAgICAgICAgICAgIGlmICgoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLmNvZGUpID09PVxyXG4gICAgICAgICAgICAgICAgYGF1dGgvJHtcIm5ldHdvcmstcmVxdWVzdC1mYWlsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk5FVFdPUktfUkVRVUVTVF9GQUlMRUQgKi99YCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZSgvKiB3YXNFcnJvciAqLyB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2NoZWR1bGUoKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBVc2VyTWV0YWRhdGEge1xyXG4gICAgY29uc3RydWN0b3IoY3JlYXRlZEF0LCBsYXN0TG9naW5BdCkge1xyXG4gICAgICAgIHRoaXMuY3JlYXRlZEF0ID0gY3JlYXRlZEF0O1xyXG4gICAgICAgIHRoaXMubGFzdExvZ2luQXQgPSBsYXN0TG9naW5BdDtcclxuICAgICAgICB0aGlzLl9pbml0aWFsaXplVGltZSgpO1xyXG4gICAgfVxyXG4gICAgX2luaXRpYWxpemVUaW1lKCkge1xyXG4gICAgICAgIHRoaXMubGFzdFNpZ25JblRpbWUgPSB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcodGhpcy5sYXN0TG9naW5BdCk7XHJcbiAgICAgICAgdGhpcy5jcmVhdGlvblRpbWUgPSB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcodGhpcy5jcmVhdGVkQXQpO1xyXG4gICAgfVxyXG4gICAgX2NvcHkobWV0YWRhdGEpIHtcclxuICAgICAgICB0aGlzLmNyZWF0ZWRBdCA9IG1ldGFkYXRhLmNyZWF0ZWRBdDtcclxuICAgICAgICB0aGlzLmxhc3RMb2dpbkF0ID0gbWV0YWRhdGEubGFzdExvZ2luQXQ7XHJcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVRpbWUoKTtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IHRoaXMuY3JlYXRlZEF0LFxyXG4gICAgICAgICAgICBsYXN0TG9naW5BdDogdGhpcy5sYXN0TG9naW5BdFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gX3JlbG9hZFdpdGhvdXRTYXZpbmcodXNlcikge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgYXV0aCA9IHVzZXIuYXV0aDtcclxuICAgIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB1c2VyLmdldElkVG9rZW4oKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodXNlciwgZ2V0QWNjb3VudEluZm8oYXV0aCwgeyBpZFRva2VuIH0pKTtcclxuICAgIF9hc3NlcnQocmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLnVzZXJzLmxlbmd0aCwgYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgY29uc3QgY29yZUFjY291bnQgPSByZXNwb25zZS51c2Vyc1swXTtcclxuICAgIHVzZXIuX25vdGlmeVJlbG9hZExpc3RlbmVyKGNvcmVBY2NvdW50KTtcclxuICAgIGNvbnN0IG5ld1Byb3ZpZGVyRGF0YSA9ICgoX2EgPSBjb3JlQWNjb3VudC5wcm92aWRlclVzZXJJbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKVxyXG4gICAgICAgID8gZXh0cmFjdFByb3ZpZGVyRGF0YShjb3JlQWNjb3VudC5wcm92aWRlclVzZXJJbmZvKVxyXG4gICAgICAgIDogW107XHJcbiAgICBjb25zdCBwcm92aWRlckRhdGEgPSBtZXJnZVByb3ZpZGVyRGF0YSh1c2VyLnByb3ZpZGVyRGF0YSwgbmV3UHJvdmlkZXJEYXRhKTtcclxuICAgIC8vIFByZXNlcnZlcyB0aGUgbm9uLW5vbnltb3VzIHN0YXR1cyBvZiB0aGUgc3RvcmVkIHVzZXIsIGV2ZW4gaWYgbm8gbW9yZVxyXG4gICAgLy8gY3JlZGVudGlhbHMgKGZlZGVyYXRlZCBvciBlbWFpbC9wYXNzd29yZCkgYXJlIGxpbmtlZCB0byB0aGUgdXNlci4gSWZcclxuICAgIC8vIHRoZSB1c2VyIHdhcyBwcmV2aW91c2x5IGFub255bW91cywgdGhlbiB1c2UgcHJvdmlkZXIgZGF0YSB0byB1cGRhdGUuXHJcbiAgICAvLyBPbiB0aGUgb3RoZXIgaGFuZCwgaWYgaXQgd2FzIG5vdCBhbm9ueW1vdXMgYmVmb3JlLCBpdCBzaG91bGQgbmV2ZXIgYmVcclxuICAgIC8vIGNvbnNpZGVyZWQgYW5vbnltb3VzIG5vdy5cclxuICAgIGNvbnN0IG9sZElzQW5vbnltb3VzID0gdXNlci5pc0Fub255bW91cztcclxuICAgIGNvbnN0IG5ld0lzQW5vbnltb3VzID0gISh1c2VyLmVtYWlsICYmIGNvcmVBY2NvdW50LnBhc3N3b3JkSGFzaCkgJiYgIShwcm92aWRlckRhdGEgPT09IG51bGwgfHwgcHJvdmlkZXJEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm92aWRlckRhdGEubGVuZ3RoKTtcclxuICAgIGNvbnN0IGlzQW5vbnltb3VzID0gIW9sZElzQW5vbnltb3VzID8gZmFsc2UgOiBuZXdJc0Fub255bW91cztcclxuICAgIGNvbnN0IHVwZGF0ZXMgPSB7XHJcbiAgICAgICAgdWlkOiBjb3JlQWNjb3VudC5sb2NhbElkLFxyXG4gICAgICAgIGRpc3BsYXlOYW1lOiBjb3JlQWNjb3VudC5kaXNwbGF5TmFtZSB8fCBudWxsLFxyXG4gICAgICAgIHBob3RvVVJMOiBjb3JlQWNjb3VudC5waG90b1VybCB8fCBudWxsLFxyXG4gICAgICAgIGVtYWlsOiBjb3JlQWNjb3VudC5lbWFpbCB8fCBudWxsLFxyXG4gICAgICAgIGVtYWlsVmVyaWZpZWQ6IGNvcmVBY2NvdW50LmVtYWlsVmVyaWZpZWQgfHwgZmFsc2UsXHJcbiAgICAgICAgcGhvbmVOdW1iZXI6IGNvcmVBY2NvdW50LnBob25lTnVtYmVyIHx8IG51bGwsXHJcbiAgICAgICAgdGVuYW50SWQ6IGNvcmVBY2NvdW50LnRlbmFudElkIHx8IG51bGwsXHJcbiAgICAgICAgcHJvdmlkZXJEYXRhLFxyXG4gICAgICAgIG1ldGFkYXRhOiBuZXcgVXNlck1ldGFkYXRhKGNvcmVBY2NvdW50LmNyZWF0ZWRBdCwgY29yZUFjY291bnQubGFzdExvZ2luQXQpLFxyXG4gICAgICAgIGlzQW5vbnltb3VzXHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmFzc2lnbih1c2VyLCB1cGRhdGVzKTtcclxufVxyXG4vKipcclxuICogUmVsb2FkcyB1c2VyIGFjY291bnQgZGF0YSwgaWYgc2lnbmVkIGluLlxyXG4gKlxyXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiByZWxvYWQodXNlcikge1xyXG4gICAgY29uc3QgdXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xyXG4gICAgYXdhaXQgX3JlbG9hZFdpdGhvdXRTYXZpbmcodXNlckludGVybmFsKTtcclxuICAgIC8vIEV2ZW4gdGhvdWdoIHRoZSBjdXJyZW50IHVzZXIgaGFzbid0IGNoYW5nZWQsIHVwZGF0ZVxyXG4gICAgLy8gY3VycmVudCB1c2VyIHdpbGwgdHJpZ2dlciBhIHBlcnNpc3RlbmNlIHVwZGF0ZSB3LyB0aGVcclxuICAgIC8vIG5ldyBpbmZvLlxyXG4gICAgYXdhaXQgdXNlckludGVybmFsLmF1dGguX3BlcnNpc3RVc2VySWZDdXJyZW50KHVzZXJJbnRlcm5hbCk7XHJcbiAgICB1c2VySW50ZXJuYWwuYXV0aC5fbm90aWZ5TGlzdGVuZXJzSWZDdXJyZW50KHVzZXJJbnRlcm5hbCk7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VQcm92aWRlckRhdGEob3JpZ2luYWwsIG5ld0RhdGEpIHtcclxuICAgIGNvbnN0IGRlZHVwZWQgPSBvcmlnaW5hbC5maWx0ZXIobyA9PiAhbmV3RGF0YS5zb21lKG4gPT4gbi5wcm92aWRlcklkID09PSBvLnByb3ZpZGVySWQpKTtcclxuICAgIHJldHVybiBbLi4uZGVkdXBlZCwgLi4ubmV3RGF0YV07XHJcbn1cclxuZnVuY3Rpb24gZXh0cmFjdFByb3ZpZGVyRGF0YShwcm92aWRlcnMpIHtcclxuICAgIHJldHVybiBwcm92aWRlcnMubWFwKChfYSkgPT4ge1xyXG4gICAgICAgIHZhciB7IHByb3ZpZGVySWQgfSA9IF9hLCBwcm92aWRlciA9IF9fcmVzdChfYSwgW1wicHJvdmlkZXJJZFwiXSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJvdmlkZXJJZCxcclxuICAgICAgICAgICAgdWlkOiBwcm92aWRlci5yYXdJZCB8fCAnJyxcclxuICAgICAgICAgICAgZGlzcGxheU5hbWU6IHByb3ZpZGVyLmRpc3BsYXlOYW1lIHx8IG51bGwsXHJcbiAgICAgICAgICAgIGVtYWlsOiBwcm92aWRlci5lbWFpbCB8fCBudWxsLFxyXG4gICAgICAgICAgICBwaG9uZU51bWJlcjogcHJvdmlkZXIucGhvbmVOdW1iZXIgfHwgbnVsbCxcclxuICAgICAgICAgICAgcGhvdG9VUkw6IHByb3ZpZGVyLnBob3RvVXJsIHx8IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdFN0c1Rva2VuKGF1dGgsIHJlZnJlc2hUb2tlbikge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfcGVyZm9ybUZldGNoV2l0aEVycm9ySGFuZGxpbmcoYXV0aCwge30sIGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCBib2R5ID0gcXVlcnlzdHJpbmcoe1xyXG4gICAgICAgICAgICAnZ3JhbnRfdHlwZSc6ICdyZWZyZXNoX3Rva2VuJyxcclxuICAgICAgICAgICAgJ3JlZnJlc2hfdG9rZW4nOiByZWZyZXNoVG9rZW5cclxuICAgICAgICB9KS5zbGljZSgxKTtcclxuICAgICAgICBjb25zdCB7IHRva2VuQXBpSG9zdCwgYXBpS2V5IH0gPSBhdXRoLmNvbmZpZztcclxuICAgICAgICBjb25zdCB1cmwgPSBfZ2V0RmluYWxUYXJnZXQoYXV0aCwgdG9rZW5BcGlIb3N0LCBcIi92MS90b2tlblwiIC8qIEVuZHBvaW50LlRPS0VOICovLCBga2V5PSR7YXBpS2V5fWApO1xyXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBhd2FpdCBhdXRoLl9nZXRBZGRpdGlvbmFsSGVhZGVycygpO1xyXG4gICAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIiAvKiBIdHRwSGVhZGVyLkNPTlRFTlRfVFlQRSAqL10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcclxuICAgICAgICByZXR1cm4gRmV0Y2hQcm92aWRlci5mZXRjaCgpKHVybCwge1xyXG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLyxcclxuICAgICAgICAgICAgaGVhZGVycyxcclxuICAgICAgICAgICAgYm9keVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICAvLyBUaGUgcmVzcG9uc2UgY29tZXMgYmFjayBpbiBzbmFrZV9jYXNlLiBDb252ZXJ0IHRvIGNhbWVsOlxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBhY2Nlc3NUb2tlbjogcmVzcG9uc2UuYWNjZXNzX3Rva2VuLFxyXG4gICAgICAgIGV4cGlyZXNJbjogcmVzcG9uc2UuZXhwaXJlc19pbixcclxuICAgICAgICByZWZyZXNoVG9rZW46IHJlc3BvbnNlLnJlZnJlc2hfdG9rZW5cclxuICAgIH07XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gcmV2b2tlVG9rZW4oYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YyL2FjY291bnRzOnJldm9rZVRva2VuXCIgLyogRW5kcG9pbnQuUkVWT0tFX1RPS0VOICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBXZSBuZWVkIHRvIG1hcmsgdGhpcyBjbGFzcyBhcyBpbnRlcm5hbCBleHBsaWNpdGx5IHRvIGV4Y2x1ZGUgaXQgaW4gdGhlIHB1YmxpYyB0eXBpbmdzLCBiZWNhdXNlXHJcbiAqIGl0IHJlZmVyZW5jZXMgQXV0aEludGVybmFsIHdoaWNoIGhhcyBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgd2l0aCBVc2VySW50ZXJuYWwuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgU3RzVG9rZW5NYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMucmVmcmVzaFRva2VuID0gbnVsbDtcclxuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gbnVsbDtcclxuICAgICAgICB0aGlzLmV4cGlyYXRpb25UaW1lID0gbnVsbDtcclxuICAgIH1cclxuICAgIGdldCBpc0V4cGlyZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuICghdGhpcy5leHBpcmF0aW9uVGltZSB8fFxyXG4gICAgICAgICAgICBEYXRlLm5vdygpID4gdGhpcy5leHBpcmF0aW9uVGltZSAtIDMwMDAwIC8qIEJ1ZmZlci5UT0tFTl9SRUZSRVNIICovKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUZyb21TZXJ2ZXJSZXNwb25zZShyZXNwb25zZSkge1xyXG4gICAgICAgIF9hc3NlcnQocmVzcG9uc2UuaWRUb2tlbiwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgICAgIF9hc3NlcnQodHlwZW9mIHJlc3BvbnNlLmlkVG9rZW4gIT09ICd1bmRlZmluZWQnLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICAgICAgX2Fzc2VydCh0eXBlb2YgcmVzcG9uc2UucmVmcmVzaFRva2VuICE9PSAndW5kZWZpbmVkJywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgICAgIGNvbnN0IGV4cGlyZXNJbiA9ICdleHBpcmVzSW4nIGluIHJlc3BvbnNlICYmIHR5cGVvZiByZXNwb25zZS5leHBpcmVzSW4gIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgICAgID8gTnVtYmVyKHJlc3BvbnNlLmV4cGlyZXNJbilcclxuICAgICAgICAgICAgOiBfdG9rZW5FeHBpcmVzSW4ocmVzcG9uc2UuaWRUb2tlbik7XHJcbiAgICAgICAgdGhpcy51cGRhdGVUb2tlbnNBbmRFeHBpcmF0aW9uKHJlc3BvbnNlLmlkVG9rZW4sIHJlc3BvbnNlLnJlZnJlc2hUb2tlbiwgZXhwaXJlc0luKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUZyb21JZFRva2VuKGlkVG9rZW4pIHtcclxuICAgICAgICBfYXNzZXJ0KGlkVG9rZW4ubGVuZ3RoICE9PSAwLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICAgICAgY29uc3QgZXhwaXJlc0luID0gX3Rva2VuRXhwaXJlc0luKGlkVG9rZW4pO1xyXG4gICAgICAgIHRoaXMudXBkYXRlVG9rZW5zQW5kRXhwaXJhdGlvbihpZFRva2VuLCBudWxsLCBleHBpcmVzSW4pO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0VG9rZW4oYXV0aCwgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcclxuICAgICAgICBpZiAoIWZvcmNlUmVmcmVzaCAmJiB0aGlzLmFjY2Vzc1Rva2VuICYmICF0aGlzLmlzRXhwaXJlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY2Nlc3NUb2tlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2Fzc2VydCh0aGlzLnJlZnJlc2hUb2tlbiwgYXV0aCwgXCJ1c2VyLXRva2VuLWV4cGlyZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlRPS0VOX0VYUElSRUQgKi8pO1xyXG4gICAgICAgIGlmICh0aGlzLnJlZnJlc2hUb2tlbikge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlZnJlc2goYXV0aCwgdGhpcy5yZWZyZXNoVG9rZW4pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY2Nlc3NUb2tlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjbGVhclJlZnJlc2hUb2tlbigpIHtcclxuICAgICAgICB0aGlzLnJlZnJlc2hUb2tlbiA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBhc3luYyByZWZyZXNoKGF1dGgsIG9sZFRva2VuKSB7XHJcbiAgICAgICAgY29uc3QgeyBhY2Nlc3NUb2tlbiwgcmVmcmVzaFRva2VuLCBleHBpcmVzSW4gfSA9IGF3YWl0IHJlcXVlc3RTdHNUb2tlbihhdXRoLCBvbGRUb2tlbik7XHJcbiAgICAgICAgdGhpcy51cGRhdGVUb2tlbnNBbmRFeHBpcmF0aW9uKGFjY2Vzc1Rva2VuLCByZWZyZXNoVG9rZW4sIE51bWJlcihleHBpcmVzSW4pKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVRva2Vuc0FuZEV4cGlyYXRpb24oYWNjZXNzVG9rZW4sIHJlZnJlc2hUb2tlbiwgZXhwaXJlc0luU2VjKSB7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoVG9rZW4gPSByZWZyZXNoVG9rZW4gfHwgbnVsbDtcclxuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW4gfHwgbnVsbDtcclxuICAgICAgICB0aGlzLmV4cGlyYXRpb25UaW1lID0gRGF0ZS5ub3coKSArIGV4cGlyZXNJblNlYyAqIDEwMDA7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbUpTT04oYXBwTmFtZSwgb2JqZWN0KSB7XHJcbiAgICAgICAgY29uc3QgeyByZWZyZXNoVG9rZW4sIGFjY2Vzc1Rva2VuLCBleHBpcmF0aW9uVGltZSB9ID0gb2JqZWN0O1xyXG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgU3RzVG9rZW5NYW5hZ2VyKCk7XHJcbiAgICAgICAgaWYgKHJlZnJlc2hUb2tlbikge1xyXG4gICAgICAgICAgICBfYXNzZXJ0KHR5cGVvZiByZWZyZXNoVG9rZW4gPT09ICdzdHJpbmcnLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLywge1xyXG4gICAgICAgICAgICAgICAgYXBwTmFtZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbWFuYWdlci5yZWZyZXNoVG9rZW4gPSByZWZyZXNoVG9rZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhY2Nlc3NUb2tlbikge1xyXG4gICAgICAgICAgICBfYXNzZXJ0KHR5cGVvZiBhY2Nlc3NUb2tlbiA9PT0gJ3N0cmluZycsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovLCB7XHJcbiAgICAgICAgICAgICAgICBhcHBOYW1lXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBtYW5hZ2VyLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChleHBpcmF0aW9uVGltZSkge1xyXG4gICAgICAgICAgICBfYXNzZXJ0KHR5cGVvZiBleHBpcmF0aW9uVGltZSA9PT0gJ251bWJlcicsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovLCB7XHJcbiAgICAgICAgICAgICAgICBhcHBOYW1lXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBtYW5hZ2VyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYW5hZ2VyO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJlZnJlc2hUb2tlbjogdGhpcy5yZWZyZXNoVG9rZW4sXHJcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiB0aGlzLmFjY2Vzc1Rva2VuLFxyXG4gICAgICAgICAgICBleHBpcmF0aW9uVGltZTogdGhpcy5leHBpcmF0aW9uVGltZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBfYXNzaWduKHN0c1Rva2VuTWFuYWdlcikge1xyXG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBzdHNUb2tlbk1hbmFnZXIuYWNjZXNzVG9rZW47XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoVG9rZW4gPSBzdHNUb2tlbk1hbmFnZXIucmVmcmVzaFRva2VuO1xyXG4gICAgICAgIHRoaXMuZXhwaXJhdGlvblRpbWUgPSBzdHNUb2tlbk1hbmFnZXIuZXhwaXJhdGlvblRpbWU7XHJcbiAgICB9XHJcbiAgICBfY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFN0c1Rva2VuTWFuYWdlcigpLCB0aGlzLnRvSlNPTigpKTtcclxuICAgIH1cclxuICAgIF9wZXJmb3JtUmVmcmVzaCgpIHtcclxuICAgICAgICByZXR1cm4gZGVidWdGYWlsKCdub3QgaW1wbGVtZW50ZWQnKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBhc3NlcnRTdHJpbmdPclVuZGVmaW5lZChhc3NlcnRpb24sIGFwcE5hbWUpIHtcclxuICAgIF9hc3NlcnQodHlwZW9mIGFzc2VydGlvbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGFzc2VydGlvbiA9PT0gJ3VuZGVmaW5lZCcsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovLCB7IGFwcE5hbWUgfSk7XHJcbn1cclxuY2xhc3MgVXNlckltcGwge1xyXG4gICAgY29uc3RydWN0b3IoX2EpIHtcclxuICAgICAgICB2YXIgeyB1aWQsIGF1dGgsIHN0c1Rva2VuTWFuYWdlciB9ID0gX2EsIG9wdCA9IF9fcmVzdChfYSwgW1widWlkXCIsIFwiYXV0aFwiLCBcInN0c1Rva2VuTWFuYWdlclwiXSk7XHJcbiAgICAgICAgLy8gRm9yIHRoZSB1c2VyIG9iamVjdCwgcHJvdmlkZXIgaXMgYWx3YXlzIEZpcmViYXNlLlxyXG4gICAgICAgIHRoaXMucHJvdmlkZXJJZCA9IFwiZmlyZWJhc2VcIiAvKiBQcm92aWRlcklkLkZJUkVCQVNFICovO1xyXG4gICAgICAgIHRoaXMucHJvYWN0aXZlUmVmcmVzaCA9IG5ldyBQcm9hY3RpdmVSZWZyZXNoKHRoaXMpO1xyXG4gICAgICAgIHRoaXMucmVsb2FkVXNlckluZm8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmVsb2FkTGlzdGVuZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudWlkID0gdWlkO1xyXG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XHJcbiAgICAgICAgdGhpcy5zdHNUb2tlbk1hbmFnZXIgPSBzdHNUb2tlbk1hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IHN0c1Rva2VuTWFuYWdlci5hY2Nlc3NUb2tlbjtcclxuICAgICAgICB0aGlzLmRpc3BsYXlOYW1lID0gb3B0LmRpc3BsYXlOYW1lIHx8IG51bGw7XHJcbiAgICAgICAgdGhpcy5lbWFpbCA9IG9wdC5lbWFpbCB8fCBudWxsO1xyXG4gICAgICAgIHRoaXMuZW1haWxWZXJpZmllZCA9IG9wdC5lbWFpbFZlcmlmaWVkIHx8IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucGhvbmVOdW1iZXIgPSBvcHQucGhvbmVOdW1iZXIgfHwgbnVsbDtcclxuICAgICAgICB0aGlzLnBob3RvVVJMID0gb3B0LnBob3RvVVJMIHx8IG51bGw7XHJcbiAgICAgICAgdGhpcy5pc0Fub255bW91cyA9IG9wdC5pc0Fub255bW91cyB8fCBmYWxzZTtcclxuICAgICAgICB0aGlzLnRlbmFudElkID0gb3B0LnRlbmFudElkIHx8IG51bGw7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlckRhdGEgPSBvcHQucHJvdmlkZXJEYXRhID8gWy4uLm9wdC5wcm92aWRlckRhdGFdIDogW107XHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG5ldyBVc2VyTWV0YWRhdGEob3B0LmNyZWF0ZWRBdCB8fCB1bmRlZmluZWQsIG9wdC5sYXN0TG9naW5BdCB8fCB1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0SWRUb2tlbihmb3JjZVJlZnJlc2gpIHtcclxuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IGF3YWl0IF9sb2dvdXRJZkludmFsaWRhdGVkKHRoaXMsIHRoaXMuc3RzVG9rZW5NYW5hZ2VyLmdldFRva2VuKHRoaXMuYXV0aCwgZm9yY2VSZWZyZXNoKSk7XHJcbiAgICAgICAgX2Fzc2VydChhY2Nlc3NUb2tlbiwgdGhpcy5hdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICAgICAgaWYgKHRoaXMuYWNjZXNzVG9rZW4gIT09IGFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbjtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hdXRoLl9wZXJzaXN0VXNlcklmQ3VycmVudCh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5hdXRoLl9ub3RpZnlMaXN0ZW5lcnNJZkN1cnJlbnQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhY2Nlc3NUb2tlbjtcclxuICAgIH1cclxuICAgIGdldElkVG9rZW5SZXN1bHQoZm9yY2VSZWZyZXNoKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldElkVG9rZW5SZXN1bHQodGhpcywgZm9yY2VSZWZyZXNoKTtcclxuICAgIH1cclxuICAgIHJlbG9hZCgpIHtcclxuICAgICAgICByZXR1cm4gcmVsb2FkKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgX2Fzc2lnbih1c2VyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMgPT09IHVzZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfYXNzZXJ0KHRoaXMudWlkID09PSB1c2VyLnVpZCwgdGhpcy5hdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5TmFtZSA9IHVzZXIuZGlzcGxheU5hbWU7XHJcbiAgICAgICAgdGhpcy5waG90b1VSTCA9IHVzZXIucGhvdG9VUkw7XHJcbiAgICAgICAgdGhpcy5lbWFpbCA9IHVzZXIuZW1haWw7XHJcbiAgICAgICAgdGhpcy5lbWFpbFZlcmlmaWVkID0gdXNlci5lbWFpbFZlcmlmaWVkO1xyXG4gICAgICAgIHRoaXMucGhvbmVOdW1iZXIgPSB1c2VyLnBob25lTnVtYmVyO1xyXG4gICAgICAgIHRoaXMuaXNBbm9ueW1vdXMgPSB1c2VyLmlzQW5vbnltb3VzO1xyXG4gICAgICAgIHRoaXMudGVuYW50SWQgPSB1c2VyLnRlbmFudElkO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJEYXRhID0gdXNlci5wcm92aWRlckRhdGEubWFwKHVzZXJJbmZvID0+IChPYmplY3QuYXNzaWduKHt9LCB1c2VySW5mbykpKTtcclxuICAgICAgICB0aGlzLm1ldGFkYXRhLl9jb3B5KHVzZXIubWV0YWRhdGEpO1xyXG4gICAgICAgIHRoaXMuc3RzVG9rZW5NYW5hZ2VyLl9hc3NpZ24odXNlci5zdHNUb2tlbk1hbmFnZXIpO1xyXG4gICAgfVxyXG4gICAgX2Nsb25lKGF1dGgpIHtcclxuICAgICAgICBjb25zdCBuZXdVc2VyID0gbmV3IFVzZXJJbXBsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcyksIHsgYXV0aCwgc3RzVG9rZW5NYW5hZ2VyOiB0aGlzLnN0c1Rva2VuTWFuYWdlci5fY2xvbmUoKSB9KSk7XHJcbiAgICAgICAgbmV3VXNlci5tZXRhZGF0YS5fY29weSh0aGlzLm1ldGFkYXRhKTtcclxuICAgICAgICByZXR1cm4gbmV3VXNlcjtcclxuICAgIH1cclxuICAgIF9vblJlbG9hZChjYWxsYmFjaykge1xyXG4gICAgICAgIC8vIFRoZXJlIHNob3VsZCBvbmx5IGV2ZXIgYmUgb25lIGxpc3RlbmVyLCBhbmQgdGhhdCBpcyBhIHNpbmdsZSBpbnN0YW5jZSBvZiBNdWx0aUZhY3RvclVzZXJcclxuICAgICAgICBfYXNzZXJ0KCF0aGlzLnJlbG9hZExpc3RlbmVyLCB0aGlzLmF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICB0aGlzLnJlbG9hZExpc3RlbmVyID0gY2FsbGJhY2s7XHJcbiAgICAgICAgaWYgKHRoaXMucmVsb2FkVXNlckluZm8pIHtcclxuICAgICAgICAgICAgdGhpcy5fbm90aWZ5UmVsb2FkTGlzdGVuZXIodGhpcy5yZWxvYWRVc2VySW5mbyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVsb2FkVXNlckluZm8gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9ub3RpZnlSZWxvYWRMaXN0ZW5lcih1c2VySW5mbykge1xyXG4gICAgICAgIGlmICh0aGlzLnJlbG9hZExpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVsb2FkTGlzdGVuZXIodXNlckluZm8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSWYgbm8gbGlzdGVuZXIgaXMgc3Vic2NyaWJlZCB5ZXQsIHNhdmUgdGhlIHJlc3VsdCBzbyBpdCdzIGF2YWlsYWJsZSB3aGVuIHRoZXkgZG8gc3Vic2NyaWJlXHJcbiAgICAgICAgICAgIHRoaXMucmVsb2FkVXNlckluZm8gPSB1c2VySW5mbztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfc3RhcnRQcm9hY3RpdmVSZWZyZXNoKCkge1xyXG4gICAgICAgIHRoaXMucHJvYWN0aXZlUmVmcmVzaC5fc3RhcnQoKTtcclxuICAgIH1cclxuICAgIF9zdG9wUHJvYWN0aXZlUmVmcmVzaCgpIHtcclxuICAgICAgICB0aGlzLnByb2FjdGl2ZVJlZnJlc2guX3N0b3AoKTtcclxuICAgIH1cclxuICAgIGFzeW5jIF91cGRhdGVUb2tlbnNJZk5lY2Vzc2FyeShyZXNwb25zZSwgcmVsb2FkID0gZmFsc2UpIHtcclxuICAgICAgICBsZXQgdG9rZW5zUmVmcmVzaGVkID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlLmlkVG9rZW4gJiZcclxuICAgICAgICAgICAgcmVzcG9uc2UuaWRUb2tlbiAhPT0gdGhpcy5zdHNUb2tlbk1hbmFnZXIuYWNjZXNzVG9rZW4pIHtcclxuICAgICAgICAgICAgdGhpcy5zdHNUb2tlbk1hbmFnZXIudXBkYXRlRnJvbVNlcnZlclJlc3BvbnNlKHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgdG9rZW5zUmVmcmVzaGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlbG9hZCkge1xyXG4gICAgICAgICAgICBhd2FpdCBfcmVsb2FkV2l0aG91dFNhdmluZyh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXdhaXQgdGhpcy5hdXRoLl9wZXJzaXN0VXNlcklmQ3VycmVudCh0aGlzKTtcclxuICAgICAgICBpZiAodG9rZW5zUmVmcmVzaGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXV0aC5fbm90aWZ5TGlzdGVuZXJzSWZDdXJyZW50KHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzeW5jIGRlbGV0ZSgpIHtcclxuICAgICAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAodGhpcy5hdXRoLmFwcCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKHRoaXMuYXV0aCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpZFRva2VuID0gYXdhaXQgdGhpcy5nZXRJZFRva2VuKCk7XHJcbiAgICAgICAgYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodGhpcywgZGVsZXRlQWNjb3VudCh0aGlzLmF1dGgsIHsgaWRUb2tlbiB9KSk7XHJcbiAgICAgICAgdGhpcy5zdHNUb2tlbk1hbmFnZXIuY2xlYXJSZWZyZXNoVG9rZW4oKTtcclxuICAgICAgICAvLyBUT0RPOiBEZXRlcm1pbmUgaWYgY2FuY2VsbGFibGUtcHJvbWlzZXMgYXJlIG5lY2Vzc2FyeSB0byB1c2UgaW4gdGhpcyBjbGFzcyBzbyB0aGF0IGRlbGV0ZSgpXHJcbiAgICAgICAgLy8gICAgICAgY2FuY2VscyBwZW5kaW5nIGFjdGlvbnMuLi5cclxuICAgICAgICByZXR1cm4gdGhpcy5hdXRoLnNpZ25PdXQoKTtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdWlkOiB0aGlzLnVpZCwgZW1haWw6IHRoaXMuZW1haWwgfHwgdW5kZWZpbmVkLCBlbWFpbFZlcmlmaWVkOiB0aGlzLmVtYWlsVmVyaWZpZWQsIGRpc3BsYXlOYW1lOiB0aGlzLmRpc3BsYXlOYW1lIHx8IHVuZGVmaW5lZCwgaXNBbm9ueW1vdXM6IHRoaXMuaXNBbm9ueW1vdXMsIHBob3RvVVJMOiB0aGlzLnBob3RvVVJMIHx8IHVuZGVmaW5lZCwgcGhvbmVOdW1iZXI6IHRoaXMucGhvbmVOdW1iZXIgfHwgdW5kZWZpbmVkLCB0ZW5hbnRJZDogdGhpcy50ZW5hbnRJZCB8fCB1bmRlZmluZWQsIHByb3ZpZGVyRGF0YTogdGhpcy5wcm92aWRlckRhdGEubWFwKHVzZXJJbmZvID0+IChPYmplY3QuYXNzaWduKHt9LCB1c2VySW5mbykpKSwgc3RzVG9rZW5NYW5hZ2VyOiB0aGlzLnN0c1Rva2VuTWFuYWdlci50b0pTT04oKSwgXHJcbiAgICAgICAgICAgIC8vIFJlZGlyZWN0IGV2ZW50IElEIG11c3QgYmUgbWFpbnRhaW5lZCBpbiBjYXNlIHRoZXJlIGlzIGEgcGVuZGluZ1xyXG4gICAgICAgICAgICAvLyByZWRpcmVjdCBldmVudC5cclxuICAgICAgICAgICAgX3JlZGlyZWN0RXZlbnRJZDogdGhpcy5fcmVkaXJlY3RFdmVudElkIH0sIHRoaXMubWV0YWRhdGEudG9KU09OKCkpLCB7IFxyXG4gICAgICAgICAgICAvLyBSZXF1aXJlZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBsZWdhY3kgU0RLIChnby9maXJlYmFzZS1hdXRoLXNkay1wZXJzaXN0ZW5jZS1wYXJzaW5nKTpcclxuICAgICAgICAgICAgYXBpS2V5OiB0aGlzLmF1dGguY29uZmlnLmFwaUtleSwgYXBwTmFtZTogdGhpcy5hdXRoLm5hbWUgfSk7XHJcbiAgICB9XHJcbiAgICBnZXQgcmVmcmVzaFRva2VuKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0c1Rva2VuTWFuYWdlci5yZWZyZXNoVG9rZW4gfHwgJyc7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2Zyb21KU09OKGF1dGgsIG9iamVjdCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XHJcbiAgICAgICAgY29uc3QgZGlzcGxheU5hbWUgPSAoX2EgPSBvYmplY3QuZGlzcGxheU5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCBlbWFpbCA9IChfYiA9IG9iamVjdC5lbWFpbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IHBob25lTnVtYmVyID0gKF9jID0gb2JqZWN0LnBob25lTnVtYmVyKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgcGhvdG9VUkwgPSAoX2QgPSBvYmplY3QucGhvdG9VUkwpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCB0ZW5hbnRJZCA9IChfZSA9IG9iamVjdC50ZW5hbnRJZCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IF9yZWRpcmVjdEV2ZW50SWQgPSAoX2YgPSBvYmplY3QuX3JlZGlyZWN0RXZlbnRJZCkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IGNyZWF0ZWRBdCA9IChfZyA9IG9iamVjdC5jcmVhdGVkQXQpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCBsYXN0TG9naW5BdCA9IChfaCA9IG9iamVjdC5sYXN0TG9naW5BdCkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IHsgdWlkLCBlbWFpbFZlcmlmaWVkLCBpc0Fub255bW91cywgcHJvdmlkZXJEYXRhLCBzdHNUb2tlbk1hbmFnZXI6IHBsYWluT2JqZWN0VG9rZW5NYW5hZ2VyIH0gPSBvYmplY3Q7XHJcbiAgICAgICAgX2Fzc2VydCh1aWQgJiYgcGxhaW5PYmplY3RUb2tlbk1hbmFnZXIsIGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICBjb25zdCBzdHNUb2tlbk1hbmFnZXIgPSBTdHNUb2tlbk1hbmFnZXIuZnJvbUpTT04odGhpcy5uYW1lLCBwbGFpbk9iamVjdFRva2VuTWFuYWdlcik7XHJcbiAgICAgICAgX2Fzc2VydCh0eXBlb2YgdWlkID09PSAnc3RyaW5nJywgYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKGRpc3BsYXlOYW1lLCBhdXRoLm5hbWUpO1xyXG4gICAgICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKGVtYWlsLCBhdXRoLm5hbWUpO1xyXG4gICAgICAgIF9hc3NlcnQodHlwZW9mIGVtYWlsVmVyaWZpZWQgPT09ICdib29sZWFuJywgYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgICAgIF9hc3NlcnQodHlwZW9mIGlzQW5vbnltb3VzID09PSAnYm9vbGVhbicsIGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICBhc3NlcnRTdHJpbmdPclVuZGVmaW5lZChwaG9uZU51bWJlciwgYXV0aC5uYW1lKTtcclxuICAgICAgICBhc3NlcnRTdHJpbmdPclVuZGVmaW5lZChwaG90b1VSTCwgYXV0aC5uYW1lKTtcclxuICAgICAgICBhc3NlcnRTdHJpbmdPclVuZGVmaW5lZCh0ZW5hbnRJZCwgYXV0aC5uYW1lKTtcclxuICAgICAgICBhc3NlcnRTdHJpbmdPclVuZGVmaW5lZChfcmVkaXJlY3RFdmVudElkLCBhdXRoLm5hbWUpO1xyXG4gICAgICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKGNyZWF0ZWRBdCwgYXV0aC5uYW1lKTtcclxuICAgICAgICBhc3NlcnRTdHJpbmdPclVuZGVmaW5lZChsYXN0TG9naW5BdCwgYXV0aC5uYW1lKTtcclxuICAgICAgICBjb25zdCB1c2VyID0gbmV3IFVzZXJJbXBsKHtcclxuICAgICAgICAgICAgdWlkLFxyXG4gICAgICAgICAgICBhdXRoLFxyXG4gICAgICAgICAgICBlbWFpbCxcclxuICAgICAgICAgICAgZW1haWxWZXJpZmllZCxcclxuICAgICAgICAgICAgZGlzcGxheU5hbWUsXHJcbiAgICAgICAgICAgIGlzQW5vbnltb3VzLFxyXG4gICAgICAgICAgICBwaG90b1VSTCxcclxuICAgICAgICAgICAgcGhvbmVOdW1iZXIsXHJcbiAgICAgICAgICAgIHRlbmFudElkLFxyXG4gICAgICAgICAgICBzdHNUb2tlbk1hbmFnZXIsXHJcbiAgICAgICAgICAgIGNyZWF0ZWRBdCxcclxuICAgICAgICAgICAgbGFzdExvZ2luQXRcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAocHJvdmlkZXJEYXRhICYmIEFycmF5LmlzQXJyYXkocHJvdmlkZXJEYXRhKSkge1xyXG4gICAgICAgICAgICB1c2VyLnByb3ZpZGVyRGF0YSA9IHByb3ZpZGVyRGF0YS5tYXAodXNlckluZm8gPT4gKE9iamVjdC5hc3NpZ24oe30sIHVzZXJJbmZvKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX3JlZGlyZWN0RXZlbnRJZCkge1xyXG4gICAgICAgICAgICB1c2VyLl9yZWRpcmVjdEV2ZW50SWQgPSBfcmVkaXJlY3RFdmVudElkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdXNlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZSBhIFVzZXIgZnJvbSBhbiBpZFRva2VuIHNlcnZlciByZXNwb25zZVxyXG4gICAgICogQHBhcmFtIGF1dGhcclxuICAgICAqIEBwYXJhbSBpZFRva2VuUmVzcG9uc2VcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGFzeW5jIF9mcm9tSWRUb2tlblJlc3BvbnNlKGF1dGgsIGlkVG9rZW5SZXNwb25zZSwgaXNBbm9ueW1vdXMgPSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnN0IHN0c1Rva2VuTWFuYWdlciA9IG5ldyBTdHNUb2tlbk1hbmFnZXIoKTtcclxuICAgICAgICBzdHNUb2tlbk1hbmFnZXIudXBkYXRlRnJvbVNlcnZlclJlc3BvbnNlKGlkVG9rZW5SZXNwb25zZSk7XHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgRmlyZWJhc2UgQXV0aCB1c2VyLlxyXG4gICAgICAgIGNvbnN0IHVzZXIgPSBuZXcgVXNlckltcGwoe1xyXG4gICAgICAgICAgICB1aWQ6IGlkVG9rZW5SZXNwb25zZS5sb2NhbElkLFxyXG4gICAgICAgICAgICBhdXRoLFxyXG4gICAgICAgICAgICBzdHNUb2tlbk1hbmFnZXIsXHJcbiAgICAgICAgICAgIGlzQW5vbnltb3VzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gVXBkYXRlcyB0aGUgdXNlciBpbmZvIGFuZCBkYXRhIGFuZCByZXNvbHZlcyB3aXRoIGEgdXNlciBpbnN0YW5jZS5cclxuICAgICAgICBhd2FpdCBfcmVsb2FkV2l0aG91dFNhdmluZyh1c2VyKTtcclxuICAgICAgICByZXR1cm4gdXNlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZSBhIFVzZXIgZnJvbSBhbiBpZFRva2VuIHNlcnZlciByZXNwb25zZVxyXG4gICAgICogQHBhcmFtIGF1dGhcclxuICAgICAqIEBwYXJhbSBpZFRva2VuUmVzcG9uc2VcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGFzeW5jIF9mcm9tR2V0QWNjb3VudEluZm9SZXNwb25zZShhdXRoLCByZXNwb25zZSwgaWRUb2tlbikge1xyXG4gICAgICAgIGNvbnN0IGNvcmVBY2NvdW50ID0gcmVzcG9uc2UudXNlcnNbMF07XHJcbiAgICAgICAgX2Fzc2VydChjb3JlQWNjb3VudC5sb2NhbElkICE9PSB1bmRlZmluZWQsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICBjb25zdCBwcm92aWRlckRhdGEgPSBjb3JlQWNjb3VudC5wcm92aWRlclVzZXJJbmZvICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgPyBleHRyYWN0UHJvdmlkZXJEYXRhKGNvcmVBY2NvdW50LnByb3ZpZGVyVXNlckluZm8pXHJcbiAgICAgICAgICAgIDogW107XHJcbiAgICAgICAgY29uc3QgaXNBbm9ueW1vdXMgPSAhKGNvcmVBY2NvdW50LmVtYWlsICYmIGNvcmVBY2NvdW50LnBhc3N3b3JkSGFzaCkgJiYgIShwcm92aWRlckRhdGEgPT09IG51bGwgfHwgcHJvdmlkZXJEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm92aWRlckRhdGEubGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBzdHNUb2tlbk1hbmFnZXIgPSBuZXcgU3RzVG9rZW5NYW5hZ2VyKCk7XHJcbiAgICAgICAgc3RzVG9rZW5NYW5hZ2VyLnVwZGF0ZUZyb21JZFRva2VuKGlkVG9rZW4pO1xyXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIEZpcmViYXNlIEF1dGggdXNlci5cclxuICAgICAgICBjb25zdCB1c2VyID0gbmV3IFVzZXJJbXBsKHtcclxuICAgICAgICAgICAgdWlkOiBjb3JlQWNjb3VudC5sb2NhbElkLFxyXG4gICAgICAgICAgICBhdXRoLFxyXG4gICAgICAgICAgICBzdHNUb2tlbk1hbmFnZXIsXHJcbiAgICAgICAgICAgIGlzQW5vbnltb3VzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gdXBkYXRlIHRoZSB1c2VyIHdpdGggZGF0YSBmcm9tIHRoZSBHZXRBY2NvdW50SW5mbyByZXNwb25zZS5cclxuICAgICAgICBjb25zdCB1cGRhdGVzID0ge1xyXG4gICAgICAgICAgICB1aWQ6IGNvcmVBY2NvdW50LmxvY2FsSWQsXHJcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBjb3JlQWNjb3VudC5kaXNwbGF5TmFtZSB8fCBudWxsLFxyXG4gICAgICAgICAgICBwaG90b1VSTDogY29yZUFjY291bnQucGhvdG9VcmwgfHwgbnVsbCxcclxuICAgICAgICAgICAgZW1haWw6IGNvcmVBY2NvdW50LmVtYWlsIHx8IG51bGwsXHJcbiAgICAgICAgICAgIGVtYWlsVmVyaWZpZWQ6IGNvcmVBY2NvdW50LmVtYWlsVmVyaWZpZWQgfHwgZmFsc2UsXHJcbiAgICAgICAgICAgIHBob25lTnVtYmVyOiBjb3JlQWNjb3VudC5waG9uZU51bWJlciB8fCBudWxsLFxyXG4gICAgICAgICAgICB0ZW5hbnRJZDogY29yZUFjY291bnQudGVuYW50SWQgfHwgbnVsbCxcclxuICAgICAgICAgICAgcHJvdmlkZXJEYXRhLFxyXG4gICAgICAgICAgICBtZXRhZGF0YTogbmV3IFVzZXJNZXRhZGF0YShjb3JlQWNjb3VudC5jcmVhdGVkQXQsIGNvcmVBY2NvdW50Lmxhc3RMb2dpbkF0KSxcclxuICAgICAgICAgICAgaXNBbm9ueW1vdXM6ICEoY29yZUFjY291bnQuZW1haWwgJiYgY29yZUFjY291bnQucGFzc3dvcmRIYXNoKSAmJlxyXG4gICAgICAgICAgICAgICAgIShwcm92aWRlckRhdGEgPT09IG51bGwgfHwgcHJvdmlkZXJEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm92aWRlckRhdGEubGVuZ3RoKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbih1c2VyLCB1cGRhdGVzKTtcclxuICAgICAgICByZXR1cm4gdXNlcjtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBpbnN0YW5jZUNhY2hlID0gbmV3IE1hcCgpO1xyXG5mdW5jdGlvbiBfZ2V0SW5zdGFuY2UoY2xzKSB7XHJcbiAgICBkZWJ1Z0Fzc2VydChjbHMgaW5zdGFuY2VvZiBGdW5jdGlvbiwgJ0V4cGVjdGVkIGEgY2xhc3MgZGVmaW5pdGlvbicpO1xyXG4gICAgbGV0IGluc3RhbmNlID0gaW5zdGFuY2VDYWNoZS5nZXQoY2xzKTtcclxuICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgIGRlYnVnQXNzZXJ0KGluc3RhbmNlIGluc3RhbmNlb2YgY2xzLCAnSW5zdGFuY2Ugc3RvcmVkIGluIGNhY2hlIG1pc21hdGNoZWQgd2l0aCBjbGFzcycpO1xyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcclxuICAgIH1cclxuICAgIGluc3RhbmNlID0gbmV3IGNscygpO1xyXG4gICAgaW5zdGFuY2VDYWNoZS5zZXQoY2xzLCBpbnN0YW5jZSk7XHJcbiAgICByZXR1cm4gaW5zdGFuY2U7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgSW5NZW1vcnlQZXJzaXN0ZW5jZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIk5PTkVcIiAvKiBQZXJzaXN0ZW5jZVR5cGUuTk9ORSAqLztcclxuICAgICAgICB0aGlzLnN0b3JhZ2UgPSB7fTtcclxuICAgIH1cclxuICAgIGFzeW5jIF9pc0F2YWlsYWJsZSgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGFzeW5jIF9zZXQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuc3RvcmFnZVtrZXldID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBhc3luYyBfZ2V0KGtleSkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zdG9yYWdlW2tleV07XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyBudWxsIDogdmFsdWU7XHJcbiAgICB9XHJcbiAgICBhc3luYyBfcmVtb3ZlKGtleSkge1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnN0b3JhZ2Vba2V5XTtcclxuICAgIH1cclxuICAgIF9hZGRMaXN0ZW5lcihfa2V5LCBfbGlzdGVuZXIpIHtcclxuICAgICAgICAvLyBMaXN0ZW5lcnMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIGluLW1lbW9yeSBzdG9yYWdlIHNpbmNlIGl0IGNhbm5vdCBiZSBzaGFyZWQgYWNyb3NzIHdpbmRvd3Mvd29ya2Vyc1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIF9yZW1vdmVMaXN0ZW5lcihfa2V5LCBfbGlzdGVuZXIpIHtcclxuICAgICAgICAvLyBMaXN0ZW5lcnMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIGluLW1lbW9yeSBzdG9yYWdlIHNpbmNlIGl0IGNhbm5vdCBiZSBzaGFyZWQgYWNyb3NzIHdpbmRvd3Mvd29ya2Vyc1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxufVxyXG5Jbk1lbW9yeVBlcnNpc3RlbmNlLnR5cGUgPSAnTk9ORSc7XHJcbi8qKlxyXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgUGVyc2lzdGVuY2V9IG9mIHR5cGUgJ05PTkUnLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBpbk1lbW9yeVBlcnNpc3RlbmNlID0gSW5NZW1vcnlQZXJzaXN0ZW5jZTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gX3BlcnNpc3RlbmNlS2V5TmFtZShrZXksIGFwaUtleSwgYXBwTmFtZSkge1xyXG4gICAgcmV0dXJuIGAke1wiZmlyZWJhc2VcIiAvKiBOYW1lc3BhY2UuUEVSU0lTVEVOQ0UgKi99OiR7a2V5fToke2FwaUtleX06JHthcHBOYW1lfWA7XHJcbn1cclxuY2xhc3MgUGVyc2lzdGVuY2VVc2VyTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihwZXJzaXN0ZW5jZSwgYXV0aCwgdXNlcktleSkge1xyXG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcclxuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xyXG4gICAgICAgIHRoaXMudXNlcktleSA9IHVzZXJLZXk7XHJcbiAgICAgICAgY29uc3QgeyBjb25maWcsIG5hbWUgfSA9IHRoaXMuYXV0aDtcclxuICAgICAgICB0aGlzLmZ1bGxVc2VyS2V5ID0gX3BlcnNpc3RlbmNlS2V5TmFtZSh0aGlzLnVzZXJLZXksIGNvbmZpZy5hcGlLZXksIG5hbWUpO1xyXG4gICAgICAgIHRoaXMuZnVsbFBlcnNpc3RlbmNlS2V5ID0gX3BlcnNpc3RlbmNlS2V5TmFtZShcInBlcnNpc3RlbmNlXCIgLyogS2V5TmFtZS5QRVJTSVNURU5DRV9VU0VSICovLCBjb25maWcuYXBpS2V5LCBuYW1lKTtcclxuICAgICAgICB0aGlzLmJvdW5kRXZlbnRIYW5kbGVyID0gYXV0aC5fb25TdG9yYWdlRXZlbnQuYmluZChhdXRoKTtcclxuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlLl9hZGRMaXN0ZW5lcih0aGlzLmZ1bGxVc2VyS2V5LCB0aGlzLmJvdW5kRXZlbnRIYW5kbGVyKTtcclxuICAgIH1cclxuICAgIHNldEN1cnJlbnRVc2VyKHVzZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wZXJzaXN0ZW5jZS5fc2V0KHRoaXMuZnVsbFVzZXJLZXksIHVzZXIudG9KU09OKCkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0Q3VycmVudFVzZXIoKSB7XHJcbiAgICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IHRoaXMucGVyc2lzdGVuY2UuX2dldCh0aGlzLmZ1bGxVc2VyS2V5KTtcclxuICAgICAgICByZXR1cm4gYmxvYiA/IFVzZXJJbXBsLl9mcm9tSlNPTih0aGlzLmF1dGgsIGJsb2IpIDogbnVsbDtcclxuICAgIH1cclxuICAgIHJlbW92ZUN1cnJlbnRVc2VyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlLl9yZW1vdmUodGhpcy5mdWxsVXNlcktleSk7XHJcbiAgICB9XHJcbiAgICBzYXZlUGVyc2lzdGVuY2VGb3JSZWRpcmVjdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wZXJzaXN0ZW5jZS5fc2V0KHRoaXMuZnVsbFBlcnNpc3RlbmNlS2V5LCB0aGlzLnBlcnNpc3RlbmNlLnR5cGUpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc2V0UGVyc2lzdGVuY2UobmV3UGVyc2lzdGVuY2UpIHtcclxuICAgICAgICBpZiAodGhpcy5wZXJzaXN0ZW5jZSA9PT0gbmV3UGVyc2lzdGVuY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjdXJyZW50VXNlciA9IGF3YWl0IHRoaXMuZ2V0Q3VycmVudFVzZXIoKTtcclxuICAgICAgICBhd2FpdCB0aGlzLnJlbW92ZUN1cnJlbnRVc2VyKCk7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZSA9IG5ld1BlcnNpc3RlbmNlO1xyXG4gICAgICAgIGlmIChjdXJyZW50VXNlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRDdXJyZW50VXNlcihjdXJyZW50VXNlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVsZXRlKCkge1xyXG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UuX3JlbW92ZUxpc3RlbmVyKHRoaXMuZnVsbFVzZXJLZXksIHRoaXMuYm91bmRFdmVudEhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShhdXRoLCBwZXJzaXN0ZW5jZUhpZXJhcmNoeSwgdXNlcktleSA9IFwiYXV0aFVzZXJcIiAvKiBLZXlOYW1lLkFVVEhfVVNFUiAqLykge1xyXG4gICAgICAgIGlmICghcGVyc2lzdGVuY2VIaWVyYXJjaHkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VVc2VyTWFuYWdlcihfZ2V0SW5zdGFuY2UoaW5NZW1vcnlQZXJzaXN0ZW5jZSksIGF1dGgsIHVzZXJLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBFbGltaW5hdGUgYW55IHBlcnNpc3RlbmNlcyB0aGF0IGFyZSBub3QgYXZhaWxhYmxlXHJcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlUGVyc2lzdGVuY2VzID0gKGF3YWl0IFByb21pc2UuYWxsKHBlcnNpc3RlbmNlSGllcmFyY2h5Lm1hcChhc3luYyAocGVyc2lzdGVuY2UpID0+IHtcclxuICAgICAgICAgICAgaWYgKGF3YWl0IHBlcnNpc3RlbmNlLl9pc0F2YWlsYWJsZSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGVyc2lzdGVuY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9KSkpLmZpbHRlcihwZXJzaXN0ZW5jZSA9PiBwZXJzaXN0ZW5jZSk7XHJcbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBmaXJzdCBwZXJzaXN0ZW5jZSBsaXN0ZWQsIG9yIGluIG1lbW9yeSBpZiBub25lIGF2YWlsYWJsZVxyXG4gICAgICAgIGxldCBzZWxlY3RlZFBlcnNpc3RlbmNlID0gYXZhaWxhYmxlUGVyc2lzdGVuY2VzWzBdIHx8XHJcbiAgICAgICAgICAgIF9nZXRJbnN0YW5jZShpbk1lbW9yeVBlcnNpc3RlbmNlKTtcclxuICAgICAgICBjb25zdCBrZXkgPSBfcGVyc2lzdGVuY2VLZXlOYW1lKHVzZXJLZXksIGF1dGguY29uZmlnLmFwaUtleSwgYXV0aC5uYW1lKTtcclxuICAgICAgICAvLyBQdWxsIG91dCB0aGUgZXhpc3RpbmcgdXNlciwgc2V0dGluZyB0aGUgY2hvc2VuIHBlcnNpc3RlbmNlIHRvIHRoYXRcclxuICAgICAgICAvLyBwZXJzaXN0ZW5jZSBpZiB0aGUgdXNlciBleGlzdHMuXHJcbiAgICAgICAgbGV0IHVzZXJUb01pZ3JhdGUgPSBudWxsO1xyXG4gICAgICAgIC8vIE5vdGUsIGhlcmUgd2UgY2hlY2sgZm9yIGEgdXNlciBpbiBfYWxsXyBwZXJzaXN0ZW5jZXMsIG5vdCBqdXN0IHRoZVxyXG4gICAgICAgIC8vIG9uZXMgZGVlbWVkIGF2YWlsYWJsZS4gSWYgd2UgY2FuIG1pZ3JhdGUgYSB1c2VyIG91dCBvZiBhIGJyb2tlblxyXG4gICAgICAgIC8vIHBlcnNpc3RlbmNlLCB3ZSB3aWxsIChidXQgb25seSBpZiB0aGF0IHBlcnNpc3RlbmNlIHN1cHBvcnRzIG1pZ3JhdGlvbikuXHJcbiAgICAgICAgZm9yIChjb25zdCBwZXJzaXN0ZW5jZSBvZiBwZXJzaXN0ZW5jZUhpZXJhcmNoeSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IHBlcnNpc3RlbmNlLl9nZXQoa2V5KTtcclxuICAgICAgICAgICAgICAgIGlmIChibG9iKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlciA9IFVzZXJJbXBsLl9mcm9tSlNPTihhdXRoLCBibG9iKTsgLy8gdGhyb3dzIGZvciB1bnBhcnNhYmxlIGJsb2IgKHdyb25nIGZvcm1hdClcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGVyc2lzdGVuY2UgIT09IHNlbGVjdGVkUGVyc2lzdGVuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlclRvTWlncmF0ZSA9IHVzZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkUGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB3ZSBmaW5kIHRoZSB1c2VyIGluIGEgcGVyc2lzdGVuY2UgdGhhdCBkb2VzIHN1cHBvcnQgbWlncmF0aW9uLCB1c2VcclxuICAgICAgICAvLyB0aGF0IG1pZ3JhdGlvbiBwYXRoIChvZiBvbmx5IHBlcnNpc3RlbmNlcyB0aGF0IHN1cHBvcnQgbWlncmF0aW9uKVxyXG4gICAgICAgIGNvbnN0IG1pZ3JhdGlvbkhpZXJhcmNoeSA9IGF2YWlsYWJsZVBlcnNpc3RlbmNlcy5maWx0ZXIocCA9PiBwLl9zaG91bGRBbGxvd01pZ3JhdGlvbik7XHJcbiAgICAgICAgLy8gSWYgdGhlIHBlcnNpc3RlbmNlIGRvZXMgX25vdF8gYWxsb3cgbWlncmF0aW9uLCBqdXN0IGZpbmlzaCBvZmYgaGVyZVxyXG4gICAgICAgIGlmICghc2VsZWN0ZWRQZXJzaXN0ZW5jZS5fc2hvdWxkQWxsb3dNaWdyYXRpb24gfHxcclxuICAgICAgICAgICAgIW1pZ3JhdGlvbkhpZXJhcmNoeS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVVzZXJNYW5hZ2VyKHNlbGVjdGVkUGVyc2lzdGVuY2UsIGF1dGgsIHVzZXJLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWxlY3RlZFBlcnNpc3RlbmNlID0gbWlncmF0aW9uSGllcmFyY2h5WzBdO1xyXG4gICAgICAgIGlmICh1c2VyVG9NaWdyYXRlKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgbm9ybWFsbHkgc2hvdWxkbid0IHRocm93IHNpbmNlIGNob3NlblBlcnNpc3RlbmNlLmlzQXZhaWxhYmxlKCkgaXMgdHJ1ZSwgYnV0IGlmIGl0IGRvZXNcclxuICAgICAgICAgICAgLy8gd2UnbGwganVzdCBsZXQgaXQgYnViYmxlIHRvIHN1cmZhY2UgdGhlIGVycm9yLlxyXG4gICAgICAgICAgICBhd2FpdCBzZWxlY3RlZFBlcnNpc3RlbmNlLl9zZXQoa2V5LCB1c2VyVG9NaWdyYXRlLnRvSlNPTigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBjbGVhciB0aGUga2V5IGluIG90aGVyIHBlcnNpc3RlbmNlcyBidXQgaWdub3JlIGVycm9ycy4gVGhpcyBoZWxwcyBwcmV2ZW50IGlzc3Vlc1xyXG4gICAgICAgIC8vIHN1Y2ggYXMgdXNlcnMgZ2V0dGluZyBzdHVjayB3aXRoIGEgcHJldmlvdXMgYWNjb3VudCBhZnRlciBzaWduaW5nIG91dCBhbmQgcmVmcmVzaGluZyB0aGUgdGFiLlxyXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHBlcnNpc3RlbmNlSGllcmFyY2h5Lm1hcChhc3luYyAocGVyc2lzdGVuY2UpID0+IHtcclxuICAgICAgICAgICAgaWYgKHBlcnNpc3RlbmNlICE9PSBzZWxlY3RlZFBlcnNpc3RlbmNlKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHBlcnNpc3RlbmNlLl9yZW1vdmUoa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVVzZXJNYW5hZ2VyKHNlbGVjdGVkUGVyc2lzdGVuY2UsIGF1dGgsIHVzZXJLZXkpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmUgdGhlIGJyb3dzZXIgZm9yIHRoZSBwdXJwb3NlcyBvZiByZXBvcnRpbmcgdXNhZ2UgdG8gdGhlIEFQSVxyXG4gKi9cclxuZnVuY3Rpb24gX2dldEJyb3dzZXJOYW1lKHVzZXJBZ2VudCkge1xyXG4gICAgY29uc3QgdWEgPSB1c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcclxuICAgIGlmICh1YS5pbmNsdWRlcygnb3BlcmEvJykgfHwgdWEuaW5jbHVkZXMoJ29wci8nKSB8fCB1YS5pbmNsdWRlcygnb3Bpb3MvJykpIHtcclxuICAgICAgICByZXR1cm4gXCJPcGVyYVwiIC8qIEJyb3dzZXJOYW1lLk9QRVJBICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoX2lzSUVNb2JpbGUodWEpKSB7XHJcbiAgICAgICAgLy8gV2luZG93cyBwaG9uZSBJRU1vYmlsZSBicm93c2VyLlxyXG4gICAgICAgIHJldHVybiBcIklFTW9iaWxlXCIgLyogQnJvd3Nlck5hbWUuSUVNT0JJTEUgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh1YS5pbmNsdWRlcygnbXNpZScpIHx8IHVhLmluY2x1ZGVzKCd0cmlkZW50LycpKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiSUVcIiAvKiBCcm93c2VyTmFtZS5JRSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHVhLmluY2x1ZGVzKCdlZGdlLycpKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiRWRnZVwiIC8qIEJyb3dzZXJOYW1lLkVER0UgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChfaXNGaXJlZm94KHVhKSkge1xyXG4gICAgICAgIHJldHVybiBcIkZpcmVmb3hcIiAvKiBCcm93c2VyTmFtZS5GSVJFRk9YICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodWEuaW5jbHVkZXMoJ3NpbGsvJykpIHtcclxuICAgICAgICByZXR1cm4gXCJTaWxrXCIgLyogQnJvd3Nlck5hbWUuU0lMSyAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKF9pc0JsYWNrQmVycnkodWEpKSB7XHJcbiAgICAgICAgLy8gQmxhY2tiZXJyeSBicm93c2VyLlxyXG4gICAgICAgIHJldHVybiBcIkJsYWNrYmVycnlcIiAvKiBCcm93c2VyTmFtZS5CTEFDS0JFUlJZICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoX2lzV2ViT1ModWEpKSB7XHJcbiAgICAgICAgLy8gV2ViT1MgZGVmYXVsdCBicm93c2VyLlxyXG4gICAgICAgIHJldHVybiBcIldlYm9zXCIgLyogQnJvd3Nlck5hbWUuV0VCT1MgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChfaXNTYWZhcmkodWEpKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiU2FmYXJpXCIgLyogQnJvd3Nlck5hbWUuU0FGQVJJICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHVhLmluY2x1ZGVzKCdjaHJvbWUvJykgfHwgX2lzQ2hyb21lSU9TKHVhKSkgJiZcclxuICAgICAgICAhdWEuaW5jbHVkZXMoJ2VkZ2UvJykpIHtcclxuICAgICAgICByZXR1cm4gXCJDaHJvbWVcIiAvKiBCcm93c2VyTmFtZS5DSFJPTUUgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChfaXNBbmRyb2lkKHVhKSkge1xyXG4gICAgICAgIC8vIEFuZHJvaWQgc3RvY2sgYnJvd3Nlci5cclxuICAgICAgICByZXR1cm4gXCJBbmRyb2lkXCIgLyogQnJvd3Nlck5hbWUuQU5EUk9JRCAqLztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIE1vc3QgbW9kZXJuIGJyb3dzZXJzIGhhdmUgbmFtZS92ZXJzaW9uIGF0IGVuZCBvZiB1c2VyIGFnZW50IHN0cmluZy5cclxuICAgICAgICBjb25zdCByZSA9IC8oW2EtekEtWlxcZFxcLl0rKVxcL1thLXpBLVpcXGRcXC5dKiQvO1xyXG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB1c2VyQWdlbnQubWF0Y2gocmUpO1xyXG4gICAgICAgIGlmICgobWF0Y2hlcyA9PT0gbnVsbCB8fCBtYXRjaGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXRjaGVzLmxlbmd0aCkgPT09IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNbMV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwiT3RoZXJcIiAvKiBCcm93c2VyTmFtZS5PVEhFUiAqLztcclxufVxyXG5mdW5jdGlvbiBfaXNGaXJlZm94KHVhID0gZ2V0VUEoKSkge1xyXG4gICAgcmV0dXJuIC9maXJlZm94XFwvL2kudGVzdCh1YSk7XHJcbn1cclxuZnVuY3Rpb24gX2lzU2FmYXJpKHVzZXJBZ2VudCA9IGdldFVBKCkpIHtcclxuICAgIGNvbnN0IHVhID0gdXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XHJcbiAgICByZXR1cm4gKHVhLmluY2x1ZGVzKCdzYWZhcmkvJykgJiZcclxuICAgICAgICAhdWEuaW5jbHVkZXMoJ2Nocm9tZS8nKSAmJlxyXG4gICAgICAgICF1YS5pbmNsdWRlcygnY3Jpb3MvJykgJiZcclxuICAgICAgICAhdWEuaW5jbHVkZXMoJ2FuZHJvaWQnKSk7XHJcbn1cclxuZnVuY3Rpb24gX2lzQ2hyb21lSU9TKHVhID0gZ2V0VUEoKSkge1xyXG4gICAgcmV0dXJuIC9jcmlvc1xcLy9pLnRlc3QodWEpO1xyXG59XHJcbmZ1bmN0aW9uIF9pc0lFTW9iaWxlKHVhID0gZ2V0VUEoKSkge1xyXG4gICAgcmV0dXJuIC9pZW1vYmlsZS9pLnRlc3QodWEpO1xyXG59XHJcbmZ1bmN0aW9uIF9pc0FuZHJvaWQodWEgPSBnZXRVQSgpKSB7XHJcbiAgICByZXR1cm4gL2FuZHJvaWQvaS50ZXN0KHVhKTtcclxufVxyXG5mdW5jdGlvbiBfaXNCbGFja0JlcnJ5KHVhID0gZ2V0VUEoKSkge1xyXG4gICAgcmV0dXJuIC9ibGFja2JlcnJ5L2kudGVzdCh1YSk7XHJcbn1cclxuZnVuY3Rpb24gX2lzV2ViT1ModWEgPSBnZXRVQSgpKSB7XHJcbiAgICByZXR1cm4gL3dlYm9zL2kudGVzdCh1YSk7XHJcbn1cclxuZnVuY3Rpb24gX2lzSU9TKHVhID0gZ2V0VUEoKSkge1xyXG4gICAgcmV0dXJuICgvaXBob25lfGlwYWR8aXBvZC9pLnRlc3QodWEpIHx8XHJcbiAgICAgICAgKC9tYWNpbnRvc2gvaS50ZXN0KHVhKSAmJiAvbW9iaWxlL2kudGVzdCh1YSkpKTtcclxufVxyXG5mdW5jdGlvbiBfaXNJT1M3T3I4KHVhID0gZ2V0VUEoKSkge1xyXG4gICAgcmV0dXJuICgvKGlQYWR8aVBob25lfGlQb2QpLipPUyA3X1xcZC9pLnRlc3QodWEpIHx8XHJcbiAgICAgICAgLyhpUGFkfGlQaG9uZXxpUG9kKS4qT1MgOF9cXGQvaS50ZXN0KHVhKSk7XHJcbn1cclxuZnVuY3Rpb24gX2lzSUUxMCgpIHtcclxuICAgIHJldHVybiBpc0lFKCkgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID09PSAxMDtcclxufVxyXG5mdW5jdGlvbiBfaXNNb2JpbGVCcm93c2VyKHVhID0gZ2V0VUEoKSkge1xyXG4gICAgLy8gVE9ETzogaW1wbGVtZW50IGdldEJyb3dzZXJOYW1lIGVxdWl2YWxlbnQgZm9yIE9TLlxyXG4gICAgcmV0dXJuIChfaXNJT1ModWEpIHx8XHJcbiAgICAgICAgX2lzQW5kcm9pZCh1YSkgfHxcclxuICAgICAgICBfaXNXZWJPUyh1YSkgfHxcclxuICAgICAgICBfaXNCbGFja0JlcnJ5KHVhKSB8fFxyXG4gICAgICAgIC93aW5kb3dzIHBob25lL2kudGVzdCh1YSkgfHxcclxuICAgICAgICBfaXNJRU1vYmlsZSh1YSkpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qXHJcbiAqIERldGVybWluZSB0aGUgU0RLIHZlcnNpb24gc3RyaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBfZ2V0Q2xpZW50VmVyc2lvbihjbGllbnRQbGF0Zm9ybSwgZnJhbWV3b3JrcyA9IFtdKSB7XHJcbiAgICBsZXQgcmVwb3J0ZWRQbGF0Zm9ybTtcclxuICAgIHN3aXRjaCAoY2xpZW50UGxhdGZvcm0pIHtcclxuICAgICAgICBjYXNlIFwiQnJvd3NlclwiIC8qIENsaWVudFBsYXRmb3JtLkJST1dTRVIgKi86XHJcbiAgICAgICAgICAgIC8vIEluIGEgYnJvd3NlciBlbnZpcm9ubWVudCwgcmVwb3J0IHRoZSBicm93c2VyIG5hbWUuXHJcbiAgICAgICAgICAgIHJlcG9ydGVkUGxhdGZvcm0gPSBfZ2V0QnJvd3Nlck5hbWUoZ2V0VUEoKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJXb3JrZXJcIiAvKiBDbGllbnRQbGF0Zm9ybS5XT1JLRVIgKi86XHJcbiAgICAgICAgICAgIC8vIFRlY2huaWNhbGx5IGEgd29ya2VyIHJ1bnMgZnJvbSBhIGJyb3dzZXIgYnV0IHdlIG5lZWQgdG8gZGlmZmVyZW50aWF0ZSBhXHJcbiAgICAgICAgICAgIC8vIHdvcmtlciBmcm9tIGEgYnJvd3Nlci5cclxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IENocm9tZS1Xb3JrZXIvSnNDb3JlLzQuOS4xL0ZpcmViYXNlQ29yZS13ZWIuXHJcbiAgICAgICAgICAgIHJlcG9ydGVkUGxhdGZvcm0gPSBgJHtfZ2V0QnJvd3Nlck5hbWUoZ2V0VUEoKSl9LSR7Y2xpZW50UGxhdGZvcm19YDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmVwb3J0ZWRQbGF0Zm9ybSA9IGNsaWVudFBsYXRmb3JtO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVwb3J0ZWRGcmFtZXdvcmtzID0gZnJhbWV3b3Jrcy5sZW5ndGhcclxuICAgICAgICA/IGZyYW1ld29ya3Muam9pbignLCcpXHJcbiAgICAgICAgOiAnRmlyZWJhc2VDb3JlLXdlYic7IC8qIGRlZmF1bHQgdmFsdWUgaWYgbm8gb3RoZXIgZnJhbWV3b3JrIGlzIHVzZWQgKi9cclxuICAgIHJldHVybiBgJHtyZXBvcnRlZFBsYXRmb3JtfS8ke1wiSnNDb3JlXCIgLyogQ2xpZW50SW1wbGVtZW50YXRpb24uQ09SRSAqL30vJHtTREtfVkVSU0lPTn0vJHtyZXBvcnRlZEZyYW1ld29ya3N9YDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBBdXRoTWlkZGxld2FyZVF1ZXVlIHtcclxuICAgIGNvbnN0cnVjdG9yKGF1dGgpIHtcclxuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xyXG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcclxuICAgIH1cclxuICAgIHB1c2hDYWxsYmFjayhjYWxsYmFjaywgb25BYm9ydCkge1xyXG4gICAgICAgIC8vIFRoZSBjYWxsYmFjayBjb3VsZCBiZSBzeW5jIG9yIGFzeW5jLiBXcmFwIGl0IGludG8gYVxyXG4gICAgICAgIC8vIGZ1bmN0aW9uIHRoYXQgaXMgYWx3YXlzIGFzeW5jLlxyXG4gICAgICAgIGNvbnN0IHdyYXBwZWRDYWxsYmFjayA9ICh1c2VyKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYWxsYmFjayh1c2VyKTtcclxuICAgICAgICAgICAgICAgIC8vIEVpdGhlciByZXNvbHZlIHdpdGggZXhpc3RpbmcgcHJvbWlzZSBvciB3cmFwIGEgbm9uLXByb21pc2VcclxuICAgICAgICAgICAgICAgIC8vIHJldHVybiB2YWx1ZSBpbnRvIGEgcHJvbWlzZS5cclxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU3luYyBjYWxsYmFjayB0aHJvd3MuXHJcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBBdHRhY2ggdGhlIG9uQWJvcnQgaWYgcHJlc2VudFxyXG4gICAgICAgIHdyYXBwZWRDYWxsYmFjay5vbkFib3J0ID0gb25BYm9ydDtcclxuICAgICAgICB0aGlzLnF1ZXVlLnB1c2god3JhcHBlZENhbGxiYWNrKTtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMucXVldWUubGVuZ3RoIC0gMTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBVbnN1YnNjcmliZS4gUmVwbGFjZSB3aXRoIG5vLW9wLiBEbyBub3QgcmVtb3ZlIGZyb20gYXJyYXksIG9yIGl0IHdpbGwgZGlzdHVyYlxyXG4gICAgICAgICAgICAvLyBpbmRleGluZyBvZiBvdGhlciBlbGVtZW50cy5cclxuICAgICAgICAgICAgdGhpcy5xdWV1ZVtpbmRleF0gPSAoKSA9PiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcnVuTWlkZGxld2FyZShuZXh0VXNlcikge1xyXG4gICAgICAgIGlmICh0aGlzLmF1dGguY3VycmVudFVzZXIgPT09IG5leHRVc2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2hpbGUgcnVubmluZyB0aGUgbWlkZGxld2FyZSwgYnVpbGQgYSB0ZW1wb3Jhcnkgc3RhY2sgb2Ygb25BYm9ydFxyXG4gICAgICAgIC8vIGNhbGxiYWNrcyB0byBjYWxsIGlmIG9uZSBtaWRkbGV3YXJlIGNhbGxiYWNrIHJlamVjdHMuXHJcbiAgICAgICAgY29uc3Qgb25BYm9ydFN0YWNrID0gW107XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBiZWZvcmVTdGF0ZUNhbGxiYWNrIG9mIHRoaXMucXVldWUpIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGJlZm9yZVN0YXRlQ2FsbGJhY2sobmV4dFVzZXIpO1xyXG4gICAgICAgICAgICAgICAgLy8gT25seSBwdXNoIHRoZSBvbkFib3J0IGlmIHRoZSBjYWxsYmFjayBzdWNjZWVkc1xyXG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZVN0YXRlQ2FsbGJhY2sub25BYm9ydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uQWJvcnRTdGFjay5wdXNoKGJlZm9yZVN0YXRlQ2FsbGJhY2sub25BYm9ydCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gUnVuIGFsbCBvbkFib3J0LCB3aXRoIHNlcGFyYXRlIHRyeS9jYXRjaCB0byBpZ25vcmUgYW55IGVycm9ycyBhbmRcclxuICAgICAgICAgICAgLy8gY29udGludWVcclxuICAgICAgICAgICAgb25BYm9ydFN0YWNrLnJldmVyc2UoKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBvbkFib3J0IG9mIG9uQWJvcnRTdGFjaykge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBvbkFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoXykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIHN3YWxsb3cgZXJyb3IgKi9cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyB0aGlzLmF1dGguX2Vycm9yRmFjdG9yeS5jcmVhdGUoXCJsb2dpbi1ibG9ja2VkXCIgLyogQXV0aEVycm9yQ29kZS5MT0dJTl9CTE9DS0VEICovLCB7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbE1lc3NhZ2U6IGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5tZXNzYWdlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRmV0Y2hlcyB0aGUgcGFzc3dvcmQgcG9saWN5IGZvciB0aGUgY3VycmVudGx5IHNldCB0ZW5hbnQgb3IgdGhlIHByb2plY3QgaWYgbm8gdGVuYW50IGlzIHNldC5cclxuICpcclxuICogQHBhcmFtIGF1dGggQXV0aCBvYmplY3QuXHJcbiAqIEBwYXJhbSByZXF1ZXN0IFBhc3N3b3JkIHBvbGljeSByZXF1ZXN0LlxyXG4gKiBAcmV0dXJucyBQYXNzd29yZCBwb2xpY3kgcmVzcG9uc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBfZ2V0UGFzc3dvcmRQb2xpY3koYXV0aCwgcmVxdWVzdCA9IHt9KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiR0VUXCIgLyogSHR0cE1ldGhvZC5HRVQgKi8sIFwiL3YyL3Bhc3N3b3JkUG9saWN5XCIgLyogRW5kcG9pbnQuR0VUX1BBU1NXT1JEX1BPTElDWSAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBNaW5pbXVtIG1pbiBwYXNzd29yZCBsZW5ndGggZW5mb3JjZWQgYnkgdGhlIGJhY2tlbmQsIGV2ZW4gaWYgbm8gbWluaW11bSBsZW5ndGggaXMgc2V0LlxyXG5jb25zdCBNSU5JTVVNX01JTl9QQVNTV09SRF9MRU5HVEggPSA2O1xyXG4vKipcclxuICogU3RvcmVzIHBhc3N3b3JkIHBvbGljeSByZXF1aXJlbWVudHMgYW5kIHByb3ZpZGVzIHBhc3N3b3JkIHZhbGlkYXRpb24gYWdhaW5zdCB0aGUgcG9saWN5LlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIFBhc3N3b3JkUG9saWN5SW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICAvLyBPbmx5IGluY2x1ZGUgY3VzdG9tIHN0cmVuZ3RoIG9wdGlvbnMgZGVmaW5lZCBpbiB0aGUgcmVzcG9uc2UuXHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2VPcHRpb25zID0gcmVzcG9uc2UuY3VzdG9tU3RyZW5ndGhPcHRpb25zO1xyXG4gICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zID0ge307XHJcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIG9uY2UgdGhlIGJhY2tlbmQgaXMgdXBkYXRlZCB0byBpbmNsdWRlIHRoZSBtaW5pbXVtIG1pbiBwYXNzd29yZCBsZW5ndGggaW5zdGVhZCBvZiB1bmRlZmluZWQgd2hlbiB0aGVyZSBpcyBubyBtaW5pbXVtIGxlbmd0aCBzZXQuXHJcbiAgICAgICAgdGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMubWluUGFzc3dvcmRMZW5ndGggPVxyXG4gICAgICAgICAgICAoX2EgPSByZXNwb25zZU9wdGlvbnMubWluUGFzc3dvcmRMZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IE1JTklNVU1fTUlOX1BBU1NXT1JEX0xFTkdUSDtcclxuICAgICAgICBpZiAocmVzcG9uc2VPcHRpb25zLm1heFBhc3N3b3JkTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLm1heFBhc3N3b3JkTGVuZ3RoID1cclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlT3B0aW9ucy5tYXhQYXNzd29yZExlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlT3B0aW9ucy5jb250YWluc0xvd2VyY2FzZUNoYXJhY3RlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zTG93ZXJjYXNlTGV0dGVyID1cclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlT3B0aW9ucy5jb250YWluc0xvd2VyY2FzZUNoYXJhY3RlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlT3B0aW9ucy5jb250YWluc1VwcGVyY2FzZUNoYXJhY3RlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zVXBwZXJjYXNlTGV0dGVyID1cclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlT3B0aW9ucy5jb250YWluc1VwcGVyY2FzZUNoYXJhY3RlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlT3B0aW9ucy5jb250YWluc051bWVyaWNDaGFyYWN0ZXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5jb250YWluc051bWVyaWNDaGFyYWN0ZXIgPVxyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VPcHRpb25zLmNvbnRhaW5zTnVtZXJpY0NoYXJhY3RlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlT3B0aW9ucy5jb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3RlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyID1cclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlT3B0aW9ucy5jb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3RlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbmZvcmNlbWVudFN0YXRlID0gcmVzcG9uc2UuZW5mb3JjZW1lbnRTdGF0ZTtcclxuICAgICAgICBpZiAodGhpcy5lbmZvcmNlbWVudFN0YXRlID09PSAnRU5GT1JDRU1FTlRfU1RBVEVfVU5TUEVDSUZJRUQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5mb3JjZW1lbnRTdGF0ZSA9ICdPRkYnO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVc2UgYW4gZW1wdHkgc3RyaW5nIGlmIG5vIG5vbi1hbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhcmUgc3BlY2lmaWVkIGluIHRoZSByZXNwb25zZS5cclxuICAgICAgICB0aGlzLmFsbG93ZWROb25BbHBoYW51bWVyaWNDaGFyYWN0ZXJzID1cclxuICAgICAgICAgICAgKF9jID0gKF9iID0gcmVzcG9uc2UuYWxsb3dlZE5vbkFscGhhbnVtZXJpY0NoYXJhY3RlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5qb2luKCcnKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJyc7XHJcbiAgICAgICAgdGhpcy5mb3JjZVVwZ3JhZGVPblNpZ25pbiA9IChfZCA9IHJlc3BvbnNlLmZvcmNlVXBncmFkZU9uU2lnbmluKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBmYWxzZTtcclxuICAgICAgICB0aGlzLnNjaGVtYVZlcnNpb24gPSByZXNwb25zZS5zY2hlbWFWZXJzaW9uO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGVQYXNzd29yZChwYXNzd29yZCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xyXG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHtcclxuICAgICAgICAgICAgaXNWYWxpZDogdHJ1ZSxcclxuICAgICAgICAgICAgcGFzc3dvcmRQb2xpY3k6IHRoaXNcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIENoZWNrIHRoZSBwYXNzd29yZCBsZW5ndGggYW5kIGNoYXJhY3RlciBvcHRpb25zLlxyXG4gICAgICAgIHRoaXMudmFsaWRhdGVQYXNzd29yZExlbmd0aE9wdGlvbnMocGFzc3dvcmQsIHN0YXR1cyk7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0ZVBhc3N3b3JkQ2hhcmFjdGVyT3B0aW9ucyhwYXNzd29yZCwgc3RhdHVzKTtcclxuICAgICAgICAvLyBDb21iaW5lIHRoZSBzdGF0dXMgaW50byBzaW5nbGUgaXNWYWxpZCBwcm9wZXJ0eS5cclxuICAgICAgICBzdGF0dXMuaXNWYWxpZCAmJiAoc3RhdHVzLmlzVmFsaWQgPSAoX2EgPSBzdGF0dXMubWVldHNNaW5QYXNzd29yZExlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZSk7XHJcbiAgICAgICAgc3RhdHVzLmlzVmFsaWQgJiYgKHN0YXR1cy5pc1ZhbGlkID0gKF9iID0gc3RhdHVzLm1lZXRzTWF4UGFzc3dvcmRMZW5ndGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUpO1xyXG4gICAgICAgIHN0YXR1cy5pc1ZhbGlkICYmIChzdGF0dXMuaXNWYWxpZCA9IChfYyA9IHN0YXR1cy5jb250YWluc0xvd2VyY2FzZUxldHRlcikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdHJ1ZSk7XHJcbiAgICAgICAgc3RhdHVzLmlzVmFsaWQgJiYgKHN0YXR1cy5pc1ZhbGlkID0gKF9kID0gc3RhdHVzLmNvbnRhaW5zVXBwZXJjYXNlTGV0dGVyKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0cnVlKTtcclxuICAgICAgICBzdGF0dXMuaXNWYWxpZCAmJiAoc3RhdHVzLmlzVmFsaWQgPSAoX2UgPSBzdGF0dXMuY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB0cnVlKTtcclxuICAgICAgICBzdGF0dXMuaXNWYWxpZCAmJiAoc3RhdHVzLmlzVmFsaWQgPSAoX2YgPSBzdGF0dXMuY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXIpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHRydWUpO1xyXG4gICAgICAgIHJldHVybiBzdGF0dXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlcyB0aGF0IHRoZSBwYXNzd29yZCBtZWV0cyB0aGUgbGVuZ3RoIG9wdGlvbnMgZm9yIHRoZSBwb2xpY3kuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIFBhc3N3b3JkIHRvIHZhbGlkYXRlLlxyXG4gICAgICogQHBhcmFtIHN0YXR1cyBWYWxpZGF0aW9uIHN0YXR1cy5cclxuICAgICAqL1xyXG4gICAgdmFsaWRhdGVQYXNzd29yZExlbmd0aE9wdGlvbnMocGFzc3dvcmQsIHN0YXR1cykge1xyXG4gICAgICAgIGNvbnN0IG1pblBhc3N3b3JkTGVuZ3RoID0gdGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMubWluUGFzc3dvcmRMZW5ndGg7XHJcbiAgICAgICAgY29uc3QgbWF4UGFzc3dvcmRMZW5ndGggPSB0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5tYXhQYXNzd29yZExlbmd0aDtcclxuICAgICAgICBpZiAobWluUGFzc3dvcmRMZW5ndGgpIHtcclxuICAgICAgICAgICAgc3RhdHVzLm1lZXRzTWluUGFzc3dvcmRMZW5ndGggPSBwYXNzd29yZC5sZW5ndGggPj0gbWluUGFzc3dvcmRMZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXhQYXNzd29yZExlbmd0aCkge1xyXG4gICAgICAgICAgICBzdGF0dXMubWVldHNNYXhQYXNzd29yZExlbmd0aCA9IHBhc3N3b3JkLmxlbmd0aCA8PSBtYXhQYXNzd29yZExlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlcyB0aGF0IHRoZSBwYXNzd29yZCBtZWV0cyB0aGUgY2hhcmFjdGVyIG9wdGlvbnMgZm9yIHRoZSBwb2xpY3kuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIFBhc3N3b3JkIHRvIHZhbGlkYXRlLlxyXG4gICAgICogQHBhcmFtIHN0YXR1cyBWYWxpZGF0aW9uIHN0YXR1cy5cclxuICAgICAqL1xyXG4gICAgdmFsaWRhdGVQYXNzd29yZENoYXJhY3Rlck9wdGlvbnMocGFzc3dvcmQsIHN0YXR1cykge1xyXG4gICAgICAgIC8vIEFzc2lnbiBzdGF0dXNlcyBmb3IgcmVxdWlyZW1lbnRzIGV2ZW4gaWYgdGhlIHBhc3N3b3JkIGlzIGFuIGVtcHR5IHN0cmluZy5cclxuICAgICAgICB0aGlzLnVwZGF0ZVBhc3N3b3JkQ2hhcmFjdGVyT3B0aW9uc1N0YXR1c2VzKHN0YXR1cywgXHJcbiAgICAgICAgLyogY29udGFpbnNMb3dlcmNhc2VDaGFyYWN0ZXI9ICovIGZhbHNlLCBcclxuICAgICAgICAvKiBjb250YWluc1VwcGVyY2FzZUNoYXJhY3Rlcj0gKi8gZmFsc2UsIFxyXG4gICAgICAgIC8qIGNvbnRhaW5zTnVtZXJpY0NoYXJhY3Rlcj0gKi8gZmFsc2UsIFxyXG4gICAgICAgIC8qIGNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyPSAqLyBmYWxzZSk7XHJcbiAgICAgICAgbGV0IHBhc3N3b3JkQ2hhcjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhc3N3b3JkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBhc3N3b3JkQ2hhciA9IHBhc3N3b3JkLmNoYXJBdChpKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVQYXNzd29yZENoYXJhY3Rlck9wdGlvbnNTdGF0dXNlcyhzdGF0dXMsIFxyXG4gICAgICAgICAgICAvKiBjb250YWluc0xvd2VyY2FzZUNoYXJhY3Rlcj0gKi8gcGFzc3dvcmRDaGFyID49ICdhJyAmJlxyXG4gICAgICAgICAgICAgICAgcGFzc3dvcmRDaGFyIDw9ICd6JywgXHJcbiAgICAgICAgICAgIC8qIGNvbnRhaW5zVXBwZXJjYXNlQ2hhcmFjdGVyPSAqLyBwYXNzd29yZENoYXIgPj0gJ0EnICYmXHJcbiAgICAgICAgICAgICAgICBwYXNzd29yZENoYXIgPD0gJ1onLCBcclxuICAgICAgICAgICAgLyogY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyPSAqLyBwYXNzd29yZENoYXIgPj0gJzAnICYmXHJcbiAgICAgICAgICAgICAgICBwYXNzd29yZENoYXIgPD0gJzknLCBcclxuICAgICAgICAgICAgLyogY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXI9ICovIHRoaXMuYWxsb3dlZE5vbkFscGhhbnVtZXJpY0NoYXJhY3RlcnMuaW5jbHVkZXMocGFzc3dvcmRDaGFyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBydW5uaW5nIHZhbGlkYXRpb24gc3RhdHVzIHdpdGggdGhlIHN0YXR1c2VzIGZvciB0aGUgY2hhcmFjdGVyIG9wdGlvbnMuXHJcbiAgICAgKiBFeHBlY3RlZCB0byBiZSBjYWxsZWQgZWFjaCB0aW1lIGEgY2hhcmFjdGVyIGlzIHByb2Nlc3NlZCB0byB1cGRhdGUgZWFjaCBvcHRpb24gc3RhdHVzXHJcbiAgICAgKiBiYXNlZCBvbiB0aGUgY3VycmVudCBjaGFyYWN0ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXR1cyBWYWxpZGF0aW9uIHN0YXR1cy5cclxuICAgICAqIEBwYXJhbSBjb250YWluc0xvd2VyY2FzZUNoYXJhY3RlciBXaGV0aGVyIHRoZSBjaGFyYWN0ZXIgaXMgYSBsb3dlcmNhc2UgbGV0dGVyLlxyXG4gICAgICogQHBhcmFtIGNvbnRhaW5zVXBwZXJjYXNlQ2hhcmFjdGVyIFdoZXRoZXIgdGhlIGNoYXJhY3RlciBpcyBhbiB1cHBlcmNhc2UgbGV0dGVyLlxyXG4gICAgICogQHBhcmFtIGNvbnRhaW5zTnVtZXJpY0NoYXJhY3RlciBXaGV0aGVyIHRoZSBjaGFyYWN0ZXIgaXMgYSBudW1lcmljIGNoYXJhY3Rlci5cclxuICAgICAqIEBwYXJhbSBjb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3RlciBXaGV0aGVyIHRoZSBjaGFyYWN0ZXIgaXMgYSBub24tYWxwaGFudW1lcmljIGNoYXJhY3Rlci5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlUGFzc3dvcmRDaGFyYWN0ZXJPcHRpb25zU3RhdHVzZXMoc3RhdHVzLCBjb250YWluc0xvd2VyY2FzZUNoYXJhY3RlciwgY29udGFpbnNVcHBlcmNhc2VDaGFyYWN0ZXIsIGNvbnRhaW5zTnVtZXJpY0NoYXJhY3RlciwgY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMuY29udGFpbnNMb3dlcmNhc2VMZXR0ZXIpIHtcclxuICAgICAgICAgICAgc3RhdHVzLmNvbnRhaW5zTG93ZXJjYXNlTGV0dGVyIHx8IChzdGF0dXMuY29udGFpbnNMb3dlcmNhc2VMZXR0ZXIgPSBjb250YWluc0xvd2VyY2FzZUNoYXJhY3Rlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5jb250YWluc1VwcGVyY2FzZUxldHRlcikge1xyXG4gICAgICAgICAgICBzdGF0dXMuY29udGFpbnNVcHBlcmNhc2VMZXR0ZXIgfHwgKHN0YXR1cy5jb250YWluc1VwcGVyY2FzZUxldHRlciA9IGNvbnRhaW5zVXBwZXJjYXNlQ2hhcmFjdGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zTnVtZXJpY0NoYXJhY3Rlcikge1xyXG4gICAgICAgICAgICBzdGF0dXMuY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyIHx8IChzdGF0dXMuY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyID0gY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyKSB7XHJcbiAgICAgICAgICAgIHN0YXR1cy5jb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3RlciB8fCAoc3RhdHVzLmNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyID0gY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBBdXRoSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHAsIGhlYXJ0YmVhdFNlcnZpY2VQcm92aWRlciwgYXBwQ2hlY2tTZXJ2aWNlUHJvdmlkZXIsIGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xyXG4gICAgICAgIHRoaXMuaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyID0gaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tTZXJ2aWNlUHJvdmlkZXIgPSBhcHBDaGVja1NlcnZpY2VQcm92aWRlcjtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgICAgICB0aGlzLmN1cnJlbnRVc2VyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmVtdWxhdG9yQ29uZmlnID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9wZXJhdGlvbnMgPSBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB0aGlzLmF1dGhTdGF0ZVN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24odGhpcyk7XHJcbiAgICAgICAgdGhpcy5pZFRva2VuU3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbih0aGlzKTtcclxuICAgICAgICB0aGlzLmJlZm9yZVN0YXRlUXVldWUgPSBuZXcgQXV0aE1pZGRsZXdhcmVRdWV1ZSh0aGlzKTtcclxuICAgICAgICB0aGlzLnJlZGlyZWN0VXNlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pc1Byb2FjdGl2ZVJlZnJlc2hFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5FWFBFQ1RFRF9QQVNTV09SRF9QT0xJQ1lfU0NIRU1BX1ZFUlNJT04gPSAxO1xyXG4gICAgICAgIC8vIEFueSBuZXR3b3JrIGNhbGxzIHdpbGwgc2V0IHRoaXMgdG8gdHJ1ZSBhbmQgcHJldmVudCBzdWJzZXF1ZW50IGVtdWxhdG9yXHJcbiAgICAgICAgLy8gaW5pdGlhbGl6YXRpb25cclxuICAgICAgICB0aGlzLl9jYW5Jbml0RW11bGF0b3IgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9kZWxldGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6YXRpb25Qcm9taXNlID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2Vycm9yRmFjdG9yeSA9IF9ERUZBVUxUX0FVVEhfRVJST1JfRkFDVE9SWTtcclxuICAgICAgICB0aGlzLl9hZ2VudFJlY2FwdGNoYUNvbmZpZyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fdGVuYW50UmVjYXB0Y2hhQ29uZmlncyA9IHt9O1xyXG4gICAgICAgIHRoaXMuX3Byb2plY3RQYXNzd29yZFBvbGljeSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fdGVuYW50UGFzc3dvcmRQb2xpY2llcyA9IHt9O1xyXG4gICAgICAgIC8vIFRyYWNrcyB0aGUgbGFzdCBub3RpZmllZCBVSUQgZm9yIHN0YXRlIGNoYW5nZSBsaXN0ZW5lcnMgdG8gcHJldmVudFxyXG4gICAgICAgIC8vIHJlcGVhdGVkIGNhbGxzIHRvIHRoZSBjYWxsYmFja3MuIFVuZGVmaW5lZCBtZWFucyBpdCdzIG5ldmVyIGJlZW5cclxuICAgICAgICAvLyBjYWxsZWQsIHdoZXJlYXMgbnVsbCBtZWFucyBpdCdzIGJlZW4gY2FsbGVkIHdpdGggYSBzaWduZWQgb3V0IHVzZXJcclxuICAgICAgICB0aGlzLmxhc3ROb3RpZmllZFVpZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmxhbmd1YWdlQ29kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50ZW5hbnRJZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHsgYXBwVmVyaWZpY2F0aW9uRGlzYWJsZWRGb3JUZXN0aW5nOiBmYWxzZSB9O1xyXG4gICAgICAgIHRoaXMuZnJhbWV3b3JrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IGFwcC5uYW1lO1xyXG4gICAgICAgIHRoaXMuY2xpZW50VmVyc2lvbiA9IGNvbmZpZy5zZGtDbGllbnRWZXJzaW9uO1xyXG4gICAgfVxyXG4gICAgX2luaXRpYWxpemVXaXRoUGVyc2lzdGVuY2UocGVyc2lzdGVuY2VIaWVyYXJjaHksIHBvcHVwUmVkaXJlY3RSZXNvbHZlcikge1xyXG4gICAgICAgIGlmIChwb3B1cFJlZGlyZWN0UmVzb2x2ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyID0gX2dldEluc3RhbmNlKHBvcHVwUmVkaXJlY3RSZXNvbHZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEhhdmUgdG8gY2hlY2sgZm9yIGFwcCBkZWxldGlvbiB0aHJvdWdob3V0IGluaXRpYWxpemF0aW9uIChhZnRlciBlYWNoXHJcbiAgICAgICAgLy8gcHJvbWlzZSByZXNvbHV0aW9uKVxyXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemF0aW9uUHJvbWlzZSA9IHRoaXMucXVldWUoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZGVsZXRlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucGVyc2lzdGVuY2VNYW5hZ2VyID0gYXdhaXQgUGVyc2lzdGVuY2VVc2VyTWFuYWdlci5jcmVhdGUodGhpcywgcGVyc2lzdGVuY2VIaWVyYXJjaHkpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZGVsZXRlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHJlc29sdmVyIGVhcmx5IGlmIG5lY2Vzc2FyeSAob25seSBhcHBsaWNhYmxlIHRvIHdlYjpcclxuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGNhdXNlIHRoZSBpZnJhbWUgdG8gbG9hZCBpbW1lZGlhdGVseSBpbiBjZXJ0YWluIGNhc2VzKVxyXG4gICAgICAgICAgICBpZiAoKF9hID0gdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX3Nob3VsZEluaXRQcm9hY3RpdmVseSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBmYWlscywgZG9uJ3QgaGFsdCBhdXRoIGxvYWRpbmdcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyLl9pbml0aWFsaXplKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvKiBJZ25vcmUgdGhlIGVycm9yICovXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplQ3VycmVudFVzZXIocG9wdXBSZWRpcmVjdFJlc29sdmVyKTtcclxuICAgICAgICAgICAgdGhpcy5sYXN0Tm90aWZpZWRVaWQgPSAoKF9iID0gdGhpcy5jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnVpZCkgfHwgbnVsbDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2RlbGV0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5pdGlhbGl6YXRpb25Qcm9taXNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGUgcGVyc2lzdGVuY2UgaXMgY2hhbmdlZCBpbiBhbm90aGVyIHdpbmRvdywgdGhlIHVzZXIgbWFuYWdlciB3aWxsIGxldCB1cyBrbm93XHJcbiAgICAgKi9cclxuICAgIGFzeW5jIF9vblN0b3JhZ2VFdmVudCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGVsZXRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLmFzc2VydGVkUGVyc2lzdGVuY2UuZ2V0Q3VycmVudFVzZXIoKTtcclxuICAgICAgICBpZiAoIXRoaXMuY3VycmVudFVzZXIgJiYgIXVzZXIpIHtcclxuICAgICAgICAgICAgLy8gTm8gY2hhbmdlLCBkbyBub3RoaW5nICh3YXMgc2lnbmVkIG91dCBhbmQgcmVtYWluZWQgc2lnbmVkIG91dCkuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgdGhlIHNhbWUgdXNlciBpcyB0byBiZSBzeW5jaHJvbml6ZWQuXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFVzZXIgJiYgdXNlciAmJiB0aGlzLmN1cnJlbnRVc2VyLnVpZCA9PT0gdXNlci51aWQpIHtcclxuICAgICAgICAgICAgLy8gRGF0YSB1cGRhdGUsIHNpbXBseSBjb3B5IGRhdGEgY2hhbmdlcy5cclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFVzZXIuX2Fzc2lnbih1c2VyKTtcclxuICAgICAgICAgICAgLy8gSWYgdG9rZW5zIGNoYW5nZWQgZnJvbSBwcmV2aW91cyB1c2VyIHRva2VucywgdGhpcyB3aWxsIHRyaWdnZXJcclxuICAgICAgICAgICAgLy8gbm90aWZ5QXV0aExpc3RlbmVyc18uXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY3VycmVudFVzZXIuZ2V0SWRUb2tlbigpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSBjdXJyZW50IEF1dGggc3RhdGUuIEVpdGhlciBhIG5ldyBsb2dpbiBvciBsb2dvdXQuXHJcbiAgICAgICAgLy8gU2tpcCBibG9ja2luZyBjYWxsYmFja3MsIHRoZXkgc2hvdWxkIG5vdCBhcHBseSB0byBhIGNoYW5nZSBpbiBhbm90aGVyIHRhYi5cclxuICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVDdXJyZW50VXNlcih1c2VyLCAvKiBza2lwQmVmb3JlU3RhdGVDYWxsYmFja3MgKi8gdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBpbml0aWFsaXplQ3VycmVudFVzZXJGcm9tSWRUb2tlbihpZFRva2VuKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXRBY2NvdW50SW5mbyh0aGlzLCB7IGlkVG9rZW4gfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBVc2VySW1wbC5fZnJvbUdldEFjY291bnRJbmZvUmVzcG9uc2UodGhpcywgcmVzcG9uc2UsIGlkVG9rZW4pO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIodXNlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGaXJlYmFzZVNlcnZlckFwcCBjb3VsZCBub3QgbG9naW4gdXNlciB3aXRoIHByb3ZpZGVkIGF1dGhJZFRva2VuOiAnLCBlcnIpO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgaW5pdGlhbGl6ZUN1cnJlbnRVc2VyKHBvcHVwUmVkaXJlY3RSZXNvbHZlcikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAodGhpcy5hcHApKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkVG9rZW4gPSB0aGlzLmFwcC5zZXR0aW5ncy5hdXRoSWRUb2tlbjtcclxuICAgICAgICAgICAgaWYgKGlkVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBhdXRoIG9wZXJhdGlvbiBpbiB0aGUgbmV4dCB0aWNrIHRvIGFsbG93IGEgbW9tZW50IGZvciB0aGUgY3VzdG9tZXIncyBhcHAgdG9cclxuICAgICAgICAgICAgICAgIC8vIGF0dGFjaCBhbiBlbXVsYXRvciwgaWYgZGVzaXJlZC5cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaW5pdGlhbGl6ZUN1cnJlbnRVc2VyRnJvbUlkVG9rZW4oaWRUb2tlbikudGhlbihyZXNvbHZlLCByZXNvbHZlKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSBwZW5kaW5nIHJlZGlyZWN0IGV2ZW50LlxyXG4gICAgICAgIGNvbnN0IHByZXZpb3VzbHlTdG9yZWRVc2VyID0gKGF3YWl0IHRoaXMuYXNzZXJ0ZWRQZXJzaXN0ZW5jZS5nZXRDdXJyZW50VXNlcigpKTtcclxuICAgICAgICBsZXQgZnV0dXJlQ3VycmVudFVzZXIgPSBwcmV2aW91c2x5U3RvcmVkVXNlcjtcclxuICAgICAgICBsZXQgbmVlZHNUb2NoZWNrTWlkZGxld2FyZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChwb3B1cFJlZGlyZWN0UmVzb2x2ZXIgJiYgdGhpcy5jb25maWcuYXV0aERvbWFpbikge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmdldE9ySW5pdFJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlZGlyZWN0VXNlckV2ZW50SWQgPSAoX2EgPSB0aGlzLnJlZGlyZWN0VXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9yZWRpcmVjdEV2ZW50SWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZFVzZXJFdmVudElkID0gZnV0dXJlQ3VycmVudFVzZXIgPT09IG51bGwgfHwgZnV0dXJlQ3VycmVudFVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZ1dHVyZUN1cnJlbnRVc2VyLl9yZWRpcmVjdEV2ZW50SWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMudHJ5UmVkaXJlY3RTaWduSW4ocG9wdXBSZWRpcmVjdFJlc29sdmVyKTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCB1c2VyIChpLmUuIHRoZSBvbGQgXCJjdXJyZW50VXNlclwiKSBoYXMgYSByZWRpcmVjdElkIHRoYXRcclxuICAgICAgICAgICAgLy8gbWF0Y2hlcyB0aGUgcmVkaXJlY3QgdXNlciwgdGhlbiB3ZSB3YW50IHRvIGluaXRpYWxseSBzaWduIGluIHdpdGggdGhlXHJcbiAgICAgICAgICAgIC8vIG5ldyB1c2VyIG9iamVjdCBmcm9tIHJlc3VsdC5cclxuICAgICAgICAgICAgLy8gVE9ETyhzYW1naG8pOiBNb3JlIHRob3JvdWdobHkgdGVzdCBhbGwgb2YgdGhpc1xyXG4gICAgICAgICAgICBpZiAoKCFyZWRpcmVjdFVzZXJFdmVudElkIHx8IHJlZGlyZWN0VXNlckV2ZW50SWQgPT09IHN0b3JlZFVzZXJFdmVudElkKSAmJlxyXG4gICAgICAgICAgICAgICAgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3VsdC51c2VyKSkge1xyXG4gICAgICAgICAgICAgICAgZnV0dXJlQ3VycmVudFVzZXIgPSByZXN1bHQudXNlcjtcclxuICAgICAgICAgICAgICAgIG5lZWRzVG9jaGVja01pZGRsZXdhcmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIG5vIHVzZXIgaW4gcGVyc2lzdGVuY2UsIHRoZXJlIGlzIG5vIGN1cnJlbnQgdXNlci4gU2V0IHRvIG51bGwuXHJcbiAgICAgICAgaWYgKCFmdXR1cmVDdXJyZW50VXNlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWZ1dHVyZUN1cnJlbnRVc2VyLl9yZWRpcmVjdEV2ZW50SWQpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBpc24ndCBhIHJlZGlyZWN0IGxpbmsgb3BlcmF0aW9uLCB3ZSBjYW4gcmVsb2FkIGFuZCBiYWlsLlxyXG4gICAgICAgICAgICAvLyBGaXJzdCB0aG91Z2gsIGVuc3VyZSB0aGF0IHdlIGNoZWNrIHRoZSBtaWRkbGV3YXJlIGlzIGhhcHB5LlxyXG4gICAgICAgICAgICBpZiAobmVlZHNUb2NoZWNrTWlkZGxld2FyZSkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmJlZm9yZVN0YXRlUXVldWUucnVuTWlkZGxld2FyZShmdXR1cmVDdXJyZW50VXNlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1dHVyZUN1cnJlbnRVc2VyID0gcHJldmlvdXNseVN0b3JlZFVzZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Uga25vdyB0aGlzIGlzIGF2YWlsYWJsZSBzaW5jZSB0aGUgYml0IGlzIG9ubHkgc2V0IHdoZW4gdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzb2x2ZXIgaXMgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyLl9vdmVycmlkZVJlZGlyZWN0UmVzdWx0KHRoaXMsICgpID0+IFByb21pc2UucmVqZWN0KGUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZnV0dXJlQ3VycmVudFVzZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbG9hZEFuZFNldEN1cnJlbnRVc2VyT3JDbGVhcihmdXR1cmVDdXJyZW50VXNlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9hc3NlcnQodGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyLCB0aGlzLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5nZXRPckluaXRSZWRpcmVjdFBlcnNpc3RlbmNlTWFuYWdlcigpO1xyXG4gICAgICAgIC8vIElmIHRoZSByZWRpcmVjdCB1c2VyJ3MgZXZlbnQgSUQgbWF0Y2hlcyB0aGUgY3VycmVudCB1c2VyJ3MgZXZlbnQgSUQsXHJcbiAgICAgICAgLy8gRE8gTk9UIHJlbG9hZCB0aGUgY3VycmVudCB1c2VyLCBvdGhlcndpc2UgdGhleSdsbCBiZSBjbGVhcmVkIGZyb20gc3RvcmFnZS5cclxuICAgICAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBmb3IgdGhlIHJlYXV0aGVudGljYXRlV2l0aFJlZGlyZWN0KCkgZmxvdy5cclxuICAgICAgICBpZiAodGhpcy5yZWRpcmVjdFVzZXIgJiZcclxuICAgICAgICAgICAgdGhpcy5yZWRpcmVjdFVzZXIuX3JlZGlyZWN0RXZlbnRJZCA9PT0gZnV0dXJlQ3VycmVudFVzZXIuX3JlZGlyZWN0RXZlbnRJZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKGZ1dHVyZUN1cnJlbnRVc2VyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVsb2FkQW5kU2V0Q3VycmVudFVzZXJPckNsZWFyKGZ1dHVyZUN1cnJlbnRVc2VyKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHRyeVJlZGlyZWN0U2lnbkluKHJlZGlyZWN0UmVzb2x2ZXIpIHtcclxuICAgICAgICAvLyBUaGUgcmVkaXJlY3QgdXNlciBuZWVkcyB0byBiZSBjaGVja2VkIChhbmQgc2lnbmVkIGluIGlmIGF2YWlsYWJsZSlcclxuICAgICAgICAvLyBkdXJpbmcgYXV0aCBpbml0aWFsaXphdGlvbi4gQWxsIG9mIHRoZSBub3JtYWwgc2lnbiBpbiBhbmQgbGluay9yZWF1dGhcclxuICAgICAgICAvLyBmbG93cyBjYWxsIGJhY2sgaW50byBhdXRoIGFuZCBwdXNoIHRoaW5ncyBvbnRvIHRoZSBwcm9taXNlIHF1ZXVlLiBXZVxyXG4gICAgICAgIC8vIG5lZWQgdG8gYXdhaXQgdGhlIHJlc3VsdCBvZiB0aGUgcmVkaXJlY3Qgc2lnbiBpbiAqaW5zaWRlIHRoZSBwcm9taXNlXHJcbiAgICAgICAgLy8gcXVldWUqLiBUaGlzIHByZXNlbnRzIGEgcHJvYmxlbTogd2UgcnVuIGludG8gZGVhZGxvY2suIFNlZTpcclxuICAgICAgICAvLyAgICDilIw+IFtJbml0aWFsaXphdGlvbl0g4pSA4pSA4pSA4pSA4pSA4pSQXHJcbiAgICAgICAgLy8gICAg4pSMPiBbPG90aGVyIHF1ZXVlIHRhc2tzPl0g4pSCXHJcbiAgICAgICAgLy8gICAg4pSU4pSAIFtnZXRSZWRpcmVjdFJlc3VsdF0gPOKUgOKUmFxyXG4gICAgICAgIC8vICAgIHdoZXJlIFtdIGFyZSB0YXNrcyBvbiB0aGUgcXVldWUgYW5kIGFycm93cyBkZW5vdGUgYXdhaXRzXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6YXRpb24gd2lsbCBuZXZlciBjb21wbGV0ZSBiZWNhdXNlIGl0J3Mgd2FpdGluZyBvbiBzb21ldGhpbmdcclxuICAgICAgICAvLyB0aGF0J3Mgd2FpdGluZyBmb3IgaW5pdGlhbGl6YXRpb24gdG8gY29tcGxldGUhXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBJbnN0ZWFkLCB0aGlzIG1ldGhvZCBjYWxscyBnZXRSZWRpcmVjdFJlc3VsdCgpIChzdG9yZWQgaW5cclxuICAgICAgICAvLyBfY29tcGxldGVSZWRpcmVjdEZuKSB3aXRoIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IGluc3RydWN0cyBhbGwgb2ZcclxuICAgICAgICAvLyB0aGUgdW5kZXJseWluZyBhdXRoIG9wZXJhdGlvbnMgdG8gc2tpcCBhbnl0aGluZyB0aGF0IG11dGF0ZXMgYXV0aCBzdGF0ZS5cclxuICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBXZSBrbm93IHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlciBpcyBzZXQgc2luY2UgcmVkaXJlY3RSZXNvbHZlclxyXG4gICAgICAgICAgICAvLyBpcyBwYXNzZWQgaW4uIFRoZSBfY29tcGxldGVSZWRpcmVjdEZuIGV4cGVjdHMgdGhlIHVud3JhcHBlZCBleHRlcm4uXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlci5fY29tcGxldGVSZWRpcmVjdEZuKHRoaXMsIHJlZGlyZWN0UmVzb2x2ZXIsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBTd2FsbG93IGFueSBlcnJvcnMgaGVyZTsgdGhlIGNvZGUgY2FuIHJldHJpZXZlIHRoZW0gaW5cclxuICAgICAgICAgICAgLy8gZ2V0UmVkaXJlY3RSZXN1bHQoKS5cclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0UmVkaXJlY3RVc2VyKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcmVsb2FkQW5kU2V0Q3VycmVudFVzZXJPckNsZWFyKHVzZXIpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCBfcmVsb2FkV2l0aG91dFNhdmluZyh1c2VyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaWYgKChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUuY29kZSkgIT09XHJcbiAgICAgICAgICAgICAgICBgYXV0aC8ke1wibmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiIC8qIEF1dGhFcnJvckNvZGUuTkVUV09SS19SRVFVRVNUX0ZBSUxFRCAqL31gKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcncyB3cm9uZyB3aXRoIHRoZSB1c2VyJ3MgdG9rZW4uIExvZyB0aGVtIG91dCBhbmQgcmVtb3ZlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGVtIGZyb20gc3RvcmFnZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0bHlTZXRDdXJyZW50VXNlcihudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKHVzZXIpO1xyXG4gICAgfVxyXG4gICAgdXNlRGV2aWNlTGFuZ3VhZ2UoKSB7XHJcbiAgICAgICAgdGhpcy5sYW5ndWFnZUNvZGUgPSBfZ2V0VXNlckxhbmd1YWdlKCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBfZGVsZXRlKCkge1xyXG4gICAgICAgIHRoaXMuX2RlbGV0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgdXBkYXRlQ3VycmVudFVzZXIodXNlckV4dGVybikge1xyXG4gICAgICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcCh0aGlzLmFwcCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKHRoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGhlIHB1YmxpYyB1cGRhdGVDdXJyZW50VXNlciBtZXRob2QgbmVlZHMgdG8gbWFrZSBhIGNvcHkgb2YgdGhlIHVzZXIsXHJcbiAgICAgICAgLy8gYW5kIGFsc28gY2hlY2sgdGhhdCB0aGUgcHJvamVjdCBtYXRjaGVzXHJcbiAgICAgICAgY29uc3QgdXNlciA9IHVzZXJFeHRlcm5cclxuICAgICAgICAgICAgPyBnZXRNb2R1bGFySW5zdGFuY2UodXNlckV4dGVybilcclxuICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIGlmICh1c2VyKSB7XHJcbiAgICAgICAgICAgIF9hc3NlcnQodXNlci5hdXRoLmNvbmZpZy5hcGlLZXkgPT09IHRoaXMuY29uZmlnLmFwaUtleSwgdGhpcywgXCJpbnZhbGlkLXVzZXItdG9rZW5cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQVVUSCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVDdXJyZW50VXNlcih1c2VyICYmIHVzZXIuX2Nsb25lKHRoaXMpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIF91cGRhdGVDdXJyZW50VXNlcih1c2VyLCBza2lwQmVmb3JlU3RhdGVDYWxsYmFja3MgPSBmYWxzZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kZWxldGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVzZXIpIHtcclxuICAgICAgICAgICAgX2Fzc2VydCh0aGlzLnRlbmFudElkID09PSB1c2VyLnRlbmFudElkLCB0aGlzLCBcInRlbmFudC1pZC1taXNtYXRjaFwiIC8qIEF1dGhFcnJvckNvZGUuVEVOQU5UX0lEX01JU01BVENIICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFza2lwQmVmb3JlU3RhdGVDYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5iZWZvcmVTdGF0ZVF1ZXVlLnJ1bk1pZGRsZXdhcmUodXNlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKHVzZXIpO1xyXG4gICAgICAgICAgICB0aGlzLm5vdGlmeUF1dGhMaXN0ZW5lcnMoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFzeW5jIHNpZ25PdXQoKSB7XHJcbiAgICAgICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKHRoaXMuYXBwKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSdW4gZmlyc3QsIHRvIGJsb2NrIF9zZXRSZWRpcmVjdFVzZXIoKSBpZiBhbnkgY2FsbGJhY2tzIGZhaWwuXHJcbiAgICAgICAgYXdhaXQgdGhpcy5iZWZvcmVTdGF0ZVF1ZXVlLnJ1bk1pZGRsZXdhcmUobnVsbCk7XHJcbiAgICAgICAgLy8gQ2xlYXIgdGhlIHJlZGlyZWN0IHVzZXIgd2hlbiBzaWduT3V0IGlzIGNhbGxlZFxyXG4gICAgICAgIGlmICh0aGlzLnJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyIHx8IHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlcikge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXRSZWRpcmVjdFVzZXIobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFByZXZlbnQgY2FsbGJhY2tzIGZyb20gYmVpbmcgY2FsbGVkIGFnYWluIGluIF91cGRhdGVDdXJyZW50VXNlciwgYXNcclxuICAgICAgICAvLyB0aGV5IHdlcmUgYWxyZWFkeSBjYWxsZWQgaW4gdGhlIGZpcnN0IGxpbmUuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZUN1cnJlbnRVc2VyKG51bGwsIC8qIHNraXBCZWZvcmVTdGF0ZUNhbGxiYWNrcyAqLyB0cnVlKTtcclxuICAgIH1cclxuICAgIHNldFBlcnNpc3RlbmNlKHBlcnNpc3RlbmNlKSB7XHJcbiAgICAgICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKHRoaXMuYXBwKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZShhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXNzZXJ0ZWRQZXJzaXN0ZW5jZS5zZXRQZXJzaXN0ZW5jZShfZ2V0SW5zdGFuY2UocGVyc2lzdGVuY2UpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9nZXRSZWNhcHRjaGFDb25maWcoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGVuYW50SWQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWdlbnRSZWNhcHRjaGFDb25maWc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVuYW50UmVjYXB0Y2hhQ29uZmlnc1t0aGlzLnRlbmFudElkXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3luYyB2YWxpZGF0ZVBhc3N3b3JkKHBhc3N3b3JkKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9nZXRQYXNzd29yZFBvbGljeUludGVybmFsKCkpIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlUGFzc3dvcmRQb2xpY3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUGFzc3dvcmQgcG9saWN5IHdpbGwgYmUgZGVmaW5lZCBhZnRlciBmZXRjaGluZy5cclxuICAgICAgICBjb25zdCBwYXNzd29yZFBvbGljeSA9IHRoaXMuX2dldFBhc3N3b3JkUG9saWN5SW50ZXJuYWwoKTtcclxuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBwb2xpY3kgc2NoZW1hIHZlcnNpb24gaXMgc3VwcG9ydGVkIGJ5IHRoZSBTREsuXHJcbiAgICAgICAgLy8gVE9ETzogVXBkYXRlIHRoaXMgbG9naWMgdG8gdXNlIGEgbWF4IHN1cHBvcnRlZCBwb2xpY3kgc2NoZW1hIHZlcnNpb24gb25jZSB3ZSBoYXZlIG11bHRpcGxlIHNjaGVtYSB2ZXJzaW9ucy5cclxuICAgICAgICBpZiAocGFzc3dvcmRQb2xpY3kuc2NoZW1hVmVyc2lvbiAhPT1cclxuICAgICAgICAgICAgdGhpcy5FWFBFQ1RFRF9QQVNTV09SRF9QT0xJQ1lfU0NIRU1BX1ZFUlNJT04pIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuX2Vycm9yRmFjdG9yeS5jcmVhdGUoXCJ1bnN1cHBvcnRlZC1wYXNzd29yZC1wb2xpY3ktc2NoZW1hLXZlcnNpb25cIiAvKiBBdXRoRXJyb3JDb2RlLlVOU1VQUE9SVEVEX1BBU1NXT1JEX1BPTElDWV9TQ0hFTUFfVkVSU0lPTiAqLywge30pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhc3N3b3JkUG9saWN5LnZhbGlkYXRlUGFzc3dvcmQocGFzc3dvcmQpO1xyXG4gICAgfVxyXG4gICAgX2dldFBhc3N3b3JkUG9saWN5SW50ZXJuYWwoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGVuYW50SWQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2plY3RQYXNzd29yZFBvbGljeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZW5hbnRQYXNzd29yZFBvbGljaWVzW3RoaXMudGVuYW50SWRdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzeW5jIF91cGRhdGVQYXNzd29yZFBvbGljeSgpIHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9nZXRQYXNzd29yZFBvbGljeSh0aGlzKTtcclxuICAgICAgICBjb25zdCBwYXNzd29yZFBvbGljeSA9IG5ldyBQYXNzd29yZFBvbGljeUltcGwocmVzcG9uc2UpO1xyXG4gICAgICAgIGlmICh0aGlzLnRlbmFudElkID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2plY3RQYXNzd29yZFBvbGljeSA9IHBhc3N3b3JkUG9saWN5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fdGVuYW50UGFzc3dvcmRQb2xpY2llc1t0aGlzLnRlbmFudElkXSA9IHBhc3N3b3JkUG9saWN5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9nZXRQZXJzaXN0ZW5jZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hc3NlcnRlZFBlcnNpc3RlbmNlLnBlcnNpc3RlbmNlLnR5cGU7XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlRXJyb3JNYXAoZXJyb3JNYXApIHtcclxuICAgICAgICB0aGlzLl9lcnJvckZhY3RvcnkgPSBuZXcgRXJyb3JGYWN0b3J5KCdhdXRoJywgJ0ZpcmViYXNlJywgZXJyb3JNYXAoKSk7XHJcbiAgICB9XHJcbiAgICBvbkF1dGhTdGF0ZUNoYW5nZWQobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlclN0YXRlTGlzdGVuZXIodGhpcy5hdXRoU3RhdGVTdWJzY3JpcHRpb24sIG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKTtcclxuICAgIH1cclxuICAgIGJlZm9yZUF1dGhTdGF0ZUNoYW5nZWQoY2FsbGJhY2ssIG9uQWJvcnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTdGF0ZVF1ZXVlLnB1c2hDYWxsYmFjayhjYWxsYmFjaywgb25BYm9ydCk7XHJcbiAgICB9XHJcbiAgICBvbklkVG9rZW5DaGFuZ2VkKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJTdGF0ZUxpc3RlbmVyKHRoaXMuaWRUb2tlblN1YnNjcmlwdGlvbiwgbmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpO1xyXG4gICAgfVxyXG4gICAgYXV0aFN0YXRlUmVhZHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFVzZXIpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdGhpcy5vbkF1dGhTdGF0ZUNoYW5nZWQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXZva2VzIHRoZSBnaXZlbiBhY2Nlc3MgdG9rZW4uIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIEFwcGxlIE9BdXRoIGFjY2VzcyB0b2tlbnMuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJldm9rZUFjY2Vzc1Rva2VuKHRva2VuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFVzZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHRoaXMuY3VycmVudFVzZXIuZ2V0SWRUb2tlbigpO1xyXG4gICAgICAgICAgICAvLyBHZW5lcmFsaXplIHRoaXMgdG8gYWNjZXB0IG90aGVyIHByb3ZpZGVycyBvbmNlIHN1cHBvcnRlZC5cclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgICAgIHByb3ZpZGVySWQ6ICdhcHBsZS5jb20nLFxyXG4gICAgICAgICAgICAgICAgdG9rZW5UeXBlOiBcIkFDQ0VTU19UT0tFTlwiIC8qIFRva2VuVHlwZS5BQ0NFU1NfVE9LRU4gKi8sXHJcbiAgICAgICAgICAgICAgICB0b2tlbixcclxuICAgICAgICAgICAgICAgIGlkVG9rZW5cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGVuYW50SWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC50ZW5hbnRJZCA9IHRoaXMudGVuYW50SWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXdhaXQgcmV2b2tlVG9rZW4odGhpcywgcmVxdWVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBhcGlLZXk6IHRoaXMuY29uZmlnLmFwaUtleSxcclxuICAgICAgICAgICAgYXV0aERvbWFpbjogdGhpcy5jb25maWcuYXV0aERvbWFpbixcclxuICAgICAgICAgICAgYXBwTmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBjdXJyZW50VXNlcjogKF9hID0gdGhpcy5fY3VycmVudFVzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0pTT04oKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBhc3luYyBfc2V0UmVkaXJlY3RVc2VyKHVzZXIsIHBvcHVwUmVkaXJlY3RSZXNvbHZlcikge1xyXG4gICAgICAgIGNvbnN0IHJlZGlyZWN0TWFuYWdlciA9IGF3YWl0IHRoaXMuZ2V0T3JJbml0UmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXIocG9wdXBSZWRpcmVjdFJlc29sdmVyKTtcclxuICAgICAgICByZXR1cm4gdXNlciA9PT0gbnVsbFxyXG4gICAgICAgICAgICA/IHJlZGlyZWN0TWFuYWdlci5yZW1vdmVDdXJyZW50VXNlcigpXHJcbiAgICAgICAgICAgIDogcmVkaXJlY3RNYW5hZ2VyLnNldEN1cnJlbnRVc2VyKHVzZXIpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0T3JJbml0UmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXIocG9wdXBSZWRpcmVjdFJlc29sdmVyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gKHBvcHVwUmVkaXJlY3RSZXNvbHZlciAmJiBfZ2V0SW5zdGFuY2UocG9wdXBSZWRpcmVjdFJlc29sdmVyKSkgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlcjtcclxuICAgICAgICAgICAgX2Fzc2VydChyZXNvbHZlciwgdGhpcywgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xyXG4gICAgICAgICAgICB0aGlzLnJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyID0gYXdhaXQgUGVyc2lzdGVuY2VVc2VyTWFuYWdlci5jcmVhdGUodGhpcywgW19nZXRJbnN0YW5jZShyZXNvbHZlci5fcmVkaXJlY3RQZXJzaXN0ZW5jZSldLCBcInJlZGlyZWN0VXNlclwiIC8qIEtleU5hbWUuUkVESVJFQ1RfVVNFUiAqLyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVkaXJlY3RVc2VyID1cclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXIuZ2V0Q3VycmVudFVzZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBfcmVkaXJlY3RVc2VyRm9ySWQoaWQpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSd2ZSBjbGVhcmVkIGFueSBwZW5kaW5nIHBlcnNpc3RlbmNlIGFjdGlvbnMgaWYgd2UncmUgbm90IGluXHJcbiAgICAgICAgLy8gdGhlIGluaXRpYWxpemVyXHJcbiAgICAgICAgaWYgKHRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5xdWV1ZShhc3luYyAoKSA9PiB7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKChfYSA9IHRoaXMuX2N1cnJlbnRVc2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX3JlZGlyZWN0RXZlbnRJZCkgPT09IGlkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50VXNlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCgoX2IgPSB0aGlzLnJlZGlyZWN0VXNlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLl9yZWRpcmVjdEV2ZW50SWQpID09PSBpZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWRpcmVjdFVzZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgX3BlcnNpc3RVc2VySWZDdXJyZW50KHVzZXIpIHtcclxuICAgICAgICBpZiAodXNlciA9PT0gdGhpcy5jdXJyZW50VXNlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZShhc3luYyAoKSA9PiB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIodXNlcikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBOb3RpZmllcyBsaXN0ZW5lcnMgb25seSBpZiB0aGUgdXNlciBpcyBjdXJyZW50ICovXHJcbiAgICBfbm90aWZ5TGlzdGVuZXJzSWZDdXJyZW50KHVzZXIpIHtcclxuICAgICAgICBpZiAodXNlciA9PT0gdGhpcy5jdXJyZW50VXNlcikge1xyXG4gICAgICAgICAgICB0aGlzLm5vdGlmeUF1dGhMaXN0ZW5lcnMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfa2V5KCkge1xyXG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvbmZpZy5hdXRoRG9tYWlufToke3RoaXMuY29uZmlnLmFwaUtleX06JHt0aGlzLm5hbWV9YDtcclxuICAgIH1cclxuICAgIF9zdGFydFByb2FjdGl2ZVJlZnJlc2goKSB7XHJcbiAgICAgICAgdGhpcy5pc1Byb2FjdGl2ZVJlZnJlc2hFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50VXNlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VXNlci5fc3RhcnRQcm9hY3RpdmVSZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3N0b3BQcm9hY3RpdmVSZWZyZXNoKCkge1xyXG4gICAgICAgIHRoaXMuaXNQcm9hY3RpdmVSZWZyZXNoRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRVc2VyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRVc2VyLl9zdG9wUHJvYWN0aXZlUmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIHRoZSBjdXJyZW50IHVzZXIgY2FzdCBhcyB0aGUgaW50ZXJuYWwgdHlwZSAqL1xyXG4gICAgZ2V0IF9jdXJyZW50VXNlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VXNlcjtcclxuICAgIH1cclxuICAgIG5vdGlmeUF1dGhMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmlkVG9rZW5TdWJzY3JpcHRpb24ubmV4dCh0aGlzLmN1cnJlbnRVc2VyKTtcclxuICAgICAgICBjb25zdCBjdXJyZW50VWlkID0gKF9iID0gKF9hID0gdGhpcy5jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVpZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcclxuICAgICAgICBpZiAodGhpcy5sYXN0Tm90aWZpZWRVaWQgIT09IGN1cnJlbnRVaWQpIHtcclxuICAgICAgICAgICAgdGhpcy5sYXN0Tm90aWZpZWRVaWQgPSBjdXJyZW50VWlkO1xyXG4gICAgICAgICAgICB0aGlzLmF1dGhTdGF0ZVN1YnNjcmlwdGlvbi5uZXh0KHRoaXMuY3VycmVudFVzZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlZ2lzdGVyU3RhdGVMaXN0ZW5lcihzdWJzY3JpcHRpb24sIG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RlbGV0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHsgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2IgPSB0eXBlb2YgbmV4dE9yT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbidcclxuICAgICAgICAgICAgPyBuZXh0T3JPYnNlcnZlclxyXG4gICAgICAgICAgICA6IG5leHRPck9ic2VydmVyLm5leHQuYmluZChuZXh0T3JPYnNlcnZlcik7XHJcbiAgICAgICAgbGV0IGlzVW5zdWJzY3JpYmVkID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuX2lzSW5pdGlhbGl6ZWRcclxuICAgICAgICAgICAgPyBQcm9taXNlLnJlc29sdmUoKVxyXG4gICAgICAgICAgICA6IHRoaXMuX2luaXRpYWxpemF0aW9uUHJvbWlzZTtcclxuICAgICAgICBfYXNzZXJ0KHByb21pc2UsIHRoaXMsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICAvLyBUaGUgY2FsbGJhY2sgbmVlZHMgdG8gYmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5IHBlciB0aGUgc3BlYy5cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXHJcbiAgICAgICAgcHJvbWlzZS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzVW5zdWJzY3JpYmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2IodGhpcy5jdXJyZW50VXNlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuZXh0T3JPYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN1YnNjcmlwdGlvbi5hZGRPYnNlcnZlcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlZCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpc1Vuc3Vic2NyaWJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdWJzY3JpcHRpb24uYWRkT2JzZXJ2ZXIobmV4dE9yT2JzZXJ2ZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaXNVbnN1YnNjcmliZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVucHJvdGVjdGVkIChmcm9tIHJhY2UgY29uZGl0aW9ucykgbWV0aG9kIHRvIHNldCB0aGUgY3VycmVudCB1c2VyLiBUaGlzXHJcbiAgICAgKiBzaG91bGQgb25seSBiZSBjYWxsZWQgZnJvbSB3aXRoaW4gYSBxdWV1ZWQgY2FsbGJhY2suIFRoaXMgaXMgbmVjZXNzYXJ5XHJcbiAgICAgKiBiZWNhdXNlIHRoZSBxdWV1ZSBzaG91bGRuJ3QgcmVseSBvbiBhbm90aGVyIHF1ZXVlZCBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZGlyZWN0bHlTZXRDdXJyZW50VXNlcih1c2VyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFVzZXIgJiYgdGhpcy5jdXJyZW50VXNlciAhPT0gdXNlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VXNlci5fc3RvcFByb2FjdGl2ZVJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVzZXIgJiYgdGhpcy5pc1Byb2FjdGl2ZVJlZnJlc2hFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHVzZXIuX3N0YXJ0UHJvYWN0aXZlUmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN1cnJlbnRVc2VyID0gdXNlcjtcclxuICAgICAgICBpZiAodXNlcikge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFzc2VydGVkUGVyc2lzdGVuY2Uuc2V0Q3VycmVudFVzZXIodXNlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFzc2VydGVkUGVyc2lzdGVuY2UucmVtb3ZlQ3VycmVudFVzZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBxdWV1ZShhY3Rpb24pIHtcclxuICAgICAgICAvLyBJbiBjYXNlIHNvbWV0aGluZyBlcnJvcnMsIHRoZSBjYWxsYmFjayBzdGlsbCBzaG91bGQgYmUgY2FsbGVkIGluIG9yZGVyXHJcbiAgICAgICAgLy8gdG8ga2VlcCB0aGUgcHJvbWlzZSBjaGFpbiBhbGl2ZVxyXG4gICAgICAgIHRoaXMub3BlcmF0aW9ucyA9IHRoaXMub3BlcmF0aW9ucy50aGVuKGFjdGlvbiwgYWN0aW9uKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zO1xyXG4gICAgfVxyXG4gICAgZ2V0IGFzc2VydGVkUGVyc2lzdGVuY2UoKSB7XHJcbiAgICAgICAgX2Fzc2VydCh0aGlzLnBlcnNpc3RlbmNlTWFuYWdlciwgdGhpcywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlTWFuYWdlcjtcclxuICAgIH1cclxuICAgIF9sb2dGcmFtZXdvcmsoZnJhbWV3b3JrKSB7XHJcbiAgICAgICAgaWYgKCFmcmFtZXdvcmsgfHwgdGhpcy5mcmFtZXdvcmtzLmluY2x1ZGVzKGZyYW1ld29yaykpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZyYW1ld29ya3MucHVzaChmcmFtZXdvcmspO1xyXG4gICAgICAgIC8vIFNvcnQgYWxwaGFiZXRpY2FsbHkgc28gdGhhdCBcIkZpcmViYXNlQ29yZS13ZWIsRmlyZWJhc2VVSS13ZWJcIiBhbmRcclxuICAgICAgICAvLyBcIkZpcmViYXNlVUktd2ViLEZpcmViYXNlQ29yZS13ZWJcIiBhcmVuJ3Qgdmlld2VkIGFzIGRpZmZlcmVudC5cclxuICAgICAgICB0aGlzLmZyYW1ld29ya3Muc29ydCgpO1xyXG4gICAgICAgIHRoaXMuY2xpZW50VmVyc2lvbiA9IF9nZXRDbGllbnRWZXJzaW9uKHRoaXMuY29uZmlnLmNsaWVudFBsYXRmb3JtLCB0aGlzLl9nZXRGcmFtZXdvcmtzKCkpO1xyXG4gICAgfVxyXG4gICAgX2dldEZyYW1ld29ya3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhbWV3b3JrcztcclxuICAgIH1cclxuICAgIGFzeW5jIF9nZXRBZGRpdGlvbmFsSGVhZGVycygpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgLy8gQWRkaXRpb25hbCBoZWFkZXJzIG9uIGV2ZXJ5IHJlcXVlc3RcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xyXG4gICAgICAgICAgICBbXCJYLUNsaWVudC1WZXJzaW9uXCIgLyogSHR0cEhlYWRlci5YX0NMSUVOVF9WRVJTSU9OICovXTogdGhpcy5jbGllbnRWZXJzaW9uXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodGhpcy5hcHAub3B0aW9ucy5hcHBJZCkge1xyXG4gICAgICAgICAgICBoZWFkZXJzW1wiWC1GaXJlYmFzZS1nbXBpZFwiIC8qIEh0dHBIZWFkZXIuWF9GSVJFQkFTRV9HTVBJRCAqL10gPSB0aGlzLmFwcC5vcHRpb25zLmFwcElkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB0aGUgaGVhcnRiZWF0IHNlcnZpY2UgZXhpc3RzLCBhZGQgdGhlIGhlYXJ0YmVhdCBzdHJpbmdcclxuICAgICAgICBjb25zdCBoZWFydGJlYXRzSGVhZGVyID0gYXdhaXQgKChfYSA9IHRoaXMuaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyXHJcbiAgICAgICAgICAgIC5nZXRJbW1lZGlhdGUoe1xyXG4gICAgICAgICAgICBvcHRpb25hbDogdHJ1ZVxyXG4gICAgICAgIH0pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0SGVhcnRiZWF0c0hlYWRlcigpKTtcclxuICAgICAgICBpZiAoaGVhcnRiZWF0c0hlYWRlcikge1xyXG4gICAgICAgICAgICBoZWFkZXJzW1wiWC1GaXJlYmFzZS1DbGllbnRcIiAvKiBIdHRwSGVhZGVyLlhfRklSRUJBU0VfQ0xJRU5UICovXSA9IGhlYXJ0YmVhdHNIZWFkZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHRoZSBBcHAgQ2hlY2sgc2VydmljZSBleGlzdHMsIGFkZCB0aGUgQXBwIENoZWNrIHRva2VuIGluIHRoZSBoZWFkZXJzXHJcbiAgICAgICAgY29uc3QgYXBwQ2hlY2tUb2tlbiA9IGF3YWl0IHRoaXMuX2dldEFwcENoZWNrVG9rZW4oKTtcclxuICAgICAgICBpZiAoYXBwQ2hlY2tUb2tlbikge1xyXG4gICAgICAgICAgICBoZWFkZXJzW1wiWC1GaXJlYmFzZS1BcHBDaGVja1wiIC8qIEh0dHBIZWFkZXIuWF9GSVJFQkFTRV9BUFBfQ0hFQ0sgKi9dID0gYXBwQ2hlY2tUb2tlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XHJcbiAgICB9XHJcbiAgICBhc3luYyBfZ2V0QXBwQ2hlY2tUb2tlbigpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgYXBwQ2hlY2tUb2tlblJlc3VsdCA9IGF3YWl0ICgoX2EgPSB0aGlzLmFwcENoZWNrU2VydmljZVByb3ZpZGVyXHJcbiAgICAgICAgICAgIC5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFRva2VuKCkpO1xyXG4gICAgICAgIGlmIChhcHBDaGVja1Rva2VuUmVzdWx0ID09PSBudWxsIHx8IGFwcENoZWNrVG9rZW5SZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFwcENoZWNrVG9rZW5SZXN1bHQuZXJyb3IpIHtcclxuICAgICAgICAgICAgLy8gQ29udGV4dDogYXBwQ2hlY2suZ2V0VG9rZW4oKSB3aWxsIG5ldmVyIHRocm93IGV2ZW4gaWYgYW4gZXJyb3IgaGFwcGVuZWQuXHJcbiAgICAgICAgICAgIC8vIEluIHRoZSBlcnJvciBjYXNlLCBhIGR1bW15IHRva2VuIHdpbGwgYmUgcmV0dXJuZWQgYWxvbmcgd2l0aCBhbiBlcnJvciBmaWVsZCBkZXNjcmliaW5nXHJcbiAgICAgICAgICAgIC8vIHRoZSBlcnJvci4gSW4gZ2VuZXJhbCwgd2Ugc2hvdWxkbid0IGNhcmUgYWJvdXQgdGhlIGVycm9yIGNvbmRpdGlvbiBhbmQganVzdCB1c2VcclxuICAgICAgICAgICAgLy8gdGhlIHRva2VuIChhY3R1YWwgb3IgZHVtbXkpIHRvIHNlbmQgcmVxdWVzdHMuXHJcbiAgICAgICAgICAgIF9sb2dXYXJuKGBFcnJvciB3aGlsZSByZXRyaWV2aW5nIEFwcCBDaGVjayB0b2tlbjogJHthcHBDaGVja1Rva2VuUmVzdWx0LmVycm9yfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXBwQ2hlY2tUb2tlblJlc3VsdCA9PT0gbnVsbCB8fCBhcHBDaGVja1Rva2VuUmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcHBDaGVja1Rva2VuUmVzdWx0LnRva2VuO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBNZXRob2QgdG8gYmUgdXNlZCB0byBjYXN0IGRvd24gdG8gb3VyIHByaXZhdGUgaW1wbGVtZW50YXRpb24gb2YgQXV0aC5cclxuICogSXQgd2lsbCBhbHNvIGhhbmRsZSB1bndyYXBwaW5nIGZyb20gdGhlIGNvbXBhdCB0eXBlIGlmIG5lY2Vzc2FyeVxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aCBBdXRoIG9iamVjdCBwYXNzZWQgaW4gZnJvbSBkZXZlbG9wZXJcclxuICovXHJcbmZ1bmN0aW9uIF9jYXN0QXV0aChhdXRoKSB7XHJcbiAgICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpO1xyXG59XHJcbi8qKiBIZWxwZXIgY2xhc3MgdG8gd3JhcCBzdWJzY3JpYmVyIGxvZ2ljICovXHJcbmNsYXNzIFN1YnNjcmlwdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihhdXRoKSB7XHJcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcclxuICAgICAgICB0aGlzLm9ic2VydmVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmFkZE9ic2VydmVyID0gY3JlYXRlU3Vic2NyaWJlKG9ic2VydmVyID0+ICh0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXIpKTtcclxuICAgIH1cclxuICAgIGdldCBuZXh0KCkge1xyXG4gICAgICAgIF9hc3NlcnQodGhpcy5vYnNlcnZlciwgdGhpcy5hdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub2JzZXJ2ZXIubmV4dC5iaW5kKHRoaXMub2JzZXJ2ZXIpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmxldCBleHRlcm5hbEpTUHJvdmlkZXIgPSB7XHJcbiAgICBhc3luYyBsb2FkSlMoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gbG9hZCBleHRlcm5hbCBzY3JpcHRzJyk7XHJcbiAgICB9LFxyXG4gICAgcmVjYXB0Y2hhVjJTY3JpcHQ6ICcnLFxyXG4gICAgcmVjYXB0Y2hhRW50ZXJwcmlzZVNjcmlwdDogJycsXHJcbiAgICBnYXBpU2NyaXB0OiAnJ1xyXG59O1xyXG5mdW5jdGlvbiBfbG9hZEpTKHVybCkge1xyXG4gICAgcmV0dXJuIGV4dGVybmFsSlNQcm92aWRlci5sb2FkSlModXJsKTtcclxufVxyXG5mdW5jdGlvbiBfcmVjYXB0Y2hhRW50ZXJwcmlzZVNjcmlwdFVybCgpIHtcclxuICAgIHJldHVybiBleHRlcm5hbEpTUHJvdmlkZXIucmVjYXB0Y2hhRW50ZXJwcmlzZVNjcmlwdDtcclxufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzICovXHJcbmNvbnN0IFJFQ0FQVENIQV9FTlRFUlBSSVNFX1ZFUklGSUVSX1RZUEUgPSAncmVjYXB0Y2hhLWVudGVycHJpc2UnO1xyXG5jb25zdCBGQUtFX1RPS0VOID0gJ05PX1JFQ0FQVENIQSc7XHJcbmNsYXNzIFJlY2FwdGNoYUVudGVycHJpc2VWZXJpZmllciB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXV0aEV4dGVybiAtIFRoZSBjb3JyZXNwb25kaW5nIEZpcmViYXNlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGF1dGhFeHRlcm4pIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZGVudGlmaWVzIHRoZSB0eXBlIG9mIGFwcGxpY2F0aW9uIHZlcmlmaWVyIChlLmcuIFwicmVjYXB0Y2hhLWVudGVycHJpc2VcIikuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gUkVDQVBUQ0hBX0VOVEVSUFJJU0VfVkVSSUZJRVJfVFlQRTtcclxuICAgICAgICB0aGlzLmF1dGggPSBfY2FzdEF1dGgoYXV0aEV4dGVybik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4ZWN1dGVzIHRoZSB2ZXJpZmljYXRpb24gcHJvY2Vzcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgZm9yIGEgdG9rZW4gdGhhdCBjYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIHZhbGlkaXR5IG9mIGEgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgdmVyaWZ5KGFjdGlvbiA9ICd2ZXJpZnknLCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xyXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHJldHJpZXZlU2l0ZUtleShhdXRoKSB7XHJcbiAgICAgICAgICAgIGlmICghZm9yY2VSZWZyZXNoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXV0aC50ZW5hbnRJZCA9PSBudWxsICYmIGF1dGguX2FnZW50UmVjYXB0Y2hhQ29uZmlnICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0aC5fYWdlbnRSZWNhcHRjaGFDb25maWcuc2l0ZUtleTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhdXRoLnRlbmFudElkICE9IG51bGwgJiZcclxuICAgICAgICAgICAgICAgICAgICBhdXRoLl90ZW5hbnRSZWNhcHRjaGFDb25maWdzW2F1dGgudGVuYW50SWRdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0aC5fdGVuYW50UmVjYXB0Y2hhQ29uZmlnc1thdXRoLnRlbmFudElkXS5zaXRlS2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBnZXRSZWNhcHRjaGFDb25maWcoYXV0aCwge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFR5cGU6IFwiQ0xJRU5UX1RZUEVfV0VCXCIgLyogUmVjYXB0Y2hhQ2xpZW50VHlwZS5XRUIgKi8sXHJcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogXCJSRUNBUFRDSEFfRU5URVJQUklTRVwiIC8qIFJlY2FwdGNoYVZlcnNpb24uRU5URVJQUklTRSAqL1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnJlY2FwdGNoYUtleSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ3JlY2FwdGNoYSBFbnRlcnByaXNlIHNpdGUga2V5IHVuZGVmaW5lZCcpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBSZWNhcHRjaGFDb25maWcocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXV0aC50ZW5hbnRJZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoLl9hZ2VudFJlY2FwdGNoYUNvbmZpZyA9IGNvbmZpZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGguX3RlbmFudFJlY2FwdGNoYUNvbmZpZ3NbYXV0aC50ZW5hbnRJZF0gPSBjb25maWc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoY29uZmlnLnNpdGVLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiByZXRyaWV2ZVJlY2FwdGNoYVRva2VuKHNpdGVLZXksIHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBjb25zdCBncmVjYXB0Y2hhID0gd2luZG93LmdyZWNhcHRjaGE7XHJcbiAgICAgICAgICAgIGlmIChpc0VudGVycHJpc2UoZ3JlY2FwdGNoYSkpIHtcclxuICAgICAgICAgICAgICAgIGdyZWNhcHRjaGEuZW50ZXJwcmlzZS5yZWFkeSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JlY2FwdGNoYS5lbnRlcnByaXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5leGVjdXRlKHNpdGVLZXksIHsgYWN0aW9uIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHRva2VuID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShGQUtFX1RPS0VOKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KEVycm9yKCdObyByZUNBUFRDSEEgZW50ZXJwcmlzZSBzY3JpcHQgbG9hZGVkLicpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICByZXRyaWV2ZVNpdGVLZXkodGhpcy5hdXRoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oc2l0ZUtleSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZvcmNlUmVmcmVzaCAmJiBpc0VudGVycHJpc2Uod2luZG93LmdyZWNhcHRjaGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0cmlldmVSZWNhcHRjaGFUb2tlbihzaXRlS2V5LCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1JlY2FwdGNoYVZlcmlmaWVyIGlzIG9ubHkgc3VwcG9ydGVkIGluIGJyb3dzZXInKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVybCA9IF9yZWNhcHRjaGFFbnRlcnByaXNlU2NyaXB0VXJsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybC5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IHNpdGVLZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF9sb2FkSlModXJsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHJpZXZlUmVjYXB0Y2hhVG9rZW4oc2l0ZUtleSwgcmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGluamVjdFJlY2FwdGNoYUZpZWxkcyhhdXRoLCByZXF1ZXN0LCBhY3Rpb24sIGNhcHRjaGFSZXNwID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHZlcmlmaWVyID0gbmV3IFJlY2FwdGNoYUVudGVycHJpc2VWZXJpZmllcihhdXRoKTtcclxuICAgIGxldCBjYXB0Y2hhUmVzcG9uc2U7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNhcHRjaGFSZXNwb25zZSA9IGF3YWl0IHZlcmlmaWVyLnZlcmlmeShhY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY2FwdGNoYVJlc3BvbnNlID0gYXdhaXQgdmVyaWZpZXIudmVyaWZ5KGFjdGlvbiwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBuZXdSZXF1ZXN0ID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCk7XHJcbiAgICBpZiAoIWNhcHRjaGFSZXNwKSB7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdSZXF1ZXN0LCB7IGNhcHRjaGFSZXNwb25zZSB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24obmV3UmVxdWVzdCwgeyAnY2FwdGNoYVJlc3AnOiBjYXB0Y2hhUmVzcG9uc2UgfSk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuYXNzaWduKG5ld1JlcXVlc3QsIHsgJ2NsaWVudFR5cGUnOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovIH0pO1xyXG4gICAgT2JqZWN0LmFzc2lnbihuZXdSZXF1ZXN0LCB7XHJcbiAgICAgICAgJ3JlY2FwdGNoYVZlcnNpb24nOiBcIlJFQ0FQVENIQV9FTlRFUlBSSVNFXCIgLyogUmVjYXB0Y2hhVmVyc2lvbi5FTlRFUlBSSVNFICovXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuZXdSZXF1ZXN0O1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlY2FwdGNoYUZsb3coYXV0aEluc3RhbmNlLCByZXF1ZXN0LCBhY3Rpb25OYW1lLCBhY3Rpb25NZXRob2QpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGlmICgoX2EgPSBhdXRoSW5zdGFuY2VcclxuICAgICAgICAuX2dldFJlY2FwdGNoYUNvbmZpZygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNQcm92aWRlckVuYWJsZWQoXCJFTUFJTF9QQVNTV09SRF9QUk9WSURFUlwiIC8qIFJlY2FwdGNoYVByb3ZpZGVyLkVNQUlMX1BBU1NXT1JEX1BST1ZJREVSICovKSkge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3RXaXRoUmVjYXB0Y2hhID0gYXdhaXQgaW5qZWN0UmVjYXB0Y2hhRmllbGRzKGF1dGhJbnN0YW5jZSwgcmVxdWVzdCwgYWN0aW9uTmFtZSwgYWN0aW9uTmFtZSA9PT0gXCJnZXRPb2JDb2RlXCIgLyogUmVjYXB0Y2hhQWN0aW9uTmFtZS5HRVRfT09CX0NPREUgKi8pO1xyXG4gICAgICAgIHJldHVybiBhY3Rpb25NZXRob2QoYXV0aEluc3RhbmNlLCByZXF1ZXN0V2l0aFJlY2FwdGNoYSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gYWN0aW9uTWV0aG9kKGF1dGhJbnN0YW5jZSwgcmVxdWVzdCkuY2F0Y2goYXN5bmMgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBgYXV0aC8ke1wibWlzc2luZy1yZWNhcHRjaGEtdG9rZW5cIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOICovfWApIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAke2FjdGlvbk5hbWV9IGlzIHByb3RlY3RlZCBieSByZUNBUFRDSEEgRW50ZXJwcmlzZSBmb3IgdGhpcyBwcm9qZWN0LiBBdXRvbWF0aWNhbGx5IHRyaWdnZXJpbmcgdGhlIHJlQ0FQVENIQSBmbG93IGFuZCByZXN0YXJ0aW5nIHRoZSBmbG93LmApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdFdpdGhSZWNhcHRjaGEgPSBhd2FpdCBpbmplY3RSZWNhcHRjaGFGaWVsZHMoYXV0aEluc3RhbmNlLCByZXF1ZXN0LCBhY3Rpb25OYW1lLCBhY3Rpb25OYW1lID09PSBcImdldE9vYkNvZGVcIiAvKiBSZWNhcHRjaGFBY3Rpb25OYW1lLkdFVF9PT0JfQ09ERSAqLyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uTWV0aG9kKGF1dGhJbnN0YW5jZSwgcmVxdWVzdFdpdGhSZWNhcHRjaGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIF9pbml0aWFsaXplUmVjYXB0Y2hhQ29uZmlnKGF1dGgpIHtcclxuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZ2V0UmVjYXB0Y2hhQ29uZmlnKGF1dGhJbnRlcm5hbCwge1xyXG4gICAgICAgIGNsaWVudFR5cGU6IFwiQ0xJRU5UX1RZUEVfV0VCXCIgLyogUmVjYXB0Y2hhQ2xpZW50VHlwZS5XRUIgKi8sXHJcbiAgICAgICAgdmVyc2lvbjogXCJSRUNBUFRDSEFfRU5URVJQUklTRVwiIC8qIFJlY2FwdGNoYVZlcnNpb24uRU5URVJQUklTRSAqL1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBjb25maWcgPSBuZXcgUmVjYXB0Y2hhQ29uZmlnKHJlc3BvbnNlKTtcclxuICAgIGlmIChhdXRoSW50ZXJuYWwudGVuYW50SWQgPT0gbnVsbCkge1xyXG4gICAgICAgIGF1dGhJbnRlcm5hbC5fYWdlbnRSZWNhcHRjaGFDb25maWcgPSBjb25maWc7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhdXRoSW50ZXJuYWwuX3RlbmFudFJlY2FwdGNoYUNvbmZpZ3NbYXV0aEludGVybmFsLnRlbmFudElkXSA9IGNvbmZpZztcclxuICAgIH1cclxuICAgIGlmIChjb25maWcuaXNQcm92aWRlckVuYWJsZWQoXCJFTUFJTF9QQVNTV09SRF9QUk9WSURFUlwiIC8qIFJlY2FwdGNoYVByb3ZpZGVyLkVNQUlMX1BBU1NXT1JEX1BST1ZJREVSICovKSkge1xyXG4gICAgICAgIGNvbnN0IHZlcmlmaWVyID0gbmV3IFJlY2FwdGNoYUVudGVycHJpc2VWZXJpZmllcihhdXRoSW50ZXJuYWwpO1xyXG4gICAgICAgIHZvaWQgdmVyaWZpZXIudmVyaWZ5KCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEluaXRpYWxpemVzIGFuIHtAbGluayBBdXRofSBpbnN0YW5jZSB3aXRoIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXJcclxuICoge0BsaW5rIERlcGVuZGVuY2llc30uXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqXHJcbiAqIFRoaXMgZnVuY3Rpb24gYWxsb3dzIG1vcmUgY29udHJvbCBvdmVyIHRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UgdGhhblxyXG4gKiB7QGxpbmsgZ2V0QXV0aH0uIGBnZXRBdXRoYCB1c2VzIHBsYXRmb3JtLXNwZWNpZmljIGRlZmF1bHRzIHRvIHN1cHBseVxyXG4gKiB0aGUge0BsaW5rIERlcGVuZGVuY2llc30uIEluIGdlbmVyYWwsIGBnZXRBdXRoYCBpcyB0aGUgZWFzaWVzdCB3YXkgdG9cclxuICogaW5pdGlhbGl6ZSBBdXRoIGFuZCB3b3JrcyBmb3IgbW9zdCB1c2UgY2FzZXMuIFVzZSBgaW5pdGlhbGl6ZUF1dGhgIGlmIHlvdVxyXG4gKiBuZWVkIGNvbnRyb2wgb3ZlciB3aGljaCBwZXJzaXN0ZW5jZSBsYXllciBpcyB1c2VkLCBvciB0byBtaW5pbWl6ZSBidW5kbGVcclxuICogc2l6ZSBpZiB5b3UncmUgbm90IHVzaW5nIGVpdGhlciBgc2lnbkluV2l0aFBvcHVwYCBvciBgc2lnbkluV2l0aFJlZGlyZWN0YC5cclxuICpcclxuICogRm9yIGV4YW1wbGUsIGlmIHlvdXIgYXBwIG9ubHkgdXNlcyBhbm9ueW1vdXMgYWNjb3VudHMgYW5kIHlvdSBvbmx5IHdhbnRcclxuICogYWNjb3VudHMgc2F2ZWQgZm9yIHRoZSBjdXJyZW50IHNlc3Npb24sIGluaXRpYWxpemUgYEF1dGhgIHdpdGg6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGNvbnN0IGF1dGggPSBpbml0aWFsaXplQXV0aChhcHAsIHtcclxuICogICBwZXJzaXN0ZW5jZTogYnJvd3NlclNlc3Npb25QZXJzaXN0ZW5jZSxcclxuICogICBwb3B1cFJlZGlyZWN0UmVzb2x2ZXI6IHVuZGVmaW5lZCxcclxuICogfSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBpbml0aWFsaXplQXV0aChhcHAsIGRlcHMpIHtcclxuICAgIGNvbnN0IHByb3ZpZGVyID0gX2dldFByb3ZpZGVyKGFwcCwgJ2F1dGgnKTtcclxuICAgIGlmIChwcm92aWRlci5pc0luaXRpYWxpemVkKCkpIHtcclxuICAgICAgICBjb25zdCBhdXRoID0gcHJvdmlkZXIuZ2V0SW1tZWRpYXRlKCk7XHJcbiAgICAgICAgY29uc3QgaW5pdGlhbE9wdGlvbnMgPSBwcm92aWRlci5nZXRPcHRpb25zKCk7XHJcbiAgICAgICAgaWYgKGRlZXBFcXVhbChpbml0aWFsT3B0aW9ucywgZGVwcyAhPT0gbnVsbCAmJiBkZXBzICE9PSB2b2lkIDAgPyBkZXBzIDoge30pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhdXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgX2ZhaWwoYXV0aCwgXCJhbHJlYWR5LWluaXRpYWxpemVkXCIgLyogQXV0aEVycm9yQ29kZS5BTFJFQURZX0lOSVRJQUxJWkVEICovKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBhdXRoID0gcHJvdmlkZXIuaW5pdGlhbGl6ZSh7IG9wdGlvbnM6IGRlcHMgfSk7XHJcbiAgICByZXR1cm4gYXV0aDtcclxufVxyXG5mdW5jdGlvbiBfaW5pdGlhbGl6ZUF1dGhJbnN0YW5jZShhdXRoLCBkZXBzKSB7XHJcbiAgICBjb25zdCBwZXJzaXN0ZW5jZSA9IChkZXBzID09PSBudWxsIHx8IGRlcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlcHMucGVyc2lzdGVuY2UpIHx8IFtdO1xyXG4gICAgY29uc3QgaGllcmFyY2h5ID0gKEFycmF5LmlzQXJyYXkocGVyc2lzdGVuY2UpID8gcGVyc2lzdGVuY2UgOiBbcGVyc2lzdGVuY2VdKS5tYXAoX2dldEluc3RhbmNlKTtcclxuICAgIGlmIChkZXBzID09PSBudWxsIHx8IGRlcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlcHMuZXJyb3JNYXApIHtcclxuICAgICAgICBhdXRoLl91cGRhdGVFcnJvck1hcChkZXBzLmVycm9yTWFwKTtcclxuICAgIH1cclxuICAgIC8vIFRoaXMgcHJvbWlzZSBpcyBpbnRlbmRlZCB0byBmbG9hdDsgYXV0aCBpbml0aWFsaXphdGlvbiBoYXBwZW5zIGluIHRoZVxyXG4gICAgLy8gYmFja2dyb3VuZCwgbWVhbndoaWxlIHRoZSBhdXRoIG9iamVjdCBtYXkgYmUgdXNlZCBieSB0aGUgYXBwLlxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xyXG4gICAgYXV0aC5faW5pdGlhbGl6ZVdpdGhQZXJzaXN0ZW5jZShoaWVyYXJjaHksIGRlcHMgPT09IG51bGwgfHwgZGVwcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVwcy5wb3B1cFJlZGlyZWN0UmVzb2x2ZXIpO1xyXG59XG5cbi8qKlxyXG4gKiBDaGFuZ2VzIHRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UgdG8gY29tbXVuaWNhdGUgd2l0aCB0aGUgRmlyZWJhc2UgQXV0aCBFbXVsYXRvciwgaW5zdGVhZCBvZiBwcm9kdWN0aW9uXHJcbiAqIEZpcmViYXNlIEF1dGggc2VydmljZXMuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFRoaXMgbXVzdCBiZSBjYWxsZWQgc3luY2hyb25vdXNseSBpbW1lZGlhdGVseSBmb2xsb3dpbmcgdGhlIGZpcnN0IGNhbGwgdG9cclxuICoge0BsaW5rIGluaXRpYWxpemVBdXRofS4gIERvIG5vdCB1c2Ugd2l0aCBwcm9kdWN0aW9uIGNyZWRlbnRpYWxzIGFzIGVtdWxhdG9yXHJcbiAqIHRyYWZmaWMgaXMgbm90IGVuY3J5cHRlZC5cclxuICpcclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiBjb25uZWN0QXV0aEVtdWxhdG9yKGF1dGgsICdodHRwOi8vMTI3LjAuMC4xOjkwOTknLCB7IGRpc2FibGVXYXJuaW5nczogdHJ1ZSB9KTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgYXQgd2hpY2ggdGhlIGVtdWxhdG9yIGlzIHJ1bm5pbmcgKGVnLCAnaHR0cDovL2xvY2FsaG9zdDo5MDk5JykuXHJcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIGBvcHRpb25zLmRpc2FibGVXYXJuaW5nc2AgZGVmYXVsdHMgdG8gYGZhbHNlYC4gU2V0IGl0IHRvXHJcbiAqIGB0cnVlYCB0byBkaXNhYmxlIHRoZSB3YXJuaW5nIGJhbm5lciBhdHRhY2hlZCB0byB0aGUgRE9NLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25uZWN0QXV0aEVtdWxhdG9yKGF1dGgsIHVybCwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xyXG4gICAgX2Fzc2VydChhdXRoSW50ZXJuYWwuX2NhbkluaXRFbXVsYXRvciwgYXV0aEludGVybmFsLCBcImVtdWxhdG9yLWNvbmZpZy1mYWlsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkVNVUxBVE9SX0NPTkZJR19GQUlMRUQgKi8pO1xyXG4gICAgX2Fzc2VydCgvXmh0dHBzPzpcXC9cXC8vLnRlc3QodXJsKSwgYXV0aEludGVybmFsLCBcImludmFsaWQtZW11bGF0b3Itc2NoZW1lXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0VNVUxBVE9SX1NDSEVNRSAqLyk7XHJcbiAgICBjb25zdCBkaXNhYmxlV2FybmluZ3MgPSAhIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGlzYWJsZVdhcm5pbmdzKTtcclxuICAgIGNvbnN0IHByb3RvY29sID0gZXh0cmFjdFByb3RvY29sKHVybCk7XHJcbiAgICBjb25zdCB7IGhvc3QsIHBvcnQgfSA9IGV4dHJhY3RIb3N0QW5kUG9ydCh1cmwpO1xyXG4gICAgY29uc3QgcG9ydFN0ciA9IHBvcnQgPT09IG51bGwgPyAnJyA6IGA6JHtwb3J0fWA7XHJcbiAgICAvLyBBbHdheXMgcmVwbGFjZSBwYXRoIHdpdGggXCIvXCIgKGV2ZW4gaWYgaW5wdXQgdXJsIGhhZCBubyBwYXRoIGF0IGFsbCwgb3IgaGFkIGEgZGlmZmVyZW50IG9uZSkuXHJcbiAgICBhdXRoSW50ZXJuYWwuY29uZmlnLmVtdWxhdG9yID0geyB1cmw6IGAke3Byb3RvY29sfS8vJHtob3N0fSR7cG9ydFN0cn0vYCB9O1xyXG4gICAgYXV0aEludGVybmFsLnNldHRpbmdzLmFwcFZlcmlmaWNhdGlvbkRpc2FibGVkRm9yVGVzdGluZyA9IHRydWU7XHJcbiAgICBhdXRoSW50ZXJuYWwuZW11bGF0b3JDb25maWcgPSBPYmplY3QuZnJlZXplKHtcclxuICAgICAgICBob3N0LFxyXG4gICAgICAgIHBvcnQsXHJcbiAgICAgICAgcHJvdG9jb2w6IHByb3RvY29sLnJlcGxhY2UoJzonLCAnJyksXHJcbiAgICAgICAgb3B0aW9uczogT2JqZWN0LmZyZWV6ZSh7IGRpc2FibGVXYXJuaW5ncyB9KVxyXG4gICAgfSk7XHJcbiAgICBpZiAoIWRpc2FibGVXYXJuaW5ncykge1xyXG4gICAgICAgIGVtaXRFbXVsYXRvcldhcm5pbmcoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBleHRyYWN0UHJvdG9jb2wodXJsKSB7XHJcbiAgICBjb25zdCBwcm90b2NvbEVuZCA9IHVybC5pbmRleE9mKCc6Jyk7XHJcbiAgICByZXR1cm4gcHJvdG9jb2xFbmQgPCAwID8gJycgOiB1cmwuc3Vic3RyKDAsIHByb3RvY29sRW5kICsgMSk7XHJcbn1cclxuZnVuY3Rpb24gZXh0cmFjdEhvc3RBbmRQb3J0KHVybCkge1xyXG4gICAgY29uc3QgcHJvdG9jb2wgPSBleHRyYWN0UHJvdG9jb2wodXJsKTtcclxuICAgIGNvbnN0IGF1dGhvcml0eSA9IC8oXFwvXFwvKT8oW14/Iy9dKykvLmV4ZWModXJsLnN1YnN0cihwcm90b2NvbC5sZW5ndGgpKTsgLy8gQmV0d2VlbiAvLyBhbmQgLywgPyBvciAjLlxyXG4gICAgaWYgKCFhdXRob3JpdHkpIHtcclxuICAgICAgICByZXR1cm4geyBob3N0OiAnJywgcG9ydDogbnVsbCB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgaG9zdEFuZFBvcnQgPSBhdXRob3JpdHlbMl0uc3BsaXQoJ0AnKS5wb3AoKSB8fCAnJzsgLy8gU3RyaXAgb3V0IFwidXNlcm5hbWU6cGFzc3dvcmRAXCIuXHJcbiAgICBjb25zdCBicmFja2V0ZWRJUHY2ID0gL14oXFxbW15cXF1dK1xcXSkoOnwkKS8uZXhlYyhob3N0QW5kUG9ydCk7XHJcbiAgICBpZiAoYnJhY2tldGVkSVB2Nikge1xyXG4gICAgICAgIGNvbnN0IGhvc3QgPSBicmFja2V0ZWRJUHY2WzFdO1xyXG4gICAgICAgIHJldHVybiB7IGhvc3QsIHBvcnQ6IHBhcnNlUG9ydChob3N0QW5kUG9ydC5zdWJzdHIoaG9zdC5sZW5ndGggKyAxKSkgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IFtob3N0LCBwb3J0XSA9IGhvc3RBbmRQb3J0LnNwbGl0KCc6Jyk7XHJcbiAgICAgICAgcmV0dXJuIHsgaG9zdCwgcG9ydDogcGFyc2VQb3J0KHBvcnQpIH07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VQb3J0KHBvcnRTdHIpIHtcclxuICAgIGlmICghcG9ydFN0cikge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcG9ydCA9IE51bWJlcihwb3J0U3RyKTtcclxuICAgIGlmIChpc05hTihwb3J0KSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBvcnQ7XHJcbn1cclxuZnVuY3Rpb24gZW1pdEVtdWxhdG9yV2FybmluZygpIHtcclxuICAgIGZ1bmN0aW9uIGF0dGFjaEJhbm5lcigpIHtcclxuICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcclxuICAgICAgICBjb25zdCBzdHkgPSBlbC5zdHlsZTtcclxuICAgICAgICBlbC5pbm5lclRleHQgPVxyXG4gICAgICAgICAgICAnUnVubmluZyBpbiBlbXVsYXRvciBtb2RlLiBEbyBub3QgdXNlIHdpdGggcHJvZHVjdGlvbiBjcmVkZW50aWFscy4nO1xyXG4gICAgICAgIHN0eS5wb3NpdGlvbiA9ICdmaXhlZCc7XHJcbiAgICAgICAgc3R5LndpZHRoID0gJzEwMCUnO1xyXG4gICAgICAgIHN0eS5iYWNrZ3JvdW5kQ29sb3IgPSAnI2ZmZmZmZic7XHJcbiAgICAgICAgc3R5LmJvcmRlciA9ICcuMWVtIHNvbGlkICMwMDAwMDAnO1xyXG4gICAgICAgIHN0eS5jb2xvciA9ICcjYjUwMDAwJztcclxuICAgICAgICBzdHkuYm90dG9tID0gJzBweCc7XHJcbiAgICAgICAgc3R5LmxlZnQgPSAnMHB4JztcclxuICAgICAgICBzdHkubWFyZ2luID0gJzBweCc7XHJcbiAgICAgICAgc3R5LnpJbmRleCA9ICcxMDAwMCc7XHJcbiAgICAgICAgc3R5LnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2ZpcmViYXNlLWVtdWxhdG9yLXdhcm5pbmcnKTtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuaW5mbyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbygnV0FSTklORzogWW91IGFyZSB1c2luZyB0aGUgQXV0aCBFbXVsYXRvciwnICtcclxuICAgICAgICAgICAgJyB3aGljaCBpcyBpbnRlbmRlZCBmb3IgbG9jYWwgdGVzdGluZyBvbmx5LiAgRG8gbm90IHVzZSB3aXRoJyArXHJcbiAgICAgICAgICAgICcgcHJvZHVjdGlvbiBjcmVkZW50aWFscy4nKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGF0dGFjaEJhbm5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhdHRhY2hCYW5uZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEludGVyZmFjZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNyZWRlbnRpYWxzIHJldHVybmVkIGJ5IGFuIHtAbGluayBBdXRoUHJvdmlkZXJ9LlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBJbXBsZW1lbnRhdGlvbnMgc3BlY2lmeSB0aGUgZGV0YWlscyBhYm91dCBlYWNoIGF1dGggcHJvdmlkZXIncyBjcmVkZW50aWFsIHJlcXVpcmVtZW50cy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgQXV0aENyZWRlbnRpYWwge1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhdXRoZW50aWNhdGlvbiBwcm92aWRlciBJRCBmb3IgdGhlIGNyZWRlbnRpYWwuXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIEZvciBleGFtcGxlLCAnZmFjZWJvb2suY29tJywgb3IgJ2dvb2dsZS5jb20nLlxyXG4gICAgICovXHJcbiAgICBwcm92aWRlcklkLCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGF1dGhlbnRpY2F0aW9uIHNpZ24gaW4gbWV0aG9kIGZvciB0aGUgY3JlZGVudGlhbC5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICogRm9yIGV4YW1wbGUsIHtAbGluayBTaWduSW5NZXRob2R9LkVNQUlMX1BBU1NXT1JELCBvclxyXG4gICAgICoge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfTElOSy4gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgc2lnbi1pbiBtZXRob2RcclxuICAgICAqIGlkZW50aWZpZXIgYXMgcmV0dXJuZWQgaW4ge0BsaW5rIGZldGNoU2lnbkluTWV0aG9kc0ZvckVtYWlsfS5cclxuICAgICAqL1xyXG4gICAgc2lnbkluTWV0aG9kKSB7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcklkID0gcHJvdmlkZXJJZDtcclxuICAgICAgICB0aGlzLnNpZ25Jbk1ldGhvZCA9IHNpZ25Jbk1ldGhvZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIEpTT04tc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4gZGVidWdGYWlsKCdub3QgaW1wbGVtZW50ZWQnKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9nZXRJZFRva2VuUmVzcG9uc2UoX2F1dGgpIHtcclxuICAgICAgICByZXR1cm4gZGVidWdGYWlsKCdub3QgaW1wbGVtZW50ZWQnKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9saW5rVG9JZFRva2VuKF9hdXRoLCBfaWRUb2tlbikge1xyXG4gICAgICAgIHJldHVybiBkZWJ1Z0ZhaWwoJ25vdCBpbXBsZW1lbnRlZCcpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX2dldFJlYXV0aGVudGljYXRpb25SZXNvbHZlcihfYXV0aCkge1xyXG4gICAgICAgIHJldHVybiBkZWJ1Z0ZhaWwoJ25vdCBpbXBsZW1lbnRlZCcpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHJlc2V0UGFzc3dvcmQoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnJlc2V0UGFzc3dvcmRcIiAvKiBFbmRwb2ludC5SRVNFVF9QQVNTV09SRCAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiB1cGRhdGVFbWFpbFBhc3N3b3JkKGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czp1cGRhdGVcIiAvKiBFbmRwb2ludC5TRVRfQUNDT1VOVF9JTkZPICovLCByZXF1ZXN0KTtcclxufVxyXG4vLyBVc2VkIGZvciBsaW5raW5nIGFuIGVtYWlsL3Bhc3N3b3JkIGFjY291bnQgdG8gYW4gZXhpc3RpbmcgaWRUb2tlbi4gVXNlcyB0aGUgc2FtZSByZXF1ZXN0L3Jlc3BvbnNlXHJcbi8vIGZvcm1hdCBhcyB1cGRhdGVFbWFpbFBhc3N3b3JkLlxyXG5hc3luYyBmdW5jdGlvbiBsaW5rRW1haWxQYXNzd29yZChhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6c2lnblVwXCIgLyogRW5kcG9pbnQuU0lHTl9VUCAqLywgcmVxdWVzdCk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gYXBwbHlBY3Rpb25Db2RlJDEoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnVwZGF0ZVwiIC8qIEVuZHBvaW50LlNFVF9BQ0NPVU5UX0lORk8gKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aFBhc3N3b3JkKGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBfcGVyZm9ybVNpZ25JblJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpzaWduSW5XaXRoUGFzc3dvcmRcIiAvKiBFbmRwb2ludC5TSUdOX0lOX1dJVEhfUEFTU1dPUkQgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gc2VuZE9vYkNvZGUoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNlbmRPb2JDb2RlXCIgLyogRW5kcG9pbnQuU0VORF9PT0JfQ09ERSAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBzZW5kRW1haWxWZXJpZmljYXRpb24kMShhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gc2VuZE9vYkNvZGUoYXV0aCwgcmVxdWVzdCk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gc2VuZFBhc3N3b3JkUmVzZXRFbWFpbCQxKGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBzZW5kT29iQ29kZShhdXRoLCByZXF1ZXN0KTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBzZW5kU2lnbkluTGlua1RvRW1haWwkMShhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gc2VuZE9vYkNvZGUoYXV0aCwgcmVxdWVzdCk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5QW5kQ2hhbmdlRW1haWwoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIHNlbmRPb2JDb2RlKGF1dGgsIHJlcXVlc3QpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhFbWFpbExpbmskMShhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1TaWduSW5SZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6c2lnbkluV2l0aEVtYWlsTGlua1wiIC8qIEVuZHBvaW50LlNJR05fSU5fV0lUSF9FTUFJTF9MSU5LICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhFbWFpbExpbmtGb3JMaW5raW5nKGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBfcGVyZm9ybVNpZ25JblJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpzaWduSW5XaXRoRW1haWxMaW5rXCIgLyogRW5kcG9pbnQuU0lHTl9JTl9XSVRIX0VNQUlMX0xJTksgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEludGVyZmFjZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNyZWRlbnRpYWxzIHJldHVybmVkIGJ5IHtAbGluayBFbWFpbEF1dGhQcm92aWRlcn0gZm9yXHJcbiAqIHtAbGluayBQcm92aWRlcklkfS5QQVNTV09SRFxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBDb3ZlcnMgYm90aCB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9QQVNTV09SRCBhbmRcclxuICoge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfTElOSy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgRW1haWxBdXRoQ3JlZGVudGlhbCBleHRlbmRzIEF1dGhDcmVkZW50aWFsIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX2VtYWlsLCBcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9wYXNzd29yZCwgc2lnbkluTWV0aG9kLCBcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF90ZW5hbnRJZCA9IG51bGwpIHtcclxuICAgICAgICBzdXBlcihcInBhc3N3b3JkXCIgLyogUHJvdmlkZXJJZC5QQVNTV09SRCAqLywgc2lnbkluTWV0aG9kKTtcclxuICAgICAgICB0aGlzLl9lbWFpbCA9IF9lbWFpbDtcclxuICAgICAgICB0aGlzLl9wYXNzd29yZCA9IF9wYXNzd29yZDtcclxuICAgICAgICB0aGlzLl90ZW5hbnRJZCA9IF90ZW5hbnRJZDtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHN0YXRpYyBfZnJvbUVtYWlsQW5kUGFzc3dvcmQoZW1haWwsIHBhc3N3b3JkKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFbWFpbEF1dGhDcmVkZW50aWFsKGVtYWlsLCBwYXNzd29yZCwgXCJwYXNzd29yZFwiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9QQVNTV09SRCAqLyk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBzdGF0aWMgX2Zyb21FbWFpbEFuZENvZGUoZW1haWwsIG9vYkNvZGUsIHRlbmFudElkID0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRW1haWxBdXRoQ3JlZGVudGlhbChlbWFpbCwgb29iQ29kZSwgXCJlbWFpbExpbmtcIiAvKiBTaWduSW5NZXRob2QuRU1BSUxfTElOSyAqLywgdGVuYW50SWQpO1xyXG4gICAgfVxyXG4gICAgLyoqIHtAaW5oZXJpdGRvYyBBdXRoQ3JlZGVudGlhbC50b0pTT059ICovXHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZW1haWw6IHRoaXMuX2VtYWlsLFxyXG4gICAgICAgICAgICBwYXNzd29yZDogdGhpcy5fcGFzc3dvcmQsXHJcbiAgICAgICAgICAgIHNpZ25Jbk1ldGhvZDogdGhpcy5zaWduSW5NZXRob2QsXHJcbiAgICAgICAgICAgIHRlbmFudElkOiB0aGlzLl90ZW5hbnRJZFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXRpYyBtZXRob2QgdG8gZGVzZXJpYWxpemUgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9iamVjdCBpbnRvIGFuIHtAbGluayAgQXV0aENyZWRlbnRpYWx9LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBqc29uIC0gRWl0aGVyIGBvYmplY3RgIG9yIHRoZSBzdHJpbmdpZmllZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0LiBXaGVuIHN0cmluZyBpc1xyXG4gICAgICogcHJvdmlkZWQsIGBKU09OLnBhcnNlYCB3b3VsZCBiZSBjYWxsZWQgZmlyc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgSWYgdGhlIEpTT04gaW5wdXQgZG9lcyBub3QgcmVwcmVzZW50IGFuIHtAbGluayBBdXRoQ3JlZGVudGlhbH0sIG51bGwgaXMgcmV0dXJuZWQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XHJcbiAgICAgICAgY29uc3Qgb2JqID0gdHlwZW9mIGpzb24gPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShqc29uKSA6IGpzb247XHJcbiAgICAgICAgaWYgKChvYmogPT09IG51bGwgfHwgb2JqID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmouZW1haWwpICYmIChvYmogPT09IG51bGwgfHwgb2JqID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmoucGFzc3dvcmQpKSB7XHJcbiAgICAgICAgICAgIGlmIChvYmouc2lnbkluTWV0aG9kID09PSBcInBhc3N3b3JkXCIgLyogU2lnbkluTWV0aG9kLkVNQUlMX1BBU1NXT1JEICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZnJvbUVtYWlsQW5kUGFzc3dvcmQob2JqLmVtYWlsLCBvYmoucGFzc3dvcmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9iai5zaWduSW5NZXRob2QgPT09IFwiZW1haWxMaW5rXCIgLyogU2lnbkluTWV0aG9kLkVNQUlMX0xJTksgKi8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mcm9tRW1haWxBbmRDb2RlKG9iai5lbWFpbCwgb2JqLnBhc3N3b3JkLCBvYmoudGVuYW50SWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgYXN5bmMgX2dldElkVG9rZW5SZXNwb25zZShhdXRoKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnNpZ25Jbk1ldGhvZCkge1xyXG4gICAgICAgICAgICBjYXNlIFwicGFzc3dvcmRcIiAvKiBTaWduSW5NZXRob2QuRU1BSUxfUEFTU1dPUkQgKi86XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGVtYWlsOiB0aGlzLl9lbWFpbCxcclxuICAgICAgICAgICAgICAgICAgICBwYXNzd29yZDogdGhpcy5fcGFzc3dvcmQsXHJcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50VHlwZTogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqL1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVSZWNhcHRjaGFGbG93KGF1dGgsIHJlcXVlc3QsIFwic2lnbkluV2l0aFBhc3N3b3JkXCIgLyogUmVjYXB0Y2hhQWN0aW9uTmFtZS5TSUdOX0lOX1dJVEhfUEFTU1dPUkQgKi8sIHNpZ25JbldpdGhQYXNzd29yZCk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJlbWFpbExpbmtcIiAvKiBTaWduSW5NZXRob2QuRU1BSUxfTElOSyAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaWduSW5XaXRoRW1haWxMaW5rJDEoYXV0aCwge1xyXG4gICAgICAgICAgICAgICAgICAgIGVtYWlsOiB0aGlzLl9lbWFpbCxcclxuICAgICAgICAgICAgICAgICAgICBvb2JDb2RlOiB0aGlzLl9wYXNzd29yZFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBfZmFpbChhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgYXN5bmMgX2xpbmtUb0lkVG9rZW4oYXV0aCwgaWRUb2tlbikge1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5zaWduSW5NZXRob2QpIHtcclxuICAgICAgICAgICAgY2FzZSBcInBhc3N3b3JkXCIgLyogU2lnbkluTWV0aG9kLkVNQUlMX1BBU1NXT1JEICovOlxyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBpZFRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGVtYWlsOiB0aGlzLl9lbWFpbCxcclxuICAgICAgICAgICAgICAgICAgICBwYXNzd29yZDogdGhpcy5fcGFzc3dvcmQsXHJcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50VHlwZTogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqL1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVSZWNhcHRjaGFGbG93KGF1dGgsIHJlcXVlc3QsIFwic2lnblVwUGFzc3dvcmRcIiAvKiBSZWNhcHRjaGFBY3Rpb25OYW1lLlNJR05fVVBfUEFTU1dPUkQgKi8sIGxpbmtFbWFpbFBhc3N3b3JkKTtcclxuICAgICAgICAgICAgY2FzZSBcImVtYWlsTGlua1wiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9MSU5LICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25JbldpdGhFbWFpbExpbmtGb3JMaW5raW5nKGF1dGgsIHtcclxuICAgICAgICAgICAgICAgICAgICBpZFRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgIGVtYWlsOiB0aGlzLl9lbWFpbCxcclxuICAgICAgICAgICAgICAgICAgICBvb2JDb2RlOiB0aGlzLl9wYXNzd29yZFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBfZmFpbChhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX2dldFJlYXV0aGVudGljYXRpb25SZXNvbHZlcihhdXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldElkVG9rZW5SZXNwb25zZShhdXRoKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoSWRwKGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBfcGVyZm9ybVNpZ25JblJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpzaWduSW5XaXRoSWRwXCIgLyogRW5kcG9pbnQuU0lHTl9JTl9XSVRIX0lEUCAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBJRFBfUkVRVUVTVF9VUkkkMSA9ICdodHRwOi8vbG9jYWxob3N0JztcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIE9BdXRoIGNyZWRlbnRpYWxzIHJldHVybmVkIGJ5IGFuIHtAbGluayBPQXV0aFByb3ZpZGVyfS5cclxuICpcclxuICogQHJlbWFya3NcclxuICogSW1wbGVtZW50YXRpb25zIHNwZWNpZnkgdGhlIGRldGFpbHMgYWJvdXQgZWFjaCBhdXRoIHByb3ZpZGVyJ3MgY3JlZGVudGlhbCByZXF1aXJlbWVudHMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIE9BdXRoQ3JlZGVudGlhbCBleHRlbmRzIEF1dGhDcmVkZW50aWFsIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nVG9rZW4gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgc3RhdGljIF9mcm9tUGFyYW1zKHBhcmFtcykge1xyXG4gICAgICAgIGNvbnN0IGNyZWQgPSBuZXcgT0F1dGhDcmVkZW50aWFsKHBhcmFtcy5wcm92aWRlcklkLCBwYXJhbXMuc2lnbkluTWV0aG9kKTtcclxuICAgICAgICBpZiAocGFyYW1zLmlkVG9rZW4gfHwgcGFyYW1zLmFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgICAgIC8vIE9BdXRoIDIgYW5kIGVpdGhlciBJRCB0b2tlbiBvciBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgICAgICAgIGlmIChwYXJhbXMuaWRUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgY3JlZC5pZFRva2VuID0gcGFyYW1zLmlkVG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBhcmFtcy5hY2Nlc3NUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgY3JlZC5hY2Nlc3NUb2tlbiA9IHBhcmFtcy5hY2Nlc3NUb2tlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBBZGQgbm9uY2UgaWYgYXZhaWxhYmxlIGFuZCBubyBwZW5kaW5nVG9rZW4gaXMgcHJlc2VudC5cclxuICAgICAgICAgICAgaWYgKHBhcmFtcy5ub25jZSAmJiAhcGFyYW1zLnBlbmRpbmdUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgY3JlZC5ub25jZSA9IHBhcmFtcy5ub25jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocGFyYW1zLnBlbmRpbmdUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgY3JlZC5wZW5kaW5nVG9rZW4gPSBwYXJhbXMucGVuZGluZ1Rva2VuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhcmFtcy5vYXV0aFRva2VuICYmIHBhcmFtcy5vYXV0aFRva2VuU2VjcmV0KSB7XHJcbiAgICAgICAgICAgIC8vIE9BdXRoIDEgYW5kIE9BdXRoIHRva2VuIHdpdGggdG9rZW4gc2VjcmV0XHJcbiAgICAgICAgICAgIGNyZWQuYWNjZXNzVG9rZW4gPSBwYXJhbXMub2F1dGhUb2tlbjtcclxuICAgICAgICAgICAgY3JlZC5zZWNyZXQgPSBwYXJhbXMub2F1dGhUb2tlblNlY3JldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIF9mYWlsKFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNyZWQ7XHJcbiAgICB9XHJcbiAgICAvKioge0Bpbmhlcml0ZG9jIEF1dGhDcmVkZW50aWFsLnRvSlNPTn0gICovXHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaWRUb2tlbjogdGhpcy5pZFRva2VuLFxyXG4gICAgICAgICAgICBhY2Nlc3NUb2tlbjogdGhpcy5hY2Nlc3NUb2tlbixcclxuICAgICAgICAgICAgc2VjcmV0OiB0aGlzLnNlY3JldCxcclxuICAgICAgICAgICAgbm9uY2U6IHRoaXMubm9uY2UsXHJcbiAgICAgICAgICAgIHBlbmRpbmdUb2tlbjogdGhpcy5wZW5kaW5nVG9rZW4sXHJcbiAgICAgICAgICAgIHByb3ZpZGVySWQ6IHRoaXMucHJvdmlkZXJJZCxcclxuICAgICAgICAgICAgc2lnbkluTWV0aG9kOiB0aGlzLnNpZ25Jbk1ldGhvZFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXRpYyBtZXRob2QgdG8gZGVzZXJpYWxpemUgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9iamVjdCBpbnRvIGFuXHJcbiAgICAgKiB7QGxpbmsgIEF1dGhDcmVkZW50aWFsfS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ganNvbiAtIElucHV0IGNhbiBiZSBlaXRoZXIgT2JqZWN0IG9yIHRoZSBzdHJpbmdpZmllZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0LlxyXG4gICAgICogV2hlbiBzdHJpbmcgaXMgcHJvdmlkZWQsIEpTT04ucGFyc2Ugd291bGQgYmUgY2FsbGVkIGZpcnN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIElmIHRoZSBKU09OIGlucHV0IGRvZXMgbm90IHJlcHJlc2VudCBhbiB7QGxpbmsgIEF1dGhDcmVkZW50aWFsfSwgbnVsbCBpcyByZXR1cm5lZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcclxuICAgICAgICBjb25zdCBvYmogPSB0eXBlb2YganNvbiA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbjtcclxuICAgICAgICBjb25zdCB7IHByb3ZpZGVySWQsIHNpZ25Jbk1ldGhvZCB9ID0gb2JqLCByZXN0ID0gX19yZXN0KG9iaiwgW1wicHJvdmlkZXJJZFwiLCBcInNpZ25Jbk1ldGhvZFwiXSk7XHJcbiAgICAgICAgaWYgKCFwcm92aWRlcklkIHx8ICFzaWduSW5NZXRob2QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNyZWQgPSBuZXcgT0F1dGhDcmVkZW50aWFsKHByb3ZpZGVySWQsIHNpZ25Jbk1ldGhvZCk7XHJcbiAgICAgICAgY3JlZC5pZFRva2VuID0gcmVzdC5pZFRva2VuIHx8IHVuZGVmaW5lZDtcclxuICAgICAgICBjcmVkLmFjY2Vzc1Rva2VuID0gcmVzdC5hY2Nlc3NUb2tlbiB8fCB1bmRlZmluZWQ7XHJcbiAgICAgICAgY3JlZC5zZWNyZXQgPSByZXN0LnNlY3JldDtcclxuICAgICAgICBjcmVkLm5vbmNlID0gcmVzdC5ub25jZTtcclxuICAgICAgICBjcmVkLnBlbmRpbmdUb2tlbiA9IHJlc3QucGVuZGluZ1Rva2VuIHx8IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIGNyZWQ7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBfZ2V0SWRUb2tlblJlc3BvbnNlKGF1dGgpIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5idWlsZFJlcXVlc3QoKTtcclxuICAgICAgICByZXR1cm4gc2lnbkluV2l0aElkcChhdXRoLCByZXF1ZXN0KTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9saW5rVG9JZFRva2VuKGF1dGgsIGlkVG9rZW4pIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5idWlsZFJlcXVlc3QoKTtcclxuICAgICAgICByZXF1ZXN0LmlkVG9rZW4gPSBpZFRva2VuO1xyXG4gICAgICAgIHJldHVybiBzaWduSW5XaXRoSWRwKGF1dGgsIHJlcXVlc3QpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX2dldFJlYXV0aGVudGljYXRpb25SZXNvbHZlcihhdXRoKSB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuYnVpbGRSZXF1ZXN0KCk7XHJcbiAgICAgICAgcmVxdWVzdC5hdXRvQ3JlYXRlID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHNpZ25JbldpdGhJZHAoYXV0aCwgcmVxdWVzdCk7XHJcbiAgICB9XHJcbiAgICBidWlsZFJlcXVlc3QoKSB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgcmVxdWVzdFVyaTogSURQX1JFUVVFU1RfVVJJJDEsXHJcbiAgICAgICAgICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodGhpcy5wZW5kaW5nVG9rZW4pIHtcclxuICAgICAgICAgICAgcmVxdWVzdC5wZW5kaW5nVG9rZW4gPSB0aGlzLnBlbmRpbmdUb2tlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvc3RCb2R5ID0ge307XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlkVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIHBvc3RCb2R5WydpZF90b2tlbiddID0gdGhpcy5pZFRva2VuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgICAgICAgICBwb3N0Qm9keVsnYWNjZXNzX3Rva2VuJ10gPSB0aGlzLmFjY2Vzc1Rva2VuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNlY3JldCkge1xyXG4gICAgICAgICAgICAgICAgcG9zdEJvZHlbJ29hdXRoX3Rva2VuX3NlY3JldCddID0gdGhpcy5zZWNyZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcG9zdEJvZHlbJ3Byb3ZpZGVySWQnXSA9IHRoaXMucHJvdmlkZXJJZDtcclxuICAgICAgICAgICAgaWYgKHRoaXMubm9uY2UgJiYgIXRoaXMucGVuZGluZ1Rva2VuKSB7XHJcbiAgICAgICAgICAgICAgICBwb3N0Qm9keVsnbm9uY2UnXSA9IHRoaXMubm9uY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVxdWVzdC5wb3N0Qm9keSA9IHF1ZXJ5c3RyaW5nKHBvc3RCb2R5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aFBob25lTnVtYmVyJDEoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25JbldpdGhQaG9uZU51bWJlclwiIC8qIEVuZHBvaW50LlNJR05fSU5fV0lUSF9QSE9ORV9OVU1CRVIgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gbGlua1dpdGhQaG9uZU51bWJlciQxKGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX3BlcmZvcm1TaWduSW5SZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6c2lnbkluV2l0aFBob25lTnVtYmVyXCIgLyogRW5kcG9pbnQuU0lHTl9JTl9XSVRIX1BIT05FX05VTUJFUiAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcclxuICAgIGlmIChyZXNwb25zZS50ZW1wb3JhcnlQcm9vZikge1xyXG4gICAgICAgIHRocm93IF9tYWtlVGFnZ2VkRXJyb3IoYXV0aCwgXCJhY2NvdW50LWV4aXN0cy13aXRoLWRpZmZlcmVudC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5ORUVEX0NPTkZJUk1BVElPTiAqLywgcmVzcG9uc2UpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xyXG59XHJcbmNvbnN0IFZFUklGWV9QSE9ORV9OVU1CRVJfRk9SX0VYSVNUSU5HX0VSUk9SX01BUF8gPSB7XHJcbiAgICBbXCJVU0VSX05PVF9GT1VORFwiIC8qIFNlcnZlckVycm9yLlVTRVJfTk9UX0ZPVU5EICovXTogXCJ1c2VyLW5vdC1mb3VuZFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9ERUxFVEVEICovXHJcbn07XHJcbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeVBob25lTnVtYmVyRm9yRXhpc3RpbmcoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgY29uc3QgYXBpUmVxdWVzdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCksIHsgb3BlcmF0aW9uOiAnUkVBVVRIJyB9KTtcclxuICAgIHJldHVybiBfcGVyZm9ybVNpZ25JblJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpzaWduSW5XaXRoUGhvbmVOdW1iZXJcIiAvKiBFbmRwb2ludC5TSUdOX0lOX1dJVEhfUEhPTkVfTlVNQkVSICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgYXBpUmVxdWVzdCksIFZFUklGWV9QSE9ORV9OVU1CRVJfRk9SX0VYSVNUSU5HX0VSUk9SX01BUF8pO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSBjcmVkZW50aWFscyByZXR1cm5lZCBieSB7QGxpbmsgUGhvbmVBdXRoUHJvdmlkZXJ9LlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBQaG9uZUF1dGhDcmVkZW50aWFsIGV4dGVuZHMgQXV0aENyZWRlbnRpYWwge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XHJcbiAgICAgICAgc3VwZXIoXCJwaG9uZVwiIC8qIFByb3ZpZGVySWQuUEhPTkUgKi8sIFwicGhvbmVcIiAvKiBTaWduSW5NZXRob2QuUEhPTkUgKi8pO1xyXG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgc3RhdGljIF9mcm9tVmVyaWZpY2F0aW9uKHZlcmlmaWNhdGlvbklkLCB2ZXJpZmljYXRpb25Db2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQaG9uZUF1dGhDcmVkZW50aWFsKHsgdmVyaWZpY2F0aW9uSWQsIHZlcmlmaWNhdGlvbkNvZGUgfSk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBzdGF0aWMgX2Zyb21Ub2tlblJlc3BvbnNlKHBob25lTnVtYmVyLCB0ZW1wb3JhcnlQcm9vZikge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGhvbmVBdXRoQ3JlZGVudGlhbCh7IHBob25lTnVtYmVyLCB0ZW1wb3JhcnlQcm9vZiB9KTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9nZXRJZFRva2VuUmVzcG9uc2UoYXV0aCkge1xyXG4gICAgICAgIHJldHVybiBzaWduSW5XaXRoUGhvbmVOdW1iZXIkMShhdXRoLCB0aGlzLl9tYWtlVmVyaWZpY2F0aW9uUmVxdWVzdCgpKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9saW5rVG9JZFRva2VuKGF1dGgsIGlkVG9rZW4pIHtcclxuICAgICAgICByZXR1cm4gbGlua1dpdGhQaG9uZU51bWJlciQxKGF1dGgsIE9iamVjdC5hc3NpZ24oeyBpZFRva2VuIH0sIHRoaXMuX21ha2VWZXJpZmljYXRpb25SZXF1ZXN0KCkpKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9nZXRSZWF1dGhlbnRpY2F0aW9uUmVzb2x2ZXIoYXV0aCkge1xyXG4gICAgICAgIHJldHVybiB2ZXJpZnlQaG9uZU51bWJlckZvckV4aXN0aW5nKGF1dGgsIHRoaXMuX21ha2VWZXJpZmljYXRpb25SZXF1ZXN0KCkpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX21ha2VWZXJpZmljYXRpb25SZXF1ZXN0KCkge1xyXG4gICAgICAgIGNvbnN0IHsgdGVtcG9yYXJ5UHJvb2YsIHBob25lTnVtYmVyLCB2ZXJpZmljYXRpb25JZCwgdmVyaWZpY2F0aW9uQ29kZSB9ID0gdGhpcy5wYXJhbXM7XHJcbiAgICAgICAgaWYgKHRlbXBvcmFyeVByb29mICYmIHBob25lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHRlbXBvcmFyeVByb29mLCBwaG9uZU51bWJlciB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzZXNzaW9uSW5mbzogdmVyaWZpY2F0aW9uSWQsXHJcbiAgICAgICAgICAgIGNvZGU6IHZlcmlmaWNhdGlvbkNvZGVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqIHtAaW5oZXJpdGRvYyBBdXRoQ3JlZGVudGlhbC50b0pTT059ICovXHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3Qgb2JqID0ge1xyXG4gICAgICAgICAgICBwcm92aWRlcklkOiB0aGlzLnByb3ZpZGVySWRcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy5waG9uZU51bWJlcikge1xyXG4gICAgICAgICAgICBvYmoucGhvbmVOdW1iZXIgPSB0aGlzLnBhcmFtcy5waG9uZU51bWJlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLnRlbXBvcmFyeVByb29mKSB7XHJcbiAgICAgICAgICAgIG9iai50ZW1wb3JhcnlQcm9vZiA9IHRoaXMucGFyYW1zLnRlbXBvcmFyeVByb29mO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wYXJhbXMudmVyaWZpY2F0aW9uQ29kZSkge1xyXG4gICAgICAgICAgICBvYmoudmVyaWZpY2F0aW9uQ29kZSA9IHRoaXMucGFyYW1zLnZlcmlmaWNhdGlvbkNvZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy52ZXJpZmljYXRpb25JZCkge1xyXG4gICAgICAgICAgICBvYmoudmVyaWZpY2F0aW9uSWQgPSB0aGlzLnBhcmFtcy52ZXJpZmljYXRpb25JZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuICAgIC8qKiBHZW5lcmF0ZXMgYSBwaG9uZSBjcmVkZW50aWFsIGJhc2VkIG9uIGEgcGxhaW4gb2JqZWN0IG9yIGEgSlNPTiBzdHJpbmcuICovXHJcbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xyXG4gICAgICAgIGlmICh0eXBlb2YganNvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAganNvbiA9IEpTT04ucGFyc2UoanNvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgdmVyaWZpY2F0aW9uSWQsIHZlcmlmaWNhdGlvbkNvZGUsIHBob25lTnVtYmVyLCB0ZW1wb3JhcnlQcm9vZiB9ID0ganNvbjtcclxuICAgICAgICBpZiAoIXZlcmlmaWNhdGlvbkNvZGUgJiZcclxuICAgICAgICAgICAgIXZlcmlmaWNhdGlvbklkICYmXHJcbiAgICAgICAgICAgICFwaG9uZU51bWJlciAmJlxyXG4gICAgICAgICAgICAhdGVtcG9yYXJ5UHJvb2YpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUGhvbmVBdXRoQ3JlZGVudGlhbCh7XHJcbiAgICAgICAgICAgIHZlcmlmaWNhdGlvbklkLFxyXG4gICAgICAgICAgICB2ZXJpZmljYXRpb25Db2RlLFxyXG4gICAgICAgICAgICBwaG9uZU51bWJlcixcclxuICAgICAgICAgICAgdGVtcG9yYXJ5UHJvb2ZcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogTWFwcyB0aGUgbW9kZSBzdHJpbmcgaW4gYWN0aW9uIGNvZGUgVVJMIHRvIEFjdGlvbiBDb2RlIEluZm8gb3BlcmF0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gbW9kZVxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VNb2RlKG1vZGUpIHtcclxuICAgIHN3aXRjaCAobW9kZSkge1xyXG4gICAgICAgIGNhc2UgJ3JlY292ZXJFbWFpbCc6XHJcbiAgICAgICAgICAgIHJldHVybiBcIlJFQ09WRVJfRU1BSUxcIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlJFQ09WRVJfRU1BSUwgKi87XHJcbiAgICAgICAgY2FzZSAncmVzZXRQYXNzd29yZCc6XHJcbiAgICAgICAgICAgIHJldHVybiBcIlBBU1NXT1JEX1JFU0VUXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5QQVNTV09SRF9SRVNFVCAqLztcclxuICAgICAgICBjYXNlICdzaWduSW4nOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJFTUFJTF9TSUdOSU5cIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLkVNQUlMX1NJR05JTiAqLztcclxuICAgICAgICBjYXNlICd2ZXJpZnlFbWFpbCc6XHJcbiAgICAgICAgICAgIHJldHVybiBcIlZFUklGWV9FTUFJTFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uVkVSSUZZX0VNQUlMICovO1xyXG4gICAgICAgIGNhc2UgJ3ZlcmlmeUFuZENoYW5nZUVtYWlsJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwiVkVSSUZZX0FORF9DSEFOR0VfRU1BSUxcIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMICovO1xyXG4gICAgICAgIGNhc2UgJ3JldmVydFNlY29uZEZhY3RvckFkZGl0aW9uJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwiUkVWRVJUX1NFQ09ORF9GQUNUT1JfQURESVRJT05cIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlJFVkVSVF9TRUNPTkRfRkFDVE9SX0FERElUSU9OICovO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gcGFyc2UgRkRMIGxpbmtzXHJcbiAqXHJcbiAqIEBwYXJhbSB1cmxcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlRGVlcExpbmsodXJsKSB7XHJcbiAgICBjb25zdCBsaW5rID0gcXVlcnlzdHJpbmdEZWNvZGUoZXh0cmFjdFF1ZXJ5c3RyaW5nKHVybCkpWydsaW5rJ107XHJcbiAgICAvLyBEb3VibGUgbGluayBjYXNlIChhdXRvbWF0aWMgcmVkaXJlY3QpLlxyXG4gICAgY29uc3QgZG91YmxlRGVlcExpbmsgPSBsaW5rXHJcbiAgICAgICAgPyBxdWVyeXN0cmluZ0RlY29kZShleHRyYWN0UXVlcnlzdHJpbmcobGluaykpWydkZWVwX2xpbmtfaWQnXVxyXG4gICAgICAgIDogbnVsbDtcclxuICAgIC8vIGlPUyBjdXN0b20gc2NoZW1lIGxpbmtzLlxyXG4gICAgY29uc3QgaU9TRGVlcExpbmsgPSBxdWVyeXN0cmluZ0RlY29kZShleHRyYWN0UXVlcnlzdHJpbmcodXJsKSlbJ2RlZXBfbGlua19pZCddO1xyXG4gICAgY29uc3QgaU9TRG91YmxlRGVlcExpbmsgPSBpT1NEZWVwTGlua1xyXG4gICAgICAgID8gcXVlcnlzdHJpbmdEZWNvZGUoZXh0cmFjdFF1ZXJ5c3RyaW5nKGlPU0RlZXBMaW5rKSlbJ2xpbmsnXVxyXG4gICAgICAgIDogbnVsbDtcclxuICAgIHJldHVybiBpT1NEb3VibGVEZWVwTGluayB8fCBpT1NEZWVwTGluayB8fCBkb3VibGVEZWVwTGluayB8fCBsaW5rIHx8IHVybDtcclxufVxyXG4vKipcclxuICogQSB1dGlsaXR5IGNsYXNzIHRvIHBhcnNlIGVtYWlsIGFjdGlvbiBVUkxzIHN1Y2ggYXMgcGFzc3dvcmQgcmVzZXQsIGVtYWlsIHZlcmlmaWNhdGlvbixcclxuICogZW1haWwgbGluayBzaWduIGluLCBldGMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIEFjdGlvbkNvZGVVUkwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gYWN0aW9uTGluayAtIFRoZSBsaW5rIGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgVVJMLlxyXG4gICAgICogQHJldHVybnMgVGhlIHtAbGluayBBY3Rpb25Db2RlVVJMfSBvYmplY3QsIG9yIG51bGwgaWYgdGhlIGxpbmsgaXMgaW52YWxpZC5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYWN0aW9uTGluaykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xyXG4gICAgICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHF1ZXJ5c3RyaW5nRGVjb2RlKGV4dHJhY3RRdWVyeXN0cmluZyhhY3Rpb25MaW5rKSk7XHJcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gKF9hID0gc2VhcmNoUGFyYW1zW1wiYXBpS2V5XCIgLyogUXVlcnlGaWVsZC5BUElfS0VZICovXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcclxuICAgICAgICBjb25zdCBjb2RlID0gKF9iID0gc2VhcmNoUGFyYW1zW1wib29iQ29kZVwiIC8qIFF1ZXJ5RmllbGQuQ09ERSAqL10pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGw7XHJcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gcGFyc2VNb2RlKChfYyA9IHNlYXJjaFBhcmFtc1tcIm1vZGVcIiAvKiBRdWVyeUZpZWxkLk1PREUgKi9dKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBudWxsKTtcclxuICAgICAgICAvLyBWYWxpZGF0ZSBBUEkga2V5LCBjb2RlIGFuZCBtb2RlLlxyXG4gICAgICAgIF9hc3NlcnQoYXBpS2V5ICYmIGNvZGUgJiYgb3BlcmF0aW9uLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XHJcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBhcGlLZXk7XHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb24gPSBvcGVyYXRpb247XHJcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcclxuICAgICAgICB0aGlzLmNvbnRpbnVlVXJsID0gKF9kID0gc2VhcmNoUGFyYW1zW1wiY29udGludWVVcmxcIiAvKiBRdWVyeUZpZWxkLkNPTlRJTlVFX1VSTCAqL10pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG51bGw7XHJcbiAgICAgICAgdGhpcy5sYW5ndWFnZUNvZGUgPSAoX2UgPSBzZWFyY2hQYXJhbXNbXCJsYW5ndWFnZUNvZGVcIiAvKiBRdWVyeUZpZWxkLkxBTkdVQUdFX0NPREUgKi9dKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBudWxsO1xyXG4gICAgICAgIHRoaXMudGVuYW50SWQgPSAoX2YgPSBzZWFyY2hQYXJhbXNbXCJ0ZW5hbnRJZFwiIC8qIFF1ZXJ5RmllbGQuVEVOQU5UX0lEICovXSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIHRoZSBlbWFpbCBhY3Rpb24gbGluayBzdHJpbmcgYW5kIHJldHVybnMgYW4ge0BsaW5rIEFjdGlvbkNvZGVVUkx9IGlmIHRoZSBsaW5rIGlzIHZhbGlkLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybnMgbnVsbC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGluayAgLSBUaGUgZW1haWwgYWN0aW9uIGxpbmsgc3RyaW5nLlxyXG4gICAgICogQHJldHVybnMgVGhlIHtAbGluayBBY3Rpb25Db2RlVVJMfSBvYmplY3QsIG9yIG51bGwgaWYgdGhlIGxpbmsgaXMgaW52YWxpZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBwYXJzZUxpbmsobGluaykge1xyXG4gICAgICAgIGNvbnN0IGFjdGlvbkxpbmsgPSBwYXJzZURlZXBMaW5rKGxpbmspO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aW9uQ29kZVVSTChhY3Rpb25MaW5rKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogUGFyc2VzIHRoZSBlbWFpbCBhY3Rpb24gbGluayBzdHJpbmcgYW5kIHJldHVybnMgYW4ge0BsaW5rIEFjdGlvbkNvZGVVUkx9IGlmXHJcbiAqIHRoZSBsaW5rIGlzIHZhbGlkLCBvdGhlcndpc2UgcmV0dXJucyBudWxsLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZUFjdGlvbkNvZGVVUkwobGluaykge1xyXG4gICAgcmV0dXJuIEFjdGlvbkNvZGVVUkwucGFyc2VMaW5rKGxpbmspO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQcm92aWRlciBmb3IgZ2VuZXJhdGluZyB7QGxpbmsgRW1haWxBdXRoQ3JlZGVudGlhbH0uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIEVtYWlsQXV0aFByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFByb3ZpZGVySWR9LlBBU1NXT1JELCBldmVuIGZvciBlbWFpbCBsaW5rLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJJZCA9IEVtYWlsQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lEO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIGFuIHtAbGluayBBdXRoQ3JlZGVudGlhbH0gdXNpbmcgYW4gZW1haWwgYW5kIHBhc3N3b3JkLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgKiBjb25zdCBhdXRoQ3JlZGVudGlhbCA9IEVtYWlsQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwoZW1haWwsIHBhc3N3b3JkKTtcclxuICAgICAqIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgc2lnbkluV2l0aENyZWRlbnRpYWwoYXV0aCwgYXV0aENyZWRlbnRpYWwpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAqIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgc2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmQoYXV0aCwgZW1haWwsIHBhc3N3b3JkKTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbWFpbCAtIEVtYWlsIGFkZHJlc3MuXHJcbiAgICAgKiBAcGFyYW0gcGFzc3dvcmQgLSBVc2VyIGFjY291bnQgcGFzc3dvcmQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgYXV0aCBwcm92aWRlciBjcmVkZW50aWFsLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlZGVudGlhbChlbWFpbCwgcGFzc3dvcmQpIHtcclxuICAgICAgICByZXR1cm4gRW1haWxBdXRoQ3JlZGVudGlhbC5fZnJvbUVtYWlsQW5kUGFzc3dvcmQoZW1haWwsIHBhc3N3b3JkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZSBhbiB7QGxpbmsgQXV0aENyZWRlbnRpYWx9IHVzaW5nIGFuIGVtYWlsIGFuZCBhbiBlbWFpbCBsaW5rIGFmdGVyIGEgc2lnbiBpbiB3aXRoXHJcbiAgICAgKiBlbWFpbCBsaW5rIG9wZXJhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICogY29uc3QgYXV0aENyZWRlbnRpYWwgPSBFbWFpbEF1dGhQcm92aWRlci5jcmVkZW50aWFsV2l0aExpbmsoYXV0aCwgZW1haWwsIGVtYWlsTGluayk7XHJcbiAgICAgKiBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IHNpZ25JbldpdGhDcmVkZW50aWFsKGF1dGgsIGF1dGhDcmVkZW50aWFsKTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgKiBhd2FpdCBzZW5kU2lnbkluTGlua1RvRW1haWwoYXV0aCwgZW1haWwpO1xyXG4gICAgICogLy8gT2J0YWluIGVtYWlsTGluayBmcm9tIHVzZXIuXHJcbiAgICAgKiBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IHNpZ25JbldpdGhFbWFpbExpbmsoYXV0aCwgZW1haWwsIGVtYWlsTGluayk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UgdXNlZCB0byB2ZXJpZnkgdGhlIGxpbmsuXHJcbiAgICAgKiBAcGFyYW0gZW1haWwgLSBFbWFpbCBhZGRyZXNzLlxyXG4gICAgICogQHBhcmFtIGVtYWlsTGluayAtIFNpZ24taW4gZW1haWwgbGluay5cclxuICAgICAqIEByZXR1cm5zIC0gVGhlIGF1dGggcHJvdmlkZXIgY3JlZGVudGlhbC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWRlbnRpYWxXaXRoTGluayhlbWFpbCwgZW1haWxMaW5rKSB7XHJcbiAgICAgICAgY29uc3QgYWN0aW9uQ29kZVVybCA9IEFjdGlvbkNvZGVVUkwucGFyc2VMaW5rKGVtYWlsTGluayk7XHJcbiAgICAgICAgX2Fzc2VydChhY3Rpb25Db2RlVXJsLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XHJcbiAgICAgICAgcmV0dXJuIEVtYWlsQXV0aENyZWRlbnRpYWwuX2Zyb21FbWFpbEFuZENvZGUoZW1haWwsIGFjdGlvbkNvZGVVcmwuY29kZSwgYWN0aW9uQ29kZVVybC50ZW5hbnRJZCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFByb3ZpZGVySWR9LlBBU1NXT1JELCBldmVuIGZvciBlbWFpbCBsaW5rLlxyXG4gKi9cclxuRW1haWxBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQgPSBcInBhc3N3b3JkXCIgLyogUHJvdmlkZXJJZC5QQVNTV09SRCAqLztcclxuLyoqXHJcbiAqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfUEFTU1dPUkQuXHJcbiAqL1xyXG5FbWFpbEF1dGhQcm92aWRlci5FTUFJTF9QQVNTV09SRF9TSUdOX0lOX01FVEhPRCA9IFwicGFzc3dvcmRcIiAvKiBTaWduSW5NZXRob2QuRU1BSUxfUEFTU1dPUkQgKi87XHJcbi8qKlxyXG4gKiBBbHdheXMgc2V0IHRvIHtAbGluayBTaWduSW5NZXRob2R9LkVNQUlMX0xJTksuXHJcbiAqL1xyXG5FbWFpbEF1dGhQcm92aWRlci5FTUFJTF9MSU5LX1NJR05fSU5fTUVUSE9EID0gXCJlbWFpbExpbmtcIiAvKiBTaWduSW5NZXRob2QuRU1BSUxfTElOSyAqLztcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBhbGwgRmVkZXJhdGVkIHByb3ZpZGVycyAoT0F1dGggKGluY2x1ZGluZyBPSURDKSwgU0FNTCkuXHJcbiAqXHJcbiAqIFRoaXMgY2xhc3MgaXMgbm90IG1lYW50IHRvIGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgRmVkZXJhdGVkQXV0aFByb3ZpZGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGdlbmVyaWMgT0F1dGggcHJvdmlkZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwcm92aWRlcklkIC0gUHJvdmlkZXIgZm9yIHdoaWNoIGNyZWRlbnRpYWxzIHNob3VsZCBiZSBnZW5lcmF0ZWQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVySWQpIHtcclxuICAgICAgICB0aGlzLnByb3ZpZGVySWQgPSBwcm92aWRlcklkO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLmRlZmF1bHRMYW5ndWFnZUNvZGUgPSBudWxsO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLmN1c3RvbVBhcmFtZXRlcnMgPSB7fTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBsYW5ndWFnZSBnb2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYW5ndWFnZUNvZGUgLSBsYW5ndWFnZSBjb2RlXHJcbiAgICAgKi9cclxuICAgIHNldERlZmF1bHRMYW5ndWFnZShsYW5ndWFnZUNvZGUpIHtcclxuICAgICAgICB0aGlzLmRlZmF1bHRMYW5ndWFnZUNvZGUgPSBsYW5ndWFnZUNvZGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIE9BdXRoIGN1c3RvbSBwYXJhbWV0ZXJzIHRvIHBhc3MgaW4gYW4gT0F1dGggcmVxdWVzdCBmb3IgcG9wdXAgYW5kIHJlZGlyZWN0IHNpZ24taW5cclxuICAgICAqIG9wZXJhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIEZvciBhIGRldGFpbGVkIGxpc3QsIGNoZWNrIHRoZSByZXNlcnZlZCByZXF1aXJlZCBPQXV0aCAyLjAgcGFyYW1ldGVycyBzdWNoIGFzIGBjbGllbnRfaWRgLFxyXG4gICAgICogYHJlZGlyZWN0X3VyaWAsIGBzY29wZWAsIGByZXNwb25zZV90eXBlYCwgYW5kIGBzdGF0ZWAgYXJlIG5vdCBhbGxvd2VkIGFuZCB3aWxsIGJlIGlnbm9yZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN1c3RvbU9BdXRoUGFyYW1ldGVycyAtIFRoZSBjdXN0b20gT0F1dGggcGFyYW1ldGVycyB0byBwYXNzIGluIHRoZSBPQXV0aCByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICBzZXRDdXN0b21QYXJhbWV0ZXJzKGN1c3RvbU9BdXRoUGFyYW1ldGVycykge1xyXG4gICAgICAgIHRoaXMuY3VzdG9tUGFyYW1ldGVycyA9IGN1c3RvbU9BdXRoUGFyYW1ldGVycztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgdGhlIGN1cnJlbnQgbGlzdCBvZiB7QGxpbmsgQ3VzdG9tUGFyYW1ldGVyc30uXHJcbiAgICAgKi9cclxuICAgIGdldEN1c3RvbVBhcmFtZXRlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tUGFyYW1ldGVycztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ29tbW9uIGNvZGUgdG8gYWxsIE9BdXRoIHByb3ZpZGVycy4gVGhpcyBpcyBzZXBhcmF0ZSBmcm9tIHRoZVxyXG4gKiB7QGxpbmsgT0F1dGhQcm92aWRlcn0gc28gdGhhdCBjaGlsZCBwcm92aWRlcnMgKGxpa2VcclxuICoge0BsaW5rIEdvb2dsZUF1dGhQcm92aWRlcn0pIGRvbid0IGluaGVyaXQgdGhlIGBjcmVkZW50aWFsYCBpbnN0YW5jZSBtZXRob2QuXHJcbiAqIEluc3RlYWQsIHRoZXkgcmVseSBvbiBhIHN0YXRpYyBgY3JlZGVudGlhbGAgbWV0aG9kLlxyXG4gKi9cclxuY2xhc3MgQmFzZU9BdXRoUHJvdmlkZXIgZXh0ZW5kcyBGZWRlcmF0ZWRBdXRoUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5zY29wZXMgPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGFuIE9BdXRoIHNjb3BlIHRvIHRoZSBjcmVkZW50aWFsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzY29wZSAtIFByb3ZpZGVyIE9BdXRoIHNjb3BlIHRvIGFkZC5cclxuICAgICAqL1xyXG4gICAgYWRkU2NvcGUoc2NvcGUpIHtcclxuICAgICAgICAvLyBJZiBub3QgYWxyZWFkeSBhZGRlZCwgYWRkIHNjb3BlIHRvIGxpc3QuXHJcbiAgICAgICAgaWYgKCF0aGlzLnNjb3Blcy5pbmNsdWRlcyhzY29wZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5zY29wZXMucHVzaChzY29wZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBsaXN0IG9mIE9BdXRoIHNjb3Blcy5cclxuICAgICAqL1xyXG4gICAgZ2V0U2NvcGVzKCkge1xyXG4gICAgICAgIHJldHVybiBbLi4udGhpcy5zY29wZXNdO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBQcm92aWRlciBmb3IgZ2VuZXJhdGluZyBnZW5lcmljIHtAbGluayBPQXV0aENyZWRlbnRpYWx9LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSByZWRpcmVjdC5cclxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgT0F1dGhQcm92aWRlcignZ29vZ2xlLmNvbScpO1xyXG4gKiAvLyBTdGFydCBhIHNpZ24gaW4gcHJvY2VzcyBmb3IgYW4gdW5hdXRoZW50aWNhdGVkIHVzZXIuXHJcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdwcm9maWxlJyk7XHJcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdlbWFpbCcpO1xyXG4gKiBhd2FpdCBzaWduSW5XaXRoUmVkaXJlY3QoYXV0aCwgcHJvdmlkZXIpO1xyXG4gKiAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGZ1bGwgcGFnZSByZWRpcmVjdCBhd2F5IGZyb20geW91ciBhcHBcclxuICpcclxuICogLy8gQWZ0ZXIgcmV0dXJuaW5nIGZyb20gdGhlIHJlZGlyZWN0IHdoZW4geW91ciBhcHAgaW5pdGlhbGl6ZXMgeW91IGNhbiBvYnRhaW4gdGhlIHJlc3VsdFxyXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRSZWRpcmVjdFJlc3VsdChhdXRoKTtcclxuICogaWYgKHJlc3VsdCkge1xyXG4gKiAgIC8vIFRoaXMgaXMgdGhlIHNpZ25lZC1pbiB1c2VyXHJcbiAqICAgY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xyXG4gKiAgIC8vIFRoaXMgZ2l2ZXMgeW91IGEgT0F1dGggQWNjZXNzIFRva2VuIGZvciB0aGUgcHJvdmlkZXIuXHJcbiAqICAgY29uc3QgY3JlZGVudGlhbCA9IHByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KGF1dGgsIHJlc3VsdCk7XHJcbiAqICAgY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSBwb3B1cC5cclxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgT0F1dGhQcm92aWRlcignZ29vZ2xlLmNvbScpO1xyXG4gKiBwcm92aWRlci5hZGRTY29wZSgncHJvZmlsZScpO1xyXG4gKiBwcm92aWRlci5hZGRTY29wZSgnZW1haWwnKTtcclxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aFBvcHVwKGF1dGgsIHByb3ZpZGVyKTtcclxuICpcclxuICogLy8gVGhlIHNpZ25lZC1pbiB1c2VyIGluZm8uXHJcbiAqIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcclxuICogLy8gVGhpcyBnaXZlcyB5b3UgYSBPQXV0aCBBY2Nlc3MgVG9rZW4gZm9yIHRoZSBwcm92aWRlci5cclxuICogY29uc3QgY3JlZGVudGlhbCA9IHByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KGF1dGgsIHJlc3VsdCk7XHJcbiAqIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcclxuICogYGBgXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIE9BdXRoUHJvdmlkZXIgZXh0ZW5kcyBCYXNlT0F1dGhQcm92aWRlciB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4ge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIEpTT04gc3RyaW5nIG9yIGEgcGxhaW4gb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIGpzb24gLSBBIHBsYWluIG9iamVjdCBvciBhIEpTT04gc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbUpTT04oanNvbikge1xyXG4gICAgICAgIGNvbnN0IG9iaiA9IHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uO1xyXG4gICAgICAgIF9hc3NlcnQoJ3Byb3ZpZGVySWQnIGluIG9iaiAmJiAnc2lnbkluTWV0aG9kJyBpbiBvYmosIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcclxuICAgICAgICByZXR1cm4gT0F1dGhDcmVkZW50aWFsLl9mcm9tUGFyYW1zKG9iaik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEgZ2VuZXJpYyBPQXV0aCBwcm92aWRlcidzIGFjY2VzcyB0b2tlbiBvciBJRCB0b2tlbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICogVGhlIHJhdyBub25jZSBpcyByZXF1aXJlZCB3aGVuIGFuIElEIHRva2VuIHdpdGggYSBub25jZSBmaWVsZCBpcyBwcm92aWRlZC4gVGhlIFNIQS0yNTYgaGFzaCBvZlxyXG4gICAgICogdGhlIHJhdyBub25jZSBtdXN0IG1hdGNoIHRoZSBub25jZSBmaWVsZCBpbiB0aGUgSUQgdG9rZW4uXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAqIC8vIGBnb29nbGVVc2VyYCBmcm9tIHRoZSBvbnN1Y2Nlc3MgR29vZ2xlIFNpZ24gSW4gY2FsbGJhY2suXHJcbiAgICAgKiAvLyBJbml0aWFsaXplIGEgZ2VuZXJhdGUgT0F1dGggcHJvdmlkZXIgd2l0aCBhIGBnb29nbGUuY29tYCBwcm92aWRlcklkLlxyXG4gICAgICogY29uc3QgcHJvdmlkZXIgPSBuZXcgT0F1dGhQcm92aWRlcignZ29vZ2xlLmNvbScpO1xyXG4gICAgICogY29uc3QgY3JlZGVudGlhbCA9IHByb3ZpZGVyLmNyZWRlbnRpYWwoe1xyXG4gICAgICogICBpZFRva2VuOiBnb29nbGVVc2VyLmdldEF1dGhSZXNwb25zZSgpLmlkX3Rva2VuLFxyXG4gICAgICogfSk7XHJcbiAgICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoQ3JlZGVudGlhbChjcmVkZW50aWFsKTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBFaXRoZXIgdGhlIG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIElEIHRva2VuLCBhY2Nlc3MgdG9rZW4gYW5kIHJhdyBub25jZVxyXG4gICAgICogb3IgdGhlIElEIHRva2VuIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgY3JlZGVudGlhbChwYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3JlZGVudGlhbChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHsgbm9uY2U6IHBhcmFtcy5yYXdOb25jZSB9KSk7XHJcbiAgICB9XHJcbiAgICAvKiogQW4gaW50ZXJuYWwgY3JlZGVudGlhbCBtZXRob2QgdGhhdCBhY2NlcHRzIG1vcmUgcGVybWlzc2l2ZSBvcHRpb25zICovXHJcbiAgICBfY3JlZGVudGlhbChwYXJhbXMpIHtcclxuICAgICAgICBfYXNzZXJ0KHBhcmFtcy5pZFRva2VuIHx8IHBhcmFtcy5hY2Nlc3NUb2tlbiwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xyXG4gICAgICAgIC8vIEZvciBPQXV0aENyZWRlbnRpYWwsIHNpZ24gaW4gbWV0aG9kIGlzIHNhbWUgYXMgcHJvdmlkZXJJZC5cclxuICAgICAgICByZXR1cm4gT0F1dGhDcmVkZW50aWFsLl9mcm9tUGFyYW1zKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKSwgeyBwcm92aWRlcklkOiB0aGlzLnByb3ZpZGVySWQsIHNpZ25Jbk1ldGhvZDogdGhpcy5wcm92aWRlcklkIH0pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgVXNlckNyZWRlbnRpYWx9LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbVJlc3VsdCh1c2VyQ3JlZGVudGlhbCkge1xyXG4gICAgICAgIHJldHVybiBPQXV0aFByb3ZpZGVyLm9hdXRoQ3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QodXNlckNyZWRlbnRpYWwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBBdXRoRXJyb3J9IHdoaWNoIHdhc1xyXG4gICAgICogdGhyb3duIGR1cmluZyBhIHNpZ24taW4sIGxpbmssIG9yIHJlYXV0aGVudGljYXRlIG9wZXJhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21FcnJvcihlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBPQXV0aFByb3ZpZGVyLm9hdXRoQ3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoKGVycm9yLmN1c3RvbURhdGEgfHwge30pKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBvYXV0aENyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHsgX3Rva2VuUmVzcG9uc2U6IHRva2VuUmVzcG9uc2UgfSkge1xyXG4gICAgICAgIGlmICghdG9rZW5SZXNwb25zZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBvYXV0aElkVG9rZW4sIG9hdXRoQWNjZXNzVG9rZW4sIG9hdXRoVG9rZW5TZWNyZXQsIHBlbmRpbmdUb2tlbiwgbm9uY2UsIHByb3ZpZGVySWQgfSA9IHRva2VuUmVzcG9uc2U7XHJcbiAgICAgICAgaWYgKCFvYXV0aEFjY2Vzc1Rva2VuICYmXHJcbiAgICAgICAgICAgICFvYXV0aFRva2VuU2VjcmV0ICYmXHJcbiAgICAgICAgICAgICFvYXV0aElkVG9rZW4gJiZcclxuICAgICAgICAgICAgIXBlbmRpbmdUb2tlbikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFwcm92aWRlcklkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE9BdXRoUHJvdmlkZXIocHJvdmlkZXJJZCkuX2NyZWRlbnRpYWwoe1xyXG4gICAgICAgICAgICAgICAgaWRUb2tlbjogb2F1dGhJZFRva2VuLFxyXG4gICAgICAgICAgICAgICAgYWNjZXNzVG9rZW46IG9hdXRoQWNjZXNzVG9rZW4sXHJcbiAgICAgICAgICAgICAgICBub25jZSxcclxuICAgICAgICAgICAgICAgIHBlbmRpbmdUb2tlblxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQcm92aWRlciBmb3IgZ2VuZXJhdGluZyBhbiB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmb3Ige0BsaW5rIFByb3ZpZGVySWR9LkZBQ0VCT09LLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSByZWRpcmVjdC5cclxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgRmFjZWJvb2tBdXRoUHJvdmlkZXIoKTtcclxuICogLy8gU3RhcnQgYSBzaWduIGluIHByb2Nlc3MgZm9yIGFuIHVuYXV0aGVudGljYXRlZCB1c2VyLlxyXG4gKiBwcm92aWRlci5hZGRTY29wZSgndXNlcl9iaXJ0aGRheScpO1xyXG4gKiBhd2FpdCBzaWduSW5XaXRoUmVkaXJlY3QoYXV0aCwgcHJvdmlkZXIpO1xyXG4gKiAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGZ1bGwgcGFnZSByZWRpcmVjdCBhd2F5IGZyb20geW91ciBhcHBcclxuICpcclxuICogLy8gQWZ0ZXIgcmV0dXJuaW5nIGZyb20gdGhlIHJlZGlyZWN0IHdoZW4geW91ciBhcHAgaW5pdGlhbGl6ZXMgeW91IGNhbiBvYnRhaW4gdGhlIHJlc3VsdFxyXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRSZWRpcmVjdFJlc3VsdChhdXRoKTtcclxuICogaWYgKHJlc3VsdCkge1xyXG4gKiAgIC8vIFRoaXMgaXMgdGhlIHNpZ25lZC1pbiB1c2VyXHJcbiAqICAgY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xyXG4gKiAgIC8vIFRoaXMgZ2l2ZXMgeW91IGEgRmFjZWJvb2sgQWNjZXNzIFRva2VuLlxyXG4gKiAgIGNvbnN0IGNyZWRlbnRpYWwgPSBGYWNlYm9va0F1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xyXG4gKiAgIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcG9wdXAuXHJcbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IEZhY2Vib29rQXV0aFByb3ZpZGVyKCk7XHJcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCd1c2VyX2JpcnRoZGF5Jyk7XHJcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNpZ25JbldpdGhQb3B1cChhdXRoLCBwcm92aWRlcik7XHJcbiAqXHJcbiAqIC8vIFRoZSBzaWduZWQtaW4gdXNlciBpbmZvLlxyXG4gKiBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XHJcbiAqIC8vIFRoaXMgZ2l2ZXMgeW91IGEgRmFjZWJvb2sgQWNjZXNzIFRva2VuLlxyXG4gKiBjb25zdCBjcmVkZW50aWFsID0gRmFjZWJvb2tBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcclxuICogY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xyXG4gKiBgYGBcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgRmFjZWJvb2tBdXRoUHJvdmlkZXIgZXh0ZW5kcyBCYXNlT0F1dGhQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihcImZhY2Vib29rLmNvbVwiIC8qIFByb3ZpZGVySWQuRkFDRUJPT0sgKi8pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY3JlZGVudGlhbCBmb3IgRmFjZWJvb2suXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAqIC8vIGBldmVudGAgZnJvbSB0aGUgRmFjZWJvb2sgYXV0aC5hdXRoUmVzcG9uc2VDaGFuZ2UgY2FsbGJhY2suXHJcbiAgICAgKiBjb25zdCBjcmVkZW50aWFsID0gRmFjZWJvb2tBdXRoUHJvdmlkZXIuY3JlZGVudGlhbChldmVudC5hdXRoUmVzcG9uc2UuYWNjZXNzVG9rZW4pO1xyXG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aENyZWRlbnRpYWwoY3JlZGVudGlhbCk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWNjZXNzVG9rZW4gLSBGYWNlYm9vayBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVkZW50aWFsKGFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgcmV0dXJuIE9BdXRoQ3JlZGVudGlhbC5fZnJvbVBhcmFtcyh7XHJcbiAgICAgICAgICAgIHByb3ZpZGVySWQ6IEZhY2Vib29rQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lELFxyXG4gICAgICAgICAgICBzaWduSW5NZXRob2Q6IEZhY2Vib29rQXV0aFByb3ZpZGVyLkZBQ0VCT09LX1NJR05fSU5fTUVUSE9ELFxyXG4gICAgICAgICAgICBhY2Nlc3NUb2tlblxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBVc2VyQ3JlZGVudGlhbH0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tUmVzdWx0KHVzZXJDcmVkZW50aWFsKSB7XHJcbiAgICAgICAgcmV0dXJuIEZhY2Vib29rQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHVzZXJDcmVkZW50aWFsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgQXV0aEVycm9yfSB3aGljaCB3YXNcclxuICAgICAqIHRocm93biBkdXJpbmcgYSBzaWduLWluLCBsaW5rLCBvciByZWF1dGhlbnRpY2F0ZSBvcGVyYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tRXJyb3IoZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gRmFjZWJvb2tBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoKGVycm9yLmN1c3RvbURhdGEgfHwge30pKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh7IF90b2tlblJlc3BvbnNlOiB0b2tlblJlc3BvbnNlIH0pIHtcclxuICAgICAgICBpZiAoIXRva2VuUmVzcG9uc2UgfHwgISgnb2F1dGhBY2Nlc3NUb2tlbicgaW4gdG9rZW5SZXNwb25zZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdG9rZW5SZXNwb25zZS5vYXV0aEFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gRmFjZWJvb2tBdXRoUHJvdmlkZXIuY3JlZGVudGlhbCh0b2tlblJlc3BvbnNlLm9hdXRoQWNjZXNzVG9rZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKiBBbHdheXMgc2V0IHRvIHtAbGluayBTaWduSW5NZXRob2R9LkZBQ0VCT09LLiAqL1xyXG5GYWNlYm9va0F1dGhQcm92aWRlci5GQUNFQk9PS19TSUdOX0lOX01FVEhPRCA9IFwiZmFjZWJvb2suY29tXCIgLyogU2lnbkluTWV0aG9kLkZBQ0VCT09LICovO1xyXG4vKiogQWx3YXlzIHNldCB0byB7QGxpbmsgUHJvdmlkZXJJZH0uRkFDRUJPT0suICovXHJcbkZhY2Vib29rQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lEID0gXCJmYWNlYm9vay5jb21cIiAvKiBQcm92aWRlcklkLkZBQ0VCT09LICovO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUHJvdmlkZXIgZm9yIGdlbmVyYXRpbmcgYW4ge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZm9yIHtAbGluayBQcm92aWRlcklkfS5HT09HTEUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gU2lnbiBpbiB1c2luZyBhIHJlZGlyZWN0LlxyXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBHb29nbGVBdXRoUHJvdmlkZXIoKTtcclxuICogLy8gU3RhcnQgYSBzaWduIGluIHByb2Nlc3MgZm9yIGFuIHVuYXV0aGVudGljYXRlZCB1c2VyLlxyXG4gKiBwcm92aWRlci5hZGRTY29wZSgncHJvZmlsZScpO1xyXG4gKiBwcm92aWRlci5hZGRTY29wZSgnZW1haWwnKTtcclxuICogYXdhaXQgc2lnbkluV2l0aFJlZGlyZWN0KGF1dGgsIHByb3ZpZGVyKTtcclxuICogLy8gVGhpcyB3aWxsIHRyaWdnZXIgYSBmdWxsIHBhZ2UgcmVkaXJlY3QgYXdheSBmcm9tIHlvdXIgYXBwXHJcbiAqXHJcbiAqIC8vIEFmdGVyIHJldHVybmluZyBmcm9tIHRoZSByZWRpcmVjdCB3aGVuIHlvdXIgYXBwIGluaXRpYWxpemVzIHlvdSBjYW4gb2J0YWluIHRoZSByZXN1bHRcclxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0UmVkaXJlY3RSZXN1bHQoYXV0aCk7XHJcbiAqIGlmIChyZXN1bHQpIHtcclxuICogICAvLyBUaGlzIGlzIHRoZSBzaWduZWQtaW4gdXNlclxyXG4gKiAgIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcclxuICogICAvLyBUaGlzIGdpdmVzIHlvdSBhIEdvb2dsZSBBY2Nlc3MgVG9rZW4uXHJcbiAqICAgY29uc3QgY3JlZGVudGlhbCA9IEdvb2dsZUF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xyXG4gKiAgIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcG9wdXAuXHJcbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IEdvb2dsZUF1dGhQcm92aWRlcigpO1xyXG4gKiBwcm92aWRlci5hZGRTY29wZSgncHJvZmlsZScpO1xyXG4gKiBwcm92aWRlci5hZGRTY29wZSgnZW1haWwnKTtcclxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aFBvcHVwKGF1dGgsIHByb3ZpZGVyKTtcclxuICpcclxuICogLy8gVGhlIHNpZ25lZC1pbiB1c2VyIGluZm8uXHJcbiAqIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcclxuICogLy8gVGhpcyBnaXZlcyB5b3UgYSBHb29nbGUgQWNjZXNzIFRva2VuLlxyXG4gKiBjb25zdCBjcmVkZW50aWFsID0gR29vZ2xlQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KHJlc3VsdCk7XHJcbiAqIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIEdvb2dsZUF1dGhQcm92aWRlciBleHRlbmRzIEJhc2VPQXV0aFByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKFwiZ29vZ2xlLmNvbVwiIC8qIFByb3ZpZGVySWQuR09PR0xFICovKTtcclxuICAgICAgICB0aGlzLmFkZFNjb3BlKCdwcm9maWxlJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjcmVkZW50aWFsIGZvciBHb29nbGUuIEF0IGxlYXN0IG9uZSBvZiBJRCB0b2tlbiBhbmQgYWNjZXNzIHRva2VuIGlzIHJlcXVpcmVkLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgKiAvLyBcXGBnb29nbGVVc2VyXFxgIGZyb20gdGhlIG9uc3VjY2VzcyBHb29nbGUgU2lnbiBJbiBjYWxsYmFjay5cclxuICAgICAqIGNvbnN0IGNyZWRlbnRpYWwgPSBHb29nbGVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbChnb29nbGVVc2VyLmdldEF1dGhSZXNwb25zZSgpLmlkX3Rva2VuKTtcclxuICAgICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNpZ25JbldpdGhDcmVkZW50aWFsKGNyZWRlbnRpYWwpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlkVG9rZW4gLSBHb29nbGUgSUQgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0gYWNjZXNzVG9rZW4gLSBHb29nbGUgYWNjZXNzIHRva2VuLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlZGVudGlhbChpZFRva2VuLCBhY2Nlc3NUb2tlbikge1xyXG4gICAgICAgIHJldHVybiBPQXV0aENyZWRlbnRpYWwuX2Zyb21QYXJhbXMoe1xyXG4gICAgICAgICAgICBwcm92aWRlcklkOiBHb29nbGVBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQsXHJcbiAgICAgICAgICAgIHNpZ25Jbk1ldGhvZDogR29vZ2xlQXV0aFByb3ZpZGVyLkdPT0dMRV9TSUdOX0lOX01FVEhPRCxcclxuICAgICAgICAgICAgaWRUb2tlbixcclxuICAgICAgICAgICAgYWNjZXNzVG9rZW5cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgVXNlckNyZWRlbnRpYWx9LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbVJlc3VsdCh1c2VyQ3JlZGVudGlhbCkge1xyXG4gICAgICAgIHJldHVybiBHb29nbGVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QodXNlckNyZWRlbnRpYWwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBBdXRoRXJyb3J9IHdoaWNoIHdhc1xyXG4gICAgICogdGhyb3duIGR1cmluZyBhIHNpZ24taW4sIGxpbmssIG9yIHJlYXV0aGVudGljYXRlIG9wZXJhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21FcnJvcihlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBHb29nbGVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoKGVycm9yLmN1c3RvbURhdGEgfHwge30pKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh7IF90b2tlblJlc3BvbnNlOiB0b2tlblJlc3BvbnNlIH0pIHtcclxuICAgICAgICBpZiAoIXRva2VuUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgb2F1dGhJZFRva2VuLCBvYXV0aEFjY2Vzc1Rva2VuIH0gPSB0b2tlblJlc3BvbnNlO1xyXG4gICAgICAgIGlmICghb2F1dGhJZFRva2VuICYmICFvYXV0aEFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgY291bGQgYmUgYW4gb2F1dGggMSBjcmVkZW50aWFsIG9yIGEgcGhvbmUgY3JlZGVudGlhbFxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIEdvb2dsZUF1dGhQcm92aWRlci5jcmVkZW50aWFsKG9hdXRoSWRUb2tlbiwgb2F1dGhBY2Nlc3NUb2tlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFNpZ25Jbk1ldGhvZH0uR09PR0xFLiAqL1xyXG5Hb29nbGVBdXRoUHJvdmlkZXIuR09PR0xFX1NJR05fSU5fTUVUSE9EID0gXCJnb29nbGUuY29tXCIgLyogU2lnbkluTWV0aG9kLkdPT0dMRSAqLztcclxuLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFByb3ZpZGVySWR9LkdPT0dMRS4gKi9cclxuR29vZ2xlQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lEID0gXCJnb29nbGUuY29tXCIgLyogUHJvdmlkZXJJZC5HT09HTEUgKi87XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQcm92aWRlciBmb3IgZ2VuZXJhdGluZyBhbiB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmb3Ige0BsaW5rIFByb3ZpZGVySWR9LkdJVEhVQi5cclxuICpcclxuICogQHJlbWFya3NcclxuICogR2l0SHViIHJlcXVpcmVzIGFuIE9BdXRoIDIuMCByZWRpcmVjdCwgc28geW91IGNhbiBlaXRoZXIgaGFuZGxlIHRoZSByZWRpcmVjdCBkaXJlY3RseSwgb3IgdXNlXHJcbiAqIHRoZSB7QGxpbmsgc2lnbkluV2l0aFBvcHVwfSBoYW5kbGVyOlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSByZWRpcmVjdC5cclxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgR2l0aHViQXV0aFByb3ZpZGVyKCk7XHJcbiAqIC8vIFN0YXJ0IGEgc2lnbiBpbiBwcm9jZXNzIGZvciBhbiB1bmF1dGhlbnRpY2F0ZWQgdXNlci5cclxuICogcHJvdmlkZXIuYWRkU2NvcGUoJ3JlcG8nKTtcclxuICogYXdhaXQgc2lnbkluV2l0aFJlZGlyZWN0KGF1dGgsIHByb3ZpZGVyKTtcclxuICogLy8gVGhpcyB3aWxsIHRyaWdnZXIgYSBmdWxsIHBhZ2UgcmVkaXJlY3QgYXdheSBmcm9tIHlvdXIgYXBwXHJcbiAqXHJcbiAqIC8vIEFmdGVyIHJldHVybmluZyBmcm9tIHRoZSByZWRpcmVjdCB3aGVuIHlvdXIgYXBwIGluaXRpYWxpemVzIHlvdSBjYW4gb2J0YWluIHRoZSByZXN1bHRcclxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0UmVkaXJlY3RSZXN1bHQoYXV0aCk7XHJcbiAqIGlmIChyZXN1bHQpIHtcclxuICogICAvLyBUaGlzIGlzIHRoZSBzaWduZWQtaW4gdXNlclxyXG4gKiAgIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcclxuICogICAvLyBUaGlzIGdpdmVzIHlvdSBhIEdpdEh1YiBBY2Nlc3MgVG9rZW4uXHJcbiAqICAgY29uc3QgY3JlZGVudGlhbCA9IEdpdGh1YkF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xyXG4gKiAgIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcG9wdXAuXHJcbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IEdpdGh1YkF1dGhQcm92aWRlcigpO1xyXG4gKiBwcm92aWRlci5hZGRTY29wZSgncmVwbycpO1xyXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoUG9wdXAoYXV0aCwgcHJvdmlkZXIpO1xyXG4gKlxyXG4gKiAvLyBUaGUgc2lnbmVkLWluIHVzZXIgaW5mby5cclxuICogY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xyXG4gKiAvLyBUaGlzIGdpdmVzIHlvdSBhIEdpdEh1YiBBY2Nlc3MgVG9rZW4uXHJcbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBHaXRodWJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcclxuICogY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xyXG4gKiBgYGBcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgR2l0aHViQXV0aFByb3ZpZGVyIGV4dGVuZHMgQmFzZU9BdXRoUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoXCJnaXRodWIuY29tXCIgLyogUHJvdmlkZXJJZC5HSVRIVUIgKi8pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY3JlZGVudGlhbCBmb3IgR2l0SHViLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY2Nlc3NUb2tlbiAtIEdpdEh1YiBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVkZW50aWFsKGFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgcmV0dXJuIE9BdXRoQ3JlZGVudGlhbC5fZnJvbVBhcmFtcyh7XHJcbiAgICAgICAgICAgIHByb3ZpZGVySWQ6IEdpdGh1YkF1dGhQcm92aWRlci5QUk9WSURFUl9JRCxcclxuICAgICAgICAgICAgc2lnbkluTWV0aG9kOiBHaXRodWJBdXRoUHJvdmlkZXIuR0lUSFVCX1NJR05fSU5fTUVUSE9ELFxyXG4gICAgICAgICAgICBhY2Nlc3NUb2tlblxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBVc2VyQ3JlZGVudGlhbH0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tUmVzdWx0KHVzZXJDcmVkZW50aWFsKSB7XHJcbiAgICAgICAgcmV0dXJuIEdpdGh1YkF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh1c2VyQ3JlZGVudGlhbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIEF1dGhFcnJvcn0gd2hpY2ggd2FzXHJcbiAgICAgKiB0aHJvd24gZHVyaW5nIGEgc2lnbi1pbiwgbGluaywgb3IgcmVhdXRoZW50aWNhdGUgb3BlcmF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbUVycm9yKGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIEdpdGh1YkF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCgoZXJyb3IuY3VzdG9tRGF0YSB8fCB7fSkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHsgX3Rva2VuUmVzcG9uc2U6IHRva2VuUmVzcG9uc2UgfSkge1xyXG4gICAgICAgIGlmICghdG9rZW5SZXNwb25zZSB8fCAhKCdvYXV0aEFjY2Vzc1Rva2VuJyBpbiB0b2tlblJlc3BvbnNlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0b2tlblJlc3BvbnNlLm9hdXRoQWNjZXNzVG9rZW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBHaXRodWJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbCh0b2tlblJlc3BvbnNlLm9hdXRoQWNjZXNzVG9rZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKiBBbHdheXMgc2V0IHRvIHtAbGluayBTaWduSW5NZXRob2R9LkdJVEhVQi4gKi9cclxuR2l0aHViQXV0aFByb3ZpZGVyLkdJVEhVQl9TSUdOX0lOX01FVEhPRCA9IFwiZ2l0aHViLmNvbVwiIC8qIFNpZ25Jbk1ldGhvZC5HSVRIVUIgKi87XHJcbi8qKiBBbHdheXMgc2V0IHRvIHtAbGluayBQcm92aWRlcklkfS5HSVRIVUIuICovXHJcbkdpdGh1YkF1dGhQcm92aWRlci5QUk9WSURFUl9JRCA9IFwiZ2l0aHViLmNvbVwiIC8qIFByb3ZpZGVySWQuR0lUSFVCICovO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBJRFBfUkVRVUVTVF9VUkkgPSAnaHR0cDovL2xvY2FsaG9zdCc7XHJcbi8qKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBTQU1MQXV0aENyZWRlbnRpYWwgZXh0ZW5kcyBBdXRoQ3JlZGVudGlhbCB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcklkLCBwZW5kaW5nVG9rZW4pIHtcclxuICAgICAgICBzdXBlcihwcm92aWRlcklkLCBwcm92aWRlcklkKTtcclxuICAgICAgICB0aGlzLnBlbmRpbmdUb2tlbiA9IHBlbmRpbmdUb2tlbjtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9nZXRJZFRva2VuUmVzcG9uc2UoYXV0aCkge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmJ1aWxkUmVxdWVzdCgpO1xyXG4gICAgICAgIHJldHVybiBzaWduSW5XaXRoSWRwKGF1dGgsIHJlcXVlc3QpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX2xpbmtUb0lkVG9rZW4oYXV0aCwgaWRUb2tlbikge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmJ1aWxkUmVxdWVzdCgpO1xyXG4gICAgICAgIHJlcXVlc3QuaWRUb2tlbiA9IGlkVG9rZW47XHJcbiAgICAgICAgcmV0dXJuIHNpZ25JbldpdGhJZHAoYXV0aCwgcmVxdWVzdCk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBfZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyKGF1dGgpIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5idWlsZFJlcXVlc3QoKTtcclxuICAgICAgICByZXF1ZXN0LmF1dG9DcmVhdGUgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gc2lnbkluV2l0aElkcChhdXRoLCByZXF1ZXN0KTtcclxuICAgIH1cclxuICAgIC8qKiB7QGluaGVyaXRkb2MgQXV0aENyZWRlbnRpYWwudG9KU09OfSAgKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzaWduSW5NZXRob2Q6IHRoaXMuc2lnbkluTWV0aG9kLFxyXG4gICAgICAgICAgICBwcm92aWRlcklkOiB0aGlzLnByb3ZpZGVySWQsXHJcbiAgICAgICAgICAgIHBlbmRpbmdUb2tlbjogdGhpcy5wZW5kaW5nVG9rZW5cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGF0aWMgbWV0aG9kIHRvIGRlc2VyaWFsaXplIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhbiBvYmplY3QgaW50byBhblxyXG4gICAgICoge0BsaW5rICBBdXRoQ3JlZGVudGlhbH0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGpzb24gLSBJbnB1dCBjYW4gYmUgZWl0aGVyIE9iamVjdCBvciB0aGUgc3RyaW5naWZpZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdC5cclxuICAgICAqIFdoZW4gc3RyaW5nIGlzIHByb3ZpZGVkLCBKU09OLnBhcnNlIHdvdWxkIGJlIGNhbGxlZCBmaXJzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBJZiB0aGUgSlNPTiBpbnB1dCBkb2VzIG5vdCByZXByZXNlbnQgYW4ge0BsaW5rICBBdXRoQ3JlZGVudGlhbH0sIG51bGwgaXMgcmV0dXJuZWQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XHJcbiAgICAgICAgY29uc3Qgb2JqID0gdHlwZW9mIGpzb24gPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShqc29uKSA6IGpzb247XHJcbiAgICAgICAgY29uc3QgeyBwcm92aWRlcklkLCBzaWduSW5NZXRob2QsIHBlbmRpbmdUb2tlbiB9ID0gb2JqO1xyXG4gICAgICAgIGlmICghcHJvdmlkZXJJZCB8fFxyXG4gICAgICAgICAgICAhc2lnbkluTWV0aG9kIHx8XHJcbiAgICAgICAgICAgICFwZW5kaW5nVG9rZW4gfHxcclxuICAgICAgICAgICAgcHJvdmlkZXJJZCAhPT0gc2lnbkluTWV0aG9kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFNBTUxBdXRoQ3JlZGVudGlhbChwcm92aWRlcklkLCBwZW5kaW5nVG9rZW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgc3RhdGljIG1ldGhvZCB0byBhdm9pZCBleHBvc2luZyB0aGUgY29uc3RydWN0b3IgdG8gZW5kIHVzZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgX2NyZWF0ZShwcm92aWRlcklkLCBwZW5kaW5nVG9rZW4pIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNBTUxBdXRoQ3JlZGVudGlhbChwcm92aWRlcklkLCBwZW5kaW5nVG9rZW4pO1xyXG4gICAgfVxyXG4gICAgYnVpbGRSZXF1ZXN0KCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJlcXVlc3RVcmk6IElEUF9SRVFVRVNUX1VSSSxcclxuICAgICAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWUsXHJcbiAgICAgICAgICAgIHBlbmRpbmdUb2tlbjogdGhpcy5wZW5kaW5nVG9rZW5cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IFNBTUxfUFJPVklERVJfUFJFRklYID0gJ3NhbWwuJztcclxuLyoqXHJcbiAqIEFuIHtAbGluayBBdXRoUHJvdmlkZXJ9IGZvciBTQU1MLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBTQU1MQXV0aFByb3ZpZGVyIGV4dGVuZHMgRmVkZXJhdGVkQXV0aFByb3ZpZGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0b3IuIFRoZSBwcm92aWRlcklkIG11c3Qgc3RhcnQgd2l0aCBcInNhbWwuXCJcclxuICAgICAqIEBwYXJhbSBwcm92aWRlcklkIC0gU0FNTCBwcm92aWRlciBJRC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXJJZCkge1xyXG4gICAgICAgIF9hc3NlcnQocHJvdmlkZXJJZC5zdGFydHNXaXRoKFNBTUxfUFJPVklERVJfUFJFRklYKSwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xyXG4gICAgICAgIHN1cGVyKHByb3ZpZGVySWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYW4ge0BsaW5rIEF1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIFVzZXJDcmVkZW50aWFsfSBhZnRlciBhXHJcbiAgICAgKiBzdWNjZXNzZnVsIFNBTUwgZmxvdyBjb21wbGV0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqXHJcbiAgICAgKiBGb3IgZXhhbXBsZSwgdG8gZ2V0IGFuIHtAbGluayBBdXRoQ3JlZGVudGlhbH0sIHlvdSBjb3VsZCB3cml0ZSB0aGVcclxuICAgICAqIGZvbGxvd2luZyBjb2RlOlxyXG4gICAgICpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IHNpZ25JbldpdGhQb3B1cChhdXRoLCBzYW1sUHJvdmlkZXIpO1xyXG4gICAgICogY29uc3QgY3JlZGVudGlhbCA9IFNBTUxBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQodXNlckNyZWRlbnRpYWwpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tUmVzdWx0KHVzZXJDcmVkZW50aWFsKSB7XHJcbiAgICAgICAgcmV0dXJuIFNBTUxBdXRoUHJvdmlkZXIuc2FtbENyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHVzZXJDcmVkZW50aWFsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgQXV0aEVycm9yfSB3aGljaCB3YXNcclxuICAgICAqIHRocm93biBkdXJpbmcgYSBzaWduLWluLCBsaW5rLCBvciByZWF1dGhlbnRpY2F0ZSBvcGVyYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tRXJyb3IoZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gU0FNTEF1dGhQcm92aWRlci5zYW1sQ3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoKGVycm9yLmN1c3RvbURhdGEgfHwge30pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiB7QGxpbmsgQXV0aENyZWRlbnRpYWx9IGZyb20gYSBKU09OIHN0cmluZyBvciBhIHBsYWluIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBqc29uIC0gQSBwbGFpbiBvYmplY3Qgb3IgYSBKU09OIHN0cmluZ1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21KU09OKGpzb24pIHtcclxuICAgICAgICBjb25zdCBjcmVkZW50aWFsID0gU0FNTEF1dGhDcmVkZW50aWFsLmZyb21KU09OKGpzb24pO1xyXG4gICAgICAgIF9hc3NlcnQoY3JlZGVudGlhbCwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xyXG4gICAgICAgIHJldHVybiBjcmVkZW50aWFsO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHNhbWxDcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh7IF90b2tlblJlc3BvbnNlOiB0b2tlblJlc3BvbnNlIH0pIHtcclxuICAgICAgICBpZiAoIXRva2VuUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgcGVuZGluZ1Rva2VuLCBwcm92aWRlcklkIH0gPSB0b2tlblJlc3BvbnNlO1xyXG4gICAgICAgIGlmICghcGVuZGluZ1Rva2VuIHx8ICFwcm92aWRlcklkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gU0FNTEF1dGhDcmVkZW50aWFsLl9jcmVhdGUocHJvdmlkZXJJZCwgcGVuZGluZ1Rva2VuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQcm92aWRlciBmb3IgZ2VuZXJhdGluZyBhbiB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmb3Ige0BsaW5rIFByb3ZpZGVySWR9LlRXSVRURVIuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gU2lnbiBpbiB1c2luZyBhIHJlZGlyZWN0LlxyXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBUd2l0dGVyQXV0aFByb3ZpZGVyKCk7XHJcbiAqIC8vIFN0YXJ0IGEgc2lnbiBpbiBwcm9jZXNzIGZvciBhbiB1bmF1dGhlbnRpY2F0ZWQgdXNlci5cclxuICogYXdhaXQgc2lnbkluV2l0aFJlZGlyZWN0KGF1dGgsIHByb3ZpZGVyKTtcclxuICogLy8gVGhpcyB3aWxsIHRyaWdnZXIgYSBmdWxsIHBhZ2UgcmVkaXJlY3QgYXdheSBmcm9tIHlvdXIgYXBwXHJcbiAqXHJcbiAqIC8vIEFmdGVyIHJldHVybmluZyBmcm9tIHRoZSByZWRpcmVjdCB3aGVuIHlvdXIgYXBwIGluaXRpYWxpemVzIHlvdSBjYW4gb2J0YWluIHRoZSByZXN1bHRcclxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0UmVkaXJlY3RSZXN1bHQoYXV0aCk7XHJcbiAqIGlmIChyZXN1bHQpIHtcclxuICogICAvLyBUaGlzIGlzIHRoZSBzaWduZWQtaW4gdXNlclxyXG4gKiAgIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcclxuICogICAvLyBUaGlzIGdpdmVzIHlvdSBhIFR3aXR0ZXIgQWNjZXNzIFRva2VuIGFuZCBTZWNyZXQuXHJcbiAqICAgY29uc3QgY3JlZGVudGlhbCA9IFR3aXR0ZXJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcclxuICogICBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XHJcbiAqICAgY29uc3Qgc2VjcmV0ID0gY3JlZGVudGlhbC5zZWNyZXQ7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gU2lnbiBpbiB1c2luZyBhIHBvcHVwLlxyXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBUd2l0dGVyQXV0aFByb3ZpZGVyKCk7XHJcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNpZ25JbldpdGhQb3B1cChhdXRoLCBwcm92aWRlcik7XHJcbiAqXHJcbiAqIC8vIFRoZSBzaWduZWQtaW4gdXNlciBpbmZvLlxyXG4gKiBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XHJcbiAqIC8vIFRoaXMgZ2l2ZXMgeW91IGEgVHdpdHRlciBBY2Nlc3MgVG9rZW4gYW5kIFNlY3JldC5cclxuICogY29uc3QgY3JlZGVudGlhbCA9IFR3aXR0ZXJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcclxuICogY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xyXG4gKiBjb25zdCBzZWNyZXQgPSBjcmVkZW50aWFsLnNlY3JldDtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIFR3aXR0ZXJBdXRoUHJvdmlkZXIgZXh0ZW5kcyBCYXNlT0F1dGhQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihcInR3aXR0ZXIuY29tXCIgLyogUHJvdmlkZXJJZC5UV0lUVEVSICovKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNyZWRlbnRpYWwgZm9yIFR3aXR0ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRva2VuIC0gVHdpdHRlciBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0gc2VjcmV0IC0gVHdpdHRlciBzZWNyZXQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVkZW50aWFsKHRva2VuLCBzZWNyZXQpIHtcclxuICAgICAgICByZXR1cm4gT0F1dGhDcmVkZW50aWFsLl9mcm9tUGFyYW1zKHtcclxuICAgICAgICAgICAgcHJvdmlkZXJJZDogVHdpdHRlckF1dGhQcm92aWRlci5QUk9WSURFUl9JRCxcclxuICAgICAgICAgICAgc2lnbkluTWV0aG9kOiBUd2l0dGVyQXV0aFByb3ZpZGVyLlRXSVRURVJfU0lHTl9JTl9NRVRIT0QsXHJcbiAgICAgICAgICAgIG9hdXRoVG9rZW46IHRva2VuLFxyXG4gICAgICAgICAgICBvYXV0aFRva2VuU2VjcmV0OiBzZWNyZXRcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgVXNlckNyZWRlbnRpYWx9LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbVJlc3VsdCh1c2VyQ3JlZGVudGlhbCkge1xyXG4gICAgICAgIHJldHVybiBUd2l0dGVyQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHVzZXJDcmVkZW50aWFsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgQXV0aEVycm9yfSB3aGljaCB3YXNcclxuICAgICAqIHRocm93biBkdXJpbmcgYSBzaWduLWluLCBsaW5rLCBvciByZWF1dGhlbnRpY2F0ZSBvcGVyYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tRXJyb3IoZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gVHdpdHRlckF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCgoZXJyb3IuY3VzdG9tRGF0YSB8fCB7fSkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHsgX3Rva2VuUmVzcG9uc2U6IHRva2VuUmVzcG9uc2UgfSkge1xyXG4gICAgICAgIGlmICghdG9rZW5SZXNwb25zZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBvYXV0aEFjY2Vzc1Rva2VuLCBvYXV0aFRva2VuU2VjcmV0IH0gPSB0b2tlblJlc3BvbnNlO1xyXG4gICAgICAgIGlmICghb2F1dGhBY2Nlc3NUb2tlbiB8fCAhb2F1dGhUb2tlblNlY3JldCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIFR3aXR0ZXJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbChvYXV0aEFjY2Vzc1Rva2VuLCBvYXV0aFRva2VuU2VjcmV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKiogQWx3YXlzIHNldCB0byB7QGxpbmsgU2lnbkluTWV0aG9kfS5UV0lUVEVSLiAqL1xyXG5Ud2l0dGVyQXV0aFByb3ZpZGVyLlRXSVRURVJfU0lHTl9JTl9NRVRIT0QgPSBcInR3aXR0ZXIuY29tXCIgLyogU2lnbkluTWV0aG9kLlRXSVRURVIgKi87XHJcbi8qKiBBbHdheXMgc2V0IHRvIHtAbGluayBQcm92aWRlcklkfS5UV0lUVEVSLiAqL1xyXG5Ud2l0dGVyQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lEID0gXCJ0d2l0dGVyLmNvbVwiIC8qIFByb3ZpZGVySWQuVFdJVFRFUiAqLztcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc2lnblVwKGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBfcGVyZm9ybVNpZ25JblJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpzaWduVXBcIiAvKiBFbmRwb2ludC5TSUdOX1VQICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIFVzZXJDcmVkZW50aWFsSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcclxuICAgICAgICB0aGlzLnVzZXIgPSBwYXJhbXMudXNlcjtcclxuICAgICAgICB0aGlzLnByb3ZpZGVySWQgPSBwYXJhbXMucHJvdmlkZXJJZDtcclxuICAgICAgICB0aGlzLl90b2tlblJlc3BvbnNlID0gcGFyYW1zLl90b2tlblJlc3BvbnNlO1xyXG4gICAgICAgIHRoaXMub3BlcmF0aW9uVHlwZSA9IHBhcmFtcy5vcGVyYXRpb25UeXBlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIF9mcm9tSWRUb2tlblJlc3BvbnNlKGF1dGgsIG9wZXJhdGlvblR5cGUsIGlkVG9rZW5SZXNwb25zZSwgaXNBbm9ueW1vdXMgPSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBVc2VySW1wbC5fZnJvbUlkVG9rZW5SZXNwb25zZShhdXRoLCBpZFRva2VuUmVzcG9uc2UsIGlzQW5vbnltb3VzKTtcclxuICAgICAgICBjb25zdCBwcm92aWRlcklkID0gcHJvdmlkZXJJZEZvclJlc3BvbnNlKGlkVG9rZW5SZXNwb25zZSk7XHJcbiAgICAgICAgY29uc3QgdXNlckNyZWQgPSBuZXcgVXNlckNyZWRlbnRpYWxJbXBsKHtcclxuICAgICAgICAgICAgdXNlcixcclxuICAgICAgICAgICAgcHJvdmlkZXJJZCxcclxuICAgICAgICAgICAgX3Rva2VuUmVzcG9uc2U6IGlkVG9rZW5SZXNwb25zZSxcclxuICAgICAgICAgICAgb3BlcmF0aW9uVHlwZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB1c2VyQ3JlZDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBfZm9yT3BlcmF0aW9uKHVzZXIsIG9wZXJhdGlvblR5cGUsIHJlc3BvbnNlKSB7XHJcbiAgICAgICAgYXdhaXQgdXNlci5fdXBkYXRlVG9rZW5zSWZOZWNlc3NhcnkocmVzcG9uc2UsIC8qIHJlbG9hZCAqLyB0cnVlKTtcclxuICAgICAgICBjb25zdCBwcm92aWRlcklkID0gcHJvdmlkZXJJZEZvclJlc3BvbnNlKHJlc3BvbnNlKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVzZXJDcmVkZW50aWFsSW1wbCh7XHJcbiAgICAgICAgICAgIHVzZXIsXHJcbiAgICAgICAgICAgIHByb3ZpZGVySWQsXHJcbiAgICAgICAgICAgIF90b2tlblJlc3BvbnNlOiByZXNwb25zZSxcclxuICAgICAgICAgICAgb3BlcmF0aW9uVHlwZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHByb3ZpZGVySWRGb3JSZXNwb25zZShyZXNwb25zZSkge1xyXG4gICAgaWYgKHJlc3BvbnNlLnByb3ZpZGVySWQpIHtcclxuICAgICAgICByZXR1cm4gcmVzcG9uc2UucHJvdmlkZXJJZDtcclxuICAgIH1cclxuICAgIGlmICgncGhvbmVOdW1iZXInIGluIHJlc3BvbnNlKSB7XHJcbiAgICAgICAgcmV0dXJuIFwicGhvbmVcIiAvKiBQcm92aWRlcklkLlBIT05FICovO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFzeW5jaHJvbm91c2x5IHNpZ25zIGluIGFzIGFuIGFub255bW91cyB1c2VyLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBJZiB0aGVyZSBpcyBhbHJlYWR5IGFuIGFub255bW91cyB1c2VyIHNpZ25lZCBpbiwgdGhhdCB1c2VyIHdpbGwgYmUgcmV0dXJuZWQ7IG90aGVyd2lzZSwgYVxyXG4gKiBuZXcgYW5vbnltb3VzIHVzZXIgaWRlbnRpdHkgd2lsbCBiZSBjcmVhdGVkIGFuZCByZXR1cm5lZC5cclxuICpcclxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzIGNyZWF0ZWQgd2l0aCBhXHJcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzaWduSW5Bbm9ueW1vdXNseShhdXRoKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAoYXV0aC5hcHApKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKGF1dGgpKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcclxuICAgIGF3YWl0IGF1dGhJbnRlcm5hbC5faW5pdGlhbGl6YXRpb25Qcm9taXNlO1xyXG4gICAgaWYgKChfYSA9IGF1dGhJbnRlcm5hbC5jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzQW5vbnltb3VzKSB7XHJcbiAgICAgICAgLy8gSWYgYW4gYW5vbnltb3VzIHVzZXIgaXMgYWxyZWFkeSBzaWduZWQgaW4sIG5vIG5lZWQgdG8gc2lnbiB0aGVtIGluIGFnYWluLlxyXG4gICAgICAgIHJldHVybiBuZXcgVXNlckNyZWRlbnRpYWxJbXBsKHtcclxuICAgICAgICAgICAgdXNlcjogYXV0aEludGVybmFsLmN1cnJlbnRVc2VyLFxyXG4gICAgICAgICAgICBwcm92aWRlcklkOiBudWxsLFxyXG4gICAgICAgICAgICBvcGVyYXRpb25UeXBlOiBcInNpZ25JblwiIC8qIE9wZXJhdGlvblR5cGUuU0lHTl9JTiAqL1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzaWduVXAoYXV0aEludGVybmFsLCB7XHJcbiAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWVcclxuICAgIH0pO1xyXG4gICAgY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBVc2VyQ3JlZGVudGlhbEltcGwuX2Zyb21JZFRva2VuUmVzcG9uc2UoYXV0aEludGVybmFsLCBcInNpZ25JblwiIC8qIE9wZXJhdGlvblR5cGUuU0lHTl9JTiAqLywgcmVzcG9uc2UsIHRydWUpO1xyXG4gICAgYXdhaXQgYXV0aEludGVybmFsLl91cGRhdGVDdXJyZW50VXNlcih1c2VyQ3JlZGVudGlhbC51c2VyKTtcclxuICAgIHJldHVybiB1c2VyQ3JlZGVudGlhbDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBNdWx0aUZhY3RvckVycm9yIGV4dGVuZHMgRmlyZWJhc2VFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihhdXRoLCBlcnJvciwgb3BlcmF0aW9uVHlwZSwgdXNlcikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBzdXBlcihlcnJvci5jb2RlLCBlcnJvci5tZXNzYWdlKTtcclxuICAgICAgICB0aGlzLm9wZXJhdGlvblR5cGUgPSBvcGVyYXRpb25UeXBlO1xyXG4gICAgICAgIHRoaXMudXNlciA9IHVzZXI7XHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0LXdpa2kvYmxvYi9tYXN0ZXIvQnJlYWtpbmctQ2hhbmdlcy5tZCNleHRlbmRpbmctYnVpbHQtaW5zLWxpa2UtZXJyb3ItYXJyYXktYW5kLW1hcC1tYXktbm8tbG9uZ2VyLXdvcmtcclxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgTXVsdGlGYWN0b3JFcnJvci5wcm90b3R5cGUpO1xyXG4gICAgICAgIHRoaXMuY3VzdG9tRGF0YSA9IHtcclxuICAgICAgICAgICAgYXBwTmFtZTogYXV0aC5uYW1lLFxyXG4gICAgICAgICAgICB0ZW5hbnRJZDogKF9hID0gYXV0aC50ZW5hbnRJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBfc2VydmVyUmVzcG9uc2U6IGVycm9yLmN1c3RvbURhdGEuX3NlcnZlclJlc3BvbnNlLFxyXG4gICAgICAgICAgICBvcGVyYXRpb25UeXBlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfZnJvbUVycm9yQW5kT3BlcmF0aW9uKGF1dGgsIGVycm9yLCBvcGVyYXRpb25UeXBlLCB1c2VyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNdWx0aUZhY3RvckVycm9yKGF1dGgsIGVycm9yLCBvcGVyYXRpb25UeXBlLCB1c2VyKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBfcHJvY2Vzc0NyZWRlbnRpYWxTYXZpbmdNZmFDb250ZXh0SWZOZWNlc3NhcnkoYXV0aCwgb3BlcmF0aW9uVHlwZSwgY3JlZGVudGlhbCwgdXNlcikge1xyXG4gICAgY29uc3QgaWRUb2tlblByb3ZpZGVyID0gb3BlcmF0aW9uVHlwZSA9PT0gXCJyZWF1dGhlbnRpY2F0ZVwiIC8qIE9wZXJhdGlvblR5cGUuUkVBVVRIRU5USUNBVEUgKi9cclxuICAgICAgICA/IGNyZWRlbnRpYWwuX2dldFJlYXV0aGVudGljYXRpb25SZXNvbHZlcihhdXRoKVxyXG4gICAgICAgIDogY3JlZGVudGlhbC5fZ2V0SWRUb2tlblJlc3BvbnNlKGF1dGgpO1xyXG4gICAgcmV0dXJuIGlkVG9rZW5Qcm92aWRlci5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IGBhdXRoLyR7XCJtdWx0aS1mYWN0b3ItYXV0aC1yZXF1aXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuTUZBX1JFUVVJUkVEICovfWApIHtcclxuICAgICAgICAgICAgdGhyb3cgTXVsdGlGYWN0b3JFcnJvci5fZnJvbUVycm9yQW5kT3BlcmF0aW9uKGF1dGgsIGVycm9yLCBvcGVyYXRpb25UeXBlLCB1c2VyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9KTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGFrZXMgYSBzZXQgb2YgVXNlckluZm8gcHJvdmlkZXIgZGF0YSBhbmQgY29udmVydHMgaXQgdG8gYSBzZXQgb2YgbmFtZXNcclxuICovXHJcbmZ1bmN0aW9uIHByb3ZpZGVyRGF0YUFzTmFtZXMocHJvdmlkZXJEYXRhKSB7XHJcbiAgICByZXR1cm4gbmV3IFNldChwcm92aWRlckRhdGFcclxuICAgICAgICAubWFwKCh7IHByb3ZpZGVySWQgfSkgPT4gcHJvdmlkZXJJZClcclxuICAgICAgICAuZmlsdGVyKHBpZCA9PiAhIXBpZCkpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBVbmxpbmtzIGEgcHJvdmlkZXIgZnJvbSBhIHVzZXIgYWNjb3VudC5cclxuICpcclxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cclxuICogQHBhcmFtIHByb3ZpZGVySWQgLSBUaGUgcHJvdmlkZXIgdG8gdW5saW5rLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiB1bmxpbmsodXNlciwgcHJvdmlkZXJJZCkge1xyXG4gICAgY29uc3QgdXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xyXG4gICAgYXdhaXQgX2Fzc2VydExpbmtlZFN0YXR1cyh0cnVlLCB1c2VySW50ZXJuYWwsIHByb3ZpZGVySWQpO1xyXG4gICAgY29uc3QgeyBwcm92aWRlclVzZXJJbmZvIH0gPSBhd2FpdCBkZWxldGVMaW5rZWRBY2NvdW50cyh1c2VySW50ZXJuYWwuYXV0aCwge1xyXG4gICAgICAgIGlkVG9rZW46IGF3YWl0IHVzZXJJbnRlcm5hbC5nZXRJZFRva2VuKCksXHJcbiAgICAgICAgZGVsZXRlUHJvdmlkZXI6IFtwcm92aWRlcklkXVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBwcm92aWRlcnNMZWZ0ID0gcHJvdmlkZXJEYXRhQXNOYW1lcyhwcm92aWRlclVzZXJJbmZvIHx8IFtdKTtcclxuICAgIHVzZXJJbnRlcm5hbC5wcm92aWRlckRhdGEgPSB1c2VySW50ZXJuYWwucHJvdmlkZXJEYXRhLmZpbHRlcihwZCA9PiBwcm92aWRlcnNMZWZ0LmhhcyhwZC5wcm92aWRlcklkKSk7XHJcbiAgICBpZiAoIXByb3ZpZGVyc0xlZnQuaGFzKFwicGhvbmVcIiAvKiBQcm92aWRlcklkLlBIT05FICovKSkge1xyXG4gICAgICAgIHVzZXJJbnRlcm5hbC5waG9uZU51bWJlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBhd2FpdCB1c2VySW50ZXJuYWwuYXV0aC5fcGVyc2lzdFVzZXJJZkN1cnJlbnQodXNlckludGVybmFsKTtcclxuICAgIHJldHVybiB1c2VySW50ZXJuYWw7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gX2xpbmsodXNlciwgY3JlZGVudGlhbCwgYnlwYXNzQXV0aFN0YXRlID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodXNlciwgY3JlZGVudGlhbC5fbGlua1RvSWRUb2tlbih1c2VyLmF1dGgsIGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpKSwgYnlwYXNzQXV0aFN0YXRlKTtcclxuICAgIHJldHVybiBVc2VyQ3JlZGVudGlhbEltcGwuX2Zvck9wZXJhdGlvbih1c2VyLCBcImxpbmtcIiAvKiBPcGVyYXRpb25UeXBlLkxJTksgKi8sIHJlc3BvbnNlKTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBfYXNzZXJ0TGlua2VkU3RhdHVzKGV4cGVjdGVkLCB1c2VyLCBwcm92aWRlcikge1xyXG4gICAgYXdhaXQgX3JlbG9hZFdpdGhvdXRTYXZpbmcodXNlcik7XHJcbiAgICBjb25zdCBwcm92aWRlcklkcyA9IHByb3ZpZGVyRGF0YUFzTmFtZXModXNlci5wcm92aWRlckRhdGEpO1xyXG4gICAgY29uc3QgY29kZSA9IGV4cGVjdGVkID09PSBmYWxzZVxyXG4gICAgICAgID8gXCJwcm92aWRlci1hbHJlYWR5LWxpbmtlZFwiIC8qIEF1dGhFcnJvckNvZGUuUFJPVklERVJfQUxSRUFEWV9MSU5LRUQgKi9cclxuICAgICAgICA6IFwibm8tc3VjaC1wcm92aWRlclwiIC8qIEF1dGhFcnJvckNvZGUuTk9fU1VDSF9QUk9WSURFUiAqLztcclxuICAgIF9hc3NlcnQocHJvdmlkZXJJZHMuaGFzKHByb3ZpZGVyKSA9PT0gZXhwZWN0ZWQsIHVzZXIuYXV0aCwgY29kZSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gX3JlYXV0aGVudGljYXRlKHVzZXIsIGNyZWRlbnRpYWwsIGJ5cGFzc0F1dGhTdGF0ZSA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCB7IGF1dGggfSA9IHVzZXI7XHJcbiAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAoYXV0aC5hcHApKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKGF1dGgpKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9wZXJhdGlvblR5cGUgPSBcInJlYXV0aGVudGljYXRlXCIgLyogT3BlcmF0aW9uVHlwZS5SRUFVVEhFTlRJQ0FURSAqLztcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZCh1c2VyLCBfcHJvY2Vzc0NyZWRlbnRpYWxTYXZpbmdNZmFDb250ZXh0SWZOZWNlc3NhcnkoYXV0aCwgb3BlcmF0aW9uVHlwZSwgY3JlZGVudGlhbCwgdXNlciksIGJ5cGFzc0F1dGhTdGF0ZSk7XHJcbiAgICAgICAgX2Fzc2VydChyZXNwb25zZS5pZFRva2VuLCBhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkID0gX3BhcnNlVG9rZW4ocmVzcG9uc2UuaWRUb2tlbik7XHJcbiAgICAgICAgX2Fzc2VydChwYXJzZWQsIGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICBjb25zdCB7IHN1YjogbG9jYWxJZCB9ID0gcGFyc2VkO1xyXG4gICAgICAgIF9hc3NlcnQodXNlci51aWQgPT09IGxvY2FsSWQsIGF1dGgsIFwidXNlci1taXNtYXRjaFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9NSVNNQVRDSCAqLyk7XHJcbiAgICAgICAgcmV0dXJuIFVzZXJDcmVkZW50aWFsSW1wbC5fZm9yT3BlcmF0aW9uKHVzZXIsIG9wZXJhdGlvblR5cGUsIHJlc3BvbnNlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gQ29udmVydCB1c2VyIGRlbGV0ZWQgZXJyb3IgaW50byB1c2VyIG1pc21hdGNoXHJcbiAgICAgICAgaWYgKChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUuY29kZSkgPT09IGBhdXRoLyR7XCJ1c2VyLW5vdC1mb3VuZFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9ERUxFVEVEICovfWApIHtcclxuICAgICAgICAgICAgX2ZhaWwoYXV0aCwgXCJ1c2VyLW1pc21hdGNoXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX01JU01BVENIICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgZTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBfc2lnbkluV2l0aENyZWRlbnRpYWwoYXV0aCwgY3JlZGVudGlhbCwgYnlwYXNzQXV0aFN0YXRlID0gZmFsc2UpIHtcclxuICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcChhdXRoLmFwcCkpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb3BlcmF0aW9uVHlwZSA9IFwic2lnbkluXCIgLyogT3BlcmF0aW9uVHlwZS5TSUdOX0lOICovO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfcHJvY2Vzc0NyZWRlbnRpYWxTYXZpbmdNZmFDb250ZXh0SWZOZWNlc3NhcnkoYXV0aCwgb3BlcmF0aW9uVHlwZSwgY3JlZGVudGlhbCk7XHJcbiAgICBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IFVzZXJDcmVkZW50aWFsSW1wbC5fZnJvbUlkVG9rZW5SZXNwb25zZShhdXRoLCBvcGVyYXRpb25UeXBlLCByZXNwb25zZSk7XHJcbiAgICBpZiAoIWJ5cGFzc0F1dGhTdGF0ZSkge1xyXG4gICAgICAgIGF3YWl0IGF1dGguX3VwZGF0ZUN1cnJlbnRVc2VyKHVzZXJDcmVkZW50aWFsLnVzZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVzZXJDcmVkZW50aWFsO1xyXG59XHJcbi8qKlxyXG4gKiBBc3luY2hyb25vdXNseSBzaWducyBpbiB3aXRoIHRoZSBnaXZlbiBjcmVkZW50aWFscy5cclxuICpcclxuICogQHJlbWFya3NcclxuICogQW4ge0BsaW5rIEF1dGhQcm92aWRlcn0gY2FuIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNyZWRlbnRpYWwuXHJcbiAqXHJcbiAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkge0BsaW5rIEF1dGh9IGluc3RhbmNlcyBjcmVhdGVkIHdpdGggYVxyXG4gKiB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZVNlcnZlckFwcH0uXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICogQHBhcmFtIGNyZWRlbnRpYWwgLSBUaGUgYXV0aCBjcmVkZW50aWFsLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoQ3JlZGVudGlhbChhdXRoLCBjcmVkZW50aWFsKSB7XHJcbiAgICByZXR1cm4gX3NpZ25JbldpdGhDcmVkZW50aWFsKF9jYXN0QXV0aChhdXRoKSwgY3JlZGVudGlhbCk7XHJcbn1cclxuLyoqXHJcbiAqIExpbmtzIHRoZSB1c2VyIGFjY291bnQgd2l0aCB0aGUgZ2l2ZW4gY3JlZGVudGlhbHMuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIEFuIHtAbGluayBBdXRoUHJvdmlkZXJ9IGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjcmVkZW50aWFsLlxyXG4gKlxyXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxyXG4gKiBAcGFyYW0gY3JlZGVudGlhbCAtIFRoZSBhdXRoIGNyZWRlbnRpYWwuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGxpbmtXaXRoQ3JlZGVudGlhbCh1c2VyLCBjcmVkZW50aWFsKSB7XHJcbiAgICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcik7XHJcbiAgICBhd2FpdCBfYXNzZXJ0TGlua2VkU3RhdHVzKGZhbHNlLCB1c2VySW50ZXJuYWwsIGNyZWRlbnRpYWwucHJvdmlkZXJJZCk7XHJcbiAgICByZXR1cm4gX2xpbmsodXNlckludGVybmFsLCBjcmVkZW50aWFsKTtcclxufVxyXG4vKipcclxuICogUmUtYXV0aGVudGljYXRlcyBhIHVzZXIgdXNpbmcgYSBmcmVzaCBjcmVkZW50aWFsLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBVc2UgYmVmb3JlIG9wZXJhdGlvbnMgc3VjaCBhcyB7QGxpbmsgdXBkYXRlUGFzc3dvcmR9IHRoYXQgcmVxdWlyZSB0b2tlbnMgZnJvbSByZWNlbnQgc2lnbi1pblxyXG4gKiBhdHRlbXB0cy4gVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgdG8gcmVjb3ZlciBmcm9tIGEgYENSRURFTlRJQUxfVE9PX09MRF9MT0dJTl9BR0FJTmAgZXJyb3JcclxuICogb3IgYSBgVE9LRU5fRVhQSVJFRGAgZXJyb3IuXHJcbiAqXHJcbiAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgb24gYW55IHtAbGluayBVc2VyfSBzaWduZWQgaW4gYnkge0BsaW5rIEF1dGh9IGluc3RhbmNlc1xyXG4gKiBjcmVhdGVkIHdpdGggYSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZVNlcnZlckFwcH0uXHJcbiAqXHJcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXHJcbiAqIEBwYXJhbSBjcmVkZW50aWFsIC0gVGhlIGF1dGggY3JlZGVudGlhbC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcmVhdXRoZW50aWNhdGVXaXRoQ3JlZGVudGlhbCh1c2VyLCBjcmVkZW50aWFsKSB7XHJcbiAgICByZXR1cm4gX3JlYXV0aGVudGljYXRlKGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKSwgY3JlZGVudGlhbCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aEN1c3RvbVRva2VuJDEoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25JbldpdGhDdXN0b21Ub2tlblwiIC8qIEVuZHBvaW50LlNJR05fSU5fV0lUSF9DVVNUT01fVE9LRU4gKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFzeW5jaHJvbm91c2x5IHNpZ25zIGluIHVzaW5nIGEgY3VzdG9tIHRva2VuLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBDdXN0b20gdG9rZW5zIGFyZSB1c2VkIHRvIGludGVncmF0ZSBGaXJlYmFzZSBBdXRoIHdpdGggZXhpc3RpbmcgYXV0aCBzeXN0ZW1zLCBhbmQgbXVzdFxyXG4gKiBiZSBnZW5lcmF0ZWQgYnkgYW4gYXV0aCBiYWNrZW5kIHVzaW5nIHRoZVxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvcmVmZXJlbmNlL2FkbWluL25vZGUvYWRtaW4uYXV0aC5BdXRoI2NyZWF0ZWN1c3RvbXRva2VuIHwgY3JlYXRlQ3VzdG9tVG9rZW59XHJcbiAqIG1ldGhvZCBpbiB0aGUge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2F1dGgvYWRtaW4gfCBBZG1pbiBTREt9IC5cclxuICpcclxuICogRmFpbHMgd2l0aCBhbiBlcnJvciBpZiB0aGUgdG9rZW4gaXMgaW52YWxpZCwgZXhwaXJlZCwgb3Igbm90IGFjY2VwdGVkIGJ5IHRoZSBGaXJlYmFzZSBBdXRoIHNlcnZpY2UuXHJcbiAqXHJcbiAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkge0BsaW5rIEF1dGh9IGluc3RhbmNlcyBjcmVhdGVkIHdpdGggYVxyXG4gKiB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZVNlcnZlckFwcH0uXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICogQHBhcmFtIGN1c3RvbVRva2VuIC0gVGhlIGN1c3RvbSB0b2tlbiB0byBzaWduIGluIHdpdGguXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhDdXN0b21Ub2tlbihhdXRoLCBjdXN0b21Ub2tlbikge1xyXG4gICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKGF1dGguYXBwKSkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChfc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvcihhdXRoKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNpZ25JbldpdGhDdXN0b21Ub2tlbiQxKGF1dGhJbnRlcm5hbCwge1xyXG4gICAgICAgIHRva2VuOiBjdXN0b21Ub2tlbixcclxuICAgICAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBjcmVkID0gYXdhaXQgVXNlckNyZWRlbnRpYWxJbXBsLl9mcm9tSWRUb2tlblJlc3BvbnNlKGF1dGhJbnRlcm5hbCwgXCJzaWduSW5cIiAvKiBPcGVyYXRpb25UeXBlLlNJR05fSU4gKi8sIHJlc3BvbnNlKTtcclxuICAgIGF3YWl0IGF1dGhJbnRlcm5hbC5fdXBkYXRlQ3VycmVudFVzZXIoY3JlZC51c2VyKTtcclxuICAgIHJldHVybiBjcmVkO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIE11bHRpRmFjdG9ySW5mb0ltcGwge1xyXG4gICAgY29uc3RydWN0b3IoZmFjdG9ySWQsIHJlc3BvbnNlKSB7XHJcbiAgICAgICAgdGhpcy5mYWN0b3JJZCA9IGZhY3RvcklkO1xyXG4gICAgICAgIHRoaXMudWlkID0gcmVzcG9uc2UubWZhRW5yb2xsbWVudElkO1xyXG4gICAgICAgIHRoaXMuZW5yb2xsbWVudFRpbWUgPSBuZXcgRGF0ZShyZXNwb25zZS5lbnJvbGxlZEF0KS50b1VUQ1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuZGlzcGxheU5hbWUgPSByZXNwb25zZS5kaXNwbGF5TmFtZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfZnJvbVNlcnZlclJlc3BvbnNlKGF1dGgsIGVucm9sbG1lbnQpIHtcclxuICAgICAgICBpZiAoJ3Bob25lSW5mbycgaW4gZW5yb2xsbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUGhvbmVNdWx0aUZhY3RvckluZm9JbXBsLl9mcm9tU2VydmVyUmVzcG9uc2UoYXV0aCwgZW5yb2xsbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCd0b3RwSW5mbycgaW4gZW5yb2xsbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gVG90cE11bHRpRmFjdG9ySW5mb0ltcGwuX2Zyb21TZXJ2ZXJSZXNwb25zZShhdXRoLCBlbnJvbGxtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9mYWlsKGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBQaG9uZU11bHRpRmFjdG9ySW5mb0ltcGwgZXh0ZW5kcyBNdWx0aUZhY3RvckluZm9JbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgc3VwZXIoXCJwaG9uZVwiIC8qIEZhY3RvcklkLlBIT05FICovLCByZXNwb25zZSk7XHJcbiAgICAgICAgdGhpcy5waG9uZU51bWJlciA9IHJlc3BvbnNlLnBob25lSW5mbztcclxuICAgIH1cclxuICAgIHN0YXRpYyBfZnJvbVNlcnZlclJlc3BvbnNlKF9hdXRoLCBlbnJvbGxtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQaG9uZU11bHRpRmFjdG9ySW5mb0ltcGwoZW5yb2xsbWVudCk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgVG90cE11bHRpRmFjdG9ySW5mb0ltcGwgZXh0ZW5kcyBNdWx0aUZhY3RvckluZm9JbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgc3VwZXIoXCJ0b3RwXCIgLyogRmFjdG9ySWQuVE9UUCAqLywgcmVzcG9uc2UpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9mcm9tU2VydmVyUmVzcG9uc2UoX2F1dGgsIGVucm9sbG1lbnQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFRvdHBNdWx0aUZhY3RvckluZm9JbXBsKGVucm9sbG1lbnQpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIF9zZXRBY3Rpb25Db2RlU2V0dGluZ3NPblJlcXVlc3QoYXV0aCwgcmVxdWVzdCwgYWN0aW9uQ29kZVNldHRpbmdzKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBfYXNzZXJ0KCgoX2EgPSBhY3Rpb25Db2RlU2V0dGluZ3MudXJsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSA+IDAsIGF1dGgsIFwiaW52YWxpZC1jb250aW51ZS11cmlcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ09OVElOVUVfVVJJICovKTtcclxuICAgIF9hc3NlcnQodHlwZW9mIGFjdGlvbkNvZGVTZXR0aW5ncy5keW5hbWljTGlua0RvbWFpbiA9PT0gJ3VuZGVmaW5lZCcgfHxcclxuICAgICAgICBhY3Rpb25Db2RlU2V0dGluZ3MuZHluYW1pY0xpbmtEb21haW4ubGVuZ3RoID4gMCwgYXV0aCwgXCJpbnZhbGlkLWR5bmFtaWMtbGluay1kb21haW5cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfRFlOQU1JQ19MSU5LX0RPTUFJTiAqLyk7XHJcbiAgICByZXF1ZXN0LmNvbnRpbnVlVXJsID0gYWN0aW9uQ29kZVNldHRpbmdzLnVybDtcclxuICAgIHJlcXVlc3QuZHluYW1pY0xpbmtEb21haW4gPSBhY3Rpb25Db2RlU2V0dGluZ3MuZHluYW1pY0xpbmtEb21haW47XHJcbiAgICByZXF1ZXN0LmNhbkhhbmRsZUNvZGVJbkFwcCA9IGFjdGlvbkNvZGVTZXR0aW5ncy5oYW5kbGVDb2RlSW5BcHA7XHJcbiAgICBpZiAoYWN0aW9uQ29kZVNldHRpbmdzLmlPUykge1xyXG4gICAgICAgIF9hc3NlcnQoYWN0aW9uQ29kZVNldHRpbmdzLmlPUy5idW5kbGVJZC5sZW5ndGggPiAwLCBhdXRoLCBcIm1pc3NpbmctaW9zLWJ1bmRsZS1pZFwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19JT1NfQlVORExFX0lEICovKTtcclxuICAgICAgICByZXF1ZXN0LmlPU0J1bmRsZUlkID0gYWN0aW9uQ29kZVNldHRpbmdzLmlPUy5idW5kbGVJZDtcclxuICAgIH1cclxuICAgIGlmIChhY3Rpb25Db2RlU2V0dGluZ3MuYW5kcm9pZCkge1xyXG4gICAgICAgIF9hc3NlcnQoYWN0aW9uQ29kZVNldHRpbmdzLmFuZHJvaWQucGFja2FnZU5hbWUubGVuZ3RoID4gMCwgYXV0aCwgXCJtaXNzaW5nLWFuZHJvaWQtcGtnLW5hbWVcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQU5EUk9JRF9QQUNLQUdFX05BTUUgKi8pO1xyXG4gICAgICAgIHJlcXVlc3QuYW5kcm9pZEluc3RhbGxBcHAgPSBhY3Rpb25Db2RlU2V0dGluZ3MuYW5kcm9pZC5pbnN0YWxsQXBwO1xyXG4gICAgICAgIHJlcXVlc3QuYW5kcm9pZE1pbmltdW1WZXJzaW9uQ29kZSA9XHJcbiAgICAgICAgICAgIGFjdGlvbkNvZGVTZXR0aW5ncy5hbmRyb2lkLm1pbmltdW1WZXJzaW9uO1xyXG4gICAgICAgIHJlcXVlc3QuYW5kcm9pZFBhY2thZ2VOYW1lID0gYWN0aW9uQ29kZVNldHRpbmdzLmFuZHJvaWQucGFja2FnZU5hbWU7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFVwZGF0ZXMgdGhlIHBhc3N3b3JkIHBvbGljeSBjYWNoZWQgaW4gdGhlIHtAbGluayBBdXRofSBpbnN0YW5jZSBpZiBhIHBvbGljeSBpcyBhbHJlYWR5XHJcbiAqIGNhY2hlZCBmb3IgdGhlIHByb2plY3Qgb3IgdGVuYW50LlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBXZSBvbmx5IGZldGNoIHRoZSBwYXNzd29yZCBwb2xpY3kgaWYgdGhlIHBhc3N3b3JkIGRpZCBub3QgbWVldCBwb2xpY3kgcmVxdWlyZW1lbnRzIGFuZFxyXG4gKiB0aGVyZSBpcyBhbiBleGlzdGluZyBwb2xpY3kgY2FjaGVkLiBBIGRldmVsb3BlciBtdXN0IGNhbGwgdmFsaWRhdGVQYXNzd29yZCBhdCBsZWFzdFxyXG4gKiBvbmNlIGZvciB0aGUgY2FjaGUgdG8gYmUgYXV0b21hdGljYWxseSB1cGRhdGVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiByZWNhY2hlUGFzc3dvcmRQb2xpY3koYXV0aCkge1xyXG4gICAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xyXG4gICAgaWYgKGF1dGhJbnRlcm5hbC5fZ2V0UGFzc3dvcmRQb2xpY3lJbnRlcm5hbCgpKSB7XHJcbiAgICAgICAgYXdhaXQgYXV0aEludGVybmFsLl91cGRhdGVQYXNzd29yZFBvbGljeSgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTZW5kcyBhIHBhc3N3b3JkIHJlc2V0IGVtYWlsIHRvIHRoZSBnaXZlbiBlbWFpbCBhZGRyZXNzLiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB0aHJvdyBhbiBlcnJvciB3aGVuXHJcbiAqIHRoZXJlJ3Mgbm8gdXNlciBhY2NvdW50IHdpdGggdGhlIGdpdmVuIGVtYWlsIGFkZHJlc3MgYW5kXHJcbiAqIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vaWRlbnRpdHktcGxhdGZvcm0vZG9jcy9hZG1pbi9lbWFpbC1lbnVtZXJhdGlvbi1wcm90ZWN0aW9uIHwgRW1haWwgRW51bWVyYXRpb24gUHJvdGVjdGlvbn1cclxuICogaXMgZW5hYmxlZC5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVG8gY29tcGxldGUgdGhlIHBhc3N3b3JkIHJlc2V0LCBjYWxsIHtAbGluayBjb25maXJtUGFzc3dvcmRSZXNldH0gd2l0aCB0aGUgY29kZSBzdXBwbGllZCBpblxyXG4gKiB0aGUgZW1haWwgc2VudCB0byB0aGUgdXNlciwgYWxvbmcgd2l0aCB0aGUgbmV3IHBhc3N3b3JkIHNwZWNpZmllZCBieSB0aGUgdXNlci5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiBjb25zdCBhY3Rpb25Db2RlU2V0dGluZ3MgPSB7XHJcbiAqICAgdXJsOiAnaHR0cHM6Ly93d3cuZXhhbXBsZS5jb20vP2VtYWlsPXVzZXJAZXhhbXBsZS5jb20nLFxyXG4gKiAgIGlPUzoge1xyXG4gKiAgICAgIGJ1bmRsZUlkOiAnY29tLmV4YW1wbGUuaW9zJ1xyXG4gKiAgIH0sXHJcbiAqICAgYW5kcm9pZDoge1xyXG4gKiAgICAgcGFja2FnZU5hbWU6ICdjb20uZXhhbXBsZS5hbmRyb2lkJyxcclxuICogICAgIGluc3RhbGxBcHA6IHRydWUsXHJcbiAqICAgICBtaW5pbXVtVmVyc2lvbjogJzEyJ1xyXG4gKiAgIH0sXHJcbiAqICAgaGFuZGxlQ29kZUluQXBwOiB0cnVlXHJcbiAqIH07XHJcbiAqIGF3YWl0IHNlbmRQYXNzd29yZFJlc2V0RW1haWwoYXV0aCwgJ3VzZXJAZXhhbXBsZS5jb20nLCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xyXG4gKiAvLyBPYnRhaW4gY29kZSBmcm9tIHVzZXIuXHJcbiAqIGF3YWl0IGNvbmZpcm1QYXNzd29yZFJlc2V0KCd1c2VyQGV4YW1wbGUuY29tJywgY29kZSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBlbWFpbCAtIFRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cclxuICogQHBhcmFtIGFjdGlvbkNvZGVTZXR0aW5ncyAtIFRoZSB7QGxpbmsgQWN0aW9uQ29kZVNldHRpbmdzfS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc2VuZFBhc3N3b3JkUmVzZXRFbWFpbChhdXRoLCBlbWFpbCwgYWN0aW9uQ29kZVNldHRpbmdzKSB7XHJcbiAgICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XHJcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgIHJlcXVlc3RUeXBlOiBcIlBBU1NXT1JEX1JFU0VUXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5QQVNTV09SRF9SRVNFVCAqLyxcclxuICAgICAgICBlbWFpbCxcclxuICAgICAgICBjbGllbnRUeXBlOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovXHJcbiAgICB9O1xyXG4gICAgaWYgKGFjdGlvbkNvZGVTZXR0aW5ncykge1xyXG4gICAgICAgIF9zZXRBY3Rpb25Db2RlU2V0dGluZ3NPblJlcXVlc3QoYXV0aEludGVybmFsLCByZXF1ZXN0LCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xyXG4gICAgfVxyXG4gICAgYXdhaXQgaGFuZGxlUmVjYXB0Y2hhRmxvdyhhdXRoSW50ZXJuYWwsIHJlcXVlc3QsIFwiZ2V0T29iQ29kZVwiIC8qIFJlY2FwdGNoYUFjdGlvbk5hbWUuR0VUX09PQl9DT0RFICovLCBzZW5kUGFzc3dvcmRSZXNldEVtYWlsJDEpO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wbGV0ZXMgdGhlIHBhc3N3b3JkIHJlc2V0IHByb2Nlc3MsIGdpdmVuIGEgY29uZmlybWF0aW9uIGNvZGUgYW5kIG5ldyBwYXNzd29yZC5cclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gb29iQ29kZSAtIEEgY29uZmlybWF0aW9uIGNvZGUgc2VudCB0byB0aGUgdXNlci5cclxuICogQHBhcmFtIG5ld1Bhc3N3b3JkIC0gVGhlIG5ldyBwYXNzd29yZC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gY29uZmlybVBhc3N3b3JkUmVzZXQoYXV0aCwgb29iQ29kZSwgbmV3UGFzc3dvcmQpIHtcclxuICAgIGF3YWl0IHJlc2V0UGFzc3dvcmQoZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLCB7XHJcbiAgICAgICAgb29iQ29kZSxcclxuICAgICAgICBuZXdQYXNzd29yZFxyXG4gICAgfSlcclxuICAgICAgICAuY2F0Y2goYXN5bmMgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09XHJcbiAgICAgICAgICAgIGBhdXRoLyR7XCJwYXNzd29yZC1kb2VzLW5vdC1tZWV0LXJlcXVpcmVtZW50c1wiIC8qIEF1dGhFcnJvckNvZGUuUEFTU1dPUkRfRE9FU19OT1RfTUVFVF9SRVFVSVJFTUVOVFMgKi99YCkge1xyXG4gICAgICAgICAgICB2b2lkIHJlY2FjaGVQYXNzd29yZFBvbGljeShhdXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9KTtcclxuICAgIC8vIERvIG5vdCByZXR1cm4gdGhlIGVtYWlsLlxyXG59XHJcbi8qKlxyXG4gKiBBcHBsaWVzIGEgdmVyaWZpY2F0aW9uIGNvZGUgc2VudCB0byB0aGUgdXNlciBieSBlbWFpbCBvciBvdGhlciBvdXQtb2YtYmFuZCBtZWNoYW5pc20uXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICogQHBhcmFtIG9vYkNvZGUgLSBBIHZlcmlmaWNhdGlvbiBjb2RlIHNlbnQgdG8gdGhlIHVzZXIuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGFwcGx5QWN0aW9uQ29kZShhdXRoLCBvb2JDb2RlKSB7XHJcbiAgICBhd2FpdCBhcHBseUFjdGlvbkNvZGUkMShnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCksIHsgb29iQ29kZSB9KTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGEgdmVyaWZpY2F0aW9uIGNvZGUgc2VudCB0byB0aGUgdXNlciBieSBlbWFpbCBvciBvdGhlciBvdXQtb2YtYmFuZCBtZWNoYW5pc20uXHJcbiAqXHJcbiAqIEByZXR1cm5zIG1ldGFkYXRhIGFib3V0IHRoZSBjb2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBvb2JDb2RlIC0gQSB2ZXJpZmljYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBjaGVja0FjdGlvbkNvZGUoYXV0aCwgb29iQ29kZSkge1xyXG4gICAgY29uc3QgYXV0aE1vZHVsYXIgPSBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCk7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc2V0UGFzc3dvcmQoYXV0aE1vZHVsYXIsIHsgb29iQ29kZSB9KTtcclxuICAgIC8vIEVtYWlsIGNvdWxkIGJlIGVtcHR5IG9ubHkgaWYgdGhlIHJlcXVlc3QgdHlwZSBpcyBFTUFJTF9TSUdOSU4gb3JcclxuICAgIC8vIFZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMLlxyXG4gICAgLy8gTmV3IGVtYWlsIHNob3VsZCBub3QgYmUgZW1wdHkgaWYgdGhlIHJlcXVlc3QgdHlwZSBpc1xyXG4gICAgLy8gVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwuXHJcbiAgICAvLyBNdWx0aS1mYWN0b3IgaW5mbyBjb3VsZCBub3QgYmUgZW1wdHkgaWYgdGhlIHJlcXVlc3QgdHlwZSBpc1xyXG4gICAgLy8gUkVWRVJUX1NFQ09ORF9GQUNUT1JfQURESVRJT04uXHJcbiAgICBjb25zdCBvcGVyYXRpb24gPSByZXNwb25zZS5yZXF1ZXN0VHlwZTtcclxuICAgIF9hc3NlcnQob3BlcmF0aW9uLCBhdXRoTW9kdWxhciwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgc3dpdGNoIChvcGVyYXRpb24pIHtcclxuICAgICAgICBjYXNlIFwiRU1BSUxfU0lHTklOXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5FTUFJTF9TSUdOSU4gKi86XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJWRVJJRllfQU5EX0NIQU5HRV9FTUFJTFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwgKi86XHJcbiAgICAgICAgICAgIF9hc3NlcnQocmVzcG9uc2UubmV3RW1haWwsIGF1dGhNb2R1bGFyLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJSRVZFUlRfU0VDT05EX0ZBQ1RPUl9BRERJVElPTlwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uUkVWRVJUX1NFQ09ORF9GQUNUT1JfQURESVRJT04gKi86XHJcbiAgICAgICAgICAgIF9hc3NlcnQocmVzcG9uc2UubWZhSW5mbywgYXV0aE1vZHVsYXIsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICAvLyBmYWxsIHRocm91Z2hcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBfYXNzZXJ0KHJlc3BvbnNlLmVtYWlsLCBhdXRoTW9kdWxhciwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgfVxyXG4gICAgLy8gVGhlIG11bHRpLWZhY3RvciBpbmZvIGZvciByZXZlcnQgc2Vjb25kIGZhY3RvciBhZGRpdGlvblxyXG4gICAgbGV0IG11bHRpRmFjdG9ySW5mbyA9IG51bGw7XHJcbiAgICBpZiAocmVzcG9uc2UubWZhSW5mbykge1xyXG4gICAgICAgIG11bHRpRmFjdG9ySW5mbyA9IE11bHRpRmFjdG9ySW5mb0ltcGwuX2Zyb21TZXJ2ZXJSZXNwb25zZShfY2FzdEF1dGgoYXV0aE1vZHVsYXIpLCByZXNwb25zZS5tZmFJbmZvKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICBlbWFpbDogKHJlc3BvbnNlLnJlcXVlc3RUeXBlID09PSBcIlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfQU5EX0NIQU5HRV9FTUFJTCAqL1xyXG4gICAgICAgICAgICAgICAgPyByZXNwb25zZS5uZXdFbWFpbFxyXG4gICAgICAgICAgICAgICAgOiByZXNwb25zZS5lbWFpbCkgfHwgbnVsbCxcclxuICAgICAgICAgICAgcHJldmlvdXNFbWFpbDogKHJlc3BvbnNlLnJlcXVlc3RUeXBlID09PSBcIlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfQU5EX0NIQU5HRV9FTUFJTCAqL1xyXG4gICAgICAgICAgICAgICAgPyByZXNwb25zZS5lbWFpbFxyXG4gICAgICAgICAgICAgICAgOiByZXNwb25zZS5uZXdFbWFpbCkgfHwgbnVsbCxcclxuICAgICAgICAgICAgbXVsdGlGYWN0b3JJbmZvXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvcGVyYXRpb25cclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBhIHBhc3N3b3JkIHJlc2V0IGNvZGUgc2VudCB0byB0aGUgdXNlciBieSBlbWFpbCBvciBvdGhlciBvdXQtb2YtYmFuZCBtZWNoYW5pc20uXHJcbiAqXHJcbiAqIEByZXR1cm5zIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcyBpZiB2YWxpZC5cclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gY29kZSAtIEEgdmVyaWZpY2F0aW9uIGNvZGUgc2VudCB0byB0aGUgdXNlci5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5UGFzc3dvcmRSZXNldENvZGUoYXV0aCwgY29kZSkge1xyXG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBjaGVja0FjdGlvbkNvZGUoZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLCBjb2RlKTtcclxuICAgIC8vIEVtYWlsIHNob3VsZCBhbHdheXMgYmUgcHJlc2VudCBzaW5jZSBhIGNvZGUgd2FzIHNlbnQgdG8gaXRcclxuICAgIHJldHVybiBkYXRhLmVtYWlsO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHVzZXIgYWNjb3VudCBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBlbWFpbCBhZGRyZXNzIGFuZCBwYXNzd29yZC5cclxuICpcclxuICogQHJlbWFya3NcclxuICogT24gc3VjY2Vzc2Z1bCBjcmVhdGlvbiBvZiB0aGUgdXNlciBhY2NvdW50LCB0aGlzIHVzZXIgd2lsbCBhbHNvIGJlIHNpZ25lZCBpbiB0byB5b3VyIGFwcGxpY2F0aW9uLlxyXG4gKlxyXG4gKiBVc2VyIGFjY291bnQgY3JlYXRpb24gY2FuIGZhaWwgaWYgdGhlIGFjY291bnQgYWxyZWFkeSBleGlzdHMgb3IgdGhlIHBhc3N3b3JkIGlzIGludmFsaWQuXHJcbiAqXHJcbiAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgb24ge0BsaW5rIEF1dGh9IGluc3RhbmNlcyBjcmVhdGVkIHdpdGggYVxyXG4gKiB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZVNlcnZlckFwcH0uXHJcbiAqXHJcbiAqIE5vdGU6IFRoZSBlbWFpbCBhZGRyZXNzIGFjdHMgYXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHVzZXIgYW5kIGVuYWJsZXMgYW4gZW1haWwtYmFzZWRcclxuICogcGFzc3dvcmQgcmVzZXQuIFRoaXMgZnVuY3Rpb24gd2lsbCBjcmVhdGUgYSBuZXcgdXNlciBhY2NvdW50IGFuZCBzZXQgdGhlIGluaXRpYWwgdXNlciBwYXNzd29yZC5cclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gZW1haWwgLSBUaGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuXHJcbiAqIEBwYXJhbSBwYXNzd29yZCAtIFRoZSB1c2VyJ3MgY2hvc2VuIHBhc3N3b3JkLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVVc2VyV2l0aEVtYWlsQW5kUGFzc3dvcmQoYXV0aCwgZW1haWwsIHBhc3N3b3JkKSB7XHJcbiAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAoYXV0aC5hcHApKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKGF1dGgpKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcclxuICAgIGNvbnN0IHJlcXVlc3QgPSB7XHJcbiAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWUsXHJcbiAgICAgICAgZW1haWwsXHJcbiAgICAgICAgcGFzc3dvcmQsXHJcbiAgICAgICAgY2xpZW50VHlwZTogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqL1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHNpZ25VcFJlc3BvbnNlID0gaGFuZGxlUmVjYXB0Y2hhRmxvdyhhdXRoSW50ZXJuYWwsIHJlcXVlc3QsIFwic2lnblVwUGFzc3dvcmRcIiAvKiBSZWNhcHRjaGFBY3Rpb25OYW1lLlNJR05fVVBfUEFTU1dPUkQgKi8sIHNpZ25VcCk7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNpZ25VcFJlc3BvbnNlLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gYGF1dGgvJHtcInBhc3N3b3JkLWRvZXMtbm90LW1lZXQtcmVxdWlyZW1lbnRzXCIgLyogQXV0aEVycm9yQ29kZS5QQVNTV09SRF9ET0VTX05PVF9NRUVUX1JFUVVJUkVNRU5UUyAqL31gKSB7XHJcbiAgICAgICAgICAgIHZvaWQgcmVjYWNoZVBhc3N3b3JkUG9saWN5KGF1dGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH0pO1xyXG4gICAgY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBVc2VyQ3JlZGVudGlhbEltcGwuX2Zyb21JZFRva2VuUmVzcG9uc2UoYXV0aEludGVybmFsLCBcInNpZ25JblwiIC8qIE9wZXJhdGlvblR5cGUuU0lHTl9JTiAqLywgcmVzcG9uc2UpO1xyXG4gICAgYXdhaXQgYXV0aEludGVybmFsLl91cGRhdGVDdXJyZW50VXNlcih1c2VyQ3JlZGVudGlhbC51c2VyKTtcclxuICAgIHJldHVybiB1c2VyQ3JlZGVudGlhbDtcclxufVxyXG4vKipcclxuICogQXN5bmNocm9ub3VzbHkgc2lnbnMgaW4gdXNpbmcgYW4gZW1haWwgYW5kIHBhc3N3b3JkLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBGYWlscyB3aXRoIGFuIGVycm9yIGlmIHRoZSBlbWFpbCBhZGRyZXNzIGFuZCBwYXNzd29yZCBkbyBub3QgbWF0Y2guIFdoZW5cclxuICoge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9pZGVudGl0eS1wbGF0Zm9ybS9kb2NzL2FkbWluL2VtYWlsLWVudW1lcmF0aW9uLXByb3RlY3Rpb24gfCBFbWFpbCBFbnVtZXJhdGlvbiBQcm90ZWN0aW9ufVxyXG4gKiBpcyBlbmFibGVkLCB0aGlzIG1ldGhvZCBmYWlscyB3aXRoIFwiYXV0aC9pbnZhbGlkLWNyZWRlbnRpYWxcIiBpbiBjYXNlIG9mIGFuIGludmFsaWRcclxuICogZW1haWwvcGFzc3dvcmQuXHJcbiAqXHJcbiAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgb24ge0BsaW5rIEF1dGh9IGluc3RhbmNlcyBjcmVhdGVkIHdpdGggYVxyXG4gKiB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZVNlcnZlckFwcH0uXHJcbiAqXHJcbiAqIE5vdGU6IFRoZSB1c2VyJ3MgcGFzc3dvcmQgaXMgTk9UIHRoZSBwYXNzd29yZCB1c2VkIHRvIGFjY2VzcyB0aGUgdXNlcidzIGVtYWlsIGFjY291bnQuIFRoZVxyXG4gKiBlbWFpbCBhZGRyZXNzIHNlcnZlcyBhcyBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdXNlciwgYW5kIHRoZSBwYXNzd29yZCBpcyB1c2VkIHRvIGFjY2Vzc1xyXG4gKiB0aGUgdXNlcidzIGFjY291bnQgaW4geW91ciBGaXJlYmFzZSBwcm9qZWN0LiBTZWUgYWxzbzoge0BsaW5rIGNyZWF0ZVVzZXJXaXRoRW1haWxBbmRQYXNzd29yZH0uXHJcbiAqXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICogQHBhcmFtIGVtYWlsIC0gVGhlIHVzZXJzIGVtYWlsIGFkZHJlc3MuXHJcbiAqIEBwYXJhbSBwYXNzd29yZCAtIFRoZSB1c2VycyBwYXNzd29yZC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gc2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmQoYXV0aCwgZW1haWwsIHBhc3N3b3JkKSB7XHJcbiAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAoYXV0aC5hcHApKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKGF1dGgpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzaWduSW5XaXRoQ3JlZGVudGlhbChnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCksIEVtYWlsQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwoZW1haWwsIHBhc3N3b3JkKSkuY2F0Y2goYXN5bmMgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IGBhdXRoLyR7XCJwYXNzd29yZC1kb2VzLW5vdC1tZWV0LXJlcXVpcmVtZW50c1wiIC8qIEF1dGhFcnJvckNvZGUuUEFTU1dPUkRfRE9FU19OT1RfTUVFVF9SRVFVSVJFTUVOVFMgKi99YCkge1xyXG4gICAgICAgICAgICB2b2lkIHJlY2FjaGVQYXNzd29yZFBvbGljeShhdXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9KTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogU2VuZHMgYSBzaWduLWluIGVtYWlsIGxpbmsgdG8gdGhlIHVzZXIgd2l0aCB0aGUgc3BlY2lmaWVkIGVtYWlsLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGUgc2lnbi1pbiBvcGVyYXRpb24gaGFzIHRvIGFsd2F5cyBiZSBjb21wbGV0ZWQgaW4gdGhlIGFwcCB1bmxpa2Ugb3RoZXIgb3V0IG9mIGJhbmQgZW1haWxcclxuICogYWN0aW9ucyAocGFzc3dvcmQgcmVzZXQgYW5kIGVtYWlsIHZlcmlmaWNhdGlvbnMpLiBUaGlzIGlzIGJlY2F1c2UsIGF0IHRoZSBlbmQgb2YgdGhlIGZsb3csXHJcbiAqIHRoZSB1c2VyIGlzIGV4cGVjdGVkIHRvIGJlIHNpZ25lZCBpbiBhbmQgdGhlaXIgQXV0aCBzdGF0ZSBwZXJzaXN0ZWQgd2l0aGluIHRoZSBhcHAuXHJcbiAqXHJcbiAqIFRvIGNvbXBsZXRlIHNpZ24gaW4gd2l0aCB0aGUgZW1haWwgbGluaywgY2FsbCB7QGxpbmsgc2lnbkluV2l0aEVtYWlsTGlua30gd2l0aCB0aGUgZW1haWxcclxuICogYWRkcmVzcyBhbmQgdGhlIGVtYWlsIGxpbmsgc3VwcGxpZWQgaW4gdGhlIGVtYWlsIHNlbnQgdG8gdGhlIHVzZXIuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogY29uc3QgYWN0aW9uQ29kZVNldHRpbmdzID0ge1xyXG4gKiAgIHVybDogJ2h0dHBzOi8vd3d3LmV4YW1wbGUuY29tLz9lbWFpbD11c2VyQGV4YW1wbGUuY29tJyxcclxuICogICBpT1M6IHtcclxuICogICAgICBidW5kbGVJZDogJ2NvbS5leGFtcGxlLmlvcydcclxuICogICB9LFxyXG4gKiAgIGFuZHJvaWQ6IHtcclxuICogICAgIHBhY2thZ2VOYW1lOiAnY29tLmV4YW1wbGUuYW5kcm9pZCcsXHJcbiAqICAgICBpbnN0YWxsQXBwOiB0cnVlLFxyXG4gKiAgICAgbWluaW11bVZlcnNpb246ICcxMidcclxuICogICB9LFxyXG4gKiAgIGhhbmRsZUNvZGVJbkFwcDogdHJ1ZVxyXG4gKiB9O1xyXG4gKiBhd2FpdCBzZW5kU2lnbkluTGlua1RvRW1haWwoYXV0aCwgJ3VzZXJAZXhhbXBsZS5jb20nLCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xyXG4gKiAvLyBPYnRhaW4gZW1haWxMaW5rIGZyb20gdGhlIHVzZXIuXHJcbiAqIGlmKGlzU2lnbkluV2l0aEVtYWlsTGluayhhdXRoLCBlbWFpbExpbmspKSB7XHJcbiAqICAgYXdhaXQgc2lnbkluV2l0aEVtYWlsTGluayhhdXRoLCAndXNlckBleGFtcGxlLmNvbScsIGVtYWlsTGluayk7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoSW50ZXJuYWwgLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gZW1haWwgLSBUaGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuXHJcbiAqIEBwYXJhbSBhY3Rpb25Db2RlU2V0dGluZ3MgLSBUaGUge0BsaW5rIEFjdGlvbkNvZGVTZXR0aW5nc30uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHNlbmRTaWduSW5MaW5rVG9FbWFpbChhdXRoLCBlbWFpbCwgYWN0aW9uQ29kZVNldHRpbmdzKSB7XHJcbiAgICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XHJcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgIHJlcXVlc3RUeXBlOiBcIkVNQUlMX1NJR05JTlwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uRU1BSUxfU0lHTklOICovLFxyXG4gICAgICAgIGVtYWlsLFxyXG4gICAgICAgIGNsaWVudFR5cGU6IFwiQ0xJRU5UX1RZUEVfV0VCXCIgLyogUmVjYXB0Y2hhQ2xpZW50VHlwZS5XRUIgKi9cclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBzZXRBY3Rpb25Db2RlU2V0dGluZ3MocmVxdWVzdCwgYWN0aW9uQ29kZVNldHRpbmdzKSB7XHJcbiAgICAgICAgX2Fzc2VydChhY3Rpb25Db2RlU2V0dGluZ3MuaGFuZGxlQ29kZUluQXBwLCBhdXRoSW50ZXJuYWwsIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcclxuICAgICAgICBpZiAoYWN0aW9uQ29kZVNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIF9zZXRBY3Rpb25Db2RlU2V0dGluZ3NPblJlcXVlc3QoYXV0aEludGVybmFsLCByZXF1ZXN0LCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldEFjdGlvbkNvZGVTZXR0aW5ncyhyZXF1ZXN0LCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xyXG4gICAgYXdhaXQgaGFuZGxlUmVjYXB0Y2hhRmxvdyhhdXRoSW50ZXJuYWwsIHJlcXVlc3QsIFwiZ2V0T29iQ29kZVwiIC8qIFJlY2FwdGNoYUFjdGlvbk5hbWUuR0VUX09PQl9DT0RFICovLCBzZW5kU2lnbkluTGlua1RvRW1haWwkMSk7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhbiBpbmNvbWluZyBsaW5rIGlzIGEgc2lnbi1pbiB3aXRoIGVtYWlsIGxpbmsgc3VpdGFibGUgZm9yIHtAbGluayBzaWduSW5XaXRoRW1haWxMaW5rfS5cclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gZW1haWxMaW5rIC0gVGhlIGxpbmsgc2VudCB0byB0aGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGlzU2lnbkluV2l0aEVtYWlsTGluayhhdXRoLCBlbWFpbExpbmspIHtcclxuICAgIGNvbnN0IGFjdGlvbkNvZGVVcmwgPSBBY3Rpb25Db2RlVVJMLnBhcnNlTGluayhlbWFpbExpbmspO1xyXG4gICAgcmV0dXJuIChhY3Rpb25Db2RlVXJsID09PSBudWxsIHx8IGFjdGlvbkNvZGVVcmwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGlvbkNvZGVVcmwub3BlcmF0aW9uKSA9PT0gXCJFTUFJTF9TSUdOSU5cIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLkVNQUlMX1NJR05JTiAqLztcclxufVxyXG4vKipcclxuICogQXN5bmNocm9ub3VzbHkgc2lnbnMgaW4gdXNpbmcgYW4gZW1haWwgYW5kIHNpZ24taW4gZW1haWwgbGluay5cclxuICpcclxuICogQHJlbWFya3NcclxuICogSWYgbm8gbGluayBpcyBwYXNzZWQsIHRoZSBsaW5rIGlzIGluZmVycmVkIGZyb20gdGhlIGN1cnJlbnQgVVJMLlxyXG4gKlxyXG4gKiBGYWlscyB3aXRoIGFuIGVycm9yIGlmIHRoZSBlbWFpbCBhZGRyZXNzIGlzIGludmFsaWQgb3IgT1RQIGluIGVtYWlsIGxpbmsgZXhwaXJlcy5cclxuICpcclxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzIGNyZWF0ZWQgd2l0aCBhXHJcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cclxuICpcclxuICogTm90ZTogQ29uZmlybSB0aGUgbGluayBpcyBhIHNpZ24taW4gZW1haWwgbGluayBiZWZvcmUgY2FsbGluZyB0aGlzIG1ldGhvZCBmaXJlYmFzZS5hdXRoLkF1dGguaXNTaWduSW5XaXRoRW1haWxMaW5rLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIGNvbnN0IGFjdGlvbkNvZGVTZXR0aW5ncyA9IHtcclxuICogICB1cmw6ICdodHRwczovL3d3dy5leGFtcGxlLmNvbS8/ZW1haWw9dXNlckBleGFtcGxlLmNvbScsXHJcbiAqICAgaU9TOiB7XHJcbiAqICAgICAgYnVuZGxlSWQ6ICdjb20uZXhhbXBsZS5pb3MnXHJcbiAqICAgfSxcclxuICogICBhbmRyb2lkOiB7XHJcbiAqICAgICBwYWNrYWdlTmFtZTogJ2NvbS5leGFtcGxlLmFuZHJvaWQnLFxyXG4gKiAgICAgaW5zdGFsbEFwcDogdHJ1ZSxcclxuICogICAgIG1pbmltdW1WZXJzaW9uOiAnMTInXHJcbiAqICAgfSxcclxuICogICBoYW5kbGVDb2RlSW5BcHA6IHRydWVcclxuICogfTtcclxuICogYXdhaXQgc2VuZFNpZ25JbkxpbmtUb0VtYWlsKGF1dGgsICd1c2VyQGV4YW1wbGUuY29tJywgYWN0aW9uQ29kZVNldHRpbmdzKTtcclxuICogLy8gT2J0YWluIGVtYWlsTGluayBmcm9tIHRoZSB1c2VyLlxyXG4gKiBpZihpc1NpZ25JbldpdGhFbWFpbExpbmsoYXV0aCwgZW1haWxMaW5rKSkge1xyXG4gKiAgIGF3YWl0IHNpZ25JbldpdGhFbWFpbExpbmsoYXV0aCwgJ3VzZXJAZXhhbXBsZS5jb20nLCBlbWFpbExpbmspO1xyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBlbWFpbCAtIFRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cclxuICogQHBhcmFtIGVtYWlsTGluayAtIFRoZSBsaW5rIHNlbnQgdG8gdGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoRW1haWxMaW5rKGF1dGgsIGVtYWlsLCBlbWFpbExpbmspIHtcclxuICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcChhdXRoLmFwcCkpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYXV0aE1vZHVsYXIgPSBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCk7XHJcbiAgICBjb25zdCBjcmVkZW50aWFsID0gRW1haWxBdXRoUHJvdmlkZXIuY3JlZGVudGlhbFdpdGhMaW5rKGVtYWlsLCBlbWFpbExpbmsgfHwgX2dldEN1cnJlbnRVcmwoKSk7XHJcbiAgICAvLyBDaGVjayBpZiB0aGUgdGVuYW50IElEIGluIHRoZSBlbWFpbCBsaW5rIG1hdGNoZXMgdGhlIHRlbmFudCBJRCBvbiBBdXRoXHJcbiAgICAvLyBpbnN0YW5jZS5cclxuICAgIF9hc3NlcnQoY3JlZGVudGlhbC5fdGVuYW50SWQgPT09IChhdXRoTW9kdWxhci50ZW5hbnRJZCB8fCBudWxsKSwgYXV0aE1vZHVsYXIsIFwidGVuYW50LWlkLW1pc21hdGNoXCIgLyogQXV0aEVycm9yQ29kZS5URU5BTlRfSURfTUlTTUFUQ0ggKi8pO1xyXG4gICAgcmV0dXJuIHNpZ25JbldpdGhDcmVkZW50aWFsKGF1dGhNb2R1bGFyLCBjcmVkZW50aWFsKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVBdXRoVXJpKGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpjcmVhdGVBdXRoVXJpXCIgLyogRW5kcG9pbnQuQ1JFQVRFX0FVVEhfVVJJICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBsaXN0IG9mIHBvc3NpYmxlIHNpZ24gaW4gbWV0aG9kcyBmb3IgdGhlIGdpdmVuIGVtYWlsIGFkZHJlc3MuIFRoaXMgbWV0aG9kIHJldHVybnMgYW5cclxuICogZW1wdHkgbGlzdCB3aGVuXHJcbiAqIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vaWRlbnRpdHktcGxhdGZvcm0vZG9jcy9hZG1pbi9lbWFpbC1lbnVtZXJhdGlvbi1wcm90ZWN0aW9uIHwgRW1haWwgRW51bWVyYXRpb24gUHJvdGVjdGlvbn1cclxuICogaXMgZW5hYmxlZCwgaXJyZXNwZWN0aXZlIG9mIHRoZSBudW1iZXIgb2YgYXV0aGVudGljYXRpb24gbWV0aG9kcyBhdmFpbGFibGUgZm9yIHRoZSBnaXZlbiBlbWFpbC5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhpcyBpcyB1c2VmdWwgdG8gZGlmZmVyZW50aWF0ZSBtZXRob2RzIG9mIHNpZ24taW4gZm9yIHRoZSBzYW1lIHByb3ZpZGVyLCBlZy5cclxuICoge0BsaW5rIEVtYWlsQXV0aFByb3ZpZGVyfSB3aGljaCBoYXMgMiBtZXRob2RzIG9mIHNpZ24taW4sXHJcbiAqIHtAbGluayBTaWduSW5NZXRob2R9LkVNQUlMX1BBU1NXT1JEIGFuZFxyXG4gKiB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9MSU5LLlxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBlbWFpbCAtIFRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cclxuICpcclxuICogRGVwcmVjYXRlZC4gTWlncmF0aW5nIG9mZiBvZiB0aGlzIG1ldGhvZCBpcyByZWNvbW1lbmRlZCBhcyBhIHNlY3VyaXR5IGJlc3QtcHJhY3RpY2UuXHJcbiAqIExlYXJuIG1vcmUgaW4gdGhlIElkZW50aXR5IFBsYXRmb3JtIGRvY3VtZW50YXRpb24gZm9yXHJcbiAqIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vaWRlbnRpdHktcGxhdGZvcm0vZG9jcy9hZG1pbi9lbWFpbC1lbnVtZXJhdGlvbi1wcm90ZWN0aW9uIHwgRW1haWwgRW51bWVyYXRpb24gUHJvdGVjdGlvbn0uXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGZldGNoU2lnbkluTWV0aG9kc0ZvckVtYWlsKGF1dGgsIGVtYWlsKSB7XHJcbiAgICAvLyBjcmVhdGVBdXRoVXJpIHJldHVybnMgYW4gZXJyb3IgaWYgY29udGludWUgVVJJIGlzIG5vdCBodHRwIG9yIGh0dHBzLlxyXG4gICAgLy8gRm9yIGVudmlyb25tZW50cyBsaWtlIENvcmRvdmEsIENocm9tZSBleHRlbnNpb25zLCBuYXRpdmUgZnJhbWV3b3JrcywgZmlsZVxyXG4gICAgLy8gc3lzdGVtcywgZXRjLCB1c2UgaHR0cDovL2xvY2FsaG9zdCBhcyBjb250aW51ZSBVUkwuXHJcbiAgICBjb25zdCBjb250aW51ZVVyaSA9IF9pc0h0dHBPckh0dHBzKCkgPyBfZ2V0Q3VycmVudFVybCgpIDogJ2h0dHA6Ly9sb2NhbGhvc3QnO1xyXG4gICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICBpZGVudGlmaWVyOiBlbWFpbCxcclxuICAgICAgICBjb250aW51ZVVyaVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHsgc2lnbmluTWV0aG9kcyB9ID0gYXdhaXQgY3JlYXRlQXV0aFVyaShnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCksIHJlcXVlc3QpO1xyXG4gICAgcmV0dXJuIHNpZ25pbk1ldGhvZHMgfHwgW107XHJcbn1cclxuLyoqXHJcbiAqIFNlbmRzIGEgdmVyaWZpY2F0aW9uIGVtYWlsIHRvIGEgdXNlci5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhlIHZlcmlmaWNhdGlvbiBwcm9jZXNzIGlzIGNvbXBsZXRlZCBieSBjYWxsaW5nIHtAbGluayBhcHBseUFjdGlvbkNvZGV9LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIGNvbnN0IGFjdGlvbkNvZGVTZXR0aW5ncyA9IHtcclxuICogICB1cmw6ICdodHRwczovL3d3dy5leGFtcGxlLmNvbS8/ZW1haWw9dXNlckBleGFtcGxlLmNvbScsXHJcbiAqICAgaU9TOiB7XHJcbiAqICAgICAgYnVuZGxlSWQ6ICdjb20uZXhhbXBsZS5pb3MnXHJcbiAqICAgfSxcclxuICogICBhbmRyb2lkOiB7XHJcbiAqICAgICBwYWNrYWdlTmFtZTogJ2NvbS5leGFtcGxlLmFuZHJvaWQnLFxyXG4gKiAgICAgaW5zdGFsbEFwcDogdHJ1ZSxcclxuICogICAgIG1pbmltdW1WZXJzaW9uOiAnMTInXHJcbiAqICAgfSxcclxuICogICBoYW5kbGVDb2RlSW5BcHA6IHRydWVcclxuICogfTtcclxuICogYXdhaXQgc2VuZEVtYWlsVmVyaWZpY2F0aW9uKHVzZXIsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XHJcbiAqIC8vIE9idGFpbiBjb2RlIGZyb20gdGhlIHVzZXIuXHJcbiAqIGF3YWl0IGFwcGx5QWN0aW9uQ29kZShhdXRoLCBjb2RlKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXHJcbiAqIEBwYXJhbSBhY3Rpb25Db2RlU2V0dGluZ3MgLSBUaGUge0BsaW5rIEFjdGlvbkNvZGVTZXR0aW5nc30uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHNlbmRFbWFpbFZlcmlmaWNhdGlvbih1c2VyLCBhY3Rpb25Db2RlU2V0dGluZ3MpIHtcclxuICAgIGNvbnN0IHVzZXJJbnRlcm5hbCA9IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKTtcclxuICAgIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB1c2VyLmdldElkVG9rZW4oKTtcclxuICAgIGNvbnN0IHJlcXVlc3QgPSB7XHJcbiAgICAgICAgcmVxdWVzdFR5cGU6IFwiVkVSSUZZX0VNQUlMXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfRU1BSUwgKi8sXHJcbiAgICAgICAgaWRUb2tlblxyXG4gICAgfTtcclxuICAgIGlmIChhY3Rpb25Db2RlU2V0dGluZ3MpIHtcclxuICAgICAgICBfc2V0QWN0aW9uQ29kZVNldHRpbmdzT25SZXF1ZXN0KHVzZXJJbnRlcm5hbC5hdXRoLCByZXF1ZXN0LCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBlbWFpbCB9ID0gYXdhaXQgc2VuZEVtYWlsVmVyaWZpY2F0aW9uJDEodXNlckludGVybmFsLmF1dGgsIHJlcXVlc3QpO1xyXG4gICAgaWYgKGVtYWlsICE9PSB1c2VyLmVtYWlsKSB7XHJcbiAgICAgICAgYXdhaXQgdXNlci5yZWxvYWQoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogU2VuZHMgYSB2ZXJpZmljYXRpb24gZW1haWwgdG8gYSBuZXcgZW1haWwgYWRkcmVzcy5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhlIHVzZXIncyBlbWFpbCB3aWxsIGJlIHVwZGF0ZWQgdG8gdGhlIG5ldyBvbmUgYWZ0ZXIgYmVpbmcgdmVyaWZpZWQuXHJcbiAqXHJcbiAqIElmIHlvdSBoYXZlIGEgY3VzdG9tIGVtYWlsIGFjdGlvbiBoYW5kbGVyLCB5b3UgY2FuIGNvbXBsZXRlIHRoZSB2ZXJpZmljYXRpb24gcHJvY2VzcyBieSBjYWxsaW5nXHJcbiAqIHtAbGluayBhcHBseUFjdGlvbkNvZGV9LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIGNvbnN0IGFjdGlvbkNvZGVTZXR0aW5ncyA9IHtcclxuICogICB1cmw6ICdodHRwczovL3d3dy5leGFtcGxlLmNvbS8/ZW1haWw9dXNlckBleGFtcGxlLmNvbScsXHJcbiAqICAgaU9TOiB7XHJcbiAqICAgICAgYnVuZGxlSWQ6ICdjb20uZXhhbXBsZS5pb3MnXHJcbiAqICAgfSxcclxuICogICBhbmRyb2lkOiB7XHJcbiAqICAgICBwYWNrYWdlTmFtZTogJ2NvbS5leGFtcGxlLmFuZHJvaWQnLFxyXG4gKiAgICAgaW5zdGFsbEFwcDogdHJ1ZSxcclxuICogICAgIG1pbmltdW1WZXJzaW9uOiAnMTInXHJcbiAqICAgfSxcclxuICogICBoYW5kbGVDb2RlSW5BcHA6IHRydWVcclxuICogfTtcclxuICogYXdhaXQgdmVyaWZ5QmVmb3JlVXBkYXRlRW1haWwodXNlciwgJ25ld2VtYWlsQGV4YW1wbGUuY29tJywgYWN0aW9uQ29kZVNldHRpbmdzKTtcclxuICogLy8gT2J0YWluIGNvZGUgZnJvbSB0aGUgdXNlci5cclxuICogYXdhaXQgYXBwbHlBY3Rpb25Db2RlKGF1dGgsIGNvZGUpO1xyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cclxuICogQHBhcmFtIG5ld0VtYWlsIC0gVGhlIG5ldyBlbWFpbCBhZGRyZXNzIHRvIGJlIHZlcmlmaWVkIGJlZm9yZSB1cGRhdGUuXHJcbiAqIEBwYXJhbSBhY3Rpb25Db2RlU2V0dGluZ3MgLSBUaGUge0BsaW5rIEFjdGlvbkNvZGVTZXR0aW5nc30uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeUJlZm9yZVVwZGF0ZUVtYWlsKHVzZXIsIG5ld0VtYWlsLCBhY3Rpb25Db2RlU2V0dGluZ3MpIHtcclxuICAgIGNvbnN0IHVzZXJJbnRlcm5hbCA9IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKTtcclxuICAgIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB1c2VyLmdldElkVG9rZW4oKTtcclxuICAgIGNvbnN0IHJlcXVlc3QgPSB7XHJcbiAgICAgICAgcmVxdWVzdFR5cGU6IFwiVkVSSUZZX0FORF9DSEFOR0VfRU1BSUxcIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMICovLFxyXG4gICAgICAgIGlkVG9rZW4sXHJcbiAgICAgICAgbmV3RW1haWxcclxuICAgIH07XHJcbiAgICBpZiAoYWN0aW9uQ29kZVNldHRpbmdzKSB7XHJcbiAgICAgICAgX3NldEFjdGlvbkNvZGVTZXR0aW5nc09uUmVxdWVzdCh1c2VySW50ZXJuYWwuYXV0aCwgcmVxdWVzdCwgYWN0aW9uQ29kZVNldHRpbmdzKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgZW1haWwgfSA9IGF3YWl0IHZlcmlmeUFuZENoYW5nZUVtYWlsKHVzZXJJbnRlcm5hbC5hdXRoLCByZXF1ZXN0KTtcclxuICAgIGlmIChlbWFpbCAhPT0gdXNlci5lbWFpbCkge1xyXG4gICAgICAgIC8vIElmIHRoZSBsb2NhbCBjb3B5IG9mIHRoZSBlbWFpbCBvbiB1c2VyIGlzIG91dGRhdGVkLCByZWxvYWQgdGhlXHJcbiAgICAgICAgLy8gdXNlci5cclxuICAgICAgICBhd2FpdCB1c2VyLnJlbG9hZCgpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVByb2ZpbGUkMShhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6dXBkYXRlXCIgLyogRW5kcG9pbnQuU0VUX0FDQ09VTlRfSU5GTyAqLywgcmVxdWVzdCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFVwZGF0ZXMgYSB1c2VyJ3MgcHJvZmlsZSBkYXRhLlxyXG4gKlxyXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxyXG4gKiBAcGFyYW0gcHJvZmlsZSAtIFRoZSBwcm9maWxlJ3MgYGRpc3BsYXlOYW1lYCBhbmQgYHBob3RvVVJMYCB0byB1cGRhdGUuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVByb2ZpbGUodXNlciwgeyBkaXNwbGF5TmFtZSwgcGhvdG9VUkw6IHBob3RvVXJsIH0pIHtcclxuICAgIGlmIChkaXNwbGF5TmFtZSA9PT0gdW5kZWZpbmVkICYmIHBob3RvVXJsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcik7XHJcbiAgICBjb25zdCBpZFRva2VuID0gYXdhaXQgdXNlckludGVybmFsLmdldElkVG9rZW4oKTtcclxuICAgIGNvbnN0IHByb2ZpbGVSZXF1ZXN0ID0ge1xyXG4gICAgICAgIGlkVG9rZW4sXHJcbiAgICAgICAgZGlzcGxheU5hbWUsXHJcbiAgICAgICAgcGhvdG9VcmwsXHJcbiAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWVcclxuICAgIH07XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9sb2dvdXRJZkludmFsaWRhdGVkKHVzZXJJbnRlcm5hbCwgdXBkYXRlUHJvZmlsZSQxKHVzZXJJbnRlcm5hbC5hdXRoLCBwcm9maWxlUmVxdWVzdCkpO1xyXG4gICAgdXNlckludGVybmFsLmRpc3BsYXlOYW1lID0gcmVzcG9uc2UuZGlzcGxheU5hbWUgfHwgbnVsbDtcclxuICAgIHVzZXJJbnRlcm5hbC5waG90b1VSTCA9IHJlc3BvbnNlLnBob3RvVXJsIHx8IG51bGw7XHJcbiAgICAvLyBVcGRhdGUgdGhlIHBhc3N3b3JkIHByb3ZpZGVyIGFzIHdlbGxcclxuICAgIGNvbnN0IHBhc3N3b3JkUHJvdmlkZXIgPSB1c2VySW50ZXJuYWwucHJvdmlkZXJEYXRhLmZpbmQoKHsgcHJvdmlkZXJJZCB9KSA9PiBwcm92aWRlcklkID09PSBcInBhc3N3b3JkXCIgLyogUHJvdmlkZXJJZC5QQVNTV09SRCAqLyk7XHJcbiAgICBpZiAocGFzc3dvcmRQcm92aWRlcikge1xyXG4gICAgICAgIHBhc3N3b3JkUHJvdmlkZXIuZGlzcGxheU5hbWUgPSB1c2VySW50ZXJuYWwuZGlzcGxheU5hbWU7XHJcbiAgICAgICAgcGFzc3dvcmRQcm92aWRlci5waG90b1VSTCA9IHVzZXJJbnRlcm5hbC5waG90b1VSTDtcclxuICAgIH1cclxuICAgIGF3YWl0IHVzZXJJbnRlcm5hbC5fdXBkYXRlVG9rZW5zSWZOZWNlc3NhcnkocmVzcG9uc2UpO1xyXG59XHJcbi8qKlxyXG4gKiBVcGRhdGVzIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cclxuICpcclxuICogQHJlbWFya3NcclxuICogQW4gZW1haWwgd2lsbCBiZSBzZW50IHRvIHRoZSBvcmlnaW5hbCBlbWFpbCBhZGRyZXNzIChpZiBpdCB3YXMgc2V0KSB0aGF0IGFsbG93cyB0byByZXZva2UgdGhlXHJcbiAqIGVtYWlsIGFkZHJlc3MgY2hhbmdlLCBpbiBvcmRlciB0byBwcm90ZWN0IHRoZW0gZnJvbSBhY2NvdW50IGhpamFja2luZy5cclxuICpcclxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBvbiBhbnkge0BsaW5rIFVzZXJ9IHNpZ25lZCBpbiBieSB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzXHJcbiAqIGNyZWF0ZWQgd2l0aCBhIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cclxuICpcclxuICogSW1wb3J0YW50OiB0aGlzIGlzIGEgc2VjdXJpdHkgc2Vuc2l0aXZlIG9wZXJhdGlvbiB0aGF0IHJlcXVpcmVzIHRoZSB1c2VyIHRvIGhhdmUgcmVjZW50bHkgc2lnbmVkXHJcbiAqIGluLiBJZiB0aGlzIHJlcXVpcmVtZW50IGlzbid0IG1ldCwgYXNrIHRoZSB1c2VyIHRvIGF1dGhlbnRpY2F0ZSBhZ2FpbiBhbmQgdGhlbiBjYWxsXHJcbiAqIHtAbGluayByZWF1dGhlbnRpY2F0ZVdpdGhDcmVkZW50aWFsfS5cclxuICpcclxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cclxuICogQHBhcmFtIG5ld0VtYWlsIC0gVGhlIG5ldyBlbWFpbCBhZGRyZXNzLlxyXG4gKlxyXG4gKiBUaHJvd3MgXCJhdXRoL29wZXJhdGlvbi1ub3QtYWxsb3dlZFwiIGVycm9yIHdoZW5cclxuICoge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9pZGVudGl0eS1wbGF0Zm9ybS9kb2NzL2FkbWluL2VtYWlsLWVudW1lcmF0aW9uLXByb3RlY3Rpb24gfCBFbWFpbCBFbnVtZXJhdGlvbiBQcm90ZWN0aW9ufVxyXG4gKiBpcyBlbmFibGVkLlxyXG4gKiBEZXByZWNhdGVkIC0gVXNlIHtAbGluayB2ZXJpZnlCZWZvcmVVcGRhdGVFbWFpbH0gaW5zdGVhZC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlRW1haWwodXNlciwgbmV3RW1haWwpIHtcclxuICAgIGNvbnN0IHVzZXJJbnRlcm5hbCA9IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKTtcclxuICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcCh1c2VySW50ZXJuYWwuYXV0aC5hcHApKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKHVzZXJJbnRlcm5hbC5hdXRoKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdXBkYXRlRW1haWxPclBhc3N3b3JkKHVzZXJJbnRlcm5hbCwgbmV3RW1haWwsIG51bGwpO1xyXG59XHJcbi8qKlxyXG4gKiBVcGRhdGVzIHRoZSB1c2VyJ3MgcGFzc3dvcmQuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIEltcG9ydGFudDogdGhpcyBpcyBhIHNlY3VyaXR5IHNlbnNpdGl2ZSBvcGVyYXRpb24gdGhhdCByZXF1aXJlcyB0aGUgdXNlciB0byBoYXZlIHJlY2VudGx5IHNpZ25lZFxyXG4gKiBpbi4gSWYgdGhpcyByZXF1aXJlbWVudCBpc24ndCBtZXQsIGFzayB0aGUgdXNlciB0byBhdXRoZW50aWNhdGUgYWdhaW4gYW5kIHRoZW4gY2FsbFxyXG4gKiB7QGxpbmsgcmVhdXRoZW50aWNhdGVXaXRoQ3JlZGVudGlhbH0uXHJcbiAqXHJcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXHJcbiAqIEBwYXJhbSBuZXdQYXNzd29yZCAtIFRoZSBuZXcgcGFzc3dvcmQuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHVwZGF0ZVBhc3N3b3JkKHVzZXIsIG5ld1Bhc3N3b3JkKSB7XHJcbiAgICByZXR1cm4gdXBkYXRlRW1haWxPclBhc3N3b3JkKGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKSwgbnVsbCwgbmV3UGFzc3dvcmQpO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUVtYWlsT3JQYXNzd29yZCh1c2VyLCBlbWFpbCwgcGFzc3dvcmQpIHtcclxuICAgIGNvbnN0IHsgYXV0aCB9ID0gdXNlcjtcclxuICAgIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB1c2VyLmdldElkVG9rZW4oKTtcclxuICAgIGNvbnN0IHJlcXVlc3QgPSB7XHJcbiAgICAgICAgaWRUb2tlbixcclxuICAgICAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZVxyXG4gICAgfTtcclxuICAgIGlmIChlbWFpbCkge1xyXG4gICAgICAgIHJlcXVlc3QuZW1haWwgPSBlbWFpbDtcclxuICAgIH1cclxuICAgIGlmIChwYXNzd29yZCkge1xyXG4gICAgICAgIHJlcXVlc3QucGFzc3dvcmQgPSBwYXNzd29yZDtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodXNlciwgdXBkYXRlRW1haWxQYXNzd29yZChhdXRoLCByZXF1ZXN0KSk7XHJcbiAgICBhd2FpdCB1c2VyLl91cGRhdGVUb2tlbnNJZk5lY2Vzc2FyeShyZXNwb25zZSwgLyogcmVsb2FkICovIHRydWUpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQYXJzZSB0aGUgYEFkZGl0aW9uYWxVc2VySW5mb2AgZnJvbSB0aGUgSUQgdG9rZW4gcmVzcG9uc2UuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBfZnJvbUlkVG9rZW5SZXNwb25zZShpZFRva2VuUmVzcG9uc2UpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBpZiAoIWlkVG9rZW5SZXNwb25zZSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBwcm92aWRlcklkIH0gPSBpZFRva2VuUmVzcG9uc2U7XHJcbiAgICBjb25zdCBwcm9maWxlID0gaWRUb2tlblJlc3BvbnNlLnJhd1VzZXJJbmZvXHJcbiAgICAgICAgPyBKU09OLnBhcnNlKGlkVG9rZW5SZXNwb25zZS5yYXdVc2VySW5mbylcclxuICAgICAgICA6IHt9O1xyXG4gICAgY29uc3QgaXNOZXdVc2VyID0gaWRUb2tlblJlc3BvbnNlLmlzTmV3VXNlciB8fFxyXG4gICAgICAgIGlkVG9rZW5SZXNwb25zZS5raW5kID09PSBcImlkZW50aXR5dG9vbGtpdCNTaWdudXBOZXdVc2VyUmVzcG9uc2VcIiAvKiBJZFRva2VuUmVzcG9uc2VLaW5kLlNpZ251cE5ld1VzZXIgKi87XHJcbiAgICBpZiAoIXByb3ZpZGVySWQgJiYgKGlkVG9rZW5SZXNwb25zZSA9PT0gbnVsbCB8fCBpZFRva2VuUmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlkVG9rZW5SZXNwb25zZS5pZFRva2VuKSkge1xyXG4gICAgICAgIGNvbnN0IHNpZ25JblByb3ZpZGVyID0gKF9iID0gKF9hID0gX3BhcnNlVG9rZW4oaWRUb2tlblJlc3BvbnNlLmlkVG9rZW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlyZWJhc2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlsnc2lnbl9pbl9wcm92aWRlciddO1xyXG4gICAgICAgIGlmIChzaWduSW5Qcm92aWRlcikge1xyXG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJlZFByb3ZpZGVySWQgPSBzaWduSW5Qcm92aWRlciAhPT0gXCJhbm9ueW1vdXNcIiAvKiBQcm92aWRlcklkLkFOT05ZTU9VUyAqLyAmJlxyXG4gICAgICAgICAgICAgICAgc2lnbkluUHJvdmlkZXIgIT09IFwiY3VzdG9tXCIgLyogUHJvdmlkZXJJZC5DVVNUT00gKi9cclxuICAgICAgICAgICAgICAgID8gc2lnbkluUHJvdmlkZXJcclxuICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAgICAgLy8gVXNlcyBnZW5lcmljIGNsYXNzIGluIGFjY29yZGFuY2Ugd2l0aCB0aGUgbGVnYWN5IFNESy5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljQWRkaXRpb25hbFVzZXJJbmZvKGlzTmV3VXNlciwgZmlsdGVyZWRQcm92aWRlcklkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIXByb3ZpZGVySWQpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHN3aXRjaCAocHJvdmlkZXJJZCkge1xyXG4gICAgICAgIGNhc2UgXCJmYWNlYm9vay5jb21cIiAvKiBQcm92aWRlcklkLkZBQ0VCT09LICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhY2Vib29rQWRkaXRpb25hbFVzZXJJbmZvKGlzTmV3VXNlciwgcHJvZmlsZSk7XHJcbiAgICAgICAgY2FzZSBcImdpdGh1Yi5jb21cIiAvKiBQcm92aWRlcklkLkdJVEhVQiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHaXRodWJBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBwcm9maWxlKTtcclxuICAgICAgICBjYXNlIFwiZ29vZ2xlLmNvbVwiIC8qIFByb3ZpZGVySWQuR09PR0xFICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEdvb2dsZUFkZGl0aW9uYWxVc2VySW5mbyhpc05ld1VzZXIsIHByb2ZpbGUpO1xyXG4gICAgICAgIGNhc2UgXCJ0d2l0dGVyLmNvbVwiIC8qIFByb3ZpZGVySWQuVFdJVFRFUiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUd2l0dGVyQWRkaXRpb25hbFVzZXJJbmZvKGlzTmV3VXNlciwgcHJvZmlsZSwgaWRUb2tlblJlc3BvbnNlLnNjcmVlbk5hbWUgfHwgbnVsbCk7XHJcbiAgICAgICAgY2FzZSBcImN1c3RvbVwiIC8qIFByb3ZpZGVySWQuQ1VTVE9NICovOlxyXG4gICAgICAgIGNhc2UgXCJhbm9ueW1vdXNcIiAvKiBQcm92aWRlcklkLkFOT05ZTU9VUyAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljQWRkaXRpb25hbFVzZXJJbmZvKGlzTmV3VXNlciwgbnVsbCk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljQWRkaXRpb25hbFVzZXJJbmZvKGlzTmV3VXNlciwgcHJvdmlkZXJJZCwgcHJvZmlsZSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgR2VuZXJpY0FkZGl0aW9uYWxVc2VySW5mbyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihpc05ld1VzZXIsIHByb3ZpZGVySWQsIHByb2ZpbGUgPSB7fSkge1xyXG4gICAgICAgIHRoaXMuaXNOZXdVc2VyID0gaXNOZXdVc2VyO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJJZCA9IHByb3ZpZGVySWQ7XHJcbiAgICAgICAgdGhpcy5wcm9maWxlID0gcHJvZmlsZTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBGZWRlcmF0ZWRBZGRpdGlvbmFsVXNlckluZm9XaXRoVXNlcm5hbWUgZXh0ZW5kcyBHZW5lcmljQWRkaXRpb25hbFVzZXJJbmZvIHtcclxuICAgIGNvbnN0cnVjdG9yKGlzTmV3VXNlciwgcHJvdmlkZXJJZCwgcHJvZmlsZSwgdXNlcm5hbWUpIHtcclxuICAgICAgICBzdXBlcihpc05ld1VzZXIsIHByb3ZpZGVySWQsIHByb2ZpbGUpO1xyXG4gICAgICAgIHRoaXMudXNlcm5hbWUgPSB1c2VybmFtZTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBGYWNlYm9va0FkZGl0aW9uYWxVc2VySW5mbyBleHRlbmRzIEdlbmVyaWNBZGRpdGlvbmFsVXNlckluZm8ge1xyXG4gICAgY29uc3RydWN0b3IoaXNOZXdVc2VyLCBwcm9maWxlKSB7XHJcbiAgICAgICAgc3VwZXIoaXNOZXdVc2VyLCBcImZhY2Vib29rLmNvbVwiIC8qIFByb3ZpZGVySWQuRkFDRUJPT0sgKi8sIHByb2ZpbGUpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIEdpdGh1YkFkZGl0aW9uYWxVc2VySW5mbyBleHRlbmRzIEZlZGVyYXRlZEFkZGl0aW9uYWxVc2VySW5mb1dpdGhVc2VybmFtZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihpc05ld1VzZXIsIHByb2ZpbGUpIHtcclxuICAgICAgICBzdXBlcihpc05ld1VzZXIsIFwiZ2l0aHViLmNvbVwiIC8qIFByb3ZpZGVySWQuR0lUSFVCICovLCBwcm9maWxlLCB0eXBlb2YgKHByb2ZpbGUgPT09IG51bGwgfHwgcHJvZmlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvZmlsZS5sb2dpbikgPT09ICdzdHJpbmcnID8gcHJvZmlsZSA9PT0gbnVsbCB8fCBwcm9maWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9maWxlLmxvZ2luIDogbnVsbCk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgR29vZ2xlQWRkaXRpb25hbFVzZXJJbmZvIGV4dGVuZHMgR2VuZXJpY0FkZGl0aW9uYWxVc2VySW5mbyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihpc05ld1VzZXIsIHByb2ZpbGUpIHtcclxuICAgICAgICBzdXBlcihpc05ld1VzZXIsIFwiZ29vZ2xlLmNvbVwiIC8qIFByb3ZpZGVySWQuR09PR0xFICovLCBwcm9maWxlKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBUd2l0dGVyQWRkaXRpb25hbFVzZXJJbmZvIGV4dGVuZHMgRmVkZXJhdGVkQWRkaXRpb25hbFVzZXJJbmZvV2l0aFVzZXJuYW1lIHtcclxuICAgIGNvbnN0cnVjdG9yKGlzTmV3VXNlciwgcHJvZmlsZSwgc2NyZWVuTmFtZSkge1xyXG4gICAgICAgIHN1cGVyKGlzTmV3VXNlciwgXCJ0d2l0dGVyLmNvbVwiIC8qIFByb3ZpZGVySWQuVFdJVFRFUiAqLywgcHJvZmlsZSwgc2NyZWVuTmFtZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEV4dHJhY3RzIHByb3ZpZGVyIHNwZWNpZmljIHtAbGluayBBZGRpdGlvbmFsVXNlckluZm99IGZvciB0aGUgZ2l2ZW4gY3JlZGVudGlhbC5cclxuICpcclxuICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QWRkaXRpb25hbFVzZXJJbmZvKHVzZXJDcmVkZW50aWFsKSB7XHJcbiAgICBjb25zdCB7IHVzZXIsIF90b2tlblJlc3BvbnNlIH0gPSB1c2VyQ3JlZGVudGlhbDtcclxuICAgIGlmICh1c2VyLmlzQW5vbnltb3VzICYmICFfdG9rZW5SZXNwb25zZSkge1xyXG4gICAgICAgIC8vIEhhbmRsZSB0aGUgc3BlY2lhbCBjYXNlIHdoZXJlIHNpZ25JbkFub255bW91c2x5KCkgZ2V0cyBjYWxsZWQgdHdpY2UuXHJcbiAgICAgICAgLy8gTm8gbmV0d29yayBjYWxsIGlzIG1hZGUgc28gdGhlcmUncyBub3RoaW5nIHRvIGFjdHVhbGx5IGZpbGwgdGhpcyBpblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVySWQ6IG51bGwsXHJcbiAgICAgICAgICAgIGlzTmV3VXNlcjogZmFsc2UsXHJcbiAgICAgICAgICAgIHByb2ZpbGU6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9mcm9tSWRUb2tlblJlc3BvbnNlKF90b2tlblJlc3BvbnNlKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBOb24tb3B0aW9uYWwgYXV0aCBtZXRob2RzLlxyXG4vKipcclxuICogQ2hhbmdlcyB0aGUgdHlwZSBvZiBwZXJzaXN0ZW5jZSBvbiB0aGUge0BsaW5rIEF1dGh9IGluc3RhbmNlIGZvciB0aGUgY3VycmVudGx5IHNhdmVkXHJcbiAqIGBBdXRoYCBzZXNzaW9uIGFuZCBhcHBsaWVzIHRoaXMgdHlwZSBvZiBwZXJzaXN0ZW5jZSBmb3IgZnV0dXJlIHNpZ24taW4gcmVxdWVzdHMsIGluY2x1ZGluZ1xyXG4gKiBzaWduLWluIHdpdGggcmVkaXJlY3QgcmVxdWVzdHMuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFRoaXMgbWFrZXMgaXQgZWFzeSBmb3IgYSB1c2VyIHNpZ25pbmcgaW4gdG8gc3BlY2lmeSB3aGV0aGVyIHRoZWlyIHNlc3Npb24gc2hvdWxkIGJlXHJcbiAqIHJlbWVtYmVyZWQgb3Igbm90LiBJdCBhbHNvIG1ha2VzIGl0IGVhc2llciB0byBuZXZlciBwZXJzaXN0IHRoZSBgQXV0aGAgc3RhdGUgZm9yIGFwcGxpY2F0aW9uc1xyXG4gKiB0aGF0IGFyZSBzaGFyZWQgYnkgb3RoZXIgdXNlcnMgb3IgaGF2ZSBzZW5zaXRpdmUgZGF0YS5cclxuICpcclxuICogVGhpcyBtZXRob2QgZG9lcyBub3Qgd29yayBpbiBhIE5vZGUuanMgZW52aXJvbm1lbnQgb3Igd2l0aCB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzIGNyZWF0ZWQgd2l0aCBhXHJcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiBzZXRQZXJzaXN0ZW5jZShhdXRoLCBicm93c2VyU2Vzc2lvblBlcnNpc3RlbmNlKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHBlcnNpc3RlbmNlIC0gVGhlIHtAbGluayBQZXJzaXN0ZW5jZX0gdG8gdXNlLlxyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIG9uY2UgdGhlIHBlcnNpc3RlbmNlIGNoYW5nZSBoYXMgY29tcGxldGVkXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHNldFBlcnNpc3RlbmNlKGF1dGgsIHBlcnNpc3RlbmNlKSB7XHJcbiAgICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLnNldFBlcnNpc3RlbmNlKHBlcnNpc3RlbmNlKTtcclxufVxyXG4vKipcclxuICogTG9hZHMgdGhlIHJlQ0FQVENIQSBjb25maWd1cmF0aW9uIGludG8gdGhlIGBBdXRoYCBpbnN0YW5jZS5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhpcyB3aWxsIGxvYWQgdGhlIHJlQ0FQVENIQSBjb25maWcsIHdoaWNoIGluZGljYXRlcyB3aGV0aGVyIHRoZSByZUNBUFRDSEFcclxuICogdmVyaWZpY2F0aW9uIGZsb3cgc2hvdWxkIGJlIHRyaWdnZXJlZCBmb3IgZWFjaCBhdXRoIHByb3ZpZGVyLCBpbnRvIHRoZVxyXG4gKiBjdXJyZW50IEF1dGggc2Vzc2lvbi5cclxuICpcclxuICogSWYgaW5pdGlhbGl6ZVJlY2FwdGNoYUNvbmZpZygpIGlzIG5vdCBpbnZva2VkLCB0aGUgYXV0aCBmbG93IHdpbGwgYWx3YXlzIHN0YXJ0XHJcbiAqIHdpdGhvdXQgcmVDQVBUQ0hBIHZlcmlmaWNhdGlvbi4gSWYgdGhlIHByb3ZpZGVyIGlzIGNvbmZpZ3VyZWQgdG8gcmVxdWlyZSByZUNBUFRDSEFcclxuICogdmVyaWZpY2F0aW9uLCB0aGUgU0RLIHdpbGwgdHJhbnNwYXJlbnRseSBsb2FkIHRoZSByZUNBUFRDSEEgY29uZmlnIGFuZCByZXN0YXJ0IHRoZVxyXG4gKiBhdXRoIGZsb3dzLlxyXG4gKlxyXG4gKiBUaHVzLCBieSBjYWxsaW5nIHRoaXMgb3B0aW9uYWwgbWV0aG9kLCB5b3Ugd2lsbCByZWR1Y2UgdGhlIGxhdGVuY3kgb2YgZnV0dXJlIGF1dGggZmxvd3MuXHJcbiAqIExvYWRpbmcgdGhlIHJlQ0FQVENIQSBjb25maWcgZWFybHkgd2lsbCBhbHNvIGVuaGFuY2UgdGhlIHNpZ25hbCBjb2xsZWN0ZWQgYnkgcmVDQVBUQ0hBLlxyXG4gKlxyXG4gKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB3b3JrIGluIGEgTm9kZS5qcyBlbnZpcm9ubWVudC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiBpbml0aWFsaXplUmVjYXB0Y2hhQ29uZmlnKGF1dGgpO1xyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBpbml0aWFsaXplUmVjYXB0Y2hhQ29uZmlnKGF1dGgpIHtcclxuICAgIHJldHVybiBfaW5pdGlhbGl6ZVJlY2FwdGNoYUNvbmZpZyhhdXRoKTtcclxufVxyXG4vKipcclxuICogVmFsaWRhdGVzIHRoZSBwYXNzd29yZCBhZ2FpbnN0IHRoZSBwYXNzd29yZCBwb2xpY3kgY29uZmlndXJlZCBmb3IgdGhlIHByb2plY3Qgb3IgdGVuYW50LlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBJZiBubyB0ZW5hbnQgSUQgaXMgc2V0IG9uIHRoZSBgQXV0aGAgaW5zdGFuY2UsIHRoZW4gdGhpcyBtZXRob2Qgd2lsbCB1c2UgdGhlIHBhc3N3b3JkXHJcbiAqIHBvbGljeSBjb25maWd1cmVkIGZvciB0aGUgcHJvamVjdC4gT3RoZXJ3aXNlLCB0aGlzIG1ldGhvZCB3aWxsIHVzZSB0aGUgcG9saWN5IGNvbmZpZ3VyZWRcclxuICogZm9yIHRoZSB0ZW5hbnQuIElmIGEgcGFzc3dvcmQgcG9saWN5IGhhcyBub3QgYmVlbiBjb25maWd1cmVkLCB0aGVuIHRoZSBkZWZhdWx0IHBvbGljeVxyXG4gKiBjb25maWd1cmVkIGZvciBhbGwgcHJvamVjdHMgd2lsbCBiZSB1c2VkLlxyXG4gKlxyXG4gKiBJZiBhbiBhdXRoIGZsb3cgZmFpbHMgYmVjYXVzZSBhIHN1Ym1pdHRlZCBwYXNzd29yZCBkb2VzIG5vdCBtZWV0IHRoZSBwYXNzd29yZCBwb2xpY3lcclxuICogcmVxdWlyZW1lbnRzIGFuZCB0aGlzIG1ldGhvZCBoYXMgcHJldmlvdXNseSBiZWVuIGNhbGxlZCwgdGhlbiB0aGlzIG1ldGhvZCB3aWxsIHVzZSB0aGVcclxuICogbW9zdCByZWNlbnQgcG9saWN5IGF2YWlsYWJsZSB3aGVuIGNhbGxlZCBhZ2Fpbi5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiB2YWxpZGF0ZVBhc3N3b3JkKGF1dGgsICdzb21lLXBhc3N3b3JkJyk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aCBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gcGFzc3dvcmQgVGhlIHBhc3N3b3JkIHRvIHZhbGlkYXRlLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZVBhc3N3b3JkKGF1dGgsIHBhc3N3b3JkKSB7XHJcbiAgICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XHJcbiAgICByZXR1cm4gYXV0aEludGVybmFsLnZhbGlkYXRlUGFzc3dvcmQocGFzc3dvcmQpO1xyXG59XHJcbi8qKlxyXG4gKiBBZGRzIGFuIG9ic2VydmVyIGZvciBjaGFuZ2VzIHRvIHRoZSBzaWduZWQtaW4gdXNlcidzIElEIHRva2VuLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGlzIGluY2x1ZGVzIHNpZ24taW4sIHNpZ24tb3V0LCBhbmQgdG9rZW4gcmVmcmVzaCBldmVudHMuXHJcbiAqIFRoaXMgd2lsbCBub3QgYmUgdHJpZ2dlcmVkIGF1dG9tYXRpY2FsbHkgdXBvbiBJRCB0b2tlbiBleHBpcmF0aW9uLiBVc2Uge0BsaW5rIFVzZXIuZ2V0SWRUb2tlbn0gdG8gcmVmcmVzaCB0aGUgSUQgdG9rZW4uXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICogQHBhcmFtIG5leHRPck9ic2VydmVyIC0gY2FsbGJhY2sgdHJpZ2dlcmVkIG9uIGNoYW5nZS5cclxuICogQHBhcmFtIGVycm9yIC0gRGVwcmVjYXRlZC4gVGhpcyBjYWxsYmFjayBpcyBuZXZlciB0cmlnZ2VyZWQuIEVycm9yc1xyXG4gKiBvbiBzaWduaW5nIGluL291dCBjYW4gYmUgY2F1Z2h0IGluIHByb21pc2VzIHJldHVybmVkIGZyb21cclxuICogc2lnbi1pbi9zaWduLW91dCBmdW5jdGlvbnMuXHJcbiAqIEBwYXJhbSBjb21wbGV0ZWQgLSBEZXByZWNhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5ldmVyIHRyaWdnZXJlZC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gb25JZFRva2VuQ2hhbmdlZChhdXRoLCBuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlZCkge1xyXG4gICAgcmV0dXJuIGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKS5vbklkVG9rZW5DaGFuZ2VkKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKTtcclxufVxyXG4vKipcclxuICogQWRkcyBhIGJsb2NraW5nIGNhbGxiYWNrIHRoYXQgcnVucyBiZWZvcmUgYW4gYXV0aCBzdGF0ZSBjaGFuZ2VcclxuICogc2V0cyBhIG5ldyB1c2VyLlxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBjYWxsYmFjayAtIGNhbGxiYWNrIHRyaWdnZXJlZCBiZWZvcmUgbmV3IHVzZXIgdmFsdWUgaXMgc2V0LlxyXG4gKiAgIElmIHRoaXMgdGhyb3dzLCBpdCBibG9ja3MgdGhlIHVzZXIgZnJvbSBiZWluZyBzZXQuXHJcbiAqIEBwYXJhbSBvbkFib3J0IC0gY2FsbGJhY2sgdHJpZ2dlcmVkIGlmIGEgbGF0ZXIgYGJlZm9yZUF1dGhTdGF0ZUNoYW5nZWQoKWBcclxuICogICBjYWxsYmFjayB0aHJvd3MsIGFsbG93aW5nIHlvdSB0byB1bmRvIGFueSBzaWRlIGVmZmVjdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBiZWZvcmVBdXRoU3RhdGVDaGFuZ2VkKGF1dGgsIGNhbGxiYWNrLCBvbkFib3J0KSB7XHJcbiAgICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLmJlZm9yZUF1dGhTdGF0ZUNoYW5nZWQoY2FsbGJhY2ssIG9uQWJvcnQpO1xyXG59XHJcbi8qKlxyXG4gKiBBZGRzIGFuIG9ic2VydmVyIGZvciBjaGFuZ2VzIHRvIHRoZSB1c2VyJ3Mgc2lnbi1pbiBzdGF0ZS5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVG8ga2VlcCB0aGUgb2xkIGJlaGF2aW9yLCBzZWUge0BsaW5rIG9uSWRUb2tlbkNoYW5nZWR9LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBuZXh0T3JPYnNlcnZlciAtIGNhbGxiYWNrIHRyaWdnZXJlZCBvbiBjaGFuZ2UuXHJcbiAqIEBwYXJhbSBlcnJvciAtIERlcHJlY2F0ZWQuIFRoaXMgY2FsbGJhY2sgaXMgbmV2ZXIgdHJpZ2dlcmVkLiBFcnJvcnNcclxuICogb24gc2lnbmluZyBpbi9vdXQgY2FuIGJlIGNhdWdodCBpbiBwcm9taXNlcyByZXR1cm5lZCBmcm9tXHJcbiAqIHNpZ24taW4vc2lnbi1vdXQgZnVuY3Rpb25zLlxyXG4gKiBAcGFyYW0gY29tcGxldGVkIC0gRGVwcmVjYXRlZC4gVGhpcyBjYWxsYmFjayBpcyBuZXZlciB0cmlnZ2VyZWQuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIG9uQXV0aFN0YXRlQ2hhbmdlZChhdXRoLCBuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlZCkge1xyXG4gICAgcmV0dXJuIGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKS5vbkF1dGhTdGF0ZUNoYW5nZWQobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpO1xyXG59XHJcbi8qKlxyXG4gKiBTZXRzIHRoZSBjdXJyZW50IGxhbmd1YWdlIHRvIHRoZSBkZWZhdWx0IGRldmljZS9icm93c2VyIHByZWZlcmVuY2UuXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gdXNlRGV2aWNlTGFuZ3VhZ2UoYXV0aCkge1xyXG4gICAgZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLnVzZURldmljZUxhbmd1YWdlKCk7XHJcbn1cclxuLyoqXHJcbiAqIEFzeW5jaHJvbm91c2x5IHNldHMgdGhlIHByb3ZpZGVkIHVzZXIgYXMge0BsaW5rIEF1dGguY3VycmVudFVzZXJ9IG9uIHRoZVxyXG4gKiB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIEEgbmV3IGluc3RhbmNlIGNvcHkgb2YgdGhlIHVzZXIgcHJvdmlkZWQgd2lsbCBiZSBtYWRlIGFuZCBzZXQgYXMgY3VycmVudFVzZXIuXHJcbiAqXHJcbiAqIFRoaXMgd2lsbCB0cmlnZ2VyIHtAbGluayBvbkF1dGhTdGF0ZUNoYW5nZWR9IGFuZCB7QGxpbmsgb25JZFRva2VuQ2hhbmdlZH0gbGlzdGVuZXJzXHJcbiAqIGxpa2Ugb3RoZXIgc2lnbiBpbiBtZXRob2RzLlxyXG4gKlxyXG4gKiBUaGUgb3BlcmF0aW9uIGZhaWxzIHdpdGggYW4gZXJyb3IgaWYgdGhlIHVzZXIgdG8gYmUgdXBkYXRlZCBiZWxvbmdzIHRvIGEgZGlmZmVyZW50IEZpcmViYXNlXHJcbiAqIHByb2plY3QuXHJcbiAqXHJcbiAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkge0BsaW5rIEF1dGh9IGluc3RhbmNlcyBjcmVhdGVkIHdpdGggYVxyXG4gKiB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZVNlcnZlckFwcH0uXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHVzZXIgLSBUaGUgbmV3IHtAbGluayBVc2VyfS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlQ3VycmVudFVzZXIoYXV0aCwgdXNlcikge1xyXG4gICAgcmV0dXJuIGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKS51cGRhdGVDdXJyZW50VXNlcih1c2VyKTtcclxufVxyXG4vKipcclxuICogU2lnbnMgb3V0IHRoZSBjdXJyZW50IHVzZXIuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkge0BsaW5rIEF1dGh9IGluc3RhbmNlcyBjcmVhdGVkIHdpdGggYVxyXG4gKiB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZVNlcnZlckFwcH0uXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gc2lnbk91dChhdXRoKSB7XHJcbiAgICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLnNpZ25PdXQoKTtcclxufVxyXG4vKipcclxuICogUmV2b2tlcyB0aGUgZ2l2ZW4gYWNjZXNzIHRva2VuLiBDdXJyZW50bHkgb25seSBzdXBwb3J0cyBBcHBsZSBPQXV0aCBhY2Nlc3MgdG9rZW5zLlxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSB0b2tlbiAtIFRoZSBBcHBsZSBPQXV0aCBhY2Nlc3MgdG9rZW4uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHJldm9rZUFjY2Vzc1Rva2VuKGF1dGgsIHRva2VuKSB7XHJcbiAgICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XHJcbiAgICByZXR1cm4gYXV0aEludGVybmFsLnJldm9rZUFjY2Vzc1Rva2VuKHRva2VuKTtcclxufVxyXG4vKipcclxuICogRGVsZXRlcyBhbmQgc2lnbnMgb3V0IHRoZSB1c2VyLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBJbXBvcnRhbnQ6IHRoaXMgaXMgYSBzZWN1cml0eS1zZW5zaXRpdmUgb3BlcmF0aW9uIHRoYXQgcmVxdWlyZXMgdGhlIHVzZXIgdG8gaGF2ZSByZWNlbnRseVxyXG4gKiBzaWduZWQgaW4uIElmIHRoaXMgcmVxdWlyZW1lbnQgaXNuJ3QgbWV0LCBhc2sgdGhlIHVzZXIgdG8gYXV0aGVudGljYXRlIGFnYWluIGFuZCB0aGVuIGNhbGxcclxuICoge0BsaW5rIHJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWx9LlxyXG4gKlxyXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBkZWxldGVVc2VyKHVzZXIpIHtcclxuICAgIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UodXNlcikuZGVsZXRlKCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgTXVsdGlGYWN0b3JTZXNzaW9uSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBjcmVkZW50aWFsLCB1c2VyKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLmNyZWRlbnRpYWwgPSBjcmVkZW50aWFsO1xyXG4gICAgICAgIHRoaXMudXNlciA9IHVzZXI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2Zyb21JZHRva2VuKGlkVG9rZW4sIHVzZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE11bHRpRmFjdG9yU2Vzc2lvbkltcGwoXCJlbnJvbGxcIiAvKiBNdWx0aUZhY3RvclNlc3Npb25UeXBlLkVOUk9MTCAqLywgaWRUb2tlbiwgdXNlcik7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2Zyb21NZmFQZW5kaW5nQ3JlZGVudGlhbChtZmFQZW5kaW5nQ3JlZGVudGlhbCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTXVsdGlGYWN0b3JTZXNzaW9uSW1wbChcInNpZ25pblwiIC8qIE11bHRpRmFjdG9yU2Vzc2lvblR5cGUuU0lHTl9JTiAqLywgbWZhUGVuZGluZ0NyZWRlbnRpYWwpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMudHlwZSA9PT0gXCJlbnJvbGxcIiAvKiBNdWx0aUZhY3RvclNlc3Npb25UeXBlLkVOUk9MTCAqL1xyXG4gICAgICAgICAgICA/ICdpZFRva2VuJ1xyXG4gICAgICAgICAgICA6ICdwZW5kaW5nQ3JlZGVudGlhbCc7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbXVsdGlGYWN0b3JTZXNzaW9uOiB7XHJcbiAgICAgICAgICAgICAgICBba2V5XTogdGhpcy5jcmVkZW50aWFsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21KU09OKG9iaikge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iai5tdWx0aUZhY3RvclNlc3Npb24pIHtcclxuICAgICAgICAgICAgaWYgKChfYSA9IG9iai5tdWx0aUZhY3RvclNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wZW5kaW5nQ3JlZGVudGlhbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE11bHRpRmFjdG9yU2Vzc2lvbkltcGwuX2Zyb21NZmFQZW5kaW5nQ3JlZGVudGlhbChvYmoubXVsdGlGYWN0b3JTZXNzaW9uLnBlbmRpbmdDcmVkZW50aWFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgoX2IgPSBvYmoubXVsdGlGYWN0b3JTZXNzaW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaWRUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE11bHRpRmFjdG9yU2Vzc2lvbkltcGwuX2Zyb21JZHRva2VuKG9iai5tdWx0aUZhY3RvclNlc3Npb24uaWRUb2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgTXVsdGlGYWN0b3JSZXNvbHZlckltcGwge1xyXG4gICAgY29uc3RydWN0b3Ioc2Vzc2lvbiwgaGludHMsIHNpZ25JblJlc29sdmVyKSB7XHJcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcclxuICAgICAgICB0aGlzLmhpbnRzID0gaGludHM7XHJcbiAgICAgICAgdGhpcy5zaWduSW5SZXNvbHZlciA9IHNpZ25JblJlc29sdmVyO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgc3RhdGljIF9mcm9tRXJyb3IoYXV0aEV4dGVybiwgZXJyb3IpIHtcclxuICAgICAgICBjb25zdCBhdXRoID0gX2Nhc3RBdXRoKGF1dGhFeHRlcm4pO1xyXG4gICAgICAgIGNvbnN0IHNlcnZlclJlc3BvbnNlID0gZXJyb3IuY3VzdG9tRGF0YS5fc2VydmVyUmVzcG9uc2U7XHJcbiAgICAgICAgY29uc3QgaGludHMgPSAoc2VydmVyUmVzcG9uc2UubWZhSW5mbyB8fCBbXSkubWFwKGVucm9sbG1lbnQgPT4gTXVsdGlGYWN0b3JJbmZvSW1wbC5fZnJvbVNlcnZlclJlc3BvbnNlKGF1dGgsIGVucm9sbG1lbnQpKTtcclxuICAgICAgICBfYXNzZXJ0KHNlcnZlclJlc3BvbnNlLm1mYVBlbmRpbmdDcmVkZW50aWFsLCBhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IE11bHRpRmFjdG9yU2Vzc2lvbkltcGwuX2Zyb21NZmFQZW5kaW5nQ3JlZGVudGlhbChzZXJ2ZXJSZXNwb25zZS5tZmFQZW5kaW5nQ3JlZGVudGlhbCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNdWx0aUZhY3RvclJlc29sdmVySW1wbChzZXNzaW9uLCBoaW50cywgYXN5bmMgKGFzc2VydGlvbikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtZmFSZXNwb25zZSA9IGF3YWl0IGFzc2VydGlvbi5fcHJvY2VzcyhhdXRoLCBzZXNzaW9uKTtcclxuICAgICAgICAgICAgLy8gQ2xlYXIgb3V0IHRoZSB1bm5lZWRlZCBmaWVsZHMgZnJvbSB0aGUgb2xkIGxvZ2luIHJlc3BvbnNlXHJcbiAgICAgICAgICAgIGRlbGV0ZSBzZXJ2ZXJSZXNwb25zZS5tZmFJbmZvO1xyXG4gICAgICAgICAgICBkZWxldGUgc2VydmVyUmVzcG9uc2UubWZhUGVuZGluZ0NyZWRlbnRpYWw7XHJcbiAgICAgICAgICAgIC8vIFVzZSBpbiB0aGUgbmV3IHRva2VuICYgcmVmcmVzaCB0b2tlbiBpbiB0aGUgb2xkIHJlc3BvbnNlXHJcbiAgICAgICAgICAgIGNvbnN0IGlkVG9rZW5SZXNwb25zZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VydmVyUmVzcG9uc2UpLCB7IGlkVG9rZW46IG1mYVJlc3BvbnNlLmlkVG9rZW4sIHJlZnJlc2hUb2tlbjogbWZhUmVzcG9uc2UucmVmcmVzaFRva2VuIH0pO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiB3ZSBzaG91bGQgY29sbGFwc2UgdGhpcyBzd2l0Y2ggc3RhdGVtZW50IGludG8gVXNlckNyZWRlbnRpYWxJbXBsLl9mb3JPcGVyYXRpb24gYW5kIGhhdmUgaXQgc3VwcG9ydCB0aGUgU0lHTl9JTiBjYXNlXHJcbiAgICAgICAgICAgIHN3aXRjaCAoZXJyb3Iub3BlcmF0aW9uVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInNpZ25JblwiIC8qIE9wZXJhdGlvblR5cGUuU0lHTl9JTiAqLzpcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IFVzZXJDcmVkZW50aWFsSW1wbC5fZnJvbUlkVG9rZW5SZXNwb25zZShhdXRoLCBlcnJvci5vcGVyYXRpb25UeXBlLCBpZFRva2VuUmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGF1dGguX3VwZGF0ZUN1cnJlbnRVc2VyKHVzZXJDcmVkZW50aWFsLnVzZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1c2VyQ3JlZGVudGlhbDtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZWF1dGhlbnRpY2F0ZVwiIC8qIE9wZXJhdGlvblR5cGUuUkVBVVRIRU5USUNBVEUgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgX2Fzc2VydChlcnJvci51c2VyLCBhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFVzZXJDcmVkZW50aWFsSW1wbC5fZm9yT3BlcmF0aW9uKGVycm9yLnVzZXIsIGVycm9yLm9wZXJhdGlvblR5cGUsIGlkVG9rZW5SZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIF9mYWlsKGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcmVzb2x2ZVNpZ25Jbihhc3NlcnRpb25FeHRlcm4pIHtcclxuICAgICAgICBjb25zdCBhc3NlcnRpb24gPSBhc3NlcnRpb25FeHRlcm47XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbkluUmVzb2x2ZXIoYXNzZXJ0aW9uKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUHJvdmlkZXMgYSB7QGxpbmsgTXVsdGlGYWN0b3JSZXNvbHZlcn0gc3VpdGFibGUgZm9yIGNvbXBsZXRpb24gb2YgYVxyXG4gKiBtdWx0aS1mYWN0b3IgZmxvdy5cclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUge0BsaW5rIE11bHRpRmFjdG9yRXJyb3J9IHJhaXNlZCBkdXJpbmcgYSBzaWduLWluLCBvclxyXG4gKiByZWF1dGhlbnRpY2F0aW9uIG9wZXJhdGlvbi5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TXVsdGlGYWN0b3JSZXNvbHZlcihhdXRoLCBlcnJvcikge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgYXV0aE1vZHVsYXIgPSBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCk7XHJcbiAgICBjb25zdCBlcnJvckludGVybmFsID0gZXJyb3I7XHJcbiAgICBfYXNzZXJ0KGVycm9yLmN1c3RvbURhdGEub3BlcmF0aW9uVHlwZSwgYXV0aE1vZHVsYXIsIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcclxuICAgIF9hc3NlcnQoKF9hID0gZXJyb3JJbnRlcm5hbC5jdXN0b21EYXRhLl9zZXJ2ZXJSZXNwb25zZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1mYVBlbmRpbmdDcmVkZW50aWFsLCBhdXRoTW9kdWxhciwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xyXG4gICAgcmV0dXJuIE11bHRpRmFjdG9yUmVzb2x2ZXJJbXBsLl9mcm9tRXJyb3IoYXV0aE1vZHVsYXIsIGVycm9ySW50ZXJuYWwpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIHN0YXJ0RW5yb2xsVG90cE1mYShhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjIvYWNjb3VudHMvbWZhRW5yb2xsbWVudDpzdGFydFwiIC8qIEVuZHBvaW50LlNUQVJUX01GQV9FTlJPTExNRU5UICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xyXG59XHJcbmZ1bmN0aW9uIGZpbmFsaXplRW5yb2xsVG90cE1mYShhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjIvYWNjb3VudHMvbWZhRW5yb2xsbWVudDpmaW5hbGl6ZVwiIC8qIEVuZHBvaW50LkZJTkFMSVpFX01GQV9FTlJPTExNRU5UICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xyXG59XHJcbmZ1bmN0aW9uIHdpdGhkcmF3TWZhKGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92Mi9hY2NvdW50cy9tZmFFbnJvbGxtZW50OndpdGhkcmF3XCIgLyogRW5kcG9pbnQuV0lUSERSQVdfTUZBICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xyXG59XG5cbmNsYXNzIE11bHRpRmFjdG9yVXNlckltcGwge1xyXG4gICAgY29uc3RydWN0b3IodXNlcikge1xyXG4gICAgICAgIHRoaXMudXNlciA9IHVzZXI7XHJcbiAgICAgICAgdGhpcy5lbnJvbGxlZEZhY3RvcnMgPSBbXTtcclxuICAgICAgICB1c2VyLl9vblJlbG9hZCh1c2VySW5mbyA9PiB7XHJcbiAgICAgICAgICAgIGlmICh1c2VySW5mby5tZmFJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVucm9sbGVkRmFjdG9ycyA9IHVzZXJJbmZvLm1mYUluZm8ubWFwKGVucm9sbG1lbnQgPT4gTXVsdGlGYWN0b3JJbmZvSW1wbC5fZnJvbVNlcnZlclJlc3BvbnNlKHVzZXIuYXV0aCwgZW5yb2xsbWVudCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2Zyb21Vc2VyKHVzZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE11bHRpRmFjdG9yVXNlckltcGwodXNlcik7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRTZXNzaW9uKCkge1xyXG4gICAgICAgIHJldHVybiBNdWx0aUZhY3RvclNlc3Npb25JbXBsLl9mcm9tSWR0b2tlbihhd2FpdCB0aGlzLnVzZXIuZ2V0SWRUb2tlbigpLCB0aGlzLnVzZXIpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZW5yb2xsKGFzc2VydGlvbkV4dGVybiwgZGlzcGxheU5hbWUpIHtcclxuICAgICAgICBjb25zdCBhc3NlcnRpb24gPSBhc3NlcnRpb25FeHRlcm47XHJcbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IChhd2FpdCB0aGlzLmdldFNlc3Npb24oKSk7XHJcbiAgICAgICAgY29uc3QgZmluYWxpemVNZmFSZXNwb25zZSA9IGF3YWl0IF9sb2dvdXRJZkludmFsaWRhdGVkKHRoaXMudXNlciwgYXNzZXJ0aW9uLl9wcm9jZXNzKHRoaXMudXNlci5hdXRoLCBzZXNzaW9uLCBkaXNwbGF5TmFtZSkpO1xyXG4gICAgICAgIC8vIE5ldyB0b2tlbnMgd2lsbCBiZSBpc3N1ZWQgYWZ0ZXIgZW5yb2xsbWVudCBvZiB0aGUgbmV3IHNlY29uZCBmYWN0b3JzLlxyXG4gICAgICAgIC8vIFRoZXkgbmVlZCB0byBiZSB1cGRhdGVkIG9uIHRoZSB1c2VyLlxyXG4gICAgICAgIGF3YWl0IHRoaXMudXNlci5fdXBkYXRlVG9rZW5zSWZOZWNlc3NhcnkoZmluYWxpemVNZmFSZXNwb25zZSk7XHJcbiAgICAgICAgLy8gVGhlIHVzZXIgbmVlZHMgdG8gYmUgcmVsb2FkZWQgdG8gZ2V0IHRoZSBuZXcgbXVsdGktZmFjdG9yIGluZm9ybWF0aW9uXHJcbiAgICAgICAgLy8gZnJvbSBzZXJ2ZXIuIFVTRVJfUkVMT0FERUQgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQgYW5kIGBlbnJvbGxlZEZhY3RvcnNgXHJcbiAgICAgICAgLy8gd2lsbCBiZSB1cGRhdGVkLlxyXG4gICAgICAgIHJldHVybiB0aGlzLnVzZXIucmVsb2FkKCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyB1bmVucm9sbChpbmZvT3JVaWQpIHtcclxuICAgICAgICBjb25zdCBtZmFFbnJvbGxtZW50SWQgPSB0eXBlb2YgaW5mb09yVWlkID09PSAnc3RyaW5nJyA/IGluZm9PclVpZCA6IGluZm9PclVpZC51aWQ7XHJcbiAgICAgICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHRoaXMudXNlci5nZXRJZFRva2VuKCk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgaWRUb2tlblJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodGhpcy51c2VyLCB3aXRoZHJhd01mYSh0aGlzLnVzZXIuYXV0aCwge1xyXG4gICAgICAgICAgICAgICAgaWRUb2tlbixcclxuICAgICAgICAgICAgICAgIG1mYUVucm9sbG1lbnRJZFxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2Vjb25kIGZhY3RvciBmcm9tIHRoZSB1c2VyJ3MgbGlzdC5cclxuICAgICAgICAgICAgdGhpcy5lbnJvbGxlZEZhY3RvcnMgPSB0aGlzLmVucm9sbGVkRmFjdG9ycy5maWx0ZXIoKHsgdWlkIH0pID0+IHVpZCAhPT0gbWZhRW5yb2xsbWVudElkKTtcclxuICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGJhY2tlbmQgZGVjaWRlZCB0byByZXZva2UgdGhlIHVzZXIncyBzZXNzaW9uLFxyXG4gICAgICAgICAgICAvLyB0aGUgdG9rZW5SZXNwb25zZSBtYXkgYmUgZW1wdHkuIElmIHRoZSB0b2tlbnMgd2VyZSBub3QgdXBkYXRlZCAoYW5kIHRoZXlcclxuICAgICAgICAgICAgLy8gYXJlIG5vdyBpbnZhbGlkKSwgcmVsb2FkaW5nIHRoZSB1c2VyIHdpbGwgZGlzY292ZXIgdGhpcyBhbmQgaW52YWxpZGF0ZVxyXG4gICAgICAgICAgICAvLyB0aGUgdXNlcidzIHN0YXRlIGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnVzZXIuX3VwZGF0ZVRva2Vuc0lmTmVjZXNzYXJ5KGlkVG9rZW5SZXNwb25zZSk7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudXNlci5yZWxvYWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY29uc3QgbXVsdGlGYWN0b3JVc2VyQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xyXG4vKipcclxuICogVGhlIHtAbGluayBNdWx0aUZhY3RvclVzZXJ9IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHVzZXIuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFRoaXMgaXMgdXNlZCB0byBhY2Nlc3MgYWxsIG11bHRpLWZhY3RvciBwcm9wZXJ0aWVzIGFuZCBvcGVyYXRpb25zIHJlbGF0ZWQgdG8gdGhlIHVzZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIG11bHRpRmFjdG9yKHVzZXIpIHtcclxuICAgIGNvbnN0IHVzZXJNb2R1bGFyID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xyXG4gICAgaWYgKCFtdWx0aUZhY3RvclVzZXJDYWNoZS5oYXModXNlck1vZHVsYXIpKSB7XHJcbiAgICAgICAgbXVsdGlGYWN0b3JVc2VyQ2FjaGUuc2V0KHVzZXJNb2R1bGFyLCBNdWx0aUZhY3RvclVzZXJJbXBsLl9mcm9tVXNlcih1c2VyTW9kdWxhcikpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG11bHRpRmFjdG9yVXNlckNhY2hlLmdldCh1c2VyTW9kdWxhcik7XHJcbn1cblxudmFyIG5hbWUgPSBcIkBmaXJlYmFzZS9hdXRoXCI7XG52YXIgdmVyc2lvbiA9IFwiMS43LjlcIjtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgQXV0aEludGVyb3Age1xyXG4gICAgY29uc3RydWN0b3IoYXV0aCkge1xyXG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XHJcbiAgICAgICAgdGhpcy5pbnRlcm5hbExpc3RlbmVycyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIGdldFVpZCgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdGhpcy5hc3NlcnRBdXRoQ29uZmlndXJlZCgpO1xyXG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5hdXRoLmN1cnJlbnRVc2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudWlkKSB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKSB7XHJcbiAgICAgICAgdGhpcy5hc3NlcnRBdXRoQ29uZmlndXJlZCgpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMuYXV0aC5faW5pdGlhbGl6YXRpb25Qcm9taXNlO1xyXG4gICAgICAgIGlmICghdGhpcy5hdXRoLmN1cnJlbnRVc2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IGF3YWl0IHRoaXMuYXV0aC5jdXJyZW50VXNlci5nZXRJZFRva2VuKGZvcmNlUmVmcmVzaCk7XHJcbiAgICAgICAgcmV0dXJuIHsgYWNjZXNzVG9rZW4gfTtcclxuICAgIH1cclxuICAgIGFkZEF1dGhUb2tlbkxpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5hc3NlcnRBdXRoQ29uZmlndXJlZCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmludGVybmFsTGlzdGVuZXJzLmhhcyhsaXN0ZW5lcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMuYXV0aC5vbklkVG9rZW5DaGFuZ2VkKHVzZXIgPT4ge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcigodXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLnN0c1Rva2VuTWFuYWdlci5hY2Nlc3NUb2tlbikgfHwgbnVsbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5pbnRlcm5hbExpc3RlbmVycy5zZXQobGlzdGVuZXIsIHVuc3Vic2NyaWJlKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVByb2FjdGl2ZVJlZnJlc2goKTtcclxuICAgIH1cclxuICAgIHJlbW92ZUF1dGhUb2tlbkxpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5hc3NlcnRBdXRoQ29uZmlndXJlZCgpO1xyXG4gICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdGhpcy5pbnRlcm5hbExpc3RlbmVycy5nZXQobGlzdGVuZXIpO1xyXG4gICAgICAgIGlmICghdW5zdWJzY3JpYmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmludGVybmFsTGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XHJcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVByb2FjdGl2ZVJlZnJlc2goKTtcclxuICAgIH1cclxuICAgIGFzc2VydEF1dGhDb25maWd1cmVkKCkge1xyXG4gICAgICAgIF9hc3NlcnQodGhpcy5hdXRoLl9pbml0aWFsaXphdGlvblByb21pc2UsIFwiZGVwZW5kZW50LXNkay1pbml0aWFsaXplZC1iZWZvcmUtYXV0aFwiIC8qIEF1dGhFcnJvckNvZGUuREVQRU5ERU5UX1NES19JTklUX0JFRk9SRV9BVVRIICovKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVByb2FjdGl2ZVJlZnJlc2goKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJuYWxMaXN0ZW5lcnMuc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5hdXRoLl9zdGFydFByb2FjdGl2ZVJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXV0aC5fc3RvcFByb2FjdGl2ZVJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VmVyc2lvbkZvclBsYXRmb3JtKGNsaWVudFBsYXRmb3JtKSB7XHJcbiAgICBzd2l0Y2ggKGNsaWVudFBsYXRmb3JtKSB7XHJcbiAgICAgICAgY2FzZSBcIk5vZGVcIiAvKiBDbGllbnRQbGF0Zm9ybS5OT0RFICovOlxyXG4gICAgICAgICAgICByZXR1cm4gJ25vZGUnO1xyXG4gICAgICAgIGNhc2UgXCJSZWFjdE5hdGl2ZVwiIC8qIENsaWVudFBsYXRmb3JtLlJFQUNUX05BVElWRSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuICdybic7XHJcbiAgICAgICAgY2FzZSBcIldvcmtlclwiIC8qIENsaWVudFBsYXRmb3JtLldPUktFUiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuICd3ZWJ3b3JrZXInO1xyXG4gICAgICAgIGNhc2UgXCJDb3Jkb3ZhXCIgLyogQ2xpZW50UGxhdGZvcm0uQ09SRE9WQSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuICdjb3Jkb3ZhJztcclxuICAgICAgICBjYXNlIFwiV2ViRXh0ZW5zaW9uXCIgLyogQ2xpZW50UGxhdGZvcm0uV0VCX0VYVEVOU0lPTiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuICd3ZWItZXh0ZW5zaW9uJztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuZnVuY3Rpb24gcmVnaXN0ZXJBdXRoKGNsaWVudFBsYXRmb3JtKSB7XHJcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudChcImF1dGhcIiAvKiBfQ29tcG9uZW50TmFtZS5BVVRIICovLCAoY29udGFpbmVyLCB7IG9wdGlvbnM6IGRlcHMgfSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGFwcCA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XHJcbiAgICAgICAgY29uc3QgaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdoZWFydGJlYXQnKTtcclxuICAgICAgICBjb25zdCBhcHBDaGVja1NlcnZpY2VQcm92aWRlciA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwLWNoZWNrLWludGVybmFsJyk7XHJcbiAgICAgICAgY29uc3QgeyBhcGlLZXksIGF1dGhEb21haW4gfSA9IGFwcC5vcHRpb25zO1xyXG4gICAgICAgIF9hc3NlcnQoYXBpS2V5ICYmICFhcGlLZXkuaW5jbHVkZXMoJzonKSwgXCJpbnZhbGlkLWFwaS1rZXlcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQVBJX0tFWSAqLywgeyBhcHBOYW1lOiBhcHAubmFtZSB9KTtcclxuICAgICAgICBjb25zdCBjb25maWcgPSB7XHJcbiAgICAgICAgICAgIGFwaUtleSxcclxuICAgICAgICAgICAgYXV0aERvbWFpbixcclxuICAgICAgICAgICAgY2xpZW50UGxhdGZvcm0sXHJcbiAgICAgICAgICAgIGFwaUhvc3Q6IFwiaWRlbnRpdHl0b29sa2l0Lmdvb2dsZWFwaXMuY29tXCIgLyogRGVmYXVsdENvbmZpZy5BUElfSE9TVCAqLyxcclxuICAgICAgICAgICAgdG9rZW5BcGlIb3N0OiBcInNlY3VyZXRva2VuLmdvb2dsZWFwaXMuY29tXCIgLyogRGVmYXVsdENvbmZpZy5UT0tFTl9BUElfSE9TVCAqLyxcclxuICAgICAgICAgICAgYXBpU2NoZW1lOiBcImh0dHBzXCIgLyogRGVmYXVsdENvbmZpZy5BUElfU0NIRU1FICovLFxyXG4gICAgICAgICAgICBzZGtDbGllbnRWZXJzaW9uOiBfZ2V0Q2xpZW50VmVyc2lvbihjbGllbnRQbGF0Zm9ybSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGF1dGhJbnN0YW5jZSA9IG5ldyBBdXRoSW1wbChhcHAsIGhlYXJ0YmVhdFNlcnZpY2VQcm92aWRlciwgYXBwQ2hlY2tTZXJ2aWNlUHJvdmlkZXIsIGNvbmZpZyk7XHJcbiAgICAgICAgX2luaXRpYWxpemVBdXRoSW5zdGFuY2UoYXV0aEluc3RhbmNlLCBkZXBzKTtcclxuICAgICAgICByZXR1cm4gYXV0aEluc3RhbmNlO1xyXG4gICAgfSwgXCJQVUJMSUNcIiAvKiBDb21wb25lbnRUeXBlLlBVQkxJQyAqLylcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBdXRoIGNhbiBvbmx5IGJlIGluaXRpYWxpemVkIGJ5IGV4cGxpY2l0bHkgY2FsbGluZyBnZXRBdXRoKCkgb3IgaW5pdGlhbGl6ZUF1dGgoKVxyXG4gICAgICAgICAqIEZvciB3aHkgd2UgZG8gdGhpcywgU2VlIGdvL2ZpcmViYXNlLW5leHQtYXV0aC1pbml0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLnNldEluc3RhbnRpYXRpb25Nb2RlKFwiRVhQTElDSVRcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5FWFBMSUNJVCAqLylcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCZWNhdXNlIGFsbCBmaXJlYmFzZSBwcm9kdWN0cyB0aGF0IGRlcGVuZCBvbiBhdXRoIGRlcGVuZCBvbiBhdXRoLWludGVybmFsIGRpcmVjdGx5LFxyXG4gICAgICAgICAqIHdlIG5lZWQgdG8gaW5pdGlhbGl6ZSBhdXRoLWludGVybmFsIGFmdGVyIGF1dGggaXMgaW5pdGlhbGl6ZWQgdG8gbWFrZSBpdCBhdmFpbGFibGUgdG8gb3RoZXIgZmlyZWJhc2UgcHJvZHVjdHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLnNldEluc3RhbmNlQ3JlYXRlZENhbGxiYWNrKChjb250YWluZXIsIF9pbnN0YW5jZUlkZW50aWZpZXIsIF9pbnN0YW5jZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGF1dGhJbnRlcm5hbFByb3ZpZGVyID0gY29udGFpbmVyLmdldFByb3ZpZGVyKFwiYXV0aC1pbnRlcm5hbFwiIC8qIF9Db21wb25lbnROYW1lLkFVVEhfSU5URVJOQUwgKi8pO1xyXG4gICAgICAgIGF1dGhJbnRlcm5hbFByb3ZpZGVyLmluaXRpYWxpemUoKTtcclxuICAgIH0pKTtcclxuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KFwiYXV0aC1pbnRlcm5hbFwiIC8qIF9Db21wb25lbnROYW1lLkFVVEhfSU5URVJOQUwgKi8sIGNvbnRhaW5lciA9PiB7XHJcbiAgICAgICAgY29uc3QgYXV0aCA9IF9jYXN0QXV0aChjb250YWluZXIuZ2V0UHJvdmlkZXIoXCJhdXRoXCIgLyogX0NvbXBvbmVudE5hbWUuQVVUSCAqLykuZ2V0SW1tZWRpYXRlKCkpO1xyXG4gICAgICAgIHJldHVybiAoYXV0aCA9PiBuZXcgQXV0aEludGVyb3AoYXV0aCkpKGF1dGgpO1xyXG4gICAgfSwgXCJQUklWQVRFXCIgLyogQ29tcG9uZW50VHlwZS5QUklWQVRFICovKS5zZXRJbnN0YW50aWF0aW9uTW9kZShcIkVYUExJQ0lUXCIgLyogSW5zdGFudGlhdGlvbk1vZGUuRVhQTElDSVQgKi8pKTtcclxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uLCBnZXRWZXJzaW9uRm9yUGxhdGZvcm0oY2xpZW50UGxhdGZvcm0pKTtcclxuICAgIC8vIEJVSUxEX1RBUkdFVCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHZhbHVlcyBsaWtlIGVzbTUsIGVzbTIwMTcsIGNqczUsIGV0YyBkdXJpbmcgdGhlIGNvbXBpbGF0aW9uXHJcbiAgICByZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbiwgJ2VzbTIwMTcnKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBJbml0aWFsaXplIHRoZSBmZXRjaCBwb2x5ZmlsbCwgdGhlIHR5cGVzIGFyZSBzbGlnaHRseSBvZmYgc28ganVzdCBjYXN0IGFuZCBob3BlIGZvciB0aGUgYmVzdFxyXG5GZXRjaFByb3ZpZGVyLmluaXRpYWxpemUoZmV0Y2gkMSwgSGVhZGVycyQxLCBSZXNwb25zZSQxKTtcclxuLy8gRmlyc3QsIHdlIHNldCB1cCB0aGUgdmFyaW91cyBwbGF0Zm9ybS1zcGVjaWZpYyBmZWF0dXJlcyBmb3IgTm9kZSAocmVnaXN0ZXJcclxuLy8gdGhlIHZlcnNpb24gYW5kIGRlY2xhcmUgdGhlIE5vZGUgZ2V0QXV0aCBmdW5jdGlvbilcclxuZnVuY3Rpb24gZ2V0QXV0aChhcHAgPSBnZXRBcHAoKSkge1xyXG4gICAgY29uc3QgcHJvdmlkZXIgPSBfZ2V0UHJvdmlkZXIoYXBwLCAnYXV0aCcpO1xyXG4gICAgaWYgKHByb3ZpZGVyLmlzSW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgIHJldHVybiBwcm92aWRlci5nZXRJbW1lZGlhdGUoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGF1dGggPSBpbml0aWFsaXplQXV0aChhcHApO1xyXG4gICAgY29uc3QgYXV0aEVtdWxhdG9ySG9zdCA9IGdldERlZmF1bHRFbXVsYXRvckhvc3QoJ2F1dGgnKTtcclxuICAgIGlmIChhdXRoRW11bGF0b3JIb3N0KSB7XHJcbiAgICAgICAgY29ubmVjdEF1dGhFbXVsYXRvcihhdXRoLCBgaHR0cDovLyR7YXV0aEVtdWxhdG9ySG9zdH1gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhdXRoO1xyXG59XHJcbnJlZ2lzdGVyQXV0aChcIk5vZGVcIiAvKiBDbGllbnRQbGF0Zm9ybS5OT0RFICovKTtcclxuLy8gVGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGNvbnRhaW5zIG5vLW9wcyBhbmQgZXJyb3JzIGZvciBicm93c2VyLXNwZWNpZmljXHJcbi8vIG1ldGhvZHMuIFdlIGtlZXAgdGhlIGJyb3dzZXIgYW5kIE5vZGUgZW50cnkgcG9pbnRzIHRoZSBzYW1lLCBidXQgZmVhdHVyZXNcclxuLy8gdGhhdCBvbmx5IHdvcmsgaW4gYnJvd3NlcnMgYXJlIHNldCB0byBlaXRoZXIgZG8gbm90aGluZyAoc2V0UGVyc2lzdGVuY2UpIG9yXHJcbi8vIHRvIHJlamVjdCB3aXRoIGFuIGF1dGgvb3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudCBlcnJvci5cclxuLy8gVGhlIGJlbG93IGV4cG9ydHMgYXJlIHB1bGxlZCBpbnRvIHRoZSBtYWluIGVudHJ5IHBvaW50IGJ5IGEgcm9sbHVwIGFsaWFzXHJcbi8vIHBsdWdpbiAob3ZlcndyaXRpbmcgdGhlIGRlZmF1bHQgYnJvd3NlciBpbXBvcnRzKS5cclxuLyoqIGF1dGgvb3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudCAqL1xyXG5jb25zdCBOT1RfQVZBSUxBQkxFX0VSUk9SID0gX2NyZWF0ZUVycm9yKFwib3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiIC8qIEF1dGhFcnJvckNvZGUuT1BFUkFUSU9OX05PVF9TVVBQT1JURUQgKi8pO1xyXG4vKiogUmVqZWN0IHdpdGggYXV0aC9vcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50ICovXHJcbmFzeW5jIGZ1bmN0aW9uIGZhaWwoKSB7XHJcbiAgICB0aHJvdyBOT1RfQVZBSUxBQkxFX0VSUk9SO1xyXG59XHJcbi8qKlxyXG4gKiBBIGNsYXNzIHdoaWNoIHdpbGwgdGhyb3cgd2l0aFxyXG4gKiBhdXRoL29wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnQgaWYgaW5zdGFudGlhdGVkXHJcbiAqL1xyXG5jbGFzcyBGYWlsQ2xhc3Mge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhyb3cgTk9UX0FWQUlMQUJMRV9FUlJPUjtcclxuICAgIH1cclxufVxyXG5jb25zdCBicm93c2VyTG9jYWxQZXJzaXN0ZW5jZSA9IGluTWVtb3J5UGVyc2lzdGVuY2U7XHJcbmNvbnN0IGJyb3dzZXJTZXNzaW9uUGVyc2lzdGVuY2UgPSBpbk1lbW9yeVBlcnNpc3RlbmNlO1xyXG5jb25zdCBpbmRleGVkREJMb2NhbFBlcnNpc3RlbmNlID0gaW5NZW1vcnlQZXJzaXN0ZW5jZTtcclxuY29uc3QgYnJvd3NlclBvcHVwUmVkaXJlY3RSZXNvbHZlciA9IE5PVF9BVkFJTEFCTEVfRVJST1I7XHJcbmNvbnN0IFBob25lQXV0aFByb3ZpZGVyID0gRmFpbENsYXNzO1xyXG5jb25zdCBzaWduSW5XaXRoUGhvbmVOdW1iZXIgPSBmYWlsO1xyXG5jb25zdCBsaW5rV2l0aFBob25lTnVtYmVyID0gZmFpbDtcclxuY29uc3QgcmVhdXRoZW50aWNhdGVXaXRoUGhvbmVOdW1iZXIgPSBmYWlsO1xyXG5jb25zdCB1cGRhdGVQaG9uZU51bWJlciA9IGZhaWw7XHJcbmNvbnN0IHNpZ25JbldpdGhQb3B1cCA9IGZhaWw7XHJcbmNvbnN0IGxpbmtXaXRoUG9wdXAgPSBmYWlsO1xyXG5jb25zdCByZWF1dGhlbnRpY2F0ZVdpdGhQb3B1cCA9IGZhaWw7XHJcbmNvbnN0IHNpZ25JbldpdGhSZWRpcmVjdCA9IGZhaWw7XHJcbmNvbnN0IGxpbmtXaXRoUmVkaXJlY3QgPSBmYWlsO1xyXG5jb25zdCByZWF1dGhlbnRpY2F0ZVdpdGhSZWRpcmVjdCA9IGZhaWw7XHJcbmNvbnN0IGdldFJlZGlyZWN0UmVzdWx0ID0gZmFpbDtcclxuY29uc3QgUmVjYXB0Y2hhVmVyaWZpZXIgPSBGYWlsQ2xhc3M7XHJcbmNsYXNzIFBob25lTXVsdGlGYWN0b3JHZW5lcmF0b3Ige1xyXG4gICAgc3RhdGljIGFzc2VydGlvbigpIHtcclxuICAgICAgICB0aHJvdyBOT1RfQVZBSUxBQkxFX0VSUk9SO1xyXG4gICAgfVxyXG59XHJcbi8vIFNldCBwZXJzaXN0ZW5jZSBzaG91bGQgbm8tb3AgaW5zdGVhZCBvZiBmYWlsLiBDaGFuZ2luZyB0aGUgcHJvdG90eXBlIHdpbGxcclxuLy8gbWFrZSBzdXJlIGJvdGggc2V0UGVyc2lzdGVuY2UoYXV0aCwgcGVyc2lzdGVuY2UpIGFuZFxyXG4vLyBhdXRoLnNldFBlcnNpc3RlbmNlKHBlcnNpc3RlbmNlKSBhcmUgY292ZXJlZC5cclxuQXV0aEltcGwucHJvdG90eXBlLnNldFBlcnNpc3RlbmNlID0gYXN5bmMgKCkgPT4geyB9O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBmaW5hbGl6ZVNpZ25JblRvdHBNZmEoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YyL2FjY291bnRzL21mYVNpZ25JbjpmaW5hbGl6ZVwiIC8qIEVuZHBvaW50LkZJTkFMSVpFX01GQV9TSUdOX0lOICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xyXG59XG5cbmNsYXNzIE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3JJZCkge1xyXG4gICAgICAgIHRoaXMuZmFjdG9ySWQgPSBmYWN0b3JJZDtcclxuICAgIH1cclxuICAgIF9wcm9jZXNzKGF1dGgsIHNlc3Npb24sIGRpc3BsYXlOYW1lKSB7XHJcbiAgICAgICAgc3dpdGNoIChzZXNzaW9uLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBcImVucm9sbFwiIC8qIE11bHRpRmFjdG9yU2Vzc2lvblR5cGUuRU5ST0xMICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplRW5yb2xsKGF1dGgsIHNlc3Npb24uY3JlZGVudGlhbCwgZGlzcGxheU5hbWUpO1xyXG4gICAgICAgICAgICBjYXNlIFwic2lnbmluXCIgLyogTXVsdGlGYWN0b3JTZXNzaW9uVHlwZS5TSUdOX0lOICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplU2lnbkluKGF1dGgsIHNlc3Npb24uY3JlZGVudGlhbCk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVidWdGYWlsKCd1bmV4cGVjdGVkIE11bHRpRmFjdG9yU2Vzc2lvblR5cGUnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIFRvdHBNdWx0aUZhY3RvckdlbmVyYXRvciB7XHJcbiAgICAvKipcclxuICAgICAqIFByb3ZpZGVzIGEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0gdG8gY29uZmlybSBvd25lcnNoaXAgb2ZcclxuICAgICAqIHRoZSBUT1RQICh0aW1lLWJhc2VkIG9uZS10aW1lIHBhc3N3b3JkKSBzZWNvbmQgZmFjdG9yLlxyXG4gICAgICogVGhpcyBhc3NlcnRpb24gaXMgdXNlZCB0byBjb21wbGV0ZSBlbnJvbGxtZW50IGluIFRPVFAgc2Vjb25kIGZhY3Rvci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2VjcmV0IEEge0BsaW5rIFRvdHBTZWNyZXR9IGNvbnRhaW5pbmcgdGhlIHNoYXJlZCBzZWNyZXQga2V5IGFuZCBvdGhlciBUT1RQIHBhcmFtZXRlcnMuXHJcbiAgICAgKiBAcGFyYW0gb25lVGltZVBhc3N3b3JkIE9uZS10aW1lIHBhc3N3b3JkIGZyb20gVE9UUCBBcHAuXHJcbiAgICAgKiBAcmV0dXJucyBBIHtAbGluayBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb259IHdoaWNoIGNhbiBiZSB1c2VkIHdpdGhcclxuICAgICAqIHtAbGluayBNdWx0aUZhY3RvclVzZXIuZW5yb2xsfS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGFzc2VydGlvbkZvckVucm9sbG1lbnQoc2VjcmV0LCBvbmVUaW1lUGFzc3dvcmQpIHtcclxuICAgICAgICByZXR1cm4gVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbC5fZnJvbVNlY3JldChzZWNyZXQsIG9uZVRpbWVQYXNzd29yZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFByb3ZpZGVzIGEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0gdG8gY29uZmlybSBvd25lcnNoaXAgb2YgdGhlIFRPVFAgc2Vjb25kIGZhY3Rvci5cclxuICAgICAqIFRoaXMgYXNzZXJ0aW9uIGlzIHVzZWQgdG8gY29tcGxldGUgc2lnbkluIHdpdGggVE9UUCBhcyB0aGUgc2Vjb25kIGZhY3Rvci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZW5yb2xsbWVudElkIGlkZW50aWZpZXMgdGhlIGVucm9sbGVkIFRPVFAgc2Vjb25kIGZhY3Rvci5cclxuICAgICAqIEBwYXJhbSBvbmVUaW1lUGFzc3dvcmQgT25lLXRpbWUgcGFzc3dvcmQgZnJvbSBUT1RQIEFwcC5cclxuICAgICAqIEByZXR1cm5zIEEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0gd2hpY2ggY2FuIGJlIHVzZWQgd2l0aFxyXG4gICAgICoge0BsaW5rIE11bHRpRmFjdG9yUmVzb2x2ZXIucmVzb2x2ZVNpZ25Jbn0uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhc3NlcnRpb25Gb3JTaWduSW4oZW5yb2xsbWVudElkLCBvbmVUaW1lUGFzc3dvcmQpIHtcclxuICAgICAgICByZXR1cm4gVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbC5fZnJvbUVucm9sbG1lbnRJZChlbnJvbGxtZW50SWQsIG9uZVRpbWVQYXNzd29yZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRvIHtAbGluayBUb3RwU2VjcmV0fSB3aGljaCBjb250YWlucyB0aGUgVE9UUCBzaGFyZWQgc2VjcmV0IGtleSBhbmQgb3RoZXIgcGFyYW1ldGVycy5cclxuICAgICAqIENyZWF0ZXMgYSBUT1RQIHNlY3JldCBhcyBwYXJ0IG9mIGVucm9sbGluZyBhIFRPVFAgc2Vjb25kIGZhY3Rvci5cclxuICAgICAqIFVzZWQgZm9yIGdlbmVyYXRpbmcgYSBRUiBjb2RlIFVSTCBvciBpbnB1dHRpbmcgaW50byBhIFRPVFAgYXBwLlxyXG4gICAgICogVGhpcyBtZXRob2QgdXNlcyB0aGUgYXV0aCBpbnN0YW5jZSBjb3JyZXNwb25kaW5nIHRvIHRoZSB1c2VyIGluIHRoZSBtdWx0aUZhY3RvclNlc3Npb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNlc3Npb24gVGhlIHtAbGluayBNdWx0aUZhY3RvclNlc3Npb259IHRoYXQgdGhlIHVzZXIgaXMgcGFydCBvZi5cclxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0byB7QGxpbmsgVG90cFNlY3JldH0uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhc3luYyBnZW5lcmF0ZVNlY3JldChzZXNzaW9uKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IG1mYVNlc3Npb24gPSBzZXNzaW9uO1xyXG4gICAgICAgIF9hc3NlcnQodHlwZW9mICgoX2EgPSBtZmFTZXNzaW9uLnVzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdXRoKSAhPT0gJ3VuZGVmaW5lZCcsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHN0YXJ0RW5yb2xsVG90cE1mYShtZmFTZXNzaW9uLnVzZXIuYXV0aCwge1xyXG4gICAgICAgICAgICBpZFRva2VuOiBtZmFTZXNzaW9uLmNyZWRlbnRpYWwsXHJcbiAgICAgICAgICAgIHRvdHBFbnJvbGxtZW50SW5mbzoge31cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gVG90cFNlY3JldC5fZnJvbVN0YXJ0VG90cE1mYUVucm9sbG1lbnRSZXNwb25zZShyZXNwb25zZSwgbWZhU2Vzc2lvbi51c2VyLmF1dGgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgaWRlbnRpZmllciBvZiB0aGUgVE9UUCBzZWNvbmQgZmFjdG9yOiBgdG90cGAuXHJcbiAqL1xyXG5Ub3RwTXVsdGlGYWN0b3JHZW5lcmF0b3IuRkFDVE9SX0lEID0gXCJ0b3RwXCIgLyogRmFjdG9ySWQuVE9UUCAqLztcclxuY2xhc3MgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbCBleHRlbmRzIE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihvdHAsIGVucm9sbG1lbnRJZCwgc2VjcmV0KSB7XHJcbiAgICAgICAgc3VwZXIoXCJ0b3RwXCIgLyogRmFjdG9ySWQuVE9UUCAqLyk7XHJcbiAgICAgICAgdGhpcy5vdHAgPSBvdHA7XHJcbiAgICAgICAgdGhpcy5lbnJvbGxtZW50SWQgPSBlbnJvbGxtZW50SWQ7XHJcbiAgICAgICAgdGhpcy5zZWNyZXQgPSBzZWNyZXQ7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBzdGF0aWMgX2Zyb21TZWNyZXQoc2VjcmV0LCBvdHApIHtcclxuICAgICAgICByZXR1cm4gbmV3IFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbkltcGwob3RwLCB1bmRlZmluZWQsIHNlY3JldCk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBzdGF0aWMgX2Zyb21FbnJvbGxtZW50SWQoZW5yb2xsbWVudElkLCBvdHApIHtcclxuICAgICAgICByZXR1cm4gbmV3IFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbkltcGwob3RwLCBlbnJvbGxtZW50SWQpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgYXN5bmMgX2ZpbmFsaXplRW5yb2xsKGF1dGgsIGlkVG9rZW4sIGRpc3BsYXlOYW1lKSB7XHJcbiAgICAgICAgX2Fzc2VydCh0eXBlb2YgdGhpcy5zZWNyZXQgIT09ICd1bmRlZmluZWQnLCBhdXRoLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XHJcbiAgICAgICAgcmV0dXJuIGZpbmFsaXplRW5yb2xsVG90cE1mYShhdXRoLCB7XHJcbiAgICAgICAgICAgIGlkVG9rZW4sXHJcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lLFxyXG4gICAgICAgICAgICB0b3RwVmVyaWZpY2F0aW9uSW5mbzogdGhpcy5zZWNyZXQuX21ha2VUb3RwVmVyaWZpY2F0aW9uSW5mbyh0aGlzLm90cClcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGFzeW5jIF9maW5hbGl6ZVNpZ25JbihhdXRoLCBtZmFQZW5kaW5nQ3JlZGVudGlhbCkge1xyXG4gICAgICAgIF9hc3NlcnQodGhpcy5lbnJvbGxtZW50SWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm90cCAhPT0gdW5kZWZpbmVkLCBhdXRoLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XHJcbiAgICAgICAgY29uc3QgdG90cFZlcmlmaWNhdGlvbkluZm8gPSB7IHZlcmlmaWNhdGlvbkNvZGU6IHRoaXMub3RwIH07XHJcbiAgICAgICAgcmV0dXJuIGZpbmFsaXplU2lnbkluVG90cE1mYShhdXRoLCB7XHJcbiAgICAgICAgICAgIG1mYVBlbmRpbmdDcmVkZW50aWFsLFxyXG4gICAgICAgICAgICBtZmFFbnJvbGxtZW50SWQ6IHRoaXMuZW5yb2xsbWVudElkLFxyXG4gICAgICAgICAgICB0b3RwVmVyaWZpY2F0aW9uSW5mb1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBQcm92aWRlciBmb3IgZ2VuZXJhdGluZyBhIHtAbGluayBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb259LlxyXG4gKlxyXG4gKiBTdG9yZXMgdGhlIHNoYXJlZCBzZWNyZXQga2V5IGFuZCBvdGhlciBwYXJhbWV0ZXJzIHRvIGdlbmVyYXRlIHRpbWUtYmFzZWQgT1RQcy5cclxuICogSW1wbGVtZW50cyBtZXRob2RzIHRvIHJldHJpZXZlIHRoZSBzaGFyZWQgc2VjcmV0IGtleSBhbmQgZ2VuZXJhdGUgYSBRUiBjb2RlIFVSTC5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgVG90cFNlY3JldCB7XHJcbiAgICAvLyBUaGUgcHVibGljIG1lbWJlcnMgYXJlIGRlY2xhcmVkIG91dHNpZGUgdGhlIGNvbnN0cnVjdG9yIHNvIHRoZSBkb2NzIGNhbiBiZSBnZW5lcmF0ZWQuXHJcbiAgICBjb25zdHJ1Y3RvcihzZWNyZXRLZXksIGhhc2hpbmdBbGdvcml0aG0sIGNvZGVMZW5ndGgsIGNvZGVJbnRlcnZhbFNlY29uZHMsIGVucm9sbG1lbnRDb21wbGV0aW9uRGVhZGxpbmUsIHNlc3Npb25JbmZvLCBhdXRoKSB7XHJcbiAgICAgICAgdGhpcy5zZXNzaW9uSW5mbyA9IHNlc3Npb25JbmZvO1xyXG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XHJcbiAgICAgICAgdGhpcy5zZWNyZXRLZXkgPSBzZWNyZXRLZXk7XHJcbiAgICAgICAgdGhpcy5oYXNoaW5nQWxnb3JpdGhtID0gaGFzaGluZ0FsZ29yaXRobTtcclxuICAgICAgICB0aGlzLmNvZGVMZW5ndGggPSBjb2RlTGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuY29kZUludGVydmFsU2Vjb25kcyA9IGNvZGVJbnRlcnZhbFNlY29uZHM7XHJcbiAgICAgICAgdGhpcy5lbnJvbGxtZW50Q29tcGxldGlvbkRlYWRsaW5lID0gZW5yb2xsbWVudENvbXBsZXRpb25EZWFkbGluZTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHN0YXRpYyBfZnJvbVN0YXJ0VG90cE1mYUVucm9sbG1lbnRSZXNwb25zZShyZXNwb25zZSwgYXV0aCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVG90cFNlY3JldChyZXNwb25zZS50b3RwU2Vzc2lvbkluZm8uc2hhcmVkU2VjcmV0S2V5LCByZXNwb25zZS50b3RwU2Vzc2lvbkluZm8uaGFzaGluZ0FsZ29yaXRobSwgcmVzcG9uc2UudG90cFNlc3Npb25JbmZvLnZlcmlmaWNhdGlvbkNvZGVMZW5ndGgsIHJlc3BvbnNlLnRvdHBTZXNzaW9uSW5mby5wZXJpb2RTZWMsIG5ldyBEYXRlKHJlc3BvbnNlLnRvdHBTZXNzaW9uSW5mby5maW5hbGl6ZUVucm9sbG1lbnRUaW1lKS50b1VUQ1N0cmluZygpLCByZXNwb25zZS50b3RwU2Vzc2lvbkluZm8uc2Vzc2lvbkluZm8sIGF1dGgpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX21ha2VUb3RwVmVyaWZpY2F0aW9uSW5mbyhvdHApIHtcclxuICAgICAgICByZXR1cm4geyBzZXNzaW9uSW5mbzogdGhpcy5zZXNzaW9uSW5mbywgdmVyaWZpY2F0aW9uQ29kZTogb3RwIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBRUiBjb2RlIFVSTCBhcyBkZXNjcmliZWQgaW5cclxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvZ29vZ2xlLWF1dGhlbnRpY2F0b3Ivd2lraS9LZXktVXJpLUZvcm1hdFxyXG4gICAgICogVGhpcyBjYW4gYmUgZGlzcGxheWVkIHRvIHRoZSB1c2VyIGFzIGEgUVIgY29kZSB0byBiZSBzY2FubmVkIGludG8gYSBUT1RQIGFwcCBsaWtlIEdvb2dsZSBBdXRoZW50aWNhdG9yLlxyXG4gICAgICogSWYgdGhlIG9wdGlvbmFsIHBhcmFtZXRlcnMgYXJlIHVuc3BlY2lmaWVkLCBhbiBhY2NvdW50TmFtZSBvZiA8dXNlckVtYWlsPiBhbmQgaXNzdWVyIG9mIDxmaXJlYmFzZUFwcE5hbWU+IGFyZSB1c2VkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY2NvdW50TmFtZSB0aGUgbmFtZSBvZiB0aGUgYWNjb3VudC9hcHAgYWxvbmcgd2l0aCBhIHVzZXIgaWRlbnRpZmllci5cclxuICAgICAqIEBwYXJhbSBpc3N1ZXIgaXNzdWVyIG9mIHRoZSBUT1RQIChsaWtlbHkgdGhlIGFwcCBuYW1lKS5cclxuICAgICAqIEByZXR1cm5zIEEgUVIgY29kZSBVUkwgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBnZW5lcmF0ZVFyQ29kZVVybChhY2NvdW50TmFtZSwgaXNzdWVyKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGxldCB1c2VEZWZhdWx0cyA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChfaXNFbXB0eVN0cmluZyhhY2NvdW50TmFtZSkgfHwgX2lzRW1wdHlTdHJpbmcoaXNzdWVyKSkge1xyXG4gICAgICAgICAgICB1c2VEZWZhdWx0cyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1c2VEZWZhdWx0cykge1xyXG4gICAgICAgICAgICBpZiAoX2lzRW1wdHlTdHJpbmcoYWNjb3VudE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBhY2NvdW50TmFtZSA9ICgoX2EgPSB0aGlzLmF1dGguY3VycmVudFVzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbWFpbCkgfHwgJ3Vua25vd251c2VyJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoX2lzRW1wdHlTdHJpbmcoaXNzdWVyKSkge1xyXG4gICAgICAgICAgICAgICAgaXNzdWVyID0gdGhpcy5hdXRoLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGBvdHBhdXRoOi8vdG90cC8ke2lzc3Vlcn06JHthY2NvdW50TmFtZX0/c2VjcmV0PSR7dGhpcy5zZWNyZXRLZXl9Jmlzc3Vlcj0ke2lzc3Vlcn0mYWxnb3JpdGhtPSR7dGhpcy5oYXNoaW5nQWxnb3JpdGhtfSZkaWdpdHM9JHt0aGlzLmNvZGVMZW5ndGh9YDtcclxuICAgIH1cclxufVxyXG4vKiogQGludGVybmFsICovXHJcbmZ1bmN0aW9uIF9pc0VtcHR5U3RyaW5nKGlucHV0KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAndW5kZWZpbmVkJyB8fCAoaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlucHV0Lmxlbmd0aCkgPT09IDA7XHJcbn1cblxuZXhwb3J0IHsgVHdpdHRlckF1dGhQcm92aWRlciBhcyAkLCBBY3Rpb25Db2RlT3BlcmF0aW9uIGFzIEEsIHVwZGF0ZUN1cnJlbnRVc2VyIGFzIEIsIHNpZ25PdXQgYXMgQywgcmV2b2tlQWNjZXNzVG9rZW4gYXMgRCwgZGVsZXRlVXNlciBhcyBFLCBGYWN0b3JJZCBhcyBGLCBkZWJ1Z0Vycm9yTWFwIGFzIEcsIHByb2RFcnJvck1hcCBhcyBILCBBVVRIX0VSUk9SX0NPREVTX01BUF9ET19OT1RfVVNFX0lOVEVSTkFMTFkgYXMgSSwgaW5pdGlhbGl6ZUF1dGggYXMgSiwgY29ubmVjdEF1dGhFbXVsYXRvciBhcyBLLCBBdXRoQ3JlZGVudGlhbCBhcyBMLCBFbWFpbEF1dGhDcmVkZW50aWFsIGFzIE0sIE9BdXRoQ3JlZGVudGlhbCBhcyBOLCBPcGVyYXRpb25UeXBlIGFzIE8sIFBob25lQXV0aFByb3ZpZGVyIGFzIFAsIFBob25lQXV0aENyZWRlbnRpYWwgYXMgUSwgUmVjYXB0Y2hhVmVyaWZpZXIgYXMgUiwgU2lnbkluTWV0aG9kIGFzIFMsIFRvdHBNdWx0aUZhY3RvckdlbmVyYXRvciBhcyBULCBpbk1lbW9yeVBlcnNpc3RlbmNlIGFzIFUsIEVtYWlsQXV0aFByb3ZpZGVyIGFzIFYsIEZhY2Vib29rQXV0aFByb3ZpZGVyIGFzIFcsIEdvb2dsZUF1dGhQcm92aWRlciBhcyBYLCBHaXRodWJBdXRoUHJvdmlkZXIgYXMgWSwgT0F1dGhQcm92aWRlciBhcyBaLCBTQU1MQXV0aFByb3ZpZGVyIGFzIF8sIGJyb3dzZXJTZXNzaW9uUGVyc2lzdGVuY2UgYXMgYSwgc2lnbkluQW5vbnltb3VzbHkgYXMgYTAsIHNpZ25JbldpdGhDcmVkZW50aWFsIGFzIGExLCBsaW5rV2l0aENyZWRlbnRpYWwgYXMgYTIsIHJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWwgYXMgYTMsIHNpZ25JbldpdGhDdXN0b21Ub2tlbiBhcyBhNCwgc2VuZFBhc3N3b3JkUmVzZXRFbWFpbCBhcyBhNSwgY29uZmlybVBhc3N3b3JkUmVzZXQgYXMgYTYsIGFwcGx5QWN0aW9uQ29kZSBhcyBhNywgY2hlY2tBY3Rpb25Db2RlIGFzIGE4LCB2ZXJpZnlQYXNzd29yZFJlc2V0Q29kZSBhcyBhOSwgX2ZhaWwgYXMgYUEsIGRlYnVnQXNzZXJ0IGFzIGFCLCBfcGVyc2lzdGVuY2VLZXlOYW1lIGFzIGFDLCBfc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvciBhcyBhRCwgX2Nhc3RBdXRoIGFzIGFFLCBGZWRlcmF0ZWRBdXRoUHJvdmlkZXIgYXMgYUYsIEJhc2VPQXV0aFByb3ZpZGVyIGFzIGFHLCBfZW11bGF0b3JVcmwgYXMgYUgsIF9wZXJmb3JtQXBpUmVxdWVzdCBhcyBhSSwgX2lzSU9TIGFzIGFKLCBfaXNBbmRyb2lkIGFzIGFLLCBfaXNJT1M3T3I4IGFzIGFMLCBfY3JlYXRlRXJyb3IgYXMgYU0sIF9pc01vYmlsZUJyb3dzZXIgYXMgYU4sIF9pc0lFMTAgYXMgYU8sIFVzZXJJbXBsIGFzIGFQLCBBdXRoSW1wbCBhcyBhUSwgX2dldENsaWVudFZlcnNpb24gYXMgYVIsIEZldGNoUHJvdmlkZXIgYXMgYVMsIFNBTUxBdXRoQ3JlZGVudGlhbCBhcyBhVCwgY3JlYXRlVXNlcldpdGhFbWFpbEFuZFBhc3N3b3JkIGFzIGFhLCBzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZCBhcyBhYiwgc2VuZFNpZ25JbkxpbmtUb0VtYWlsIGFzIGFjLCBpc1NpZ25JbldpdGhFbWFpbExpbmsgYXMgYWQsIHNpZ25JbldpdGhFbWFpbExpbmsgYXMgYWUsIGZldGNoU2lnbkluTWV0aG9kc0ZvckVtYWlsIGFzIGFmLCBzZW5kRW1haWxWZXJpZmljYXRpb24gYXMgYWcsIHZlcmlmeUJlZm9yZVVwZGF0ZUVtYWlsIGFzIGFoLCBBY3Rpb25Db2RlVVJMIGFzIGFpLCBwYXJzZUFjdGlvbkNvZGVVUkwgYXMgYWosIHVwZGF0ZVByb2ZpbGUgYXMgYWssIHVwZGF0ZUVtYWlsIGFzIGFsLCB1cGRhdGVQYXNzd29yZCBhcyBhbSwgZ2V0SWRUb2tlbiBhcyBhbiwgZ2V0SWRUb2tlblJlc3VsdCBhcyBhbywgdW5saW5rIGFzIGFwLCBnZXRBZGRpdGlvbmFsVXNlckluZm8gYXMgYXEsIHJlbG9hZCBhcyBhciwgZ2V0TXVsdGlGYWN0b3JSZXNvbHZlciBhcyBhcywgbXVsdGlGYWN0b3IgYXMgYXQsIF9nZXRJbnN0YW5jZSBhcyBhdSwgX2Fzc2VydCBhcyBhdiwgX3NpZ25JbldpdGhDcmVkZW50aWFsIGFzIGF3LCBfcmVhdXRoZW50aWNhdGUgYXMgYXgsIF9saW5rIGFzIGF5LCBzaWduSW5XaXRoSWRwIGFzIGF6LCBicm93c2VyTG9jYWxQZXJzaXN0ZW5jZSBhcyBiLCBzaWduSW5XaXRoUG9wdXAgYXMgYywgbGlua1dpdGhQb3B1cCBhcyBkLCByZWF1dGhlbnRpY2F0ZVdpdGhQb3B1cCBhcyBlLCBzaWduSW5XaXRoUmVkaXJlY3QgYXMgZiwgbGlua1dpdGhSZWRpcmVjdCBhcyBnLCByZWF1dGhlbnRpY2F0ZVdpdGhSZWRpcmVjdCBhcyBoLCBpbmRleGVkREJMb2NhbFBlcnNpc3RlbmNlIGFzIGksIGdldFJlZGlyZWN0UmVzdWx0IGFzIGosIGJyb3dzZXJQb3B1cFJlZGlyZWN0UmVzb2x2ZXIgYXMgaywgbGlua1dpdGhQaG9uZU51bWJlciBhcyBsLCBQaG9uZU11bHRpRmFjdG9yR2VuZXJhdG9yIGFzIG0sIFRvdHBTZWNyZXQgYXMgbiwgZ2V0QXV0aCBhcyBvLCBQcm92aWRlcklkIGFzIHAsIHNldFBlcnNpc3RlbmNlIGFzIHEsIHJlYXV0aGVudGljYXRlV2l0aFBob25lTnVtYmVyIGFzIHIsIHNpZ25JbldpdGhQaG9uZU51bWJlciBhcyBzLCBpbml0aWFsaXplUmVjYXB0Y2hhQ29uZmlnIGFzIHQsIHVwZGF0ZVBob25lTnVtYmVyIGFzIHUsIHZhbGlkYXRlUGFzc3dvcmQgYXMgdiwgb25JZFRva2VuQ2hhbmdlZCBhcyB3LCBiZWZvcmVBdXRoU3RhdGVDaGFuZ2VkIGFzIHgsIG9uQXV0aFN0YXRlQ2hhbmdlZCBhcyB5LCB1c2VEZXZpY2VMYW5ndWFnZSBhcyB6IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b3RwLTIxOWJiOTZmLmpzLm1hcFxuIl0sIm5hbWVzIjpbIlNES19WRVJTSU9OIiwiX2lzRmlyZWJhc2VTZXJ2ZXJBcHAiLCJfZ2V0UHJvdmlkZXIiLCJfcmVnaXN0ZXJDb21wb25lbnQiLCJyZWdpc3RlclZlcnNpb24iLCJnZXRBcHAiLCJFcnJvckZhY3RvcnkiLCJpc0Jyb3dzZXJFeHRlbnNpb24iLCJpc01vYmlsZUNvcmRvdmEiLCJpc1JlYWN0TmF0aXZlIiwiRmlyZWJhc2VFcnJvciIsInF1ZXJ5c3RyaW5nIiwiaXNDbG91ZGZsYXJlV29ya2VyIiwiZ2V0TW9kdWxhckluc3RhbmNlIiwiYmFzZTY0RGVjb2RlIiwiZ2V0VUEiLCJpc0lFIiwiY3JlYXRlU3Vic2NyaWJlIiwiZGVlcEVxdWFsIiwicXVlcnlzdHJpbmdEZWNvZGUiLCJleHRyYWN0UXVlcnlzdHJpbmciLCJnZXREZWZhdWx0RW11bGF0b3JIb3N0IiwiX19yZXN0IiwiQ29tcG9uZW50IiwiZmV0Y2giLCJmZXRjaCQxIiwiSGVhZGVycyIsIkhlYWRlcnMkMSIsIlJlc3BvbnNlIiwiUmVzcG9uc2UkMSIsIkxvZ2dlciIsIkxvZ0xldmVsIiwiRmFjdG9ySWQiLCJQSE9ORSIsIlRPVFAiLCJQcm92aWRlcklkIiwiRkFDRUJPT0siLCJHSVRIVUIiLCJHT09HTEUiLCJQQVNTV09SRCIsIlRXSVRURVIiLCJTaWduSW5NZXRob2QiLCJFTUFJTF9MSU5LIiwiRU1BSUxfUEFTU1dPUkQiLCJPcGVyYXRpb25UeXBlIiwiTElOSyIsIlJFQVVUSEVOVElDQVRFIiwiU0lHTl9JTiIsIkFjdGlvbkNvZGVPcGVyYXRpb24iLCJFTUFJTF9TSUdOSU4iLCJQQVNTV09SRF9SRVNFVCIsIlJFQ09WRVJfRU1BSUwiLCJSRVZFUlRfU0VDT05EX0ZBQ1RPUl9BRERJVElPTiIsIlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMIiwiVkVSSUZZX0VNQUlMIiwiX2RlYnVnRXJyb3JNYXAiLCJfcHJvZEVycm9yTWFwIiwiZGVidWdFcnJvck1hcCIsInByb2RFcnJvck1hcCIsIl9ERUZBVUxUX0FVVEhfRVJST1JfRkFDVE9SWSIsIkFVVEhfRVJST1JfQ09ERVNfTUFQX0RPX05PVF9VU0VfSU5URVJOQUxMWSIsIkFETUlOX09OTFlfT1BFUkFUSU9OIiwiQVJHVU1FTlRfRVJST1IiLCJBUFBfTk9UX0FVVEhPUklaRUQiLCJBUFBfTk9UX0lOU1RBTExFRCIsIkNBUFRDSEFfQ0hFQ0tfRkFJTEVEIiwiQ09ERV9FWFBJUkVEIiwiQ09SRE9WQV9OT1RfUkVBRFkiLCJDT1JTX1VOU1VQUE9SVEVEIiwiQ1JFREVOVElBTF9BTFJFQURZX0lOX1VTRSIsIkNSRURFTlRJQUxfTUlTTUFUQ0giLCJDUkVERU5USUFMX1RPT19PTERfTE9HSU5fQUdBSU4iLCJERVBFTkRFTlRfU0RLX0lOSVRfQkVGT1JFX0FVVEgiLCJEWU5BTUlDX0xJTktfTk9UX0FDVElWQVRFRCIsIkVNQUlMX0NIQU5HRV9ORUVEU19WRVJJRklDQVRJT04iLCJFTUFJTF9FWElTVFMiLCJFTVVMQVRPUl9DT05GSUdfRkFJTEVEIiwiRVhQSVJFRF9PT0JfQ09ERSIsIkVYUElSRURfUE9QVVBfUkVRVUVTVCIsIklOVEVSTkFMX0VSUk9SIiwiSU5WQUxJRF9BUElfS0VZIiwiSU5WQUxJRF9BUFBfQ1JFREVOVElBTCIsIklOVkFMSURfQVBQX0lEIiwiSU5WQUxJRF9BVVRIIiwiSU5WQUxJRF9BVVRIX0VWRU5UIiwiSU5WQUxJRF9DRVJUX0hBU0giLCJJTlZBTElEX0NPREUiLCJJTlZBTElEX0NPTlRJTlVFX1VSSSIsIklOVkFMSURfQ09SRE9WQV9DT05GSUdVUkFUSU9OIiwiSU5WQUxJRF9DVVNUT01fVE9LRU4iLCJJTlZBTElEX0RZTkFNSUNfTElOS19ET01BSU4iLCJJTlZBTElEX0VNQUlMIiwiSU5WQUxJRF9FTVVMQVRPUl9TQ0hFTUUiLCJJTlZBTElEX0lEUF9SRVNQT05TRSIsIklOVkFMSURfTE9HSU5fQ1JFREVOVElBTFMiLCJJTlZBTElEX01FU1NBR0VfUEFZTE9BRCIsIklOVkFMSURfTUZBX1NFU1NJT04iLCJJTlZBTElEX09BVVRIX0NMSUVOVF9JRCIsIklOVkFMSURfT0FVVEhfUFJPVklERVIiLCJJTlZBTElEX09PQl9DT0RFIiwiSU5WQUxJRF9PUklHSU4iLCJJTlZBTElEX1BBU1NXT1JEIiwiSU5WQUxJRF9QRVJTSVNURU5DRSIsIklOVkFMSURfUEhPTkVfTlVNQkVSIiwiSU5WQUxJRF9QUk9WSURFUl9JRCIsIklOVkFMSURfUkVDSVBJRU5UX0VNQUlMIiwiSU5WQUxJRF9TRU5ERVIiLCJJTlZBTElEX1NFU1NJT05fSU5GTyIsIklOVkFMSURfVEVOQU5UX0lEIiwiTUZBX0lORk9fTk9UX0ZPVU5EIiwiTUZBX1JFUVVJUkVEIiwiTUlTU0lOR19BTkRST0lEX1BBQ0tBR0VfTkFNRSIsIk1JU1NJTkdfQVBQX0NSRURFTlRJQUwiLCJNSVNTSU5HX0FVVEhfRE9NQUlOIiwiTUlTU0lOR19DT0RFIiwiTUlTU0lOR19DT05USU5VRV9VUkkiLCJNSVNTSU5HX0lGUkFNRV9TVEFSVCIsIk1JU1NJTkdfSU9TX0JVTkRMRV9JRCIsIk1JU1NJTkdfT1JfSU5WQUxJRF9OT05DRSIsIk1JU1NJTkdfTUZBX0lORk8iLCJNSVNTSU5HX01GQV9TRVNTSU9OIiwiTUlTU0lOR19QSE9ORV9OVU1CRVIiLCJNSVNTSU5HX1NFU1NJT05fSU5GTyIsIk1PRFVMRV9ERVNUUk9ZRUQiLCJORUVEX0NPTkZJUk1BVElPTiIsIk5FVFdPUktfUkVRVUVTVF9GQUlMRUQiLCJOVUxMX1VTRVIiLCJOT19BVVRIX0VWRU5UIiwiTk9fU1VDSF9QUk9WSURFUiIsIk9QRVJBVElPTl9OT1RfQUxMT1dFRCIsIk9QRVJBVElPTl9OT1RfU1VQUE9SVEVEIiwiUE9QVVBfQkxPQ0tFRCIsIlBPUFVQX0NMT1NFRF9CWV9VU0VSIiwiUFJPVklERVJfQUxSRUFEWV9MSU5LRUQiLCJRVU9UQV9FWENFRURFRCIsIlJFRElSRUNUX0NBTkNFTExFRF9CWV9VU0VSIiwiUkVESVJFQ1RfT1BFUkFUSU9OX1BFTkRJTkciLCJSRUpFQ1RFRF9DUkVERU5USUFMIiwiU0VDT05EX0ZBQ1RPUl9BTFJFQURZX0VOUk9MTEVEIiwiU0VDT05EX0ZBQ1RPUl9MSU1JVF9FWENFRURFRCIsIlRFTkFOVF9JRF9NSVNNQVRDSCIsIlRJTUVPVVQiLCJUT0tFTl9FWFBJUkVEIiwiVE9PX01BTllfQVRURU1QVFNfVFJZX0xBVEVSIiwiVU5BVVRIT1JJWkVEX0RPTUFJTiIsIlVOU1VQUE9SVEVEX0ZJUlNUX0ZBQ1RPUiIsIlVOU1VQUE9SVEVEX1BFUlNJU1RFTkNFIiwiVU5TVVBQT1JURURfVEVOQU5UX09QRVJBVElPTiIsIlVOVkVSSUZJRURfRU1BSUwiLCJVU0VSX0NBTkNFTExFRCIsIlVTRVJfREVMRVRFRCIsIlVTRVJfRElTQUJMRUQiLCJVU0VSX01JU01BVENIIiwiVVNFUl9TSUdORURfT1VUIiwiV0VBS19QQVNTV09SRCIsIldFQl9TVE9SQUdFX1VOU1VQUE9SVEVEIiwiQUxSRUFEWV9JTklUSUFMSVpFRCIsIlJFQ0FQVENIQV9OT1RfRU5BQkxFRCIsIk1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOIiwiSU5WQUxJRF9SRUNBUFRDSEFfVE9LRU4iLCJJTlZBTElEX1JFQ0FQVENIQV9BQ1RJT04iLCJNSVNTSU5HX0NMSUVOVF9UWVBFIiwiTUlTU0lOR19SRUNBUFRDSEFfVkVSU0lPTiIsIklOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT04iLCJJTlZBTElEX1JFUV9UWVBFIiwibG9nQ2xpZW50IiwiX2xvZ1dhcm4iLCJtc2ciLCJhcmdzIiwibG9nTGV2ZWwiLCJXQVJOIiwid2FybiIsIl9sb2dFcnJvciIsIkVSUk9SIiwiZXJyb3IiLCJfZmFpbCIsImF1dGhPckNvZGUiLCJyZXN0IiwiY3JlYXRlRXJyb3JJbnRlcm5hbCIsIl9jcmVhdGVFcnJvciIsIl9lcnJvcldpdGhDdXN0b21NZXNzYWdlIiwiYXV0aCIsImNvZGUiLCJtZXNzYWdlIiwiZXJyb3JNYXAiLCJPYmplY3QiLCJhc3NpZ24iLCJmYWN0b3J5IiwiY3JlYXRlIiwiYXBwTmFtZSIsIm5hbWUiLCJfc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvciIsImZ1bGxQYXJhbXMiLCJzbGljZSIsIl9lcnJvckZhY3RvcnkiLCJfYXNzZXJ0IiwiYXNzZXJ0aW9uIiwiZGVidWdGYWlsIiwiZmFpbHVyZSIsIkVycm9yIiwiZGVidWdBc3NlcnQiLCJfZ2V0Q3VycmVudFVybCIsIl9hIiwic2VsZiIsImxvY2F0aW9uIiwiaHJlZiIsIl9pc0h0dHBPckh0dHBzIiwiX2dldEN1cnJlbnRTY2hlbWUiLCJwcm90b2NvbCIsIl9pc09ubGluZSIsIm5hdmlnYXRvciIsIm9uTGluZSIsIl9nZXRVc2VyTGFuZ3VhZ2UiLCJuYXZpZ2F0b3JMYW5ndWFnZSIsImxhbmd1YWdlcyIsImxhbmd1YWdlIiwiRGVsYXkiLCJjb25zdHJ1Y3RvciIsInNob3J0RGVsYXkiLCJsb25nRGVsYXkiLCJpc01vYmlsZSIsImdldCIsIk1hdGgiLCJtaW4iLCJfZW11bGF0b3JVcmwiLCJjb25maWciLCJwYXRoIiwiZW11bGF0b3IiLCJ1cmwiLCJzdGFydHNXaXRoIiwiRmV0Y2hQcm92aWRlciIsImluaXRpYWxpemUiLCJmZXRjaEltcGwiLCJoZWFkZXJzSW1wbCIsInJlc3BvbnNlSW1wbCIsImdsb2JhbFRoaXMiLCJoZWFkZXJzIiwicmVzcG9uc2UiLCJTRVJWRVJfRVJST1JfTUFQIiwiREVGQVVMVF9BUElfVElNRU9VVF9NUyIsIl9hZGRUaWRJZk5lY2Vzc2FyeSIsInJlcXVlc3QiLCJ0ZW5hbnRJZCIsIl9wZXJmb3JtQXBpUmVxdWVzdCIsIm1ldGhvZCIsImN1c3RvbUVycm9yTWFwIiwiX3BlcmZvcm1GZXRjaFdpdGhFcnJvckhhbmRsaW5nIiwiYm9keSIsInBhcmFtcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJxdWVyeSIsImtleSIsImFwaUtleSIsIl9nZXRBZGRpdGlvbmFsSGVhZGVycyIsImxhbmd1YWdlQ29kZSIsImZldGNoQXJncyIsInJlZmVycmVyUG9saWN5IiwiX2dldEZpbmFsVGFyZ2V0IiwiYXBpSG9zdCIsImZldGNoRm4iLCJfY2FuSW5pdEVtdWxhdG9yIiwibmV0d29ya1RpbWVvdXQiLCJOZXR3b3JrVGltZW91dCIsIlByb21pc2UiLCJyYWNlIiwicHJvbWlzZSIsImNsZWFyTmV0d29ya1RpbWVvdXQiLCJqc29uIiwiX21ha2VUYWdnZWRFcnJvciIsIm9rIiwiZXJyb3JNZXNzYWdlIiwic2VydmVyRXJyb3JDb2RlIiwic2VydmVyRXJyb3JNZXNzYWdlIiwic3BsaXQiLCJhdXRoRXJyb3IiLCJ0b0xvd2VyQ2FzZSIsInJlcGxhY2UiLCJlIiwiU3RyaW5nIiwiX3BlcmZvcm1TaWduSW5SZXF1ZXN0Iiwic2VydmVyUmVzcG9uc2UiLCJfc2VydmVyUmVzcG9uc2UiLCJob3N0IiwiYmFzZSIsImFwaVNjaGVtZSIsIl9wYXJzZUVuZm9yY2VtZW50U3RhdGUiLCJlbmZvcmNlbWVudFN0YXRlU3RyIiwidGltZXIiLCJfIiwicmVqZWN0Iiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsImVycm9yUGFyYW1zIiwiZW1haWwiLCJwaG9uZU51bWJlciIsImN1c3RvbURhdGEiLCJfdG9rZW5SZXNwb25zZSIsImlzRW50ZXJwcmlzZSIsImdyZWNhcHRjaGEiLCJ1bmRlZmluZWQiLCJlbnRlcnByaXNlIiwiUmVjYXB0Y2hhQ29uZmlnIiwic2l0ZUtleSIsInJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGUiLCJyZWNhcHRjaGFLZXkiLCJnZXRQcm92aWRlckVuZm9yY2VtZW50U3RhdGUiLCJwcm92aWRlclN0ciIsImxlbmd0aCIsInByb3ZpZGVyIiwiZW5mb3JjZW1lbnRTdGF0ZSIsImlzUHJvdmlkZXJFbmFibGVkIiwiZ2V0UmVjYXB0Y2hhQ29uZmlnIiwiZGVsZXRlQWNjb3VudCIsImRlbGV0ZUxpbmtlZEFjY291bnRzIiwiZ2V0QWNjb3VudEluZm8iLCJ1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmciLCJ1dGNUaW1lc3RhbXAiLCJkYXRlIiwiRGF0ZSIsIk51bWJlciIsImlzTmFOIiwiZ2V0VGltZSIsInRvVVRDU3RyaW5nIiwiZ2V0SWRUb2tlbiIsInVzZXIiLCJmb3JjZVJlZnJlc2giLCJnZXRJZFRva2VuUmVzdWx0IiwidXNlckludGVybmFsIiwidG9rZW4iLCJjbGFpbXMiLCJfcGFyc2VUb2tlbiIsImV4cCIsImF1dGhfdGltZSIsImlhdCIsImZpcmViYXNlIiwic2lnbkluUHJvdmlkZXIiLCJhdXRoVGltZSIsInNlY29uZHNTdHJpbmdUb01pbGxpc2Vjb25kcyIsImlzc3VlZEF0VGltZSIsImV4cGlyYXRpb25UaW1lIiwic2lnbkluU2Vjb25kRmFjdG9yIiwic2Vjb25kcyIsImFsZ29yaXRobSIsInBheWxvYWQiLCJzaWduYXR1cmUiLCJkZWNvZGVkIiwicGFyc2UiLCJ0b1N0cmluZyIsIl90b2tlbkV4cGlyZXNJbiIsInBhcnNlZFRva2VuIiwiX2xvZ291dElmSW52YWxpZGF0ZWQiLCJieXBhc3NBdXRoU3RhdGUiLCJpc1VzZXJJbnZhbGlkYXRlZCIsImN1cnJlbnRVc2VyIiwic2lnbk91dCIsIlByb2FjdGl2ZVJlZnJlc2giLCJpc1J1bm5pbmciLCJ0aW1lcklkIiwiZXJyb3JCYWNrb2ZmIiwiX3N0YXJ0Iiwic2NoZWR1bGUiLCJfc3RvcCIsImdldEludGVydmFsIiwid2FzRXJyb3IiLCJpbnRlcnZhbCIsImV4cFRpbWUiLCJzdHNUb2tlbk1hbmFnZXIiLCJub3ciLCJtYXgiLCJpdGVyYXRpb24iLCJVc2VyTWV0YWRhdGEiLCJjcmVhdGVkQXQiLCJsYXN0TG9naW5BdCIsIl9pbml0aWFsaXplVGltZSIsImxhc3RTaWduSW5UaW1lIiwiY3JlYXRpb25UaW1lIiwiX2NvcHkiLCJtZXRhZGF0YSIsInRvSlNPTiIsIl9yZWxvYWRXaXRob3V0U2F2aW5nIiwiaWRUb2tlbiIsInVzZXJzIiwiY29yZUFjY291bnQiLCJfbm90aWZ5UmVsb2FkTGlzdGVuZXIiLCJuZXdQcm92aWRlckRhdGEiLCJwcm92aWRlclVzZXJJbmZvIiwiZXh0cmFjdFByb3ZpZGVyRGF0YSIsInByb3ZpZGVyRGF0YSIsIm1lcmdlUHJvdmlkZXJEYXRhIiwib2xkSXNBbm9ueW1vdXMiLCJpc0Fub255bW91cyIsIm5ld0lzQW5vbnltb3VzIiwicGFzc3dvcmRIYXNoIiwidXBkYXRlcyIsInVpZCIsImxvY2FsSWQiLCJkaXNwbGF5TmFtZSIsInBob3RvVVJMIiwicGhvdG9VcmwiLCJlbWFpbFZlcmlmaWVkIiwicmVsb2FkIiwiX3BlcnNpc3RVc2VySWZDdXJyZW50IiwiX25vdGlmeUxpc3RlbmVyc0lmQ3VycmVudCIsIm9yaWdpbmFsIiwibmV3RGF0YSIsImRlZHVwZWQiLCJmaWx0ZXIiLCJvIiwic29tZSIsIm4iLCJwcm92aWRlcklkIiwicHJvdmlkZXJzIiwibWFwIiwicmF3SWQiLCJyZXF1ZXN0U3RzVG9rZW4iLCJyZWZyZXNoVG9rZW4iLCJ0b2tlbkFwaUhvc3QiLCJhY2Nlc3NUb2tlbiIsImFjY2Vzc190b2tlbiIsImV4cGlyZXNJbiIsImV4cGlyZXNfaW4iLCJyZWZyZXNoX3Rva2VuIiwicmV2b2tlVG9rZW4iLCJTdHNUb2tlbk1hbmFnZXIiLCJpc0V4cGlyZWQiLCJ1cGRhdGVGcm9tU2VydmVyUmVzcG9uc2UiLCJ1cGRhdGVUb2tlbnNBbmRFeHBpcmF0aW9uIiwidXBkYXRlRnJvbUlkVG9rZW4iLCJnZXRUb2tlbiIsInJlZnJlc2giLCJjbGVhclJlZnJlc2hUb2tlbiIsIm9sZFRva2VuIiwiZXhwaXJlc0luU2VjIiwiZnJvbUpTT04iLCJvYmplY3QiLCJtYW5hZ2VyIiwiX2Fzc2lnbiIsIl9jbG9uZSIsIl9wZXJmb3JtUmVmcmVzaCIsImFzc2VydFN0cmluZ09yVW5kZWZpbmVkIiwiVXNlckltcGwiLCJvcHQiLCJwcm9hY3RpdmVSZWZyZXNoIiwicmVsb2FkVXNlckluZm8iLCJyZWxvYWRMaXN0ZW5lciIsInVzZXJJbmZvIiwibmV3VXNlciIsIl9vblJlbG9hZCIsImNhbGxiYWNrIiwiX3N0YXJ0UHJvYWN0aXZlUmVmcmVzaCIsIl9zdG9wUHJvYWN0aXZlUmVmcmVzaCIsIl91cGRhdGVUb2tlbnNJZk5lY2Vzc2FyeSIsInRva2Vuc1JlZnJlc2hlZCIsImRlbGV0ZSIsImFwcCIsIl9yZWRpcmVjdEV2ZW50SWQiLCJfZnJvbUpTT04iLCJfYiIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJfaCIsInBsYWluT2JqZWN0VG9rZW5NYW5hZ2VyIiwiQXJyYXkiLCJpc0FycmF5IiwiX2Zyb21JZFRva2VuUmVzcG9uc2UiLCJpZFRva2VuUmVzcG9uc2UiLCJfZnJvbUdldEFjY291bnRJbmZvUmVzcG9uc2UiLCJpbnN0YW5jZUNhY2hlIiwiTWFwIiwiX2dldEluc3RhbmNlIiwiY2xzIiwiRnVuY3Rpb24iLCJpbnN0YW5jZSIsInNldCIsIkluTWVtb3J5UGVyc2lzdGVuY2UiLCJ0eXBlIiwic3RvcmFnZSIsIl9pc0F2YWlsYWJsZSIsIl9zZXQiLCJ2YWx1ZSIsIl9nZXQiLCJfcmVtb3ZlIiwiX2FkZExpc3RlbmVyIiwiX2tleSIsIl9saXN0ZW5lciIsIl9yZW1vdmVMaXN0ZW5lciIsImluTWVtb3J5UGVyc2lzdGVuY2UiLCJfcGVyc2lzdGVuY2VLZXlOYW1lIiwiUGVyc2lzdGVuY2VVc2VyTWFuYWdlciIsInBlcnNpc3RlbmNlIiwidXNlcktleSIsImZ1bGxVc2VyS2V5IiwiZnVsbFBlcnNpc3RlbmNlS2V5IiwiYm91bmRFdmVudEhhbmRsZXIiLCJfb25TdG9yYWdlRXZlbnQiLCJiaW5kIiwic2V0Q3VycmVudFVzZXIiLCJnZXRDdXJyZW50VXNlciIsImJsb2IiLCJyZW1vdmVDdXJyZW50VXNlciIsInNhdmVQZXJzaXN0ZW5jZUZvclJlZGlyZWN0Iiwic2V0UGVyc2lzdGVuY2UiLCJuZXdQZXJzaXN0ZW5jZSIsInBlcnNpc3RlbmNlSGllcmFyY2h5IiwiYXZhaWxhYmxlUGVyc2lzdGVuY2VzIiwiYWxsIiwic2VsZWN0ZWRQZXJzaXN0ZW5jZSIsInVzZXJUb01pZ3JhdGUiLCJtaWdyYXRpb25IaWVyYXJjaHkiLCJwIiwiX3Nob3VsZEFsbG93TWlncmF0aW9uIiwiX2dldEJyb3dzZXJOYW1lIiwidXNlckFnZW50IiwidWEiLCJpbmNsdWRlcyIsIl9pc0lFTW9iaWxlIiwiX2lzRmlyZWZveCIsIl9pc0JsYWNrQmVycnkiLCJfaXNXZWJPUyIsIl9pc1NhZmFyaSIsIl9pc0Nocm9tZUlPUyIsIl9pc0FuZHJvaWQiLCJyZSIsIm1hdGNoZXMiLCJtYXRjaCIsInRlc3QiLCJfaXNJT1MiLCJfaXNJT1M3T3I4IiwiX2lzSUUxMCIsImRvY3VtZW50IiwiZG9jdW1lbnRNb2RlIiwiX2lzTW9iaWxlQnJvd3NlciIsIl9nZXRDbGllbnRWZXJzaW9uIiwiY2xpZW50UGxhdGZvcm0iLCJmcmFtZXdvcmtzIiwicmVwb3J0ZWRQbGF0Zm9ybSIsInJlcG9ydGVkRnJhbWV3b3JrcyIsImpvaW4iLCJBdXRoTWlkZGxld2FyZVF1ZXVlIiwicXVldWUiLCJwdXNoQ2FsbGJhY2siLCJvbkFib3J0Iiwid3JhcHBlZENhbGxiYWNrIiwicmVzb2x2ZSIsInJlc3VsdCIsInB1c2giLCJpbmRleCIsInJ1bk1pZGRsZXdhcmUiLCJuZXh0VXNlciIsIm9uQWJvcnRTdGFjayIsImJlZm9yZVN0YXRlQ2FsbGJhY2siLCJyZXZlcnNlIiwib3JpZ2luYWxNZXNzYWdlIiwiX2dldFBhc3N3b3JkUG9saWN5IiwiTUlOSU1VTV9NSU5fUEFTU1dPUkRfTEVOR1RIIiwiUGFzc3dvcmRQb2xpY3lJbXBsIiwicmVzcG9uc2VPcHRpb25zIiwiY3VzdG9tU3RyZW5ndGhPcHRpb25zIiwibWluUGFzc3dvcmRMZW5ndGgiLCJtYXhQYXNzd29yZExlbmd0aCIsImNvbnRhaW5zTG93ZXJjYXNlQ2hhcmFjdGVyIiwiY29udGFpbnNMb3dlcmNhc2VMZXR0ZXIiLCJjb250YWluc1VwcGVyY2FzZUNoYXJhY3RlciIsImNvbnRhaW5zVXBwZXJjYXNlTGV0dGVyIiwiY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyIiwiY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXIiLCJhbGxvd2VkTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVycyIsImZvcmNlVXBncmFkZU9uU2lnbmluIiwic2NoZW1hVmVyc2lvbiIsInZhbGlkYXRlUGFzc3dvcmQiLCJwYXNzd29yZCIsInN0YXR1cyIsImlzVmFsaWQiLCJwYXNzd29yZFBvbGljeSIsInZhbGlkYXRlUGFzc3dvcmRMZW5ndGhPcHRpb25zIiwidmFsaWRhdGVQYXNzd29yZENoYXJhY3Rlck9wdGlvbnMiLCJtZWV0c01pblBhc3N3b3JkTGVuZ3RoIiwibWVldHNNYXhQYXNzd29yZExlbmd0aCIsInVwZGF0ZVBhc3N3b3JkQ2hhcmFjdGVyT3B0aW9uc1N0YXR1c2VzIiwicGFzc3dvcmRDaGFyIiwiaSIsImNoYXJBdCIsIkF1dGhJbXBsIiwiaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyIiwiYXBwQ2hlY2tTZXJ2aWNlUHJvdmlkZXIiLCJlbXVsYXRvckNvbmZpZyIsIm9wZXJhdGlvbnMiLCJhdXRoU3RhdGVTdWJzY3JpcHRpb24iLCJTdWJzY3JpcHRpb24iLCJpZFRva2VuU3Vic2NyaXB0aW9uIiwiYmVmb3JlU3RhdGVRdWV1ZSIsInJlZGlyZWN0VXNlciIsImlzUHJvYWN0aXZlUmVmcmVzaEVuYWJsZWQiLCJFWFBFQ1RFRF9QQVNTV09SRF9QT0xJQ1lfU0NIRU1BX1ZFUlNJT04iLCJfaXNJbml0aWFsaXplZCIsIl9kZWxldGVkIiwiX2luaXRpYWxpemF0aW9uUHJvbWlzZSIsIl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXIiLCJfYWdlbnRSZWNhcHRjaGFDb25maWciLCJfdGVuYW50UmVjYXB0Y2hhQ29uZmlncyIsIl9wcm9qZWN0UGFzc3dvcmRQb2xpY3kiLCJfdGVuYW50UGFzc3dvcmRQb2xpY2llcyIsImxhc3ROb3RpZmllZFVpZCIsInNldHRpbmdzIiwiYXBwVmVyaWZpY2F0aW9uRGlzYWJsZWRGb3JUZXN0aW5nIiwiY2xpZW50VmVyc2lvbiIsInNka0NsaWVudFZlcnNpb24iLCJfaW5pdGlhbGl6ZVdpdGhQZXJzaXN0ZW5jZSIsInBvcHVwUmVkaXJlY3RSZXNvbHZlciIsInBlcnNpc3RlbmNlTWFuYWdlciIsIl9zaG91bGRJbml0UHJvYWN0aXZlbHkiLCJfaW5pdGlhbGl6ZSIsImluaXRpYWxpemVDdXJyZW50VXNlciIsImFzc2VydGVkUGVyc2lzdGVuY2UiLCJfY3VycmVudFVzZXIiLCJfdXBkYXRlQ3VycmVudFVzZXIiLCJpbml0aWFsaXplQ3VycmVudFVzZXJGcm9tSWRUb2tlbiIsImRpcmVjdGx5U2V0Q3VycmVudFVzZXIiLCJlcnIiLCJjb25zb2xlIiwiYXV0aElkVG9rZW4iLCJ0aGVuIiwicHJldmlvdXNseVN0b3JlZFVzZXIiLCJmdXR1cmVDdXJyZW50VXNlciIsIm5lZWRzVG9jaGVja01pZGRsZXdhcmUiLCJhdXRoRG9tYWluIiwiZ2V0T3JJbml0UmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXIiLCJyZWRpcmVjdFVzZXJFdmVudElkIiwic3RvcmVkVXNlckV2ZW50SWQiLCJ0cnlSZWRpcmVjdFNpZ25JbiIsIl9vdmVycmlkZVJlZGlyZWN0UmVzdWx0IiwicmVsb2FkQW5kU2V0Q3VycmVudFVzZXJPckNsZWFyIiwicmVkaXJlY3RSZXNvbHZlciIsIl9jb21wbGV0ZVJlZGlyZWN0Rm4iLCJfc2V0UmVkaXJlY3RVc2VyIiwidXNlRGV2aWNlTGFuZ3VhZ2UiLCJfZGVsZXRlIiwidXBkYXRlQ3VycmVudFVzZXIiLCJ1c2VyRXh0ZXJuIiwic2tpcEJlZm9yZVN0YXRlQ2FsbGJhY2tzIiwibm90aWZ5QXV0aExpc3RlbmVycyIsInJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyIiwiX2dldFJlY2FwdGNoYUNvbmZpZyIsIl9nZXRQYXNzd29yZFBvbGljeUludGVybmFsIiwiX3VwZGF0ZVBhc3N3b3JkUG9saWN5IiwiX2dldFBlcnNpc3RlbmNlIiwiX3VwZGF0ZUVycm9yTWFwIiwib25BdXRoU3RhdGVDaGFuZ2VkIiwibmV4dE9yT2JzZXJ2ZXIiLCJjb21wbGV0ZWQiLCJyZWdpc3RlclN0YXRlTGlzdGVuZXIiLCJiZWZvcmVBdXRoU3RhdGVDaGFuZ2VkIiwib25JZFRva2VuQ2hhbmdlZCIsImF1dGhTdGF0ZVJlYWR5IiwidW5zdWJzY3JpYmUiLCJyZXZva2VBY2Nlc3NUb2tlbiIsInRva2VuVHlwZSIsInJlZGlyZWN0TWFuYWdlciIsInJlc29sdmVyIiwiX3JlZGlyZWN0UGVyc2lzdGVuY2UiLCJfcmVkaXJlY3RVc2VyRm9ySWQiLCJpZCIsIm5leHQiLCJjdXJyZW50VWlkIiwic3Vic2NyaXB0aW9uIiwiY2IiLCJpc1Vuc3Vic2NyaWJlZCIsImFkZE9ic2VydmVyIiwiYWN0aW9uIiwiX2xvZ0ZyYW1ld29yayIsImZyYW1ld29yayIsInNvcnQiLCJfZ2V0RnJhbWV3b3JrcyIsIm9wdGlvbnMiLCJhcHBJZCIsImhlYXJ0YmVhdHNIZWFkZXIiLCJnZXRJbW1lZGlhdGUiLCJvcHRpb25hbCIsImdldEhlYXJ0YmVhdHNIZWFkZXIiLCJhcHBDaGVja1Rva2VuIiwiX2dldEFwcENoZWNrVG9rZW4iLCJhcHBDaGVja1Rva2VuUmVzdWx0IiwiX2Nhc3RBdXRoIiwib2JzZXJ2ZXIiLCJleHRlcm5hbEpTUHJvdmlkZXIiLCJsb2FkSlMiLCJyZWNhcHRjaGFWMlNjcmlwdCIsInJlY2FwdGNoYUVudGVycHJpc2VTY3JpcHQiLCJnYXBpU2NyaXB0IiwiX2xvYWRKUyIsIl9yZWNhcHRjaGFFbnRlcnByaXNlU2NyaXB0VXJsIiwiUkVDQVBUQ0hBX0VOVEVSUFJJU0VfVkVSSUZJRVJfVFlQRSIsIkZBS0VfVE9LRU4iLCJSZWNhcHRjaGFFbnRlcnByaXNlVmVyaWZpZXIiLCJhdXRoRXh0ZXJuIiwidmVyaWZ5IiwicmV0cmlldmVTaXRlS2V5IiwiY2xpZW50VHlwZSIsInZlcnNpb24iLCJjYXRjaCIsInJldHJpZXZlUmVjYXB0Y2hhVG9rZW4iLCJ3aW5kb3ciLCJyZWFkeSIsImV4ZWN1dGUiLCJpbmplY3RSZWNhcHRjaGFGaWVsZHMiLCJjYXB0Y2hhUmVzcCIsInZlcmlmaWVyIiwiY2FwdGNoYVJlc3BvbnNlIiwibmV3UmVxdWVzdCIsImhhbmRsZVJlY2FwdGNoYUZsb3ciLCJhdXRoSW5zdGFuY2UiLCJhY3Rpb25OYW1lIiwiYWN0aW9uTWV0aG9kIiwicmVxdWVzdFdpdGhSZWNhcHRjaGEiLCJsb2ciLCJfaW5pdGlhbGl6ZVJlY2FwdGNoYUNvbmZpZyIsImF1dGhJbnRlcm5hbCIsImluaXRpYWxpemVBdXRoIiwiZGVwcyIsImlzSW5pdGlhbGl6ZWQiLCJpbml0aWFsT3B0aW9ucyIsImdldE9wdGlvbnMiLCJfaW5pdGlhbGl6ZUF1dGhJbnN0YW5jZSIsImhpZXJhcmNoeSIsImNvbm5lY3RBdXRoRW11bGF0b3IiLCJkaXNhYmxlV2FybmluZ3MiLCJleHRyYWN0UHJvdG9jb2wiLCJwb3J0IiwiZXh0cmFjdEhvc3RBbmRQb3J0IiwicG9ydFN0ciIsImZyZWV6ZSIsImVtaXRFbXVsYXRvcldhcm5pbmciLCJwcm90b2NvbEVuZCIsImluZGV4T2YiLCJzdWJzdHIiLCJhdXRob3JpdHkiLCJleGVjIiwiaG9zdEFuZFBvcnQiLCJwb3AiLCJicmFja2V0ZWRJUHY2IiwicGFyc2VQb3J0IiwiYXR0YWNoQmFubmVyIiwiZWwiLCJjcmVhdGVFbGVtZW50Iiwic3R5Iiwic3R5bGUiLCJpbm5lclRleHQiLCJwb3NpdGlvbiIsIndpZHRoIiwiYmFja2dyb3VuZENvbG9yIiwiYm9yZGVyIiwiY29sb3IiLCJib3R0b20iLCJsZWZ0IiwibWFyZ2luIiwiekluZGV4IiwidGV4dEFsaWduIiwiY2xhc3NMaXN0IiwiYWRkIiwiYXBwZW5kQ2hpbGQiLCJpbmZvIiwicmVhZHlTdGF0ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJBdXRoQ3JlZGVudGlhbCIsInNpZ25Jbk1ldGhvZCIsIl9nZXRJZFRva2VuUmVzcG9uc2UiLCJfYXV0aCIsIl9saW5rVG9JZFRva2VuIiwiX2lkVG9rZW4iLCJfZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyIiwicmVzZXRQYXNzd29yZCIsInVwZGF0ZUVtYWlsUGFzc3dvcmQiLCJsaW5rRW1haWxQYXNzd29yZCIsImFwcGx5QWN0aW9uQ29kZSQxIiwic2lnbkluV2l0aFBhc3N3b3JkIiwic2VuZE9vYkNvZGUiLCJzZW5kRW1haWxWZXJpZmljYXRpb24kMSIsInNlbmRQYXNzd29yZFJlc2V0RW1haWwkMSIsInNlbmRTaWduSW5MaW5rVG9FbWFpbCQxIiwidmVyaWZ5QW5kQ2hhbmdlRW1haWwiLCJzaWduSW5XaXRoRW1haWxMaW5rJDEiLCJzaWduSW5XaXRoRW1haWxMaW5rRm9yTGlua2luZyIsIkVtYWlsQXV0aENyZWRlbnRpYWwiLCJfZW1haWwiLCJfcGFzc3dvcmQiLCJfdGVuYW50SWQiLCJfZnJvbUVtYWlsQW5kUGFzc3dvcmQiLCJfZnJvbUVtYWlsQW5kQ29kZSIsIm9vYkNvZGUiLCJvYmoiLCJyZXR1cm5TZWN1cmVUb2tlbiIsInNpZ25JbldpdGhJZHAiLCJJRFBfUkVRVUVTVF9VUkkkMSIsIk9BdXRoQ3JlZGVudGlhbCIsImFyZ3VtZW50cyIsInBlbmRpbmdUb2tlbiIsIl9mcm9tUGFyYW1zIiwiY3JlZCIsIm5vbmNlIiwib2F1dGhUb2tlbiIsIm9hdXRoVG9rZW5TZWNyZXQiLCJzZWNyZXQiLCJidWlsZFJlcXVlc3QiLCJhdXRvQ3JlYXRlIiwicmVxdWVzdFVyaSIsInBvc3RCb2R5Iiwic2lnbkluV2l0aFBob25lTnVtYmVyJDEiLCJsaW5rV2l0aFBob25lTnVtYmVyJDEiLCJ0ZW1wb3JhcnlQcm9vZiIsIlZFUklGWV9QSE9ORV9OVU1CRVJfRk9SX0VYSVNUSU5HX0VSUk9SX01BUF8iLCJ2ZXJpZnlQaG9uZU51bWJlckZvckV4aXN0aW5nIiwiYXBpUmVxdWVzdCIsIm9wZXJhdGlvbiIsIlBob25lQXV0aENyZWRlbnRpYWwiLCJfZnJvbVZlcmlmaWNhdGlvbiIsInZlcmlmaWNhdGlvbklkIiwidmVyaWZpY2F0aW9uQ29kZSIsIl9mcm9tVG9rZW5SZXNwb25zZSIsIl9tYWtlVmVyaWZpY2F0aW9uUmVxdWVzdCIsInNlc3Npb25JbmZvIiwicGFyc2VNb2RlIiwibW9kZSIsInBhcnNlRGVlcExpbmsiLCJsaW5rIiwiZG91YmxlRGVlcExpbmsiLCJpT1NEZWVwTGluayIsImlPU0RvdWJsZURlZXBMaW5rIiwiQWN0aW9uQ29kZVVSTCIsImFjdGlvbkxpbmsiLCJzZWFyY2hQYXJhbXMiLCJjb250aW51ZVVybCIsInBhcnNlTGluayIsInBhcnNlQWN0aW9uQ29kZVVSTCIsIkVtYWlsQXV0aFByb3ZpZGVyIiwiUFJPVklERVJfSUQiLCJjcmVkZW50aWFsIiwiY3JlZGVudGlhbFdpdGhMaW5rIiwiZW1haWxMaW5rIiwiYWN0aW9uQ29kZVVybCIsIkVNQUlMX1BBU1NXT1JEX1NJR05fSU5fTUVUSE9EIiwiRU1BSUxfTElOS19TSUdOX0lOX01FVEhPRCIsIkZlZGVyYXRlZEF1dGhQcm92aWRlciIsImRlZmF1bHRMYW5ndWFnZUNvZGUiLCJjdXN0b21QYXJhbWV0ZXJzIiwic2V0RGVmYXVsdExhbmd1YWdlIiwic2V0Q3VzdG9tUGFyYW1ldGVycyIsImN1c3RvbU9BdXRoUGFyYW1ldGVycyIsImdldEN1c3RvbVBhcmFtZXRlcnMiLCJCYXNlT0F1dGhQcm92aWRlciIsInNjb3BlcyIsImFkZFNjb3BlIiwic2NvcGUiLCJnZXRTY29wZXMiLCJPQXV0aFByb3ZpZGVyIiwiY3JlZGVudGlhbEZyb21KU09OIiwiX2NyZWRlbnRpYWwiLCJyYXdOb25jZSIsImNyZWRlbnRpYWxGcm9tUmVzdWx0IiwidXNlckNyZWRlbnRpYWwiLCJvYXV0aENyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0IiwiY3JlZGVudGlhbEZyb21FcnJvciIsInRva2VuUmVzcG9uc2UiLCJvYXV0aElkVG9rZW4iLCJvYXV0aEFjY2Vzc1Rva2VuIiwiRmFjZWJvb2tBdXRoUHJvdmlkZXIiLCJGQUNFQk9PS19TSUdOX0lOX01FVEhPRCIsImNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0IiwiR29vZ2xlQXV0aFByb3ZpZGVyIiwiR09PR0xFX1NJR05fSU5fTUVUSE9EIiwiR2l0aHViQXV0aFByb3ZpZGVyIiwiR0lUSFVCX1NJR05fSU5fTUVUSE9EIiwiSURQX1JFUVVFU1RfVVJJIiwiU0FNTEF1dGhDcmVkZW50aWFsIiwiX2NyZWF0ZSIsIlNBTUxfUFJPVklERVJfUFJFRklYIiwiU0FNTEF1dGhQcm92aWRlciIsInNhbWxDcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCIsIlR3aXR0ZXJBdXRoUHJvdmlkZXIiLCJUV0lUVEVSX1NJR05fSU5fTUVUSE9EIiwic2lnblVwIiwiVXNlckNyZWRlbnRpYWxJbXBsIiwib3BlcmF0aW9uVHlwZSIsInByb3ZpZGVySWRGb3JSZXNwb25zZSIsInVzZXJDcmVkIiwiX2Zvck9wZXJhdGlvbiIsInNpZ25JbkFub255bW91c2x5IiwiTXVsdGlGYWN0b3JFcnJvciIsInNldFByb3RvdHlwZU9mIiwicHJvdG90eXBlIiwiX2Zyb21FcnJvckFuZE9wZXJhdGlvbiIsIl9wcm9jZXNzQ3JlZGVudGlhbFNhdmluZ01mYUNvbnRleHRJZk5lY2Vzc2FyeSIsImlkVG9rZW5Qcm92aWRlciIsInByb3ZpZGVyRGF0YUFzTmFtZXMiLCJTZXQiLCJwaWQiLCJ1bmxpbmsiLCJfYXNzZXJ0TGlua2VkU3RhdHVzIiwiZGVsZXRlUHJvdmlkZXIiLCJwcm92aWRlcnNMZWZ0IiwicGQiLCJoYXMiLCJfbGluayIsImV4cGVjdGVkIiwicHJvdmlkZXJJZHMiLCJfcmVhdXRoZW50aWNhdGUiLCJwYXJzZWQiLCJzdWIiLCJfc2lnbkluV2l0aENyZWRlbnRpYWwiLCJzaWduSW5XaXRoQ3JlZGVudGlhbCIsImxpbmtXaXRoQ3JlZGVudGlhbCIsInJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWwiLCJzaWduSW5XaXRoQ3VzdG9tVG9rZW4kMSIsInNpZ25JbldpdGhDdXN0b21Ub2tlbiIsImN1c3RvbVRva2VuIiwiTXVsdGlGYWN0b3JJbmZvSW1wbCIsImZhY3RvcklkIiwibWZhRW5yb2xsbWVudElkIiwiZW5yb2xsbWVudFRpbWUiLCJlbnJvbGxlZEF0IiwiX2Zyb21TZXJ2ZXJSZXNwb25zZSIsImVucm9sbG1lbnQiLCJQaG9uZU11bHRpRmFjdG9ySW5mb0ltcGwiLCJUb3RwTXVsdGlGYWN0b3JJbmZvSW1wbCIsInBob25lSW5mbyIsIl9zZXRBY3Rpb25Db2RlU2V0dGluZ3NPblJlcXVlc3QiLCJhY3Rpb25Db2RlU2V0dGluZ3MiLCJkeW5hbWljTGlua0RvbWFpbiIsImNhbkhhbmRsZUNvZGVJbkFwcCIsImhhbmRsZUNvZGVJbkFwcCIsImlPUyIsImJ1bmRsZUlkIiwiaU9TQnVuZGxlSWQiLCJhbmRyb2lkIiwicGFja2FnZU5hbWUiLCJhbmRyb2lkSW5zdGFsbEFwcCIsImluc3RhbGxBcHAiLCJhbmRyb2lkTWluaW11bVZlcnNpb25Db2RlIiwibWluaW11bVZlcnNpb24iLCJhbmRyb2lkUGFja2FnZU5hbWUiLCJyZWNhY2hlUGFzc3dvcmRQb2xpY3kiLCJzZW5kUGFzc3dvcmRSZXNldEVtYWlsIiwicmVxdWVzdFR5cGUiLCJjb25maXJtUGFzc3dvcmRSZXNldCIsIm5ld1Bhc3N3b3JkIiwiYXBwbHlBY3Rpb25Db2RlIiwiY2hlY2tBY3Rpb25Db2RlIiwiYXV0aE1vZHVsYXIiLCJuZXdFbWFpbCIsIm1mYUluZm8iLCJtdWx0aUZhY3RvckluZm8iLCJkYXRhIiwicHJldmlvdXNFbWFpbCIsInZlcmlmeVBhc3N3b3JkUmVzZXRDb2RlIiwiY3JlYXRlVXNlcldpdGhFbWFpbEFuZFBhc3N3b3JkIiwic2lnblVwUmVzcG9uc2UiLCJzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZCIsInNlbmRTaWduSW5MaW5rVG9FbWFpbCIsInNldEFjdGlvbkNvZGVTZXR0aW5ncyIsImlzU2lnbkluV2l0aEVtYWlsTGluayIsInNpZ25JbldpdGhFbWFpbExpbmsiLCJjcmVhdGVBdXRoVXJpIiwiZmV0Y2hTaWduSW5NZXRob2RzRm9yRW1haWwiLCJjb250aW51ZVVyaSIsImlkZW50aWZpZXIiLCJzaWduaW5NZXRob2RzIiwic2VuZEVtYWlsVmVyaWZpY2F0aW9uIiwidmVyaWZ5QmVmb3JlVXBkYXRlRW1haWwiLCJ1cGRhdGVQcm9maWxlJDEiLCJ1cGRhdGVQcm9maWxlIiwicHJvZmlsZVJlcXVlc3QiLCJwYXNzd29yZFByb3ZpZGVyIiwiZmluZCIsInVwZGF0ZUVtYWlsIiwidXBkYXRlRW1haWxPclBhc3N3b3JkIiwidXBkYXRlUGFzc3dvcmQiLCJwcm9maWxlIiwicmF3VXNlckluZm8iLCJpc05ld1VzZXIiLCJraW5kIiwiZmlsdGVyZWRQcm92aWRlcklkIiwiR2VuZXJpY0FkZGl0aW9uYWxVc2VySW5mbyIsIkZhY2Vib29rQWRkaXRpb25hbFVzZXJJbmZvIiwiR2l0aHViQWRkaXRpb25hbFVzZXJJbmZvIiwiR29vZ2xlQWRkaXRpb25hbFVzZXJJbmZvIiwiVHdpdHRlckFkZGl0aW9uYWxVc2VySW5mbyIsInNjcmVlbk5hbWUiLCJGZWRlcmF0ZWRBZGRpdGlvbmFsVXNlckluZm9XaXRoVXNlcm5hbWUiLCJ1c2VybmFtZSIsImxvZ2luIiwiZ2V0QWRkaXRpb25hbFVzZXJJbmZvIiwiaW5pdGlhbGl6ZVJlY2FwdGNoYUNvbmZpZyIsImRlbGV0ZVVzZXIiLCJNdWx0aUZhY3RvclNlc3Npb25JbXBsIiwiX2Zyb21JZHRva2VuIiwiX2Zyb21NZmFQZW5kaW5nQ3JlZGVudGlhbCIsIm1mYVBlbmRpbmdDcmVkZW50aWFsIiwibXVsdGlGYWN0b3JTZXNzaW9uIiwicGVuZGluZ0NyZWRlbnRpYWwiLCJNdWx0aUZhY3RvclJlc29sdmVySW1wbCIsInNlc3Npb24iLCJoaW50cyIsInNpZ25JblJlc29sdmVyIiwiX2Zyb21FcnJvciIsIm1mYVJlc3BvbnNlIiwiX3Byb2Nlc3MiLCJyZXNvbHZlU2lnbkluIiwiYXNzZXJ0aW9uRXh0ZXJuIiwiZ2V0TXVsdGlGYWN0b3JSZXNvbHZlciIsImVycm9ySW50ZXJuYWwiLCJzdGFydEVucm9sbFRvdHBNZmEiLCJmaW5hbGl6ZUVucm9sbFRvdHBNZmEiLCJ3aXRoZHJhd01mYSIsIk11bHRpRmFjdG9yVXNlckltcGwiLCJlbnJvbGxlZEZhY3RvcnMiLCJfZnJvbVVzZXIiLCJnZXRTZXNzaW9uIiwiZW5yb2xsIiwiZmluYWxpemVNZmFSZXNwb25zZSIsInVuZW5yb2xsIiwiaW5mb09yVWlkIiwibXVsdGlGYWN0b3JVc2VyQ2FjaGUiLCJXZWFrTWFwIiwibXVsdGlGYWN0b3IiLCJ1c2VyTW9kdWxhciIsIkF1dGhJbnRlcm9wIiwiaW50ZXJuYWxMaXN0ZW5lcnMiLCJnZXRVaWQiLCJhc3NlcnRBdXRoQ29uZmlndXJlZCIsImFkZEF1dGhUb2tlbkxpc3RlbmVyIiwibGlzdGVuZXIiLCJ1cGRhdGVQcm9hY3RpdmVSZWZyZXNoIiwicmVtb3ZlQXV0aFRva2VuTGlzdGVuZXIiLCJzaXplIiwiZ2V0VmVyc2lvbkZvclBsYXRmb3JtIiwicmVnaXN0ZXJBdXRoIiwiY29udGFpbmVyIiwiZ2V0UHJvdmlkZXIiLCJzZXRJbnN0YW50aWF0aW9uTW9kZSIsInNldEluc3RhbmNlQ3JlYXRlZENhbGxiYWNrIiwiX2luc3RhbmNlSWRlbnRpZmllciIsIl9pbnN0YW5jZSIsImF1dGhJbnRlcm5hbFByb3ZpZGVyIiwiZ2V0QXV0aCIsImF1dGhFbXVsYXRvckhvc3QiLCJOT1RfQVZBSUxBQkxFX0VSUk9SIiwiZmFpbCIsIkZhaWxDbGFzcyIsImJyb3dzZXJMb2NhbFBlcnNpc3RlbmNlIiwiYnJvd3NlclNlc3Npb25QZXJzaXN0ZW5jZSIsImluZGV4ZWREQkxvY2FsUGVyc2lzdGVuY2UiLCJicm93c2VyUG9wdXBSZWRpcmVjdFJlc29sdmVyIiwiUGhvbmVBdXRoUHJvdmlkZXIiLCJzaWduSW5XaXRoUGhvbmVOdW1iZXIiLCJsaW5rV2l0aFBob25lTnVtYmVyIiwicmVhdXRoZW50aWNhdGVXaXRoUGhvbmVOdW1iZXIiLCJ1cGRhdGVQaG9uZU51bWJlciIsInNpZ25JbldpdGhQb3B1cCIsImxpbmtXaXRoUG9wdXAiLCJyZWF1dGhlbnRpY2F0ZVdpdGhQb3B1cCIsInNpZ25JbldpdGhSZWRpcmVjdCIsImxpbmtXaXRoUmVkaXJlY3QiLCJyZWF1dGhlbnRpY2F0ZVdpdGhSZWRpcmVjdCIsImdldFJlZGlyZWN0UmVzdWx0IiwiUmVjYXB0Y2hhVmVyaWZpZXIiLCJQaG9uZU11bHRpRmFjdG9yR2VuZXJhdG9yIiwiZmluYWxpemVTaWduSW5Ub3RwTWZhIiwiTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsIiwiX2ZpbmFsaXplRW5yb2xsIiwiX2ZpbmFsaXplU2lnbkluIiwiVG90cE11bHRpRmFjdG9yR2VuZXJhdG9yIiwiYXNzZXJ0aW9uRm9yRW5yb2xsbWVudCIsIm9uZVRpbWVQYXNzd29yZCIsIlRvdHBNdWx0aUZhY3RvckFzc2VydGlvbkltcGwiLCJfZnJvbVNlY3JldCIsImFzc2VydGlvbkZvclNpZ25JbiIsImVucm9sbG1lbnRJZCIsIl9mcm9tRW5yb2xsbWVudElkIiwiZ2VuZXJhdGVTZWNyZXQiLCJtZmFTZXNzaW9uIiwidG90cEVucm9sbG1lbnRJbmZvIiwiVG90cFNlY3JldCIsIl9mcm9tU3RhcnRUb3RwTWZhRW5yb2xsbWVudFJlc3BvbnNlIiwiRkFDVE9SX0lEIiwib3RwIiwidG90cFZlcmlmaWNhdGlvbkluZm8iLCJfbWFrZVRvdHBWZXJpZmljYXRpb25JbmZvIiwic2VjcmV0S2V5IiwiaGFzaGluZ0FsZ29yaXRobSIsImNvZGVMZW5ndGgiLCJjb2RlSW50ZXJ2YWxTZWNvbmRzIiwiZW5yb2xsbWVudENvbXBsZXRpb25EZWFkbGluZSIsInRvdHBTZXNzaW9uSW5mbyIsInNoYXJlZFNlY3JldEtleSIsInZlcmlmaWNhdGlvbkNvZGVMZW5ndGgiLCJwZXJpb2RTZWMiLCJmaW5hbGl6ZUVucm9sbG1lbnRUaW1lIiwiZ2VuZXJhdGVRckNvZGVVcmwiLCJhY2NvdW50TmFtZSIsImlzc3VlciIsInVzZURlZmF1bHRzIiwiX2lzRW1wdHlTdHJpbmciLCJpbnB1dCIsIiQiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJHIiwiSCIsIkkiLCJKIiwiSyIsIkwiLCJNIiwiTiIsIk8iLCJQIiwiUSIsIlIiLCJTIiwiVCIsIlUiLCJWIiwiVyIsIlgiLCJZIiwiWiIsImEiLCJhMCIsImExIiwiYTIiLCJhMyIsImE0IiwiYTUiLCJhNiIsImE3IiwiYTgiLCJhOSIsImFBIiwiYUIiLCJhQyIsImFEIiwiYUUiLCJhRiIsImFHIiwiYUgiLCJhSSIsImFKIiwiYUsiLCJhTCIsImFNIiwiYU4iLCJhTyIsImFQIiwiYVEiLCJhUiIsImFTIiwiYVQiLCJhYSIsImFiIiwiYWMiLCJhZCIsImFlIiwiYWYiLCJhZyIsImFoIiwiYWkiLCJhaiIsImFrIiwiYWwiLCJhbSIsImFuIiwiYW8iLCJhcCIsImFxIiwiYXIiLCJhcyIsImF0IiwiYXUiLCJhdiIsImF3IiwiYXgiLCJheSIsImF6IiwiYiIsImMiLCJkIiwiZiIsImciLCJoIiwiaiIsImsiLCJsIiwibSIsInEiLCJyIiwicyIsInQiLCJ1IiwidiIsInciLCJ4IiwieSIsInoiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/@firebase/auth/dist/node-esm/totp-219bb96f.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/storage/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/firebase/storage/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageError: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.StorageError),\n/* harmony export */   StorageErrorCode: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.StorageErrorCode),\n/* harmony export */   StringFormat: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.StringFormat),\n/* harmony export */   _FbsBlob: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__._FbsBlob),\n/* harmony export */   _Location: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__._Location),\n/* harmony export */   _TaskEvent: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__._TaskEvent),\n/* harmony export */   _TaskState: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__._TaskState),\n/* harmony export */   _UploadTask: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__._UploadTask),\n/* harmony export */   _dataFromString: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__._dataFromString),\n/* harmony export */   _getChild: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__._getChild),\n/* harmony export */   _invalidArgument: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__._invalidArgument),\n/* harmony export */   _invalidRootOperation: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__._invalidRootOperation),\n/* harmony export */   connectStorageEmulator: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.connectStorageEmulator),\n/* harmony export */   deleteObject: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.deleteObject),\n/* harmony export */   getBlob: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.getBlob),\n/* harmony export */   getBytes: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.getBytes),\n/* harmony export */   getDownloadURL: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.getDownloadURL),\n/* harmony export */   getMetadata: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.getMetadata),\n/* harmony export */   getStorage: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.getStorage),\n/* harmony export */   getStream: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.getStream),\n/* harmony export */   list: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.list),\n/* harmony export */   listAll: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.listAll),\n/* harmony export */   ref: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.ref),\n/* harmony export */   updateMetadata: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.updateMetadata),\n/* harmony export */   uploadBytes: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.uploadBytes),\n/* harmony export */   uploadBytesResumable: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.uploadBytesResumable),\n/* harmony export */   uploadString: () => (/* reexport safe */ _firebase_storage__WEBPACK_IMPORTED_MODULE_0__.uploadString)\n/* harmony export */ });\n/* harmony import */ var _firebase_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/storage */ \"(ssr)/./node_modules/@firebase/storage/dist/node-esm/index.node.esm.js\");\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtDLENBQ2xDLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BoeXNpY3MtZmlnaHRlci1hY2FkZW15Ly4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL3N0b3JhZ2UvZGlzdC9pbmRleC5tanM/ZmE0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICdAZmlyZWJhc2Uvc3RvcmFnZSc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/storage/dist/index.mjs\n");

/***/ })

};
;